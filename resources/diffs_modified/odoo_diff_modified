-                                      (line.product_id.name, line.product_uom_qty, values['product_uom_qty'], line.order_id.name))
+                                      (line.product_id.display_name, line.product_uom_qty, values['product_uom_qty'], line.order_id.name))
-            _message_post_helper(res_model='sale.order', res_id=Order.id, message=body, token=token, message_type='notification', subtype="mail.mt_note", partner_ids=Order.user_id.sudo().partner_id.ids)
+            _message_post_helper(res_model='sale.order', res_id=Order.id, message=body, token=Order.access_token, message_type='notification', subtype="mail.mt_note", partner_ids=Order.user_id.sudo().partner_id.ids)
-        default=lambda self: self.env.user.company_id)
+    company_id = fields.Many2one('res.company', related='journal_id.company_id', string='Company', store=True, readonly=True)
-            move.product_id.standard_price = new_standard_price
+            move.product_id.sudo().standard_price = new_standard_price
-            new_account_move = AccountMove.create({
+            new_account_move = AccountMove.sudo().create({
-            moves_to_unlink.unlink()
+            moves_to_unlink.sudo().unlink()
-            acquirers = request.env['payment.acquirer'].sudo().search([('website_published', '=', True), ('company_id', '=', order_sudo.company_id.id)])
+            domain = expression.AND([
-        )
+        domain = expression.AND([
-                products = self.search(args + ['&', ('default_code', operator, name), ('name', operator, name)], limit=limit)
+                domain = expression.OR([
-        self.activity_type_id = self.recommended_activity_type_id
+        if self.recommended_activity_type_id:
-        'ir.ui.view', 'Form Button Template', required=True)
+        'ir.ui.view', 'Form Button Template', required=True,
-        self.write({'website_published': not self.website_published})
+        ''' When clicking on the website publish toggle button, the website_published is reversed and
-            if order.picking_ids and all([x.state == 'done' for x in order.picking_ids]):
+            if order.picking_ids and all([x.state in ['done', 'cancel'] for x in order.picking_ids]):
-        default=lambda self: self.env['res.company']._company_default_get('account.asset.asset'))
+    company_id = fields.Many2one('res.company', string='Company', readonly=True, related="category_id.company_id", store=True)
-                if RE_ONLY.search(fp.read()):
+            with open(filename, 'rb') as fp:
-        if aml_to_balance_currency:
+        if aml_to_balance_currency and any([residual for dummy, residual in aml_to_balance_currency.values()]):
-            aml_recs, partial_recs = self.env['account.partial.reconcile'].create_exchange_rate_entry(aml_to_balance, 0.0, total_amount_currency, currency, exchange_move)
+            if total_amount_currency:
-            partial_rec_set |= partial_recs
+                #add the ecxhange rate line and the exchange rate partial reconciliation in the et of the full reconcile
-                rounding_method ='UP')
+                precision_rounding=rounding,
-                lambda r: (r.debit_move_id + r.credit_move_id) & current_invoice.move_id.line_ids
+                lambda r: (r.debit_move_id + r.credit_move_id) & aml_to_keep
-        self.mapped('move_line_ids').unlink()
+        moves_to_unreserve = self.env['stock.move']
-        self.env.user.company_id.write({'currency_id': self.env.ref('base.USD').id})
+        self.env.cr.execute(
-    def slide_download(self, slide, sitemap=False):
+    @http.route('''/slides/slide/<model("slide.slide"):slide>/download''', type='http', auth="public", website=True, sitemap=False)
-            return werkzeug.utils.redirect('/web?redirect=/slides/slide/%s' % (slide.id))
+            return request.redirect('/web/login?redirect=/slides/slide/%s' % (slide.id))
-        if aml_to_balance_currency and any([residual for dummy, residual in aml_to_balance_currency.values()]):
+        if aml_to_balance_currency:
-        if aml_to_balance_currency:
+        if aml_to_balance_currency and any([residual for dummy, residual in aml_to_balance_currency.values()]):
-        model_to_check = ['account.move.line', 'account.invoice', 'account.move', 'account.payment', 'account.bank.statement']
+        model_to_check = ['account.move.line', 'account.invoice', 'account.payment', 'account.bank.statement']
-            models_to_delete = ['account.reconcile.model', 'account.fiscal.position', 'account.tax', 'account.journal']
+            models_to_delete = ['account.reconcile.model', 'account.fiscal.position', 'account.tax', 'account.move', 'account.journal']
-            'amount': int(self.amount if self.currency_id.name in INT_CURRENCIES else self.amount*100),
+            'amount': int(self.amount if self.currency_id.name in INT_CURRENCIES else float_round(self.amount * 100, 2)),
-            'amount': int(self.amount*100), # by default, stripe refund the full amount (we don't really need to specify the value)
+            'amount': int(float_round(self.amount * 100, 2)), # by default, stripe refund the full amount (we don't really need to specify the value)
-            'amount': int(self.amount if self.currency_id.name in INT_CURRENCIES else self.amount*100),
+            'amount': int(self.amount if self.currency_id.name in INT_CURRENCIES else float_round(self.amount * 100, 2)),
-    check_manual_sequencing = fields.Boolean(related='journal_id.check_manual_sequencing')
+    check_manual_sequencing = fields.Boolean(related='journal_id.check_manual_sequencing', readonly=1)
-        email_hash = hashlib.md5(email.lower()).hexdigest()
+        email_hash = hashlib.md5(email.lower().encode('utf-8')).hexdigest()
-                raise UserError(_("You have already processed %d. Please input a quantity higher than %d ")%(produced, produced))
+                format_qty = '%.{precision}f'.format(precision=precision)
-        return self.env.ref('account.account_invoices').report_action(self)
+        if self.user_has_groups('account.group_account_invoice'):
-                       WHERE md.module NOT IN (SELECT name FROM ir_module_module)
+                       WHERE md.module IN (SELECT name FROM ir_module_module) IS NOT TRUE
-                    _logger.warning('Invalid custom view(s) for model %s', model)
+                try:
-            # not all records may be accessible, try with only current record
+            # not all prefetched records may be accessible, try with only the current recordset
-                'name': ufile.filename,
+                'name': filename,
-                'datas_fname': ufile.filename,
+                'datas_fname': filename,
-                'filename': ufile.filename,
+                'filename': filename,
-    automatic_invoice = fields.Boolean("Automatic Invoice")
+    automatic_invoice = fields.Boolean("Automatic Invoice",
-        return self.move_line_ids
+        return self.move_line_ids or self.move_line_nosuggest_ids
-    @api.depends('move_line_ids.qty_done', 'move_line_ids.product_uom_id')
+    @api.depends('move_line_ids.qty_done', 'move_line_ids.product_uom_id', 'move_line_nosuggest_ids.qty_done')
-from werkzeug.exceptions import Forbidden
+from werkzeug.exceptions import Forbidden, NotFound
-            url = "/shop/category/%s" % slug(category)
+            url = "/shop/category/%s" % slug(category)
-    @api.constrains('state', 'number_of_days_temp')
+    @api.constrains('state', 'number_of_days_temp', 'holiday_status_id')
-                move.quantity_done += move_line.product_uom_id._compute_quantity(move_line.qty_done, move.product_uom)
+                quantity_done += move_line.product_uom_id._compute_quantity(move_line.qty_done, move.product_uom, round=False)
-            )
+            if not float_is_zero(taken_quantity, precision_rounding=self.product_id.uom_id.rounding):
-            if float_compare(move.quantity_done, move.product_uom_qty, precision_rounding=rounding) < 0:
+            # To know whether we need to create a backorder or not, round to the general product's
-    def _prepare_move_split_vals(self, uom_qty):
+    def _prepare_move_split_vals(self, qty):
-            'product_uom_qty': uom_qty,
+            'product_uom_qty': qty,
-        # HALF-UP rounding as only rounding errors will be because of propagation of error from default UoM
+
-        defaults = self._prepare_move_split_vals(uom_qty)
+        if float_compare(qty, self.product_uom._compute_quantity(uom_qty, self.product_id.uom_id, rounding_method='HALF-UP'), precision_digits=decimal_precision) == 0:
-        # In this case we don't merge move since the new move with 0 quantity done will be used for the backorder.
+        # Update the original `product_qty` of the move. Use the general product's decimal
-        # TDE FIXME: due to action confirm change
+            # Check here if `ml.qty_done` respects the rounding of `ml.product_uom_id`.
-        no_quantities_done = all(float_is_zero(move_line.qty_done, precision_rounding=move_line.product_uom_id.rounding) for move_line in self.move_line_ids)
+        precision_digits = self.env['decimal.precision'].precision_get('Product Unit of Measure')
-                (record, '%s.%s' % xids[record.id])
+                (record, to_xid(record.id))
-            (record, '%s.%s' % xids[record.id])
+            (record, to_xid(record.id))
-        for product in self.search([]):
+        for product in self.with_context(prefetch_fields=False).search([]):
-        # TDE FIXME: should probably clean the search methods
+        ''' Optimized method which doesn't search on stock.moves, only on stock.quants. '''
-        original_quantity = self.product_qty - self.qty_produced
+        original_quantity = (self.product_qty - self.qty_produced) or 1.0
-        'marital': fields.selection([('single', 'Single'), ('married', 'Married'), ('widower', 'Widower'), ('divorced', 'Divorced')], 'Marital Status'),
+        'birthday': fields.date("Date of Birth", groups="base.group_hr_user"),
-        'bank_account_id': fields.many2one('res.partner.bank', 'Bank Account Number', domain="[('partner_id','=',address_home_id)]", help="Employee bank salary account"),
+        'bank_account_id': fields.many2one('res.partner.bank', 'Bank Account Number', domain="[('partner_id','=',address_home_id)]", help="Employee bank salary account", groups="base.group_hr_user"),
-        'passport_id': fields.char('Passport No'),
+        'passport_id': fields.char('Passport No', groups="base.group_hr_user"),
-        'vehicle_distance': fields.integer('Home-Work Dist.', help="In kilometers"),
+        'medic_exam': fields.date('Medical Examination Date', groups="base.group_hr_user"),
-            'tasks': tasks,
+            'tasks': tasks, #TODO master remove this, grouped_tasks is enough
-        return self.related_field.base_field if self.inherited else self
+        return self.inherited_field.base_field if self.inherited_field else self
-                if not self.pool.loaded and field.manual:
+                if not self.pool.loaded and field.base_field.manual:
-                'context': dict(self.env.context, to_date=self.date),
+                'context': dict(self.env.context, to_date=self.date, company_owned=True),
-        return self.related_field.base_field if self.inherited else self
+        return self.inherited_field.base_field if self.inherited_field else self
-                if partial and field.manual:
+                if partial and field.base_field.manual:
-                'type': 'form_save' if acquirer.save_token else 'form',
+                'type': 'form_save' if acquirer.save_token != 'none' and partner_id else 'form',
-            'type': 'form_save' if token.acquirer_id.save_token else 'form',
+            'type': 'form_save' if token.acquirer_id.save_token != 'none' and partner_id else 'form',
-        groupby_fields = [gb['groupby'] for gb in annotated_groupbys]
+
-                    orderby_terms.append(order)
+                    order_split[0] = '"%s"' % groupby_fields.get(order_field, order_field)
-                order_split[0] = '"' + order_field + '"'
+                order_split[0] = '"%s"' % order_field
-                # e.g. 'https://www.transifex.com/odoo/odoo-10/translate/#fr/sale/42?q=Sale+Order'
+                # e.g. https://www.transifex.com/odoo/odoo-10/translate/#fr/sale/42?q=text'Sale+Order'
-                    'src': werkzeug.url_quote_plus(translation.source[:50]),
+                    'src': werkzeug.url_quote_plus(
-        for line in result.mapped('sale_line_id'):
+        for line in result.mapped('sale_line_id').sudo():
-                    for line in sale_order_lines:
+                    for line in sale_order_lines.sudo():
-    driver_id = fields.Many2one('res.partner', 'Driver', help='Driver of the vehicle', copy=False)
+    driver_id = fields.Many2one('res.partner', 'Driver', track_visibility="onchange", help='Driver of the vehicle', copy=False)
-        myPad = EtherpadLiteClient(company.pad_key, company.pad_server + '/api')
+        myPad = EtherpadLiteClient(company.pad_key, (company.pad_server or '') + '/api')
-                myPad = EtherpadLiteClient(company.pad_key, company.pad_server + '/api')
+                myPad = EtherpadLiteClient(company.pad_key, (company.pad_server or '') + '/api')
-            rset1.exdate(recurring_date)
+
-        }, request.context)
+    @http.route('/web/view/edit_custom', type='json', auth="user")
-        })
+    @http.route('/web/view/edit_custom', type='json', auth="user")
-    check_manual_sequencing = fields.Boolean(related='journal_id.check_manual_sequencing')
+    check_manual_sequencing = fields.Boolean(related='journal_id.check_manual_sequencing', readonly=1)
-            vals.update({'check_number': sequence.next_by_id()})
+        if vals['payment_method_id'] == self.env.ref('account_check_printing.account_payment_method_check').id:
-                        'title': _('Model %s does not exist' % self.relation),
+                        'title': _('Model %s does not exist') % self.relation,
-            msg = _("You are in a private conversation with <b>@%s</b>.") % channel_partners[0].partner_id.name
+            msg = _("You are in a private conversation with <b>@%s</b>.") % (channel_partners[0].partner_id.name if channel_partners else _('Anonymous'))
-                    production_move.quantity_done += float_round(self.qty_producing * production_move.unit_factor, precision_rounding=rounding)
+            production_move = self.production_id.move_finished_ids.filtered(
-                    production_move.quantity_done += self.qty_producing
+                    move_line.create({'move_id': production_move.id,
-                'public': True,
+                'public': res_model == 'ir.ui.view',
-                        'public': True,
+                        'public': res_model == 'ir.ui.view',
-                    references[invoice] = references[invoice] | order
+                    references[invoices[group_key]] |= order
-                'body_html': mailing.body_html,
+                'body_html': tools.html_sanitize(mailing.body_html, sanitize_attributes=True, sanitize_style=True, strip_classes=True),
-    @api.one
+                'type': 'form_save' if acquirer.save_token else 'form',
-            'payment_token_id': pm_id
+            'payment_token_id': pm_id,
-from pygments.lexers import get_lexer_by_name
+from pygments.lexers import get_lexer_by_name, PythonLexer
-            account_id = self.product_id.property_account_income_id.id
+            account_id = self.product_id.property_account_income_id.id or self.product_id.categ_id.property_account_income_categ_id.id
-        return action
+        # TODO: remove me in master
-        return action
+        #TODO: remove me in master
-            valuation = sum([variant._sum_remaining_values() for variant in self.product_variant_ids])
+            valuation = sum([variant._sum_remaining_values()[0] for variant in self.product_variant_ids])
-        return sum(moves.mapped('remaining_value'))
+        return sum(moves.mapped('remaining_value')), moves
-    @api.depends('stock_move_ids.product_qty', 'stock_move_ids.state', 'stock_move_ids.remaining_value', 'product_tmpl_id.cost_method', 'product_tmpl_id.standard_price')
+    @api.depends('stock_move_ids.product_qty', 'stock_move_ids.state', 'stock_move_ids.remaining_value', 'product_tmpl_id.cost_method', 'product_tmpl_id.standard_price', 'product_tmpl_id.property_valuation', 'product_tmpl_id.categ_id.property_valuation')
-                product.stock_value = product.standard_price * product.with_context(company_owned=True).qty_available
+                qty_available = product.with_context(company_owned=True).qty_available
-                product.stock_value = product._sum_remaining_values()
+                if to_date:
-    @api.depends('stock_move_ids.product_qty', 'stock_move_ids.state', 'product_tmpl_id.cost_method')
+    @api.depends('stock_move_ids.product_qty', 'stock_move_ids.state', 'stock_move_ids.remaining_value', 'product_tmpl_id.cost_method', 'product_tmpl_id.standard_price')
-                    move_id.with_context(force_valuation_amount=correction_value)._account_entry_move()
+                    move_id.with_context(force_valuation_amount=correction_value, forced_quantity=qty_difference)._account_entry_move()
-                    move.with_context(force_valuation_amount=-corrected_value)._account_entry_move()
+                    move.with_context(force_valuation_amount=-corrected_value, forced_quantity=0)._account_entry_move()
-                    move.with_context(force_valuation_amount=corrected_value)._account_entry_move()
+                    move.with_context(force_valuation_amount=corrected_value, forced_quantity=0)._account_entry_move()
-            'ref': self.picking_id.name,
+            'ref': ref,
-            'ref': self.picking_id.name,
+            'ref': ref,
-                'ref': self.picking_id.name,
+                'ref': ref,
-        move_lines = self._prepare_account_move_line(self.product_qty, abs(self.value), credit_account_id, debit_account_id)
+        quantity = self.env.context.get('forced_quantity', self.product_qty if self._is_in() else -1 * self.product_qty)
-                'ref': self.picking_id.name,
+                'ref': ref,
-            'quantity': self.quantity,
+            'quantity': 0,
-                              quantity=qty_out,
+                              quantity=0,
-                               quantity=qty_out,
+                               quantity=0,
-                                  quantity=qty_out,
+                                  quantity=0,
-                                   quantity=qty_out,
+                                   quantity=0,
-    
+
-                new_remaining_value = 0
+                move_vals = {}
-                    move_vals.pop('remaining_qty')
+                    if move_id._is_in():
-                    # FIFO handling
+                        move_vals['value'] = move_id.value + correction_value
-                        move_vals.pop('remaining_qty')
+                        # no need to adapt `remaining_qty` and `remaining_value` as `_run_fifo` took care of it
-                    move_vals['remaining_value'] = new_remaining_value
+                        move_vals['value'] = move_id.value - correction_value
-        # Find back incoming stock moves (called candidates here) to value this move.
+
-                'price_unit': (-tmp_value + negative_stock_value) / (move.product_qty or quantity),
+                'value': -tmp_value,
-            new_remaining_value = 0 if not new_remaining_qty else move.remaining_value + tmp_value
+            # When working with `price_unit`, beware that out move are negative.
-        self.assertEqual(move1.value, 100.0)
+        self.assertEqual(move1.value, 120.0)  # move 1 is now 10@10 + 2@10
-        self.assertEqual(move1.value, 100)
+        self.assertEqual(move1.value, 120)
-        self.assertEqual(move1.value, 100)
+        self.assertEqual(move1.value, 120)
-        self.assertEqual(move1.value, 100)
+        self.assertEqual(move1.value, 120)
-        self.assertEqual(move1.value, 100)
+        self.assertEqual(move1.value, 120)
-        self.assertEqual(move5.value, -160.0)
+
-        self.assertEqual(move6.value, 120)
+        self.assertEqual(move6.value, 96)  # move6 is now 8@12
-        self.assertEqual(move1.value, 100)
+        self.assertEqual(move1.value, 120)
-        self.assertEqual(move5.value, -160.0)
+        self.assertEqual(move5.value, -200.0)
-        self.assertEqual(move6.value, 120)
+        self.assertEqual(move6.value, 90)
-        self.assertEqual(move1.remaining_value, 200.0)
+        self.assertEqual(move1.value, -680.0)  # 40@15 + 10@8
-        self.assertEqual(vacuum1_valuation_aml.credit, 200)
+        # 280 was credited more in valuation (we compensated 40 items here, so initially 40 were
-        self.assertEqual(vacuum1_output_aml.debit, 200)
+        self.assertEqual(vacuum1_output_aml.debit, 280)
-        self.assertEqual(move1.value, -400.0)
+        self.assertEqual(move1.value, -850.0)  # 40@15 + 10@25
-        self.assertEqual(vacuum2_valuation_aml.credit, 250)
+        # there is still 10@8 to compensate with 10@25 -> 170 to credit more in the valuation account
-        self.assertEqual(vacuum2_output_aml.debit, 250)
+        self.assertEqual(vacuum2_output_aml.debit, 170)
-        self.assertEqual(move2.value, 200.0)
+        self.assertEqual(move2.value, 220.0)  # after correction, the move should be valued at 11@20
-        # Add one move of product 2
+        # Add one move of product 2, this'll make some negative stock.
-        self.assertEqual(move4.value, -20.0)
+        self.assertEqual(self.product2.qty_available, -2)
-        move1 = self.env['stock.move'].create({
+        move5 = self.env['stock.move'].create({
-        move1._action_done()
+        move5._action_confirm()
-        """ Check that incrementing the done quantity will correctly re-run a fifo lookup.
+        """ Increase OUT done move while quantities are available.
-        self.assertEqual(move2.value, -100.0)
+        self.assertEqual(move2.value, -80.0)  # the move actually sent 8@10
-        self.assertEqual(move2.value, -100.0)
+        self.assertEqual(move2.value, -100.0)  # the move actually sent 10@10
-        group.add_option("--geoip-db", dest="geoip_database", my_default='/usr/share/GeoIP/GeoLiteCity.dat',
+        group.add_option("--geoip-db", dest="geoip_database", my_default='/usr/share/GeoIP/GeoLite2-City.mmdb',
-from openerp.tools import config
+from openerp.tools import config, ustr
-                self._geoip_resolver = False
+                self._geoip_resolver = GeoIPResolver.open(geofile) or False
-                record = self._geoip_resolver.record_by_addr(request.httprequest.remote_addr) or {}
+                record = self._geoip_resolver.resolve(request.httprequest.remote_addr) or {}
-            'default_sale_tax_id': int(default_sale_tax_id[0]) if isinstance(default_sale_tax_id, list) and default_sale_tax_id else default_sale_tax_id,
+            'default_purchase_tax_id': int(default_purchase_tax_id[0]) if isinstance(default_purchase_tax_id, list) and default_purchase_tax_id else (int(default_purchase_tax_id) or False),
-            request = self.httprequest.stream.read().decode(self.httprequest.charset)
+            request = self.httprequest.get_data().decode(self.httprequest.charset)
-    child_ids = fields.One2many('project.task', 'parent_id', string="Sub-tasks")
+    child_ids = fields.One2many('project.task', 'parent_id', string="Sub-tasks", context={'active_test': False})
-
+            # we set the time to noon to avoid the date to be changed because of timezone issues
-                'date_planned': wizard.date_planned,
+                'date_planned': date,
-    def _export_rows(self, fields):
+    def _export_rows(self, fields, batch_invalidate=True):
-                        lines2 = value._export_rows(fields2)
+                        lines2 = value._export_rows(fields2, batch_invalidate=False)
-            columns=['module', 'model', 'name', 'res_id'],
+            columns=fields,
-        self.invalidate_cache()
+        self.env['ir.model.data'].invalidate_cache(fnames=fields)
-                ]
+                {'acc_name': _('Cash'), 'account_type': 'cash'},
-            'debit': self.amount,
+            'debit': abs(self.amount),
-            'tax_line_id': self.tax_id.id,
+            'tax_line_id': adjustment_type == 'debit' and self.tax_id.id or False,
-            'credit': self.amount,
+            'credit': abs(self.amount),
-            'tax_line_id': self.tax_id.id,
+            'tax_line_id': adjustment_type == 'credit' and self.tax_id.id or False,
-                    'url': '/my/project/%s' % self.id,
+                    'url': self.website_url,
-            'payment_date': ui_paymentline['name'],
+            'payment_date': payment_date,
-            'date': data.get('payment_date', fields.Date.today()),
+            'date': data.get('payment_date', fields.Date.context_today(self)),
-        self.assertItemsEqual(list(result), ['matches', 'headers', 'fields', 'preview', 'headers_type', 'options', 'advanced_mode', 'debug'])
+        self.assertItemsEqual(list(result), ['matches', 'headers', 'fields', 'preview', 'headers_type', 'options', 'debug'])
-        self.assertItemsEqual(list(result), ['matches', 'headers', 'fields', 'preview', 'headers_type', 'options', 'advanced_mode', 'debug'])
+        self.assertItemsEqual(list(result), ['matches', 'headers', 'fields', 'preview', 'headers_type', 'options', 'debug'])
-        self.assertItemsEqual(list(result), ['matches', 'headers', 'fields', 'preview', 'headers_type', 'options','advanced_mode', 'debug'])
+        self.assertItemsEqual(list(result), ['matches', 'headers', 'fields', 'preview', 'headers_type', 'options', 'debug'])
-        self.assertItemsEqual(list(result), ['matches', 'headers', 'fields', 'preview', 'headers_type', 'options', 'advanced_mode', 'debug'])
+        self.assertItemsEqual(list(result), ['matches', 'headers', 'fields', 'preview', 'headers_type', 'options', 'debug'])
-        if self.product_id.tracking == 'serial':
+        if self.qty_done and self.product_id.tracking == 'serial':
-        help="The fiscal position will determine taxes and accounts used for the partner.", oldname="property_account_position")
+        help="The fiscal position will determine taxes and accounts used for the partner.", oldname="property_account_position",
-                                                                         ('amount', '=', data['amount'])])
+                                                                         ('journal_id', '=', data['journal'])])
-        self.phantom_js("/", "odoo.__DEBUG__.services['web_tour.tour'].run('shop_wishlist', 1000)", "odoo.__DEBUG__.services['web_tour.tour'].tours.shop_wishlist.ready")
+        self.phantom_js("/", "odoo.__DEBUG__.services['web_tour.tour'].run('shop_wishlist')", "odoo.__DEBUG__.services['web_tour.tour'].tours.shop_wishlist.ready")
-from odoo.osv.expression import FALSE_DOMAIN
+from odoo.osv.expression import FALSE_DOMAIN, OR
-                (gpo == 'propagate' and values['group_id'].id) or False
+                (gpo == 'propagate' and 'group_id' in values and values['group_id'].id) or False
-                (gpo == 'propagate' and values['group_id']) or False
+                (gpo == 'propagate' and 'group_id' in values and values['group_id']) or False
-            return request.redirect('/page/' + page[8:], code=301)
+            url = '/page/' + page[8:]
-        asset.compute_depreciation_board()
+        asset.sudo().compute_depreciation_board()
-    @route('/invoice/pay/<int:invoice_id>/form_tx', type='json', auth="user", website=True)
+    @route('/invoice/pay/<int:invoice_id>/form_tx', type='json', auth="public", website=True)
-            tx_type='form_save' if save_token else 'form')
+            tx_type='form_save' if save_token else 'form',
-    @http.route('/invoice/pay/<int:invoice_id>/s2s_token_tx', type='http', auth='user', website=True)
+    @http.route('/invoice/pay/<int:invoice_id>/s2s_token_tx', type='http', auth='public', website=True)
-            tx_type='server2server')
+            tx_type='server2server',
-    group_delivery_invoice_address = fields.Boolean(string="Shipping Address", implied_group='sale.group_delivery_invoice_address')
+    group_delivery_invoice_address = fields.Boolean(string="Shipping Address", implied_group='sale.group_delivery_invoice_address', group='base.group_portal,base.group_user,base.group_public')
-        result = self._create_stripe_charge(acquirer_ref=self.payment_token_id.acquirer_ref)
+        result = self._create_stripe_charge(acquirer_ref=self.payment_token_id.acquirer_ref, email=self.partner_email)
-        fpos = self.env['account.fiscal.position'].with_context(company_id=values['company_id'].id).get_fiscal_position(partner.id)
+        fpos = self.env['account.fiscal.position'].with_context(force_company=values['company_id'].id).get_fiscal_position(partner.id)
-        fractional_amount = round(abs(fractional_value), self.decimal_places) * (math.pow(10, self.decimal_places))
+        formatted = "%.{0}f".format(self.decimal_places) % amount
-                        amt_value=_num2words(int(integer_value), lang=lang.iso_code),
+                        amt_value=_num2words(integer_value, lang=lang.iso_code),
-        if not self.is_zero(fractional_value):
+        if not self.is_zero(amount - integer_value):
-                        amt_value=_num2words(int(fractional_amount), lang=lang.iso_code),
+                        amt_value=_num2words(fractional_value, lang=lang.iso_code),
-        r = urllib2.Request('https://w1.mercurypay.com/ws/ws.asmx', data=xml_transaction, headers=headers)
+        url = 'https://w1.mercurypay.com/ws/ws.asmx'
-from odoo.tools.float_utils import float_compare
+from odoo.tools.float_utils import float_compare, float_repr
-            'x_amount': str(values['amount']),
+            'x_amount': float_repr(values['amount'], values['currency'].decimal_places if values['currency'] else 2),
-            'x_amount': '320.0',
+            'x_amount': '56.16',
-        res = self.authorize.render('SO004', 320.0, self.currency_usd.id, values=self.buyer_values)
+        res = self.authorize.render('SO004', 56.16, self.currency_usd.id, values=self.buyer_values)
-            return [(now_date, None)]
+            return [(False, None)]
-            move = self.env['account.move'].create({
+            move = self.env['account.move']
-            })
+                'ref': cost.name,
-            move.assert_balanced()
+                move_vals['line_ids'] += line._create_accounting_entries(move, qty_out)
-        AccountMoveLine = self.env['account.move.line'].with_context(check_move_validity=False, recompute=False)
+        AccountMoveLine = []
-        AccountMoveLine.create(credit_line)
+        AccountMoveLine.append([0, 0, debit_line])
-            AccountMoveLine.create(credit_line)
+            AccountMoveLine.append([0, 0, debit_line])
-                AccountMoveLine.create(credit_line)
+                AccountMoveLine.append([0, 0, debit_line])
-        return True
+        return AccountMoveLine
-        price_unit = - product._get_anglo_saxon_price_unit()
+        price_unit = product._get_anglo_saxon_price_unit()
-            average_price_unit = product._compute_average_price(quantity, quantity, moves)
+            average_price_unit = product._compute_average_price(0, quantity, moves)
-        return price_unit
+        # In the SO part, the entries will be inverted by function compute_invoice_totals
-        'security/ir.model.access.csv',
+        # compute employee only for timesheet lines, makes no sense for other lines
-            vals['employee_id'] = self.env['hr.employee'].search([('user_id', '=', ts_user_id)], limit=1).id
+            self.company_id = self.deferred_revenue_category_id.company_id
-                moves.post()
+                moves.filtered(lambda m: m.state != 'posted').post()
-        known_mods = self.search([])
+        known_mods = self.with_context(lang=None).search([])
-        cr.execute("UPDATE res_company SET currency_id = %s WHERE id = %s", [env.ref('base.USD').id, main_company.id])
+        main_company.currency_id = env.ref('base.USD')
-        return super(SaleOrderLine, self).name_get()
+        result = []
-                return self.search(domain, limit=limit).name_get()
+        if operator in ('ilike', 'like', '=', '=like', '=ilike'):
-import account_partial_reconcile
+from . import account_tax
-from odoo import models
+from odoo import models, api
-            self.write({'state': 'done'})
+        self.filtered(
-                record = self.env['base'].with_context(self.localcontext)
+                env = odoo.api.Environment(self.cr, self.uid, {})
-    'depends': ['account_tax_cash_basis'],
+    'depends': ['account'],
-                blog_post.teaser = ' '.join(filter(None, content.split(' '))[:50]) + '...'
+                blog_post.teaser = content[:150] + '...'
-            pickings = self.order_id.picking_ids.filtered(lambda p: p.state not in ('done', 'cancel'))
+            pickings = line.order_id.picking_ids.filtered(lambda p: p.state not in ('done', 'cancel'))
-                                      (line.product_id.name, line.product_uom_qty, values['product_uom_qty'], self.order_id.name))
+                                      (line.product_id.name, line.product_uom_qty, values['product_uom_qty'], line.order_id.name))
-            # strip 'js:auto'
+            if not modules:
-            item = modules[path[0]]
+            # build complete path to object
-            for k in path[1:]:
+            for k in objpath:
-
+        self.directive.state.nested_parse(self.directive.content, 0, content)
-            return ret.children
+
-
+        self.assertRegexpMatches(
-        """ Return a valid xml_id for the record ``self``. """
+    def __ensure_xml_id(self, skip=False):
-            return '__export__.' + name
+
-                sub = rs[idx: idx+1000]
+                sub = rs[idx:idx+1000]
-        for idx, record in enumerate(splittor(self)):
+        for record in splittor(self):
-                    current[i] = record.__export_xml_id()
+                    xid = xids.get(record)
-                            xml_ids = [r.__export_xml_id() for r in value]
+                            xml_ids = [xid for _, xid in value.__ensure_xml_id()]
-                break
+                continue
-    'category': 'Website',
+    'category': 'Theme',
-    'category': 'Hidden',
+    'category': 'Theme/Hidden',
-                    price_unit = - product._get_anglo_saxon_price_unit()
+                    price_unit = self._get_pos_anglo_saxon_price_unit(product, line['partner_id'], line['quantity'])
-        return average_price_unit
+        return self.env['product.product']._compute_average_price(qty_done, quantity, moves)
-    company_id = fields.Many2one('res.company', string='Company', required=True, default=lambda self: self.env.user.company_id)
+    company_id = fields.Many2one('res.company', string='Company')
-                (any_id2key(record[name]) if name == 'id' else record[name], desc)
+                (any_id2key(record[name]) if name == 'id' else boolean_product(record[name]), desc)
-    @api.depends('model_id', 'license_plate')
+    @api.depends('model_id.brand_id.name', 'model_id.name', 'license_plate')
-    license_plate = fields.Char(required=True, help='License plate number of the vehicle (i = plate number for a car)')
+    license_plate = fields.Char(required=True, track_visibility="onchange",
-        string="Total Cost (Depreciated)", help="This includes all the depreciated costs and the CO2 fee")
+        string="Total Cost (Depreciated)", track_visibility="onchange",
-                                    total_revenue_per_currency[timesheet_line.company_currency_id.id] += timesheet_line.timesheet_revenue
+                                    line_revenue = timesheet_line.timesheet_revenue
-        today = date.today()
+        today_default = date.today()
-        main_company.currency_id = env.ref('base.USD')
+        cr.execute("UPDATE res_company SET currency_id = %s WHERE id = %s", [env.ref('base.USD').id, main_company.id])
-        self.env.ref('base.main_company').write({'currency_id': self.env.ref('base.USD').id})
+        self.cr.execute("UPDATE res_company SET currency_id = %s WHERE id = %s", [self.env.ref('base.USD').id, self.env.ref('base.main_company').id])
-                implied_group.write({'users': [(3, user.id) for user in groups.mapped('users')]})
+        with self.env.norecompute():
-        if self.allday and self.rrule and 'UNTIL' in self.rrule and 'Z' not in self.rrule:
+        use_naive_datetime = self.allday and self.rrule and 'UNTIL' in self.rrule and 'Z' not in self.rrule
-            rset1._exdate.append(todate(meeting.recurrent_id_date))
+            recurring_date = fields.Datetime.from_string(meeting.recurrent_id_date)
-                fields.Date.today(), company_id=self.company_id.id)
+                fields.Date.today(), company_id=invoice.company_id.id)
-    @route('/invoice/pay/<int:invoice_id>/form_tx', type='json', auth="public", website=True)
+    @route('/invoice/pay/<int:invoice_id>/form_tx', type='json', auth="user", website=True)
-
+        # Check if the current user has access to this invoice
-            })
+            tx_type='form_save' if save_token else 'form')
-    @http.route('/invoice/pay/<int:invoice_id>/s2s_token_tx', type='http', auth='public', website=True)
+    @http.route('/invoice/pay/<int:invoice_id>/s2s_token_tx', type='http', auth='user', website=True)
-        callback_method = kwargs.get('callback_method', '')
+        # Check if the current user has access to this invoice
-            })
+            tx_type='server2server')
-                'amount_currency': line.price_subtotal if current_currency != company_currency else 0.0,
+                'amount_currency': line_subtotal if current_currency != company_currency else 0.0,
-            warehouses = self.env['stock.warehouse'].search([])
+            # override active_test that is false in set_values
-            warehouses = self.env['stock.warehouse'].search([
+            warehouses = warehouse_obj.search([
-        if self.env['project.issue'].search_count([('project_id.analytic_account_id', 'in', self.ids)]):
+        if self.env['project.issue'].sudo().search_count([('project_id.analytic_account_id', 'in', self.ids)]):
-            'phone': tx_values['partner_phone'],
+            'amount': tx_values['amount'],  # Mandatory
-            refunds = invoice_ids.search([('origin', 'like', order.name)]).filtered(lambda r: r.type in ['out_invoice', 'out_refund'])
+            refunds = invoice_ids.search([('origin', 'like', order.name), ('company_id', '=', order.company_id.id)]).filtered(lambda r: r.type in ['out_invoice', 'out_refund'])
-                                'account_id': line.account_id.id,
+                                'account_id': account_id.id,
-                                'account_id': line.account_id.id,
+                                'account_id': account_id.id,
-            base_tax = 0
+            price_reduce = line.price_unit * (1.0 - line.discount / 100.0)
-                                                partner=self.partner_shipping_id)['taxes'][0]['amount']
+                    if t['id'] == tax.id or t['id'] in tax.children_tax_ids.ids:
-        digits=dp.get_precision('Product Unit of Measure'), required=True)
+        digits=0, required=True)
-        digits=dp.get_precision('Product Unit of Measure'))
+        digits=dp.get_precision('Stock Weight'))
-        digits=dp.get_precision('Product Unit of Measure'))
+        'Volume', default=1.0)
-                    if t['id'] == tax.id:
+                    if t['id'] == tax.id or t['id'] in tax.children_tax_ids.ids:
-                    'new_amount_delivery': order.currency_id.round(order.delivery_price),
+                    'new_amount_delivery': float_repr(currency.round(order.delivery_price), currency.decimal_places),
-        amls_to_reconcile = move.line_ids + reversed_move.line_ids
+        amls_to_reconcile = (move.line_ids + reversed_move.line_ids).filtered(lambda l: not l.reconciled)
-            meeting.color_partner_id = meeting.user_id.partner_id.id
+        for meeting in self:
-        'car_id.atn', 'new_car_model_id.default_atn', 'new_car_model_id.default_total_depreciated_cost')
+        'car_id.atn', 'new_car_model_id.default_atn', 'new_car_model_id.default_total_depreciated_cost',
-    @api.depends('car_id', 'new_car', 'new_car_model_id')
+    @api.depends('car_id', 'new_car', 'new_car_model_id', 'car_id.total_depreciated_cost',
-            record.name = record.model_id.brand_id.name + '/' + record.model_id.name + '/' + record.license_plate
+            record.name = record.model_id.brand_id.name + '/' + record.model_id.name + '/' + (record.license_plate or _('No Plate'))
-    wage = fields.Monetary('Wage', digits=(16, 2), required=True, help="Employee's monthly gross wage.")
+    wage = fields.Monetary('Wage', digits=(16, 2), required=True, track_visibility="onchange", help="Employee's monthly gross wage.")
-            return request.redirect(redirect.url_to, code=redirect.type)
+            return request.redirect(_build_url_w_params(redirect.url_to, request.params), code=redirect.type)
-        cookies_to_set = []
+    def _set_utm(cls, response):
-                cookies_to_set.append((cook, request.params[var], cls.get_utm_domain_cookies()))
+                response.set_cookie(cook, request.params[var], domain=domain)
-            return response
+        return cls._set_utm(response)
-        return response
+    @classmethod
-            if first_menu and first_menu[0].url != '/' and (not (first_menu[0].url.startswith(('/?', '/#')))):
+            if first_menu and first_menu[0].url not in ('/', '') and (not (first_menu[0].url.startswith(('/?', '/#', ' ')))):
-            self.env['account.move'].browse(list(move_ids))._check_lock_date()
+        self.env['account.move'].browse(list(move_ids))._check_lock_date()
-        if self.currency_id.is_zero(self.amount):
+        if self.currency_id.is_zero(self.amount) and self.has_invoices:
-                balance += line[2]['debit'] - line[2]['credit']
+                balance += line[2].get('debit', 0) - line[2].get('credit', 0)
-    def _action_confirm(self, merge=True):
+    def _action_confirm(self, merge=True, merge_into=False):
-        return super(StockMove, moves)._action_confirm(merge=merge)
+        return super(StockMove, moves)._action_confirm(merge=merge, merge_into=merge_into)
-        for line in self.mapped('sale_line_id'):
+        for line in result.mapped('sale_line_id'):
-    def _merge_moves(self):
+    def _merge_moves(self, merge_into=False):
-        for picking in self.mapped('picking_id'):
+        for candidate_moves in candidate_moves_list:
-            for k, g in groupby(sorted(picking.move_lines, key=self._prepare_merge_move_sort_method), key=itemgetter(*distinct_fields)):
+            for k, g in groupby(sorted(candidate_moves, key=self._prepare_merge_move_sort_method), key=itemgetter(*distinct_fields)):
-    def _action_confirm(self, merge=True):
+    def _action_confirm(self, merge=True, merge_into=False):
-            return self._merge_moves()
+            return self._merge_moves(merge_into=merge_into)
-        extra_move = self.env['stock.move']
+        extra_move = self
-            extra_move = self.copy(default=extra_move_vals)._action_confirm()
+            extra_move = self.copy(default=extra_move_vals)
-            moves_todo |= move
+            # extra move will not be merged in mrp
-        picking = self and self[0].picking_id or False
+        picking = moves_todo and moves_todo[0].picking_id or False
-                    'name': self.statement_id.name,
+                    'name': self.statement_id.name or _("Bank Statement %s") %  self.date,
-                            bank_account_id = self.env['res.partner.bank'].create({'acc_number': line_vals['account_number']}).id
+                            bank_account_id = self.env['res.partner.bank'].create({
-                    ml._free_reservation(ml.product_id, ml.location_id, extra_qty, lot_id=ml.lot_id, package_id=ml.package_id, owner_id=ml.owner_id)
+                    ml._free_reservation(ml.product_id, ml.location_id, extra_qty, lot_id=ml.lot_id, package_id=ml.package_id, owner_id=ml.owner_id, ml_to_ignore=done_ml)
-    def _free_reservation(self, product_id, location_id, quantity, lot_id=None, package_id=None, owner_id=None):
+    def _free_reservation(self, product_id, location_id, quantity, lot_id=None, package_id=None, owner_id=None, ml_to_ignore=None):
-                ('id', '!=', self.id),
+                ('id', 'not in', ml_to_ignore.ids),
-        move1.with_context(debug=True).move_line_ids[1].lot_id = lot3
+        move1.move_line_ids[1].lot_id = lot3
-        missing_fields = [partner._fields[field].string for field in ['city', 'country_id', 'zip'] if not partner[field]]
+        missing_fields = [partner._fields[field].string for field in ['city', 'country_id'] if not partner[field]]
-        etree.SubElement(billTo, "zip").text = partner.zip
+        etree.SubElement(billTo, "zip").text = partner.zip or ''
-        etree.SubElement(billTo, "zip").text = partner.zip
+        etree.SubElement(billTo, "zip").text = partner.zip or ''
-from odoo.tools.float_utils import float_round
+from odoo.tools.float_utils import float_round, float_is_zero
-                                total_revenue_per_currency[timesheet_line.company_currency_id.id] += line_revenue
+                                if not float_is_zero(price_subtotal_sol, precision_rounding=timesheet_line.company_currency_id.rounding):
-        return ("""SELECT state, amount_total, currency_id AS currency
+        return ("""SELECT state, amount_total, currency_id AS currency, type
-        return ("""SELECT state, amount_total, currency_id AS currency
+        return ("""SELECT state, amount_total, currency_id AS currency, type
-            rslt_sum += cur.compute(result.get('amount_total'), target_currency)
+
-        if not context.get('tz'):
+        context = {}
-        request.context = context
+        # modify bound context
-            return request.render(mypage.view_id.id, {
+            return request.render(mypage.get_view_identifier(), {
-                        trans.write({'src': matches[0], 'state': trans.state})
+                        if matches[0] in trans_src:
-        (self - ml_to_delete).with_context(bypass_reservation_update=True).write({'product_uom_qty': 0.00})
+        (self - ml_to_delete).with_context(bypass_reservation_update=True).write({
-        
+
-            'product_qty_uom': str(move_line.product_uom_id._compute_quantity(move_line.qty_done, move_line.product_id.uom_id, rounding_method='HALF-UP')) + ' ' + move_line.product_id.uom_id.name,
+            'product_qty_uom': "%s %s" % (self._quantity_to_str(move_line.product_uom_id, move_line.product_id.uom_id, move_line.qty_done), move_line.product_id.uom_id.name),
-                'product_qty_uom': str(move_line.product_uom_id._compute_quantity(move_line.qty_done, move_line.product_id.uom_id, rounding_method='HALF-UP')) + ' ' + move_line.product_id.uom_id.name,
+                'product_qty_uom': "%s %s" % (self._quantity_to_str(move_line.product_uom_id, move_line.product_id.uom_id, move_line.qty_done), move_line.product_id.uom_id.name),
-                'product_qty_uom': str(move_line.quantity) + ' ' + move_line.product_id.uom_id.name,
+                'product_qty_uom': "%s %s" % (self._quantity_to_str(move_line.product_uom_id, move_line.product_id.uom_id, move_line.quantity), move_line.product_id.uom_id.name),
-from odoo.addons.portal.controllers.portal import CustomerPortal, get_records_pager
+from odoo.addons.portal.controllers.portal import get_records_pager
-            'res_id': self.id}
+            'res_id': self.picking_id.id}
-            return price
+        if not self or not uom or self.uom_id.id == uom.id:
-            action["report_name"], report_ids, report_data, context])
+        report_id = exp_report(request.session.db, request.session.uid, action["report_name"], report_ids, report_data, context)
-                request.session.db, request.session.uid, request.session.password, report_id])
+            report_struct = exp_report_get(request.session.db, request.session.uid, report_id)
-        }
+        with env.do_in_onchange():
-                                line[index] = dt.strftime(dt.strptime(pycompat.to_native(line[index].strip()), user_format), server_format)
+                                line[index] = dt.strftime(dt.strptime(pycompat.to_native(line[index]), user_format), server_format)
-    def content_common(self, xmlid=None, model='ir.attachment', id=None, field='datas', filename=None, filename_field='datas_fname', unique=None, mimetype=None, download=None, data=None, token=None):
+    def content_common(self, xmlid=None, model='ir.attachment', id=None, field='datas', filename=None, filename_field='datas_fname', unique=None, mimetype=None, download=None, data=None, token=None, **kw):
-                self.report_sxw = report.report_rml.replace('.rml', '.sxw')
+                report.report_sxw = report.report_rml.replace('.rml', '.sxw')
-        if alias.alias_contact == 'employees' and record.ids:
+        if alias.alias_contact == 'employees':
-            order.amount_delivery = sum(order.order_line.filtered('is_delivery').mapped('price_subtotal'))
+            if self.env.user.has_group('sale.group_show_price_subtotal'):
-                self.send_mail(cr, uid, [mass_mailing_id], context=context)
+            if len(self.get_remaining_recipients(cr, uid, mass_mailing_record, context=_context)) > 0:
-                self.write(cr, uid, [mass_mailing_id], {'state': 'done'}, context=context)
+                self.write(cr, uid, [mass_mailing_id], {'state': 'done'}, context=_context)
-    sale_line_id = fields.Many2one('sale.order.line', 'Sales Order Item', domain="[('is_service', '=', True), ('order_partner_id', '=', partner_id)]")
+    @api.model
-            base_tax = 0
+            price_reduce = line.price_unit * (1.0 - line.discount / 100.0)
-                                                partner=self.partner_shipping_id)['taxes'][0]['amount']
+                    if t['id'] == tax.id:
-        'min_quantity': 1,
+        'min_quantity': 0,
-        if self.env.user.share:
+        if self.env.context.get('uid'):
-        if self.env.user.share:
+        if self.env.context.get('uid'):
-        if self.env.user.share:
+        if self.env.context.get('uid'):
-        self.password = password
+        self.session_token = uid and security.compute_session_token(self)
-        security.check(self.db, self.uid, self.password)
+
-        self.setdefault("password", None)
+        self.setdefault("session_token", None)
-        session.password = password
+        session.session_token = uid and security.compute_session_token(session)
-    company_id = fields.Many2one('res.company', related='account_id.company_id', string='Company', store=True)
+    company_id = fields.Many2one('res.company', related='account_id.company_id', string='Company', store=True, readonly=True)
-        self.leave_start_datetime = today.replace(hour=7) + relativedelta(weeks=0, days=1, weekday=0)
+        self.leave_start_datetime = datetime(2018, 2, 5, 7, 0, 0, 0)  # this is monday
-            None
+            res_id = None
-        raw_values = {k: values.get(k.encode('ascii'), '') for k in keys if k in values}
+        raw_values = {k: values.get(k, '') for k in keys if k in values}
-                'merchantSig': self._adyen_generate_merchant_sig('in', values),
+            values['merchantSig'] = self._adyen_generate_merchant_sig('in', values)
-            [answers.update({label.id: {'text': label.value, 'count': 0, 'answer_id': label.id}}) for label in question.labels_ids]
+            answers = OrderedDict((label.id, {'text': label.value, 'count': 0, 'answer_id': label.id}) for label in question.labels_ids)
-        field = self[0].account_id.currency_id and 'amount_residual_currency' or 'amount_residual'
+        company_currency_id = self[0].account_id.company_id.currency_id
-        field = self[0].account_id.currency_id and 'amount_residual_currency' or 'amount_residual'
+        company_currency_id = self[0].account_id.company_id.currency_id
-    department_id = fields.Many2one('hr.department', "Department", related='user_id.employee_ids.department_id', store=True, readonly=True)
+    department_id = fields.Many2one('hr.department', "Department", compute='_compute_department_id', store=True)
-            return False
+        if data['cc_expiry']:
-    name = fields.Char(required=True)
+    name = fields.Char(required=True, translate=True)
-    name = fields.Char(required=True)
+    name = fields.Char(required=True, translate=True)
-from odoo.tools import consteq
+from odoo.tools import consteq, plaintext2html
-                              "the first inventory adjustement with this product before creating another one.") % (res.product_id.name, res.location_id.name))
+                              "the first inventory adjustement with this product before creating another one.") %
-                    _logger.info('Language: %s. Translation from template: there is no translation available for %s!' % (lang, element.name))
+                    _logger.info('Language: %s. Translation from template: there is no translation available for %s!' % (lang, element[in_field]))
-from odoo.tools import amount_to_text_en, float_round
+from odoo.tools import amount_to_text_en, float_round, float_is_zero
-        if decimals >= 10**-2:
+        if not float_is_zero(decimals, precision_digits=2):
-            if contract.car_id:
+            if not contract.new_car and contract.car_id:
-            False: ['USD', 'EUR', 'Benelux', 'Canada'],
+            False: ['Public Pricelist', 'EUR', 'Benelux', 'Canada'],
-            'US': ['USD', 'EUR', 'Benelux', 'Canada']
+            'US': ['Public Pricelist', 'EUR', 'Benelux', 'Canada']
-            False: ['USD', 'EUR', 'Benelux', 'Christmas', 'Canada'],
+            False: ['Public Pricelist', 'EUR', 'Benelux', 'Christmas', 'Canada'],
-            'US': ['USD', 'EUR', 'Benelux', 'Christmas', 'Canada'],
+            'US': ['Public Pricelist', 'EUR', 'Benelux', 'Christmas', 'Canada'],
-            False: ['USD', 'EUR', 'Benelux', 'Canada'],
+            False: ['Public Pricelist', 'EUR', 'Benelux', 'Canada'],
-            'US': ['USD', 'EUR', 'Benelux', 'Canada']
+            'US': ['Public Pricelist', 'EUR', 'Benelux', 'Canada']
-        res_id = res_model != 'ir.ui.view' and kwargs.get('res_id') or None
+        if res_model != 'ir.ui.view' and kwargs.get('res_id'):
-    name = fields.Char('Warehouse Name', index=True, required=True)
+    name = fields.Char('Warehouse Name', index=True, required=True, default=lambda self: self.env['res.company']._company_default_get('stock.inventory').name)
-            moves_to_backorder._action_assign()
+            picking._create_backorder()
-        """ Move all non-done lines into a new backorder picking. If the key 'do_only_split' is given in the context, then move all lines not in context.get('split', []) instead of all non-done lines.
+        """ Move all non-done lines into a new backorder picking.
-            backorders |= backorder_picking
+            moves_to_backorder = picking.move_lines.filtered(lambda x: x.state not in ('done', 'cancel'))
-                'name': _('INV: %s') % tools.ustr(wizard.product_id.name),
+                'name': _('INV: %s') % tools.ustr(wizard.product_id.display_name),
-        finally:
+        kwargs.update({'3d_secure': True})
-                        'src': element.name,
+                        'src': element[in_field],
-            key=lambda p: (p.active, p.create_date),
+            key=lambda p: (p.active, (p.create_date or '')),
-                            xarch, xfields = self.with_context(base_model_name=model).postprocess_and_fields(field.comodel_name, f, view_id)
+                            xarch, xfields = self.with_context(
-    def get_attrs_field_names(self, arch):
+    def get_attrs_field_names(self, arch, model, editable):
-        def process(node, get=get_name):
+        def process(node, model, editable, get=get_name):
-            if node.tag == 'field':
+
-                process(child, get)
+                process(child, model, editable, get)
-        process(arch)
+        process(arch, model, editable)
-            attrs_fields = self.get_attrs_field_names(node)
+            editable = self.env.context.get('view_is_editable', True)
-            product.bom_count = bom_count
+            product.bom_count = mapped_data.get(product.id, 0) + mapped_data_tmpl.get(product.product_tmpl_id.id, 0)
-                price += sbom.product_id.uom_id._compute_price(sbom.product_id.standard_price, sbom.product_uom_id) * sbom_data['qty']
+            price += sbom.product_id.uom_id._compute_price(sbom.product_id.standard_price, sbom.product_uom_id) * sbom_data['qty']
-from odoo.tools import float_compare, float_round, pycompat
+from odoo.tools import float_compare, float_round, float_is_zero, pycompat
-            if product_tot_qty_available == 0:
+            if float_is_zero(product_tot_qty_available, precision_rounding=rounding):
-        ('married', 'Married (or similar)'),
+        ('married', 'Married'),
-                <field name='city_id' attrs="{'invisible': [('country_enforce_cities', '=', False)], 'readonly': [('type', '=', 'contact'), ('parent_id', '!=', False)]}" context="{'default_country_id': country_id}" domain="[('country_id', '=', country_id)]"/>
+                <field name='city' placeholder="%s" attrs="{'invisible': [('country_enforce_cities', '=', True), ('city_id', '!=', False)], 'readonly': [('type', '=', 'contact'), ('parent_id', '!=', False)]}"/>
-            """
+            """ % (_('City'), _('City'))
-        for meeting in self:
+        for meeting in self.sudo():
-        return super(MailComposeMessage, self.with_context(mail_post_autofollow=True)).send_mail(auto_commit=auto_commit)
+        return super(MailComposeMessage, self).send_mail(auto_commit=auto_commit)
-            of those fields.
+        *   For the other fields, the method ``execute`` invokes `set_values`.
-    @api.constrains('amount_currency')
+    @api.constrains('amount_currency', 'debit', 'credit')
-from os.path import join
+from os.path import join, isdir
-            if not os.path.isdir(self.input_dir):
+            if not isdir(self.input_dir):
-    currency_id = fields.Many2one('res.currency', related='pricelist_id.currency_id', string='Default Currency')
+    currency_id = fields.Many2one('res.currency', related='pricelist_id.currency_id', related_sudo=False, string='Default Currency')
-
+    # DO NOT FORWARD-PORT!!! ONLY FOR v10
-                return odoo.modules.registry.Registry.new(cr.dbname, force_demo, status, update_module)
+                registry = odoo.modules.registry.Registry.new(
-            self.scheduled_date = min(self.move_lines.mapped('date_expected') or [False])
+            self.scheduled_date = min(self.move_lines.mapped('date_expected') or [fields.Datetime.now()])
-            self.scheduled_date = max(self.move_lines.mapped('date_expected') or [False])
+            self.scheduled_date = max(self.move_lines.mapped('date_expected') or [fields.Datetime.now()])
-    module_account_reports_followup = fields.Boolean("Enable payment followup management")
+    module_account_reports_followup = fields.Boolean("Follow-up Levels")
-    module_account_sepa = fields.Boolean(string='Use SEPA payments')
+    module_account_sepa = fields.Boolean(string='SEPA Credit Transfer (SCT)')
-    module_currency_rate_live = fields.Boolean(string="Allow Currency Rate Live")
+    module_currency_rate_live = fields.Boolean(string="Automatic Currency Rates")
-                    record._cache.update(record._convert_to_cache(new_vals, update=True))
+
-                    self._fields[key].determine_inverse(self)
+                    field = self._fields[key]
-            res['stage_id'] = (self.stage_id.mail_template_id, {'composition_mode': 'mass_mail'})
+        test_issue = self[0]
-            ELSE rp.ref
+            ELSE replace(rp.ref, '|', '/')
-            ELSE rp.ref
+            ELSE replace(rp.ref, '|', '/')
-    _ogone_pending_tx_status = [46]   # 3DS HTML response
+    _ogone_wait_tx_status = [41, 50, 51, 52, 55, 56, 91, 92, 99]
-        if self.state in ['done', 'refunded']:
+        if self.state in ['done', 'refunding', 'refunded']:
-            self.write({
+            vals = {
-            })
+            }
-    bank_account_id = fields.Many2one('res.partner.bank', string="Bank Account", ondelete='restrict', copy=False, domain="[('partner_id','=', company_id)]")
+    bank_account_id = fields.Many2one('res.partner.bank', string="Bank Account", ondelete='restrict', copy=False)
-                    self.bank_account_id.company_id = vals['company_id']
+                company = self.env['res.company'].browse(vals['company_id'])
-                raise UserError(_('You cannot empty the bank account once set.'))
+            if 'bank_account_id' in vals:
-            'int_type_id': {'name': self.name + _('Sequence internal'), 'prefix': self.code + '/INT/', 'padding': 5},
+            'in_type_id': {'name': self.name + ' ' + _('Sequence in'), 'prefix': self.code + '/IN/', 'padding': 5},
-            "WHERE l.partner_id IN %s AND at.type IN ('receivable', 'payable') AND NOT l.reconciled GROUP BY l.date, l.name, l.ref, l.date_maturity, l.partner_id, at.type, l.blocked, l.amount_currency, l.currency_id, l.move_id, m.name", (((fields.date.today(), ) + (tuple(partner_ids),))))
+            "WHERE l.partner_id IN %s AND at.type IN ('receivable', 'payable') AND l.full_reconcile_id IS NULL GROUP BY l.date, l.name, l.ref, l.date_maturity, l.partner_id, at.type, l.blocked, l.amount_currency, l.currency_id, l.move_id, m.name", (((fields.date.today(), ) + (tuple(partner_ids),))))
-        reconcile_clause = "" if data['form']['reconciled'] else ' AND "account_move_line".reconciled = false '
+        reconcile_clause = "" if data['form']['reconciled'] else ' AND "account_move_line".full_reconcile_id IS NULL '
-        reconcile_clause = "" if data['form']['reconciled'] else ' AND "account_move_line".reconciled = false '
+        reconcile_clause = "" if data['form']['reconciled'] else ' AND "account_move_line".full_reconcile_id IS NULL '
-        reconcile_clause = "" if data['form']['reconciled'] else ' AND "account_move_line".reconciled = false '
+        reconcile_clause = "" if data['form']['reconciled'] else ' AND "account_move_line".full_reconcile_id IS NULL '
-            if at_least_one_amount:
+            if at_least_one_amount or self._context.get('include_nullified_amount'):
-    _order = "priority desc, sequence, date_start, name, id"
+    _order = "priority desc, sequence, id desc"
-    _ogone_wait_tx_status = [41, 50, 51, 52, 55, 56, 91, 92, 99]
+    _ogone_valid_tx_status = [5, 9, 8]
-            'RTIMEOUT': 30,
+            'OPERATION': 'RFS',
-        direct_order_url = 'https://secure.ogone.com/ncol/%s/orderdirect.asp' % (self.acquirer_id.environment)
+        direct_order_url = 'https://secure.ogone.com/ncol/%s/maintenancedirect.asp' % (self.acquirer_id.environment)
-        return werkzeug.utils.redirect(post.pop('return_url', '/'))
+        return werkzeug.utils.redirect(url_unquote_plus(post.pop('return_url', '/')))
-            'PARAMPLUS': 'return_url=%s' % ogone_tx_values.pop('return_url') if ogone_tx_values.get('return_url') else False,
+            'PARAMPLUS': url_encode(param_plus),
-        return True
+        return url
-    is_service = fields.Boolean("Is a Service", compute='_compute_is_service', store=True, help="Sales Order item should generate a task and/or a project, depending on the product settings.")
+    is_service = fields.Boolean("Is a Service", compute='_compute_is_service', store=True, compute_sudo=True, help="Sales Order item should generate a task and/or a project, depending on the product settings.")
-            record[name] = value
+        with env.do_in_onchange():
-            ('location_dest_id', '=', self.location_id.id),
+            '|',
-            ('package_id', '=', self.package_id.id)]
+            '|',
-        for line in self.move_id.line_ids:
+        for line in self.move_id.line_ids.filtered(lambda l: l.account_id.id == self.account_id.id):
-                'name': category and category.name or 'Uncategorized',
+                'name': category and category.name or _('Uncategorized'),
-        'Name', default=lambda self: self.env['ir.sequence'].next_by_code('stock.landed.cost'),
+        'Name', default=lambda self: _('New'),
-re_escaped_replacements = {'n': '\n', }
+re_escaped_replacements = {'n': '\n', 't': '\t',}
-                        'membership.membership_line': (_get_partner_id, ['state'], 10, ),
+                        'membership.membership_line': (_get_partner_id, ['state', 'date_cancel', 'date_from'], 10, ),
-                        'membership.membership_line': (_get_partner_id, ['state'], 10),
+                        'membership.membership_line': (_get_partner_id, ['state', 'date_cancel', 'date_to'], 10),
-                        'membership.membership_line': (_get_partner_id, ['state'], 10),
+                        'membership.membership_line': (_get_partner_id, ['state', 'date_cancel'], 10),
-                'company_id': emp.company_id.id,
+                'company_id': employee.company_id.id,
-            if order.currency_id != self.company_id.currency_id:
+            #also change when the unit price on the PO line changes in the meantime
-    _logger.warning("Could not find view arch definition in file '%s' for xmlid '%s'", filename, xmlid)
+
-                        data['arch_fs'] = '/'.join(path_info[0:2])
+
-            view.with_context(lang=None).write({'arch': xml_content, 'arch_fs': False})
+
-    currency_id = fields.Many2one('res.currency', related='pricelist_id.currency_id', string='Default Currency')
+    currency_id = fields.Many2one('res.currency', related='pricelist_id.currency_id', related_sudo=False, string='Default Currency')
-                if not pack_lots:
+                if not pack_lots and not float_is_zero(qty_done, precision_rounding=move.product_uom.rounding):
-        self.department_id = self.employee_id and self.employee_id.department_id
+        self.department_id = self.employee_id.department_id
-            product = self.env['product.product'].search([('default_code', 'ilike', product_code.group(1))]) or default_product
+            products = self.env['product.product'].search([('default_code', 'ilike', product_code.group(1))]) or default_product
-        if 'picking_id' in vals and 'move_id' not in vals:
+        if 'picking_id' in vals and not vals.get('move_id'):
-                    with cr.savepoint():
+                    with self._cr.savepoint():
-        channel = request.env['mail.channel'].search([('uuid', '=', channel_uuid)])
+        partner_ids = (pid, request.env.user.partner_id.id)
-                if re.search(rule.regex_url, url):
+                if re.search(rule.regex_url or '', url):
-from datetime import datetime, timedelta, date
+from datetime import datetime, timedelta
-from openerp import tools, api
+from openerp import tools, api, fields as newfields
-            date_today = date(now_user_tz.year, now_user_tz.month, now_user_tz.day)
+        date_today = newfields.Date.from_string(fields.date.context_today(self, cr, uid, context=context))
-from datetime import datetime, date
+from openerp import models, fields, api, tools
-import openerp.addons.decimal_precision as dp
+        today = fields.Date.from_string(oldfields.date.context_today(self, cr, uid, context=context))
-            ('date', '>=', date.today().replace(day=1) - relativedelta(months=+1)),
+            ('date', '>=', today.replace(day=1) - relativedelta(months=+1)),
-                if inv_date <= date.today() and inv_date >= date.today().replace(day=1):
+                if inv_date <= today and inv_date >= today.replace(day=1):
-                elif inv_date < date.today().replace(day=1) and inv_date >= date.today().replace(day=1) - relativedelta(months=+1):
+                elif inv_date < today.replace(day=1) and inv_date >= today.replace(day=1) - relativedelta(months=+1):
-        record = request.env[model.model].sudo().with_context(mail_create_nosubscribe=True).create(values)
+        model_name = model.sudo().model
-                if default_field.ttype == 'html' or model.model == 'mail.mail':
+                if default_field.ttype == 'html' or model_name == 'mail.mail':
-                    'model': model.model,
+                    'model': model_name,
-        record = model.env[model.model].browse(id_record)
+        model_name = model.sudo().model
-                'res_model': model.model,
+                'res_model': model_name,
-            if model.model != 'mail.mail':
+            if model_name != 'mail.mail':
-                    'model': model.model,
+                    'model': model_name,
-                if date_deadline == date.today():
+                if date_deadline == date_today:
-                if date_deadline >= date.today() and date_deadline <= date.today() + timedelta(days=7):
+                if date_deadline >= date_today and date_deadline <= date_today + timedelta(days=7):
-                if date_deadline < date.today() and not opp['date_closed']:
+                if date_deadline < date_today and not opp['date_closed']:
-                if date_action == date.today():
+                if date_action == date_today:
-                if date_action >= date.today() and date_action <= date.today() + timedelta(days=7):
+                if date_action >= date_today and date_action <= date_today + timedelta(days=7):
-                if date_action < date.today() and not opp['date_closed']:
+                if date_action < date_today and not opp['date_closed']:
-                if date_closed <= date.today() and date_closed >= date.today().replace(day=1):
+                if date_closed <= date_today and date_closed >= date_today.replace(day=1):
-                elif date_closed < date.today().replace(day=1) and date_closed >= date.today().replace(day=1) - relativedelta(months=+1):
+                elif date_closed < date_today.replace(day=1) and date_closed >= date_today.replace(day=1) - relativedelta(months=+1):
-                if date_act <= date.today() and date_act >= date.today().replace(day=1):
+                if date_act <= date_today and date_act >= date_today.replace(day=1):
-                elif date_act < date.today().replace(day=1) and date_act >= date.today().replace(day=1) - relativedelta(months=+1):
+                elif date_act < date_today.replace(day=1) and date_act >= date_today.replace(day=1) - relativedelta(months=+1):
-                if start == date.today():
+                if start == date_today:
-                if start >= date.today() and start <= date.today() + timedelta(days=7):
+                if start >= date_today and start <= date_today + timedelta(days=7):
-        self.env.ref('base.main_company').write({'currency_id': self.currency_eur_id})
+
-        self.env.ref('base.main_company').write({'currency_id': self.currency_euro_id})
+        company = self.env.ref('base.main_company')
-            self.assertEquals(aml.currency_id.id, line['currency_id'])
+            self.assertEquals(aml.currency_id.id, line['currency_id'])
-            average_price_unit = (average_price_unit * (qty_delivered - qty_to_consider) + (-1 * move.price_unit) * qty_to_consider) / qty_delivered
+            # `move.price_unit` is negative if the move is out and positive if the move is
-        for move in res.filtered(lambda m: m.product_id.valuation == 'real_time' and (m._is_in() or m._is_out())):
+        for move in res.filtered(lambda m: m.product_id.valuation == 'real_time' and (m._is_in() or m._is_out() or m._is_dropshipped())):
-        if self.company_id.anglo_saxon_accounting and self.location_id.usage == 'supplier' and self.location_dest_id.usage == 'customer':
+        if self.company_id.anglo_saxon_accounting and self._is_dropshipped():
-        return [('procure_method', '=', 'make_to_order'), ('move_orig_ids', '=', False)]
+        return [('procure_method', '=', 'make_to_order'), ('move_orig_ids', '=', False), ('state', 'not in', ('cancel', 'done', 'draft'))]
-                model._transient_vacuum(force=True)
+                try:
-from openerp.exceptions import ValidationError
+from openerp.exceptions import ValidationError, UserError
-            attribute_value_ids.append([variant.id, visible_attribute_ids, variant.website_price, price])
+            attribute_value_ids.append([variant.id, visible_attribute_ids, variant.website_price / quantity, price])
-    task_id = fields.Many2one('project.task', 'Task')
+    task_id = fields.Many2one('project.task', 'Task', index=True)
-    parent_id = fields.Many2one('project.task', string='Parent Task')
+    parent_id = fields.Many2one('project.task', string='Parent Task', index=True)
-    task_id = fields.Many2one('project.task', 'Task', help="Task generated by the sales order item")
+    task_id = fields.Many2one('project.task', 'Task', index=True, help="Task generated by the sales order item")
-            message.discussion.name
+        with self.env.do_in_onchange():
-        self.assertEqual(message.discussion, discussion)
+        with self.env.do_in_onchange():
-        self.assertEqual(message.discussion_name, discussion.name)
+            # read the related field discussion_name
-        if records.env != others.env:
+        if records.env.in_onchange and records.env != others.env:
-            env['account.invoice.report'].init()
+            if 'account.invoice.report' in env:
-    note_pad_url = fields.Char('Pad Url', pad_content_field='memo')
+    note_pad_url = fields.Char('Pad Url', pad_content_field='memo', copy=False)
-        self._set_pad_value(vals)
+        self._set_field_to_pad(vals)
-        self._set_pad_value(vals)
+        # Case of a regular creation: we receive the pad url, so we need to update the
-        # normally initialized by the JS layer
+        # Case of a programmatical creation (e.g. copy): we receive the field content, so we need
-
+    def _set_field_to_pad(self, vals):
-    description_pad = fields.Char('Pad URL', pad_content_field='description')
+    description_pad = fields.Char('Pad URL', pad_content_field='description', copy=False)
-
+    @classmethod
-                record.embed_code = '<iframe src="%s/slides/embed/%s?page=1" allowFullScreen="true" height="%s" width="%s" frameborder="0"></iframe>' % (base_url, record.id, 315, 420)
+                record.embed_code = '<iframe src="%s/slides/embed/%s?page=1" class="o_wslides_iframe_viewer" allowFullScreen="true" height="%s" width="%s" frameborder="0"></iframe>' % (base_url, record.id, 315, 420)
-    @api.depends('debit', 'credit', 'amount_currency', 'currency_id', 'matched_debit_ids', 'matched_credit_ids', 'matched_debit_ids.amount', 'matched_credit_ids.amount', 'account_id.currency_id', 'move_id.state')
+    @api.depends('debit', 'credit', 'amount_currency', 'currency_id', 'matched_debit_ids', 'matched_credit_ids', 'matched_debit_ids.amount', 'matched_credit_ids.amount', 'move_id.state')
-    @http.route(['/website_payment/transaction/<string:reference>/<string:amount>/<string:currency_id>',], type='json', auth='public')
+    @http.route(['/website_payment/transaction/<string:reference>/<string:amount>/<string:currency_id>',
-    @http.route(['/website_payment/token/<string:reference>/<float:amount>/<int:currency_id>'], type='http', auth='public', website=True)
+    @http.route(['/website_payment/token/<string:reference>/<string:amount>/<string:currency_id>',
-            confirmed_moves = self.env['stock.move'].search([('state', '=', 'confirmed')], limit=None, order='priority desc, date_expected asc')
+            confirmed_moves = self.env['stock.move'].search([('state', '=', 'confirmed'), ('product_uom_qty', '!=', 0.0)], limit=None, order='priority desc, date_expected asc')
-            'type': 'out_invoice',
+            'type': invoice_type,
-            'quantity': line.qty,
+            'quantity': line.qty if self.amount_total >= 0 else -line.qty,
-        distinct_fields.append('purchase_line_id')
+        distinct_fields += ['purchase_line_id', 'created_purchase_line_id']
-        keys_sorted.append(move.purchase_line_id.id)
+        keys_sorted += [move.purchase_line_id.id, move.created_purchase_line_id.id]
-            self._autoconfirm_picking()
+            # Do not run autoconfirm if any of the moves has an initial demand. If an initial demand
-            user_activity = lead.activity_ids.filtered(lambda activity: activity.user_id == self.env.user)[:1]
+            user_activity = lead.sudo().activity_ids.filtered(lambda activity: activity.user_id == self.env.user)[:1]
-            request.session['view_quote'] = now
+        if Order and request.session.get('view_quote_%s' % Order.id) != now and request.env.user.share:
-        self.write({'state': 'purchase'})
+        self.write({'state': 'purchase', 'date_approve': fields.Date.context_today(self)})
-                                    globals_dict={'parent': dotdict(parent)},
+                                    globals_dict={'parent': dotdict(parent), 'context': ctx},
-                'price': self.fixed_price,
+                'price': price,
-        raise UserError(_('Duplicate a company is not allowed. Please create a new one instead.'))
+        raise UserError(_('Duplicating a company is not allowed. Please create a new company instead.'))
-                    values['timesheet_invoice_id'] = so_line.invoice_lines[0].invoice_id.id
+                    values['timesheet_invoice_id'] = so_line.invoice_lines and so_line.invoice_lines[0].invoice_id.id
-        self.crm_alias_prefix = 'info' if self.generate_lead_from_alias else False
+        self.crm_alias_prefix = (self.crm_alias_prefix or 'info') if self.generate_lead_from_alias else False
-    module_crm_phone_validation = fields.Boolean("Phone Validation")
+    module_crm_phone_validation = fields.Boolean("Phone Formatting")
-        return self.env['stock.location'].search([('scrap_location', '=', True)], limit=1).id
+        return self.env['stock.location'].search([('scrap_location', '=', True), ('company_id', 'in', [self.env.user.company_id.id, False])], limit=1).id
-        return self.env.ref('stock.stock_location_stock', raise_if_not_found=False)
+        company_user = self.env.user.company_id
-from odoo.exceptions import ValidationError
+from odoo.exceptions import ValidationError, UserError
-        return super(Company, self).copy(default)
+        raise UserError(_('Duplicate a company is not allowed. Please create a new one instead.'))
-        rec = self.env['account.analytic.default'].account_get(self.product_id.id, self.invoice_id.partner_id.id, self.env.uid,
+        rec = self.env['account.analytic.default'].account_get(self.product_id.id, self.invoice_id.commercial_partner_id.id, self.env.uid,
-                self.product_id.id, self.invoice_id.partner_id.id, self.env.uid,
+                self.product_id.id, self.invoice_id.commercial_partner_id.id, self.env.uid,
-    dummy_account_id = fields.Many2one('account.account', related='line_ids.account_id', string='Account', store=False)
+    dummy_account_id = fields.Many2one('account.account', related='line_ids.account_id', string='Account', store=False, readonly=True)
-    user_type_id = fields.Many2one('account.account.type', string='Type', required=True, oldname="user_type", 
+    user_type_id = fields.Many2one('account.account.type', string='Type', required=True, oldname="user_type",
-                if val == '':
+                val = val.strip()
-                order.state = 'sent'
+                order.with_context(tracking_disable=True).state = 'sent'
-                sequence.number_next = journal.sequence_number_next
+                sequence.sudo().number_next = journal.sequence_number_next
-            'target': 'current',
+            'target': 'inline',
-            existing_variants = {frozenset(variant.attribute_value_ids.ids) for variant in tmpl_id.product_variant_ids}
+            existing_variants = {frozenset(variant.attribute_value_ids.filtered(lambda r: r.attribute_id.create_variant).ids) for variant in tmpl_id.product_variant_ids}
-                if st_line.bank_account_id and st_line.partner_id and st_line.bank_account_id.partner_id != st_line.partner_id:
+                if st_line.bank_account_id and st_line.partner_id and not st_line.bank_account_id.partner_id:
-            context=dict(self.env.context, default_vehicle_id=self.id, search_default_parent_false=True),
+            context=dict(copy_context, default_vehicle_id=self.id, search_default_parent_false=True),
-            'search_default_journal_id': self.id,
+        if not self.env.context.get('use_domain'):
-        default=lambda self: self.env['account.journal'].search([('type', '=', 'bank')], limit=1),
+        'account.journal', 'Payment Journal', domain=[('type', 'in', ['bank', 'cash'])],
-
+        'deprecated-module',
-    filenames = [f for f in filenames if f.lower().endswith('.xml')]
+    filepaths = []
-        root = lxml.etree.parse(os.path.join(path, filename)).getroot()
+    for fp in filepaths:
-        if self._context.get('check_move_validity', True):
+        if self._context.get('check_move_validity', True) and any(key in vals for key in ('account_id', 'journal_id', 'date', 'move_id', 'debit', 'credit')):
-import wizard
+import wizard
-
+            env['account.invoice.report'].init()
-                    + (1.326 / 1.05 * 12.0) * contract.commission_on_target \
+                    + contract.warrants_cost \
-                moves.filtered(lambda m: m.state in ['confirmed', 'waiting']).force_assign()
+                moves.filtered(lambda m: m.state in ['confirmed', 'waiting'])._force_assign()
-from odoo.tools.safe_eval import safe_eval
+from odoo.tools import DEFAULT_SERVER_DATE_FORMAT, ustr
-                'html_3ds': base64.b64decode(tree.HTML_ANSWER.decode('ascii')),
+                'html_3ds': ustr(base64.b64decode(tree.HTML_ANSWER.text)),
-        return {}
+        return {}
-        price, running the vacuum should not do anything.
+        price, running the vacuum should not do anything. Receive 2 units at the price the two
-        # ---------------------------------------------------------------------
+        # Now receive exactly the extra units at exactly the price sent, no
-    @http.route('/sitemap.xml', type='http', auth="public", website=True)
+    @http.route('/sitemap.xml', type='http', auth="public", website=True, multilang=False)
-        dom = [('website_published', '=', True), ('assigned_partner_id', '!=', False)]
+        dom = [('website_published', '=', True), ('assigned_partner_id', '!=', False), ('country_id', '!=', False)]
-from odoo import api, models
+from odoo import models
-        # the other module is installed
+        # Prevent the deletion of some `shared` fields... -_-
-                rec.name in social
+                (rec.model == 'res.company' and rec.name in social)
-        default=lambda self: self.env['res.company']._company_default_get())
+    company_id = fields.Many2one('res.company', string='Company', default=lambda self: self.env['res.company']._company_default_get())
-    uuid = fields.Char('UUID', size=50, index=True, default=lambda self: '%s' % uuid.uuid4())
+    uuid = fields.Char('UUID', size=50, index=True, default=lambda self: '%s' % uuid.uuid4(), copy=False)
-        default_template = self._get_default_template_id()
+        default_template = self._get_default_template()
-                    current_leave_struct['number_of_days'] += leave_time / work_hours
+                    if work_hours:
-            days_count += float_utils.round((work_time.total_seconds() / 3600 / theoric_hours) * 4) / 4
+            if theoric_hours:
-            days_count += float_utils.round((leave_time.total_seconds() / 3600 / theoric_hours) * 4) / 4
+            if theoric_hours:
-        help="Timezone used when encoding the leave. It is used to correctly"
+        _tz_get, string='Timezone', default=lambda self: self._context.get('tz') or self.env.user.tz or 'UTC',
-            if counterpart_aml['debit'] or writeoff_line['credit']:
+            if counterpart_aml['debit'] or (writeoff_line['credit'] and not counterpart_aml['credit']):
-            if counterpart_aml['credit'] or writeoff_line['debit']:
+            if counterpart_aml['credit'] or (writeoff_line['debit'] and not counterpart_aml['debit']):
-    discount_product_id = fields.Many2one('product.product', string='Discount Product', domain="[('available_in_pos', '=', True)]", help='The product used to model the discount.', default=_get_default_discount_product)
+    discount_pc = fields.Float(string='Discount Percentage', help='The default discount percentage')
-            self.discount_product_id = self.env['product.product'].search([('available_in_pos', '=', True)], limit=1)
+            self.discount_product_id = self.env.ref('point_of_sale.product_product_consumable', raise_if_not_found=False)
-            contract.warrant_value_employee = contract.commission_on_target * (1.00 - 0.535) * 12.0
+            contract.warrants_cost = contract.commission_on_target * 1.326 * 1.05 * 12.0
-            self.require_payment = self.template_id.require_payment
+    ], 'Payment', help="Require immediate payment by the customer when validating the order from the website quote", default=_default_require_payment)
-                values['partner_id'] = project.partner_id.id
+                if project.partner_id:
-            self.with_context(sale_analytic_norecompute=True)._sale_determine_order_line()
+            # only take the AAL from expense or vendor bill, meaning having a negative amount
-            - (1.326 / 1.05 * 12.0) * contract.commission_on_target \
+            - contract.warrants_cost \
-        })
+        Project = request.env['project.project']
-        projects = request.env['project.project'].search([('privacy_visibility', '=', 'portal')])
+        # Note: portal users can't view projects they don't follow
-            groupby_list = groupby if not lazy else groupby[:-1]
+            groupby_list = groupby[:1] if lazy else groupby
-            tables, where_clause, where_clause_params = self._where_calc(domain).get_sql()
+            query = self._where_calc(domain)
-        if field_data.get('track_visibility'):
+        if attrs and field_data.get('track_visibility'):
-            'picking_id': self.picking_id.id
+            'picking_id': self.picking_id.id,
-        for pick in self:
+        for pick in self.filtered(lambda p: p.state not in ('done', 'cancel')):
-            currency_id = inv.currency_id.id
+            currency = inv.currency_id
-            currency_id = False
+            currency = False
-        return self.env['product.product']._anglo_saxon_sale_move_lines(i_line.name, i_line.product_id, i_line.uom_id, i_line.quantity, price_unit, currency=currency_id, amount_currency=amount_currency, fiscal_position=inv.fiscal_position_id, account_analytic=i_line.account_analytic_id)
+        return self.env['product.product']._anglo_saxon_sale_move_lines(i_line.name, i_line.product_id, i_line.uom_id, i_line.quantity, price_unit, currency=currency, amount_currency=amount_currency, fiscal_position=inv.fiscal_position_id, account_analytic=i_line.account_analytic_id)
-    confirmation_date = fields.Datetime(string='Confirmation Date', readonly=True, index=True, help="Date on which the sale order is confirmed.", oldname="date_confirm")
+    confirmation_date = fields.Datetime(string='Confirmation Date', readonly=True, index=True, help="Date on which the sale order is confirmed.", oldname="date_confirm", copy=False)
-                notification = _('<div class="o_mail_notification">joined <a href="#" class="o_channel_redirect" data-oe-id="%s">#%s</a></div>') % (self.id, self.name,)
+                if partner.id != self.env.user.partner_id.id:
-        self.address_id = self.employee_id.address_home_id
+        self.address_id = self.employee_id.sudo().address_home_id
-            elif picking.state not in ('draft', 'confirmed', 'assigned') or not picking.is_locked:
+            elif picking.state not in ('draft', 'waiting', 'confirmed', 'assigned') or not picking.is_locked:
-        todo_moves = self.mapped('move_lines').filtered(lambda self: self.state in ['draft', 'partially_available', 'assigned', 'confirmed'])
+        todo_moves = self.mapped('move_lines').filtered(lambda self: self.state in ['draft', 'waiting', 'partially_available', 'assigned', 'confirmed'])
-            'res_id': self.env.user.company_id.id,
+            'res_model': 'res.config.settings',
-                                                        submit_txt=_('Pay Now')).browse(acquirer_id)
+        acquirers = None
-            'payment_form': payment_form,
+            'return_url': '/website_payment/confirm',
-    def transaction(self, reference, amount, currency_id, acquirer_id):
+        values['s2s_acquirers'] = [acq for acq in acquirers if acq.payment_flow == 's2s']
-            'acquirer_id': int(acquirer_id),
+            'acquirer_id': token.acquirer_id.id,
-        return tx.id
+
-        tx_id = request.session.pop('website_payment_tx_id', False)
+        tx_id = int(kw.get('tx_id', 0)) or request.session.pop('website_payment_tx_id', 0)
-        item2 = self.products['prod_del']
+        item1 = self.products['prod_order']  # consumable
-from odoo.tools.float_utils import float_compare, float_round
+from odoo.tools.float_utils import float_compare, float_is_zero, float_round
-            raise UserError(_('You cannot validate a transfer if you have not processed any quantity.'))
+        no_quantities_done = all(float_is_zero(move_line.qty_done, precision_rounding=move_line.product_uom_id.rounding) for move_line in self.move_line_ids)
-            Move line quantity should be set to their reservation quantity automatically
+        """ In a picking with a single available move, clicking on validate without filling any
-        owner = self.env['res.partner'].create({'name': 'Jean'})
+        partner = self.env['res.partner'].create({'name': 'Jean'})
-            'partner_id': owner.id,
+            'partner_id': partner.id,
-            'name': 'test_edit_moveline_1',
+            'name': 'test_immediate_validate_1',
-            remaining quantity.
+        """ In a picking with a single partially available move, clicking on validate without
-        owner = self.env['res.partner'].create({'name': 'Jean'})
+        partner = self.env['res.partner'].create({'name': 'Jean'})
-            'partner_id': owner.id,
+            'partner_id': partner.id,
-            'name': 'test_edit_moveline_1',
+            'name': 'test_immediate_validate_2',
-        self.assertEqual(len(picking.move_lines.move_line_ids), 1)
+        # Only 5 products should be processed on the initial move.
-        self.assertEqual(picking.move_lines.move_line_ids.qty_done, 5.0)
+        # The backoder should contain a move for the other 5 produts.
-        owner = self.env['res.partner'].create({'name': 'Jean'})
+        """ In a picking with two moves, one partially available and one unavailable, clicking
-            'picking_type_id': self.env.ref('stock.picking_type_out').id,
+            'location_dest_id': self.pack_location.id,
-            'name': 'test_edit_moveline_1',
+        product1_move = self.env['stock.move'].create({
-            'location_dest_id': self.customer_location.id,
+            'location_dest_id': self.pack_location.id,
-            'product_uom_qty': 10.0,
+            'product_uom_qty': 100,
-        wizard = self.env[(res_dict.get('res_model'))].browse(res_dict.get('res_id'))
+        picking.action_assign()
-        self.assertEqual(len(self.env['stock.quant']._gather(self.product1, self.stock_location)), 1.0)
+        # The backorder should contain 99 product1 and 100 product5.
-            return a UserError.
+        """ In a picking with a single available tracked by lot move, clicking on validate without
-        owner = self.env['res.partner'].create({'name': 'Jean'})
+        partner = self.env['res.partner'].create({'name': 'Jean'})
-            'partner_id': owner.id,
+            'partner_id': partner.id,
-            'name': 'test_edit_moveline_1',
+            'name': 'test_immediate_validate_4',
-        # We do not need to catch wizard since everything is already defined and the action_done will be processed immediately
+        # All the information are present (lots and quantities), the wizard won't be opened.
-            number when the picking type is configured that way.
+        """ In a receipt with a single tracked by serial numbers move, clicking on validate without
-            - if a user overprocesses a move he will be asked to confirm if this is ok
+        """ In a receipt picking with two moves, one tracked and one untracked, clicking on
-        self.env['stock.quant']._update_available_quantity(self.product3, self.stock_location, 1, lot_id=lot1)
+
-
+
-                    move.quantity_done = move.product_uom_qty
+                for move_line in move.move_line_ids:
-            values = dict(name=self.company_name, is_company=True)
+            values = dict(name=self.company_name, is_company=True, vat=self.vat)
-    ], 'Payment', help="Require immediate payment by the customer when validating the order from the website quote")
+    ], 'Payment', help="Require immediate payment by the customer when validating the order from the website quote", compute='_compute_require_payment', store=True)
-             " of the event on the website.", store=True, copy=False)
+             " of the event on the website.", store=True)
-    menu_id = fields.Many2one('website.menu', 'Event Menu')
+    menu_id = fields.Many2one('website.menu', 'Event Menu', copy=False)
-                menu_id.page_id.write({'url': menu['url']})
+            elif menu_id.page_id:
-            contract.warrant_value_employee = contract.warrants_cost * 0.54
+            contract.warrants_cost = contract.commission_on_target * 1.05 * 12.0
-            qty += move.product_qty
+            qty += move.product_uom._compute_quantity(move.product_uom_qty, self.product_uom, rounding_method='HALF-UP')
-            template['product_uom_qty'] = diff_quantity
+            quant_uom = self.product_id.uom_id
-        self.assertEqual(mnf_product_a.product_uom_id.id, self.uom_dozen.id, 'Wrong unit of measure in manufacturing order.')
+        self.assertEqual(mnf_product_a.product_qty, 120, 'Wrong product quantity in manufacturing order.')
-                qty += move.product_qty
+                qty += move.product_uom._compute_quantity(move.product_uom_qty, line.product_uom, rounding_method='HALF-UP')
-                self.env['procurement.group'].run(line.product_id, product_qty, line.product_uom, line.order_id.partner_shipping_id.property_stock_customer, line.name, line.order_id.name, values)
+                self.env['procurement.group'].run(line.product_id, product_qty, procurement_uom, line.order_id.partner_shipping_id.property_stock_customer, line.name, line.order_id.name, values)
-            result = meeting.attendee_ids._send_mail_to_attendees('calendar.calendar_template_meeting_reminder', force_send=True)
+            result = meeting.attendee_ids.filtered(lambda r: r.state != 'declined')._send_mail_to_attendees('calendar.calendar_template_meeting_reminder', force_send=True)
-    def mail_attendees(self, template_id, force_send=False, filter_func=lambda self: True):
+    def mail_attendees(self, template_id, force_send=False, filter_func=lambda self: self.state != 'cancel'):
-        for record in self:
+
-            weeks_in_start_year = int(date(start_date.year, 12, 31).isocalendar()[1])
+            weeks_in_start_year = int(date(start_date.year, 12, 28).isocalendar()[1]) # This date is always in the last week of ISO years
-        fault = xmlrpclib.Fault(RPC_FAULT_CODE_WARNING, openerp.tools.ustr(e.value))
+        fault = xmlrpclib.Fault(RPC_FAULT_CODE_WARNING, openerp.tools.ustr(e.name))
-        self.env['ir.property'].search([('res_id', 'in', refs)]).unlink()
+        with self.env.norecompute():
-        self.delete_workflow()
+            self.delete_workflow()
-        self.check_access_rule('unlink')
+            self.check_access_rule('unlink')
-        Attachment = self.env['ir.attachment']
+            cr = self._cr
-            cr.execute(query, (sub_ids,))
+            for sub_ids in cr.split_for_in_conditions(self.ids):
-        self.invalidate_cache()
+                # Removing the ir_model_data reference if the record being deleted
-        Model = request.env[model].with_context(**params.get('context', {}))
+        Model = request.env[model].with_context(import_compat=import_compat, **params.get('context', {}))
-    # essentially same as o2m, so boring
+    def test_multiple_records_subfield(self):
-                        if field.type == 'many2many' and len(path) > 1 and path[1] == 'id':
+                        # in import_compat mode, m2m should always be exported as
-        if 'parent_id' in values:
+        if 'parent_id' in values or 'department_id' in values:
-            holidays.write({'manager_id': values['parent_id']})
+            hr_vals = {}
-    department_id = fields.Many2one('hr.department', related='employee_id.department_id', string='Department', readonly=True, store=True)
+    department_id = fields.Many2one('hr.department', string='Department', readonly=True)
-            if not policy:
+            if not policy and not product.invoice_policy =='delivery':
-                        'analytic_tag_ids': analytic_tags and analytic_tag.ids and [(6, 0, analytic_tag.ids)] or False,
+                        'analytic_tag_ids': analytic_tags and analytic_tags.ids and [(6, 0, analytic_tags.ids)] or False,
-                        'analytic_tag_ids': analytic_tags and analytic_tag.ids and [(6, 0, analytic_tag.ids)] or False,
+                        'analytic_tag_ids': analytic_tags and analytic_tags.ids and [(6, 0, analytic_tags.ids)] or False,
-                        line.update({'price': company_currency.round(valuation_price_unit * line['quantity'])})
+                        line.update({'price': inv.currency_id.round(valuation_price_unit * line['quantity'])})
-                            'price_unit': company_currency.round(price_unit - valuation_price_unit),
+                            'price_unit': inv.currency_id.round(price_unit - valuation_price_unit),
-                            'price': company_currency.round(price_before - line.get('price', 0.0)),
+                            'price': inv.currency_id.round(price_before - line.get('price', 0.0)),
-        user_company = self.env.user.company_id.id
+        company_ids = self.env.context.get('company_ids', (self.env.user.company_id.id,))
-        arg_list += (date_from, user_company)
+        arg_list += (date_from, tuple(company_ids))
-                AND l.company_id = %s
+                AND l.company_id IN %s
-        cr.execute(query, (tuple(move_state), tuple(account_type), date_from, tuple(partner_ids), date_from, user_company))
+                AND l.company_id IN %s'''
-            args_list += (date_from, user_company)
+            args_list += (date_from, tuple(company_ids))
-                    AND l.company_id = %s'''
+                    AND l.company_id IN %s'''
-        return self.uom_id._compute_price(self.uom_id.id, price, to_uom_id=uom.id)
+        return self.uom_id._compute_price(price, uom)
-            domain += [('website_published', '=', True), '|', ('date_publish', '!=', False), ('date_publish', '>', fields.Datetime.now())]
+            domain += [('website_published', '=', True), '|', ('date_publish', '=', False), ('date_publish', '<=', fields.Datetime.now())]
-            currency_id = inv.currency_id.id
+            currency = inv.currency_id
-            currency_id = False
+            currency = False
-        return self.env['product.product']._anglo_saxon_sale_move_lines(i_line.name, i_line.product_id, i_line.uom_id, i_line.quantity, price_unit, currency=currency_id, amount_currency=amount_currency, fiscal_position=inv.fiscal_position_id, account_analytic=i_line.account_analytic_id, analytic_tags=i_line.analytic_tag_ids)
+        return self.env['product.product']._anglo_saxon_sale_move_lines(i_line.name, i_line.product_id, i_line.uom_id, i_line.quantity, price_unit, currency=currency, amount_currency=amount_currency, fiscal_position=inv.fiscal_position_id, account_analytic=i_line.account_analytic_id, analytic_tags=i_line.analytic_tag_ids)
-            req = requests.get(kwargs.get('url'), stream=True)
+            req = requests.get(kwargs.get('url'))
-            arch = lxml.html.parse(req.raw)
+            arch = lxml.html.fromstring(req.content)
-            raise UserError(_('You still have some active reordering rules on this product. Please archive or delete them first.'))
+        if 'active' in values and not values['active']:
-        def _flatten_tax_and_children(taxes):
+        def _flatten_tax_and_children(taxes, group_done=None):
-                children |= _flatten_tax_and_children(tax.children_tax_ids)
+            if group_done is None:
-_image_dataurl = re.compile(r'(data:image/[a-z]+?);base64,([a-z0-9+/]{3,}=*)([\'"])', re.I)
+_image_dataurl = re.compile(r'(data:image/[a-z]+?);base64,([a-z0-9+/\n]{3,}=*)\n*([\'"])', re.I)
-                return '%s%s alt="%s"' % (data_to_url[key], match.group(3), name)
+                    data_to_url[key] = (name, '/web/image/%s' % attachment.id)
-            headers['List-Id'] = '%s.%s' % (self.alias_name, self.alias_domain)
+            headers['List-Id'] = '<%s.%s>' % (self.alias_name, self.alias_domain)
-            domain += [('date_from', '<', fields.Datetime.to_string(start_datetime + timedelta(days=1)))]
+            domain += [('date_from', '<', fields.Datetime.to_string(end_datetime + timedelta(days=1)))]
-            variant_alone = tmpl_id.attribute_line_ids.filtered(lambda line: len(line.value_ids) == 1).mapped('value_ids')
+            variant_alone = tmpl_id.attribute_line_ids.filtered(lambda line: line.attribute_id.create_variant and len(line.value_ids) == 1).mapped('value_ids')
-class TestVariants(TransactionCase):
+class TestVariantsSearch(TransactionCase):
-        res = super(TestVariants, self).setUp()
+        res = super(TestVariantsSearch, self).setUp()
-        new_post = dict(post, cmd='_notify-validate', charset='utf-8')
+        new_post = dict(post, cmd='_notify-validate', charset='UTF-8')
-        else:
+        if self.pay_now != 'pay_now':
-                'partner_id': self.partner_id.id,
+                'partner_id': self.partner_id.commercial_partner_id.id,
-        payment_methods = self.journal_id.outbound_payment_method_ids
+        if self.voucher_type == 'sale':
-            'payment_type': 'outbound',
+            'name': name,
-            'partner_id': self.partner_id.id,
+            'partner_type': partner_type,
-            'journal_id': self.journal_id.id,
+            'journal_id': self.payment_journal_id.id,
-                'partner_id': self.partner_id.id,
+                'partner_id': self.partner_id.commercial_partner_id.id,
-        parsed_installed_version = parse_version(getattr(pkg, 'load_version', pkg.installed_version) or '')
+        installed_version = getattr(pkg, 'load_version', pkg.installed_version) or ''
-                            migrate(self.cr, pkg.installed_version)
+                            migrate(self.cr, installed_version)
-        if getattr(threading.currentThread(), 'testing', False):
+        if getattr(threading.currentThread(), 'testing', False) or self.env.registry.in_test_mode():
-    manager_id = fields.Many2one('hr.employee', related='employee_id.parent_id', string='Manager', readonly=True, store=True)
+    manager_id = fields.Many2one('hr.employee', string='Manager', readonly=True)
-        elif self.env.context.get('mail_create_nolog'): # task created
+        elif 'stage_id' in init_values and self.stage_id and self.stage_id.sequence <= 1:  # start stage -> new
-        elif 'stage_id' in init_values and self.stage_id and self.stage_id.sequence <= 1:  # start stage -> new
+        elif self.env.context.get('mail_create_nolog'): # task created
-             " of the event on the website.", store=True)
+             " of the event on the website.", store=True, copy=False)
-                    todo.update(field.convert_to_record(value, record))
+    env.cache.copy(records, env)
-        res = super(Project, self).write(vals)
+        # directly compute is_favorite to dodge allow write access right
-        }
+        return self.env['product.product']._convert_prepared_anglosaxon_line(line, part)
-        return []
+        return self.env['product.product']._anglo_saxon_sale_move_lines(i_line.name, i_line.product_id, i_line.uom_id, i_line.quantity, price_unit, currency=currency_id, amount_currency=amount_currency, fiscal_position=inv.fiscal_position_id, account_analytic=i_line.account_analytic_id, analytic_tags=i_line.analytic_tag_ids)
-            return self.product_id.uom_id._compute_price(price, self.uom_id)
+        return self.product_id._get_anglo_saxon_price_unit(uom=self.uom_id)
-        }
+        return self.env['product.product']._convert_prepared_anglosaxon_line(line, part)
-
+        def add_anglosaxon_lines(grouped_data):
-            return self.product_id.uom_id._compute_price(self.product_id.uom_id.id, price, to_uom_id=self.uom_id.id)
+        return self.product_id._get_anglo_saxon_price_unit(uom=self.uom_id)
-        company_currency = inv.company_id.currency_id.id
+        company_currency = inv.company_id.currency_id
-                    },
+        return self.env['product.product']._anglo_saxon_sale_move_lines(i_line.name, i_line.product_id, i_line.uom_id, i_line.quantity, price_unit, currency=currency_id, amount_currency=amount_currency, fiscal_position=inv.fiscal_position_id, account_analytic=i_line.account_analytic_id)
-                    move_lot.quantity += self.qty_producing
+            production_moves = self.production_id.move_finished_ids.filtered(lambda x: (x.state not in ('done', 'cancel')))
-                production_move.quantity_done += self.qty_producing  # TODO: UoM conversion?
+                    production_move.quantity_done += self.qty_producing  # TODO: UoM conversion?
-    qs_keys = request.httprequest.args.keys()
+    qs_keys = request.httprequest.args.keys() if request else []
-        self.ancestor_ids = self.env['stock.quant.package'].search(['id', 'parent_of', self.id]).ids
+        self.ancestor_ids = self.env['stock.quant.package'].search([('id', 'parent_of', self.id)]).ids
-        except IndexError:  # Invalid token
+        user_input = UserInput.sudo().search([('token', '=', token)], limit=1)
-            dp.digits = self.old_digits
+        dp = self.env.ref('product.decimal_product_uom')
-        if 'country_id' in self:
+        if 'country_id' in self and self.country_id:
-        if 'company_id' in self and self.country_id:
+        if 'company_id' in self and self.company_id:
-            invalid_fields = {}
+            country = request.env['res.country'].browse(record.get('country_id'))
-                return json.dumps({'error_fields': invalid_fields})
+                fmt_number = request.env[model_name].phone_format(number, contact_country)
-        self.post();
+        return self.post()
-                    'tax_ids': [(6, 0, line.tax_ids_after_fiscal_position.ids)],
+                    'tax_ids': [(6, 0, base_line_tax_ids.ids)],
-        return True
+        self.ensure_one()
-                        partners_to_notify.append(event_attendees_changes['removed_partners'].ids)
+                        partners_to_notify.extend(event_attendees_changes['removed_partners'].ids)
-                res.update({'currency_id': currency_id.id})
+                res.update({'currency_id': currency_id})
-        return {'value': {'currency_id': currency_id}}
+            currency_id = self.env['res.country'].browse(country_id).currency_id
-                                                                   package_id=ml.package_id, owner_id=ml.owner_id, strict=True)
+                try:
-                return '%s%s alt="%s"' % (data_to_url[key], match.group(3), name)
+                    data_to_url[key] = ['/web/image/%s?access_token=%s' % (attachment.id, attachment.access_token), name]
-                'res_model': 'ir.ui.view',
+                'res_id': res_id,
-            uploads += attachment.read(['name', 'mimetype', 'checksum', 'url'])
+            attachment.generate_access_token()
-                        'res_model': 'ir.ui.view',
+                        'res_id': res_id,
-                uploads += attachments.read(['name', 'mimetype', 'checksum', 'url'])
+                uploads += attachments.read(['name', 'mimetype', 'checksum', 'url', 'res_id', 'res_model', 'access_token'])
-    access_token = fields.Char('Access Token')
+    access_token = fields.Char('Access Token', groups="base.group_user")
-from odoo.tools import pycompat
+from odoo.tools import pycompat, consteq
-        values['portal_confirmation'] = request.env['ir.config_parameter'].sudo().get_param('sale.sale_portal_confirmation_options', default='none')
+        values['portal_confirmation'] = order.get_portal_confirmation_action()
-            return 'sign' if self.require_payment == 1 else 'pay'
+        if self.require_payment is not None or self.require_payment is not False:
-                result = re.match('((?:L-|AT-)?[0-9\-]+) (.+)', lines[-1])
+                result = re.match('((?:L-|AT-)?[0-9\-]+[A-Z]{,2}) (.+)', lines[-1])
-                partner.street = lines.pop(0)
+
-                        partner.city = res[1]
+                        _set_address_field(partner, 'zip', res[0])
-                    partner.street2 = lines.pop(0)
+                    _set_address_field(partner, 'street2', lines.pop(0))
-                partner.country_id = country and country.id or False
+                _set_address_field(partner, 'country_id', country and country.id or False)
-    @api.onchange('phone', 'country_id')
+    @api.onchange('phone', 'country_id', 'company_id')
-    @api.onchange('mobile', 'country_id')
+    @api.onchange('mobile', 'country_id', 'company_id')
-    @api.onchange('phone', 'country_id')
+    @api.onchange('phone', 'country_id', 'company_id')
-    @api.onchange('mobile', 'country_id')
+    @api.onchange('mobile', 'country_id', 'company_id')
-        if 'company_id' in self:
+        if 'company_id' in self and self.country_id:
-            raise_exception=True
+            raise_exception=False
-                _logger.warning(_('Unable to format %s:\n%s') % number, e)
+                _logger.warning(_('Unable to format %s:\n%s'), number, e)
-    is_highlighted = fields.Boolean(compute='_compute_is_highlighted', string='# Meetings Highlight')
+    is_highlighted = fields.Boolean(compute='_compute_is_highlighted', string='Is the Event Highlighted')
-            values = dict(values, url_for=website.get_cdn_url)
+            values = dict(values or {}, url_for=website.get_cdn_url)
-            to_update = self.move_line_ids.filtered(lambda m: m.location_id.id == reserved_quant.location_id.id and m.lot_id.id == reserved_quant.lot_id.id and m.package_id.id == reserved_quant.package_id.id and m.owner_id.id == reserved_quant.owner_id.id)
+            to_update = self.move_line_ids.filtered(lambda m: m.product_id.tracking != 'serial' and
-            self.subtype_id.unlink()
+        for activity in self:
-                    })
+                    vals = self._update_purchase_order_line(product_id, product_qty, product_uom, values, line, partner)
-                number = self._sms_sanitization(partner, self.env.context.get('field_name') or default_field_name)
+                number = self._sms_sanitization(partner, self.env.context.get('field_name') or 'mobile')
-    'auto-install': True,
+    'auto_install': True,
-====================================================================================
+========================================================================================
-    l10n_co_verification_code = fields.Char(compute='_compute_verification_code', string='VC',
+    l10n_co_verification_code = fields.Char(compute='_compute_verification_code', string='VC',  # todo remove this field in master
-
+        for pick in self:
-            move_lines_to_remove = self.move_line_ids.filtered(lambda move_line: move_line.state != 'done')
+            move_lines_to_remove = package.move_line_ids.filtered(lambda move_line: move_line.state != 'done')
-    'auto_installable': True,
+    'auto_install': True,
-                buf = open(join(tmpmoddir, pofilename), 'w')
+                buf = open(join(tmpmoddir, pofilename), 'wb')
-            new_args = args
+            args = ['|', ('attribute_id', operator, name), ('value_ids', operator, name)]
-            args=new_args,
+            args=args,
-from . import test_uom, test_pricelist
+from . import test_uom, test_pricelist, test_variants
-from odoo.exceptions import ValidationError
+from odoo.exceptions import ValidationError, AccessError
-            employee.is_address_home_a_company = employee.address_home_id.parent_id.id is not False
+            try:
-from datetime import datetime
+from datetime import datetime, time
-        self.leave_start_datetime = datetime.today().replace(hour=7, minute=0) + relativedelta(weeks=0, days=1, weekday=0)
+        # NOTE: second and millisecond can add a working days
-        number_of_days = (self.leave_end_datetime - self.leave_start_datetime).days+1
+        number_of_days = (self.leave_end_datetime - self.leave_start_datetime).days
-                    # myPad.setHTML(path, record[real_field])
+                    myPad.setHtmlFallbackText(path, record[real_field])
-                _logger.warning("No url found '%s'.", url)
+            except Exception:
-                myPad.setText(path, (html2plaintext(vals[field.pad_content_field]).encode('utf-8')))
+                myPad.setHtmlFallbackText(path, vals[field.pad_content_field])
-        return dict(default_purchase_tax_id=int(default_purchase_tax_id), default_sale_tax_id=int(default_sale_tax_id))
+        # DO NOT FORWARDPORT, ONLY FOR SAAS-15
-        self.env['ir.config_parameter'].sudo().set_param("account.default_sale_tax_id", self.default_sale_tax_id.id)
+        pass
-            key_version = '2'
+            key_version = self.env['ir.config_parameter'].sudo().get_param('sips.key_version', '2')
-        return cls._serve_404()
+        return False
-                html = request.env['ir.ui.view'].render_template('website.%s' % code, values)
+                html = request.env['ir.ui.view'].render_template('website.%s' % view_id, values)
-                                   ('Content-Length', len(body))])
+            body, status=error and error.pop('http_status', 200) or 200,
-            if not isinstance(exception, (odoo.exceptions.Warning, SessionExpiredException, odoo.exceptions.except_orm)):
+            if not isinstance(exception, (odoo.exceptions.Warning, SessionExpiredException,
-            if new_url.scheme and new_url.netloc:
+            if new_url.scheme and (new_url.netloc or new_url.scheme == 'mailto'):
-                'check_amount_in_words': self.check_amount_in_words,
+                'check_amount_in_words': self.currency_id.amount_to_text(res['amount']) if self.multi else self.check_amount_in_words,
-            for work_interval in working_intervals]
+        final_intervals = [i for i in
-        bom = self.env['mrp.bom'].sudo()._bom_find(product=self.product_id)
+        bom = self.env['mrp.bom'].sudo()._bom_find(product=self.product_id, company_id=self.company_id.id)
-    name = fields.Char(required=True)
+    name = fields.Char(required=True, translate=True)
-        return {'domain': {'journal_id': jrnl_filters['domain'] + domain_on_types}}
+
-        
+
-                name = name[:len(name)-2] 
+                name = name[:len(name)-2]
-            # get data of stock_history in one shot to speed things up (the view can be very slow)
+            # Step 2: retrieve the stock history lines. The result contains the 'expanded'
-                stock_history_data = {line['id']: line for line in self._cr.dictfetchall()}
+            stock_histories_by_group = {}
-                for stock_history in group_lines.get(str(line.get('__domain', domain))):
+                # Build the same keys than above, but need to take into account Many2one are tuples
-            self.mail_registration_ids.filtered(lambda reg: reg.scheduled_date and reg.scheduled_date <= datetime.strftime(fields.datetime.now(), tools.DEFAULT_SERVER_DATETIME_FORMAT)).execute()
+            self.mail_registration_ids.filtered(lambda reg: reg.scheduled_date and reg.scheduled_date <= now).execute()
-            if not self.mail_sent:
+            # Do not send emails if the mailing was scheduled before the event but the event is over
-        return res
+        return super(Users, self).unlink()
-        return OdooSessionStore(path, session_class=OpenERPSession)
+        return werkzeug.contrib.sessions.FilesystemSessionStore(path, session_class=OpenERPSession)
-            value = float_round(amount, precision_rounding=precision_rounding)
+        def try_round(amount, expected, precision_rounding=None, method='HALF-UP'):
-    # We want to apply HALF-UP tie-breaking rules, i.e. 0.5 rounds away from 0.
+    sign = math.copysign(1.0, normalized_value)
-    # When rounding the value up[resp. down], we instead subtract the epsilon value
+    # TIE-BREAKING: UP/DOWN (for ceiling[resp. flooring] operations)
-        sign = math.copysign(1.0, normalized_value)
+    if rounding_method == 'UP':
-        rounded_value = func(abs(normalized_value)) * sign
+        rounded_value = math.ceil(abs(normalized_value)) * sign
-                ('name', 'in', protected_fields), ('model', '=', self._name)
+                ('name', 'in', protected_fields_modified), ('model', '=', self._name)
-        res['domain']['journal_id'] = self.payment_type == 'inbound' and [('at_least_one_inbound', '=', True)] or [('at_least_one_outbound', '=', True)]
+        res['domain']['journal_id'] = self.payment_type == 'inbound' and [('at_least_one_inbound', '=', True)] or self.payment_type == 'outbound' and [('at_least_one_outbound', '=', True)] or []
-        if _sms_phonenumbers_lib_imported:
+        if number and _sms_phonenumbers_lib_imported:
-            field = self._fields[k]
+            field = self._fields.get(k)
-    _order = 'sequence'
+    _order = 'sequence,id'
-            if not project_id:
+            if self and not project_id:
-    @api.onchange('currency_id', 'date_invoice')
+    @api.onchange('currency_id')
-                        .compute(line.purchase_line_id.price_unit, self.currency_id, round=False)
+                line.price_unit = line.purchase_id.currency_id.with_context(date=self.date_invoice).compute(line.purchase_line_id.price_unit, self.currency_id, round=False)
-                        taxes[tax['id']]['base_amount'] += line.price_subtotal
+                        taxes[tax['id']]['base_amount'] += tax['base']
-            copy_vals = vals
+            copy_vals = dict(vals)
-from odoo import api, fields, models
+from odoo import api, fields, models, _
-    mailing_model_name = fields.Char(related='mailing_model_id.model', string='Recipients Model Name')
+    mailing_model_name = fields.Char(related='mailing_model_id.model', string='Recipients Model Name', readonly=True, related_sudo=True)
-                amt = round(line.value_amount, prec)
+                amt = sign * round(line.value_amount, prec)
-        sorted_moves = sorted(self, key=lambda a: a.date)
+        sorted_moves = sorted(self, key=lambda a: a.date_maturity or a.date)
-        'Related Document Model Name', index=True, readonly=True, related='res_model_id.model', store=True)
+        'Related Document Model Name', index=True, readonly=True, related='res_model_id.model', store=True, compute_sudo=True)
-
+# -*- coding: utf-8 -*-
-    migrate_tags_on_taxes(cr, registry)
+    migrate_tags_on_taxes(cr, None)
-        result = super(BlogPost, self).write(vals)
+        result = True
-        params['success'] = 'pay_invoice'
+        if tx.state != 'authorized' or not tx.acquirer_id.capture_manually:
-            ('acquirer_id', 'in', [acq.id for acq in values['s2s_acquirers']])])
+            ('acquirer_id', 'in', acquirers.ids)])
-        default='form', required=True, string='Payment flow',
+    payment_flow = fields.Selection(selection=[('form', 'Redirection to the acquirer website'),
-        if res != 'authorized_sale':
+        if tx.state != 'authorized' or not tx.acquirer_id.capture_manually:
-        if self.state == 'done':
+        elif self.state == 'done':
-        (1, 'Online Payment')], default=0, string='Confirmation Mode',
+        (1, 'Online Payment')], default=_get_default_online_payment, string='Confirmation Mode',
-        return request.redirect('/shop/payment/validate?success=True')
+        if tx.state != 'authorized' or not tx.acquirer_id.capture_manually:
-        if res is not True:
+        if res is not True and res != 'authorized_sale':
-        params['success'] = 'pay_sale'
+        if res != 'authorized_sale':
-        if res is not True:
+        if res is not True and res != 'authorized_sale':
-            _logger.info('<%s> transaction completed, auto-confirming order %s (ID %s) and generating invoice', self.acquirer_id.provider, self.sale_order_id.name, self.sale_order_id.id)
+            _logger.info('<%s> transaction completed, auto-confirming order %s (ID %s)', self.acquirer_id.provider, self.sale_order_id.name, self.sale_order_id.id)
-            self._generate_and_pay_invoice()
+from . import payment
-from odoo import http
+from odoo import http, _
-        token = request.env['payment.acquirer'].browse(int(kwargs.get('acquirer_id'))).s2s_process(kwargs)
+        token = False
-    tz = pytz.timezone(tz_name)
+    tz = pytz.timezone(tz_name) if tz_name else pytz.UTC
-        "The `phonenumbers` Python module is not installed. Try: pip install phonenumbers."
+    _logger.info(
-            if move_line.state == 'done' and not float_is_zero(move_line.product_uom_qty, precision_rounding=self.env['decimal.precision'].precision_get('Product Unit of Measure')):
+            if move_line.state == 'done' and not float_is_zero(move_line.product_uom_qty, precision_digits=self.env['decimal.precision'].precision_get('Product Unit of Measure')):
-        return super(Users, self).unlink()
+        res = super(Users, self).unlink()
-        self.setdefault("password", None)
+class OdooSessionStore(werkzeug.contrib.sessions.FilesystemSessionStore):
-        return werkzeug.contrib.sessions.FilesystemSessionStore(path, session_class=OpenERPSession)
+        return OdooSessionStore(path, session_class=OpenERPSession)
-        return super(Users, self).unlink()
+        res = super(Users, self).unlink()
-        self.setdefault("password", None)
+class OdooSessionStore(werkzeug.contrib.sessions.FilesystemSessionStore):
-        return werkzeug.contrib.sessions.FilesystemSessionStore(path, session_class=OpenERPSession)
+        return OdooSessionStore(path, session_class=OpenERPSession)
-    fiscalyear_last_month = fields.Selection([(1, 'January'), (2, 'February'), (3, 'March'), (4, 'April'), (5, 'May'), (6, 'June'), (7, 'July'), (8, 'August'), (9, 'September'), (10, 'October'), (11, 'November'), (12, 'December')], related='company_id.fiscalyear_last_month', default=12)
+    fiscalyear_last_day = fields.Integer(related='company_id.fiscalyear_last_day',
-            # move.quantity_done = float_round(move.quantity_done, precision_rounding=rounding, rounding_method ='UP')
+        for move in moves:
-                    'new_amount_delivery': order.delivery_price,
+                    'new_amount_delivery': order.currency_id.round(order.delivery_price),
-                    'new_amount_tax': order.amount_tax}
+                    'new_amount_tax': order.amount_tax,
-                vals = self._get_move_values(abs(diff), line.product_id.property_stock_inventory.id, line.location_id.id)
+                vals = line._get_move_values(abs(diff), line.product_id.property_stock_inventory.id, line.location_id.id)
-                vals = self._get_move_values(abs(diff), line.location_id.id, line.product_id.property_stock_inventory.id)
+                vals = line._get_move_values(abs(diff), line.location_id.id, line.product_id.property_stock_inventory.id)
-                aml.reconcile()
+                aml_returns.reconcile()
-                continue
+                # It may be interesting to have the Traceback logged anyway
-                number = self._sms_sanitization(partner, self.env.context('field_name') or default_field_name)
+                number = self._sms_sanitization(partner, self.env.context.get('field_name') or default_field_name)
-        'res.partner', 'Private Address', help='Enter here the private address of the employee, not the one linked to your company.')
+        'res.partner', 'Private Address', help='Enter here the private address of the employee, not the one linked to your company.',
-        'res.country', 'Nationality (Country)')
+        'res.country', 'Nationality (Country)', groups="hr.group_hr_user")
-    visa_expire = fields.Date('Visa Expire Date')
+    permit_no = fields.Char('Work Permit No', groups="hr.group_hr_user")
-                'flags': {'initial_mode': 'edit'},
+                'context': context,
-        track = track.sudo()
+        track = track.sudo().with_context(tz=event.date_tz or 'UTC')
-        })
+        product_lang = self.product_id.with_context(
-                raise UserError(_("No miscellaneous journal could be found. Please create one before proceeding."))
+                raise UserError(_("Please install a chart of accounts or create a miscellaneous journal before proceeding."))
-        return request.render('payment.pay', values)
+        # TODO: remove return when payment is implemented with refactored payments, i.e. use of
-    manager_id = fields.Many2one('res.users', string='Project Manager', related='project_id.user_id', readonly=True)
+    manager_id = fields.Many2one('res.users', string='Project Manager', related='project_id.user_id', readonly=True, related_sudo=False)
-    user_email = fields.Char(related='user_id.email', string='User Email', readonly=True)
+    user_email = fields.Char(related='user_id.email', string='User Email', readonly=True, related_sudo=False)
-    legend_normal = fields.Char(related='stage_id.legend_normal', string='Kanban Ongoing Explanation', readonly=True)
+    legend_blocked = fields.Char(related='stage_id.legend_blocked', string='Kanban Blocked Explanation', readonly=True, related_sudo=False)
-    @api.depends('holidays', 'wage')
+    @api.depends('holidays', 'wage', 'final_yearly_costs')
-        if isinstance(res_model, basestring):
+        if isinstance(res_model, pycompat.string_types):
-        if node.src_model and isinstance(node.src_model, basestring):
+        if node.src_model and isinstance(node.src_model, pycompat.string_types):
-                    'name': "%s (%s/%s)" % (holiday.name, index + 1, len(work_hours_data)),
+                    'name': "%s (%s/%s)" % (holiday.name or '', index + 1, len(work_hours_data)),
-        self.mapped('timesheet_ids').unlink()
+        timesheets = self.sudo().mapped('timesheet_ids')
-        # Create extra moves where necessary
+
-
+
-        return self._compute_hash(prev_order.l10n_fr_hash if prev_order else '')
+        return self._compute_hash(prev_order.l10n_fr_hash if prev_order else u'')
-        hash_string = sha256(previous_hash + self.l10n_fr_string_to_hash)
+        hash_string = sha256((previous_hash + self.l10n_fr_string_to_hash).encode('utf-8'))
-            order.l10n_fr_string_to_hash = dumps(values, sort_keys=True, encoding="utf-8",
+            order.l10n_fr_string_to_hash = dumps(values, sort_keys=True,
-        previous_hash = ''
+        previous_hash = u''
-        if data['cc_expiry'] and datetime.now().strftime('%y%M') > datetime.strptime(data['cc_expiry'], '%M / %y').strftime('%y%M'):
+        if data['cc_expiry'] and datetime.now().strftime('%y%m') > datetime.strptime(data['cc_expiry'], '%m / %y').strftime('%y%m'):
-                    return _('You cannot consume the same serial number twice. Please correct the serial numbers encoded.')
+    @api.onchange('qty_done')
-            message = move_lines_to_check._check_for_duplicated_serial_numbers()
+            if not self.qty_done:
-
+        - uid has a notification on the message, OR
-        self._cr.execute("""SELECT DISTINCT m.id, m.model, m.res_id, m.author_id, partner_rel.res_partner_id, channel_partner.channel_id as channel_id
+        self._cr.execute("""
-            ON partner_rel.mail_message_id = m.id AND partner_rel.res_partner_id = (%%s)
+            ON partner_rel.mail_message_id = m.id AND partner_rel.res_partner_id = %%(pid)s
-            WHERE m.id = ANY (%%s)""" % self._table, (pid, pid, ids,))
+            ON channel_partner.channel_id = channel.id AND channel_partner.partner_id = %%(pid)s
-            self._cr.execute("""SELECT DISTINCT m.id, m.model, m.res_id, m.author_id, m.parent_id, partner_rel.res_partner_id, channel_partner.channel_id as channel_id
+            self._cr.execute("""
-                ON partner_rel.mail_message_id = m.id AND partner_rel.res_partner_id = (%%s)
+                ON partner_rel.mail_message_id = m.id AND partner_rel.res_partner_id = %%(pid)s
-                WHERE m.id = ANY (%%s)""" % self._table, (self.env.user.partner_id.id, self.env.user.partner_id.id, self.ids,))
+                ON channel_partner.channel_id = channel.id AND channel_partner.partner_id = %%(pid)s
-        self.assertEqual(needaction_length, 0, "removing access of a message make it not readable")
+        self.assertEqual(needaction_length, 1, "message should still be readable when notified")
-        default=lambda self: self.env.user)
+        default=lambda self: self.env.user, copy=False)
-class TestTimesheet(TransactionCase):
+class TestCommonTimesheet(TransactionCase):
-        super(TestTimesheet, self).setUp()
+        super(TestCommonTimesheet, self).setUp()
-        return self._compute_hash(prev_move.l10n_fr_hash if prev_move else '')
+        return self._compute_hash(prev_move.l10n_fr_hash if prev_move else u'')
-        hash_string = sha256(previous_hash + self.l10n_fr_string_to_hash)
+        hash_string = sha256((previous_hash + self.l10n_fr_string_to_hash).encode('utf-8'))
-            move.l10n_fr_string_to_hash = dumps(values, sort_keys=True, encoding="utf-8",
+            move.l10n_fr_string_to_hash = dumps(values, sort_keys=True,
-        previous_hash = ''
+        previous_hash = u''
-            tail = self.re_remove_spaces.sub(' ', tail.rstrip())
+            tail = self.re_remove_spaces.sub(' ', tail)
-        self.phantom_js('/web/tests?mod=web', "", "", login='admin', timeout=300)
+        self.phantom_js('/web/tests?mod=web', "", "", login='admin', timeout=360)
-        if domain is None:
+        if not domain:
-                number = partner.mobile
+                default_field_name = 'mobile' if partner.mobile else 'phone'
-        if always_international and phone_nbr.country_code != country_phone_code:
+        if always_international or phone_nbr.country_code != country_phone_code:
-        return self.env.ref('hr_holidays.action_report_holidayssummary').report_action(departments, data=datas)
+        return self.env.ref('hr_holidays.action_report_holidayssummary').with_context(from_transient_model=True).report_action(departments, data=datas)
-            template = self.env.ref('base.view_company_report_form_with_print')
+            template = self.env.ref('base.view_company_report_form_with_print') if self.env.context.get('from_transient_model', False) else self.env.ref('base.view_company_report_form')
-                moves += unbuild._generate_move_from_bom_line(line, line_data['qty'])
+            if unbuild.mo_id:
-        dates = self._get_dates(vals.get('product_id'))
+        dates = self._get_dates(vals.get('product_id') or self.env.context.get('default_product_id'))
-        yield
+        transaction = IapTransaction()
-        query = """SELECT m.name, count(*), act.res_model as model,
+        query = """SELECT m.id, count(*), act.res_model as model,
-                    GROUP BY m.name, states, act.res_model;
+                    GROUP BY m.id, states, act.res_model;
-                    'name': activity['name'],
+                    'name': model_names[activity['id']],
-            ], limit=1)
+            so_line = None
-                so_line.write({'qty_delivered': analytic_line.unit_amount})
+                so_line.write({'qty_delivered': so_line.qty_delivered + analytic_line.unit_amount})
-
+
-from odoo.exceptions import AccessError
+from odoo.exceptions import AccessError, UserError
-    wage_with_holidays = fields.Monetary(compute='_compute_wage_with_holidays', string="Wage update with holidays retenues")
+    wage_with_holidays = fields.Monetary(compute='_compute_wage_with_holidays', inverse='_inverse_wage_with_holidays', string="Wage update with holidays retenues")
-                line.price_unit = line.purchase_id.currency_id.with_context(date=self.date_invoice).compute(line.purchase_line_id.price_unit, self.currency_id, round=False)
+                if line.purchase_id.currency_id != self.currency_id:
-                total_cost += v.get('former_cost', 0.0)
+
-            for field, new_value in res.iteritems():
+            for field, new_value in res.items():
-        values = super(PortalAccount, self)._prepare_portal_layout_values()
+    
-        invoice_count = request.env['account.invoice'].search_count([
+        domain = [
-        ])
+        ]
-        ]
+        domain = self._get_account_invoice_domain()
-        v['posts'] = request.env['blog.post'].search([('blog_id','=', blog.id)], limit=min(int(limit), 50))
+        v['posts'] = request.env['blog.post'].search([('blog_id','=', blog.id)],
-    quantity_done = fields.Float('Done')
+    lot_produced_qty = fields.Float(
-            dispatch_rpc('db', 'restore', [master_pwd, name, data, str2bool(copy)])
+            with tempfile.NamedTemporaryFile(delete=False) as data_file:
-        data_file.write(data.decode('base64'))
+        for chunk in chunks(data):
-                    _logger.debug('Starting job `%s`.', job['name'])
+                    _logger.info('Starting job `%s`.', job['name'])
-                    _logger.debug('Starting job `%s`.', job['cron_name'])
+                    _logger.info('Starting job `%s`.', job['cron_name'])
-    'depends': ['sale', 'sale_management', 'stock_account'],
+    'depends': ['sale_management', 'stock_account'],
-        move._assign_picking()
+from collections import OrderedDict
-        module.name: module.dependencies_id.mapped('name')
+    modules = OrderedDict(
-    }
+    )
-    'depends': ['sale', 'stock_account'],
+    'depends': ['sale', 'sale_management', 'stock_account'],
-        return browse(ids)
+        key = field.cache_key(model)
-        if homepage and homepage.url != '/':
+        if homepage and (homepage.sudo().is_visible or request.env.user.has_group('base.group_user')) and homepage.url != '/':
-                return request.redirect(first_menu.url)
+            top_menu = request.website.menu_id
-    _order = "sequence"
+    _order = "sequence, id"
-            days_tracks[track.date[:10]].append(track)
+            date = fields.Datetime.from_string(track.date).replace(tzinfo=pytz.utc).astimezone(local_tz)
-            if not self.url.startswith('/'):
+            if url and not self.url.startswith('/'):
-            replace(CASE WHEN COALESCE(sum(aml.balance), 0) >= 0 THEN '0,00' ELSE to_char(-SUM(aml.balance), '999999999999999D99') END, '.', ',') AS Credit,
+            replace(CASE WHEN COALESCE(sum(aml.balance), 0) <= 0 THEN '0,00' ELSE to_char(SUM(aml.balance), '000000000000000D99') END, '.', ',') AS Debit,
-            replace(CASE WHEN sum(aml.balance) >= 0 THEN '0,00' ELSE to_char(-SUM(aml.balance), '999999999999999D99') END, '.', ',') AS Credit,
+            replace(CASE WHEN sum(aml.balance) <= 0 THEN '0,00' ELSE to_char(SUM(aml.balance), '000000000000000D99') END, '.', ',') AS Debit,
-            replace(CASE WHEN sum(aml.balance) >= 0 THEN '0,00' ELSE to_char(-SUM(aml.balance), '999999999999999D99') END, '.', ',') AS Credit,
+            replace(CASE WHEN sum(aml.balance) <= 0 THEN '0,00' ELSE to_char(SUM(aml.balance), '000000000000000D99') END, '.', ',') AS Debit,
-            replace(CASE WHEN aml.credit = 0 THEN '0,00' ELSE to_char(aml.credit, '999999999999999D99') END, '.', ',') AS Credit,
+            replace(CASE WHEN aml.debit = 0 THEN '0,00' ELSE to_char(aml.debit, '000000000000000D99') END, '.', ',') AS Debit,
-                ELSE replace(to_char(aml.amount_currency, '999999999999999D99'), '.', ',')
+                ELSE replace(to_char(aml.amount_currency, '000000000000000D99'), '.', ',')
-                arch_fs = arch_fs and resolve_external_ids(arch_fs, view.xml_id)
+                arch_fs = arch_fs and resolve_external_ids(arch_fs, view.xml_id).replace('%%', '%')
-    ],string="Local Numbers", default="no_prefix",
+    ], string="Local Numbers", default="prefix",
-            if website:
+            if website and website.user_id:
-        'user_id': fields.many2one('res.users', string='Public User'),
+        'user_id': fields.many2one('res.users', string='Public User', required=True),
-            return [ParamDoc(text) for text in tag_texts]
+        # turns out guessed_params is *almost* (?) always set to a list,
-        'visits': fields.integer('No of Views'),
+        'visits': fields.integer('No of Views', copy=False),
-        default='''Dear Sir/Madam,
+        default=lambda s: _('''Dear Sir/Madam,
-Best Regards,''')
+Best Regards,'''))
-        default='<i>Pending,</i> Your online payment has been successfully processed. But your order is not validated yet.',
+        default=lambda s: _('<i>Pending,</i> Your online payment has been successfully processed. But your order is not validated yet.'),
-        default='<i>Done,</i> Your online payment has been successfully processed. Thank you for your order.',
+        default=lambda s: _('<i>Done,</i> Your online payment has been successfully processed. Thank you for your order.'),
-        default='<i>Cancel,</i> Your payment has been cancelled.',
+        default=lambda s: _('<i>Cancel,</i> Your payment has been cancelled.'),
-        default='<i>Error,</i> Please be aware that an error occurred during the transaction. The order has been confirmed but will not be paid. Do not hesitate to contact us if you have any questions on the status of your order.',
+        default=lambda s: _('<i>Error,</i> Please be aware that an error occurred during the transaction. The order has been confirmed but will not be paid. Do not hesitate to contact us if you have any questions on the status of your order.'),
-        'Red Kanban Label', default='Blocked', translate=True, required=True,
+        'Red Kanban Label', default=lambda s: _('Blocked'), translate=True, required=True,
-        'Green Kanban Label', default='Ready for Next Stage', translate=True, required=True,
+        'Green Kanban Label', default=lambda s: _('Ready for Next Stage'), translate=True, required=True,
-        'Grey Kanban Label', default='In Progress', translate=True, required=True,
+        'Grey Kanban Label', default=lambda s: _('In Progress'), translate=True, required=True,
-                'build your professional profile and become a better marketer together.')
+        default=lambda s: _('This community is for professionals and enthusiasts of our products and services. '
-        default="<p>This channel is private and its content is restricted to some users.</p>", translate=html_translate, sanitize_attributes=False)
+        default=lambda s: _("<p>This channel is private and its content is restricted to some users.</p>"),
-        self.assertEqual(category_no.name, 'Customers', "Duplication erased original untranslated value")
+        self.assertEqual(category_no.name, 'Clients (copie)', "Duplication should set untranslated value")
-                        vals['source'] = old_wo_lang[name]
+                        # force a source if the new_val was not changed by copy override
-        self.env[model].browse(ref_id).write(res)
+        if self._context.get('onchange_self'):
-                'location_id': self.location_id.id,
+                'location_id': location_id.id if location_id else self.location_id.id,
-            vals['image'] = image_resize_image(vals['image'], size=(64,64))
+            image = ustr(vals['image'] or '').encode('utf-8')
-           vals['image'] = image_resize_image(vals['image'], size=(64,64))
+            image = ustr(vals['image'] or '').encode('utf-8')
-            account = self.env['account.account'].create({
+        if account:
-        moves_error = self.filtered(lambda move: move.product_id.uom_id.category_id.id != move.product_uom.category_id.id)
+        moves_error = self.filtered(lambda move: move.product_id.uom_id.category_id != move.product_uom.category_id)
-            user_warning += '\n\nBlocking: %s' % ' ,'.join(moves_error.mapped('name'))
+            for move in moves_error:
-                        packages |= ml.package_id
+            packages_to_check = picking.move_line_ids\
-        self.assertEqual(move1.price_unit, price_unit_usd)
+        self.assertAlmostEqual(move1.price_unit, price_unit_usd)
-        self.assertEquals(move1.price_unit, price_unit_usd)
+        self.assertAlmostEqual(move1.price_unit, price_unit_usd)
-                contract.transport_employer_cost == contract.others_reimbursed_amount
+                contract.transport_employer_cost = contract.others_reimbursed_amount
-        locations = self.env['stock.location'].search([('usage', '=', 'internal'), ('company_id', '=', self.env.user.company_id.id)])
+        quant_locs = self.env['stock.quant'].sudo().read_group([('product_id', 'in', self.ids)], ['location_id'], ['location_id'])
-    def do_transfer(self):
+    def action_done(self):
-        res = super(StockPicking, self).do_transfer()
+        res = super(StockPicking, self).action_done()
-    do_transfer = action_done #TODO:replace later
+    # Backward compatibility
-                self.env['stock.quant'].quants_move(quants, move, move.location_dest_id)
+                self.env['stock.quant'].quants_move(quants, move, move.location_dest_id, owner_id=move.restrict_partner_id.id)
-                        self.env['stock.quant'].quants_move(quants, move, move.location_dest_id, lot_id = movelot.lot_id.id)
+                        self.env['stock.quant'].quants_move(quants, move, move.location_dest_id, lot_id = movelot.lot_id.id, owner_id=move.restrict_partner_id.id)
-        self.assertEqual(self.so.order_line[0].qty_delivered, 3.0, 'Sale Stock: delivered quantity should be 3.0 instead of "%s" after picking return' % self.so.order_line[0].qty_delivered)
+        self.assertAlmostEqual(self.so.order_line[0].qty_delivered, 3.0, 'Sale Stock: delivered quantity should be 3.0 instead of "%s" after picking return' % self.so.order_line[0].qty_delivered)
-        self.assertEqual(self.inv_2.invoice_line_ids[0].quantity, 2.0, 'Sale Stock: refund quantity on the invoice should be 2.0 instead of "%s".' % self.inv_2.invoice_line_ids[0].quantity)
+        self.assertAlmostEqual(self.inv_2.invoice_line_ids[0].quantity, 2.0, 'Sale Stock: refund quantity on the invoice should be 2.0 instead of "%s".' % self.inv_2.invoice_line_ids[0].quantity)
-
+    def mail_purchase_order_on_send(self):
-                    order.state = 'sent'
+            self.mail_purchase_order_on_send()
-                    candidate.product_uom_qty = self.product_id.uom_id._compute_quantity(quantity_split, self.product_uom_id, rounding_method='HALF-UP')
+                    candidate.product_uom_qty = self.product_id.uom_id._compute_quantity(quantity_split, candidate.product_uom_id, rounding_method='HALF-UP')
-            post.state = 'pending'
+            post.sudo().state = 'pending'
-                raise KarmaError('Not enough karma to close or reopen a post.')
+            if vals['state'] in ['active', 'close']:
-        if any(key not in ['state', 'active', 'is_correct', 'closed_uid', 'closed_date', 'closed_reason_id'] for key in vals.keys()) and any(not post.can_edit for post in self):
+        if any(key not in trusted_keys for key in vals) and any(not post.can_edit for post in self):
-# Copyright (C) Rooms For (Hong Kong) Limited T/A OSCG
+# Copyright (C) Quartile Limited
-# Copyright (C) Rooms For (Hong Kong) Limited T/A OSCG
+# Copyright (C) Quartile Limited
-    'website': 'http://www.openerp-asia.net/',
+    'author': 'Quartile Limited',
-                    count+=1
+            count += abs(holiday.number_of_days)
-    'autoinstall': True,
+    'auto_install': True,
-        tmp1, tmp2 = self._load_template(company, code_digits=code_digits, transfer_account_id=transfer_account_id, account_ref=acc_ref, taxes_ref=taxes_ref)
+        # Ensure, even if individually, that everything is translated according to the company's language.
-        help="Technical field used to keep track of the tax cash basis reconciliation."
+        help="Technical field used to keep track of the tax cash basis reconciliation. "
-        help="Events and registrations will automatically be confirmed"
+        help="Events and registrations will automatically be confirmed "
-        help="Costs paid at regular intervals, depending on the cost frequency."
+        help="Costs paid at regular intervals, depending on the cost frequency. "
-        help="Keep empty if you produce at the location where you find the raw materials."
+        help="Keep empty if you produce at the location where you find the raw materials. "
-        "which alters the execution of the manufacturing order. ")
+        help="The routing contains all the Work Centers used and for how long. This will create work orders afterwards "
-        help="This option allows customers to save their credit card as a payment token and to reuse it for a later purchase."
+        help="This option allows customers to save their credit card as a payment token and to reuse it for a later purchase. "
-        help="Timezone used when encoding the leave. It is used to correctly"
+        help="Timezone used when encoding the leave. It is used to correctly "
-                              "(%s), same location(%s), same package, same owner and same lot. Please first validate"
+            raise UserError(_("You cannot have two inventory adjustements in state 'in Progress' with the same product "
-        help="The 'Manual Operation' value will create a stock move after the current one."
+        help="The 'Manual Operation' value will create a stock move after the current one. "
-        help="By default, the system will take from the stock in the source location and passively wait for availability."
+        help="By default, the system will take from the stock in the source location and passively wait for availability. "
-             "its current stock) to gather products. If we want to chain moves and have this one to wait for the previous,"
+             "its current stock) to gather products. If we want to chain moves and have this one to wait for the previous, "
-                                    help="Provide the field used to link the newly created record"
+                                    help="Provide the field used to link the newly created record "
-                           help="Arguments sent to the client along with"
+                           help="Arguments sent to the client along with "
-                                                         "be written to the server log at DEBUG level"
+                                                         "be written to the server log at DEBUG level "
-                      "You could use STARTTLS instead."
+                    _("Your Odoo Server does not support SMTP-over-SSL. "
-            raise UserError(_("The Selection Options expression is not a valid Pythonic expression."
+            raise UserError(_("The Selection Options expression is not a valid Pythonic expression. "
-                                           "and 'No gap'. The later is slower than the former but forbids any"
+                                           "and 'No gap'. The later is slower than the former but forbids any "
-            "See i18n section of the user manual. Option '-d' is mandatory."
+        group = optparse.OptionGroup(parser, "Internationalisation options. ",
-    @queryCount(admin=33, demo=44)
+    @queryCount(admin=33, demo=47)
-    @queryCount(admin=63, demo=79)
+    @queryCount(admin=63, demo=85)
-        [('none', 'No One'), ('user', 'Authentified Users Only'), ('public', 'Everyone')],
+        [('none', 'No One'), ('user', 'Authenticated Users Only'), ('public', 'Everyone')],
-    @queryCount(admin=20, demo=31)
+    @queryCount(admin=33, demo=44)
-    @queryCount(admin=38, demo=54)
+    @queryCount(admin=63, demo=79)
-    city_id = fields.Many2one('res.city', string='Company')
+    city_id = fields.Many2one('res.city', string='City')
-        notif_users.mapped('partner_id')._notify_by_chat(self)
+        notif_partners._notify_by_chat(self)
-            order_line[0].product_uom_qty += 1
+            order_line = order_line[0]
-        price_unit_usd = po1.currency_id.compute(po1.order_line.price_unit, po1.company_id.currency_id, round=False)
+        price_unit_usd = po1.currency_id.compute(po1.order_line.price_unit, po1.company_id.currency_id, round=True)
-        price_unit_usd_new_rate = po1.currency_id.compute(po1.order_line.price_unit, po1.company_id.currency_id, round=False)
+        price_unit_usd_new_rate = po1.currency_id.compute(po1.order_line.price_unit, po1.company_id.currency_id, round=True)
-            'supplier_wh_id': supplier_warehouse.id}
+            'supplier_wh_id': supplier_warehouse.id,
-            'sequence': 20}
+            'sequence': 20,
-        self.write({'state': 'confirmed'})
+        for picking in self:
-    is_locked = fields.Boolean('Is Locked', default=True)
+    is_locked = fields.Boolean('Is Locked', default=True, copy=False)
-                assigned_list = [x.state in ('assigned', 'done', 'cancel') for x in order.move_raw_ids]
+                move_raw_ids = order.move_raw_ids.filtered(lambda m: m.product_qty)
-        '''/slides/<model("slide.channel):channel>/page/<int:page>''',
+        '''/slides/<model("slide.channel"):channel>/page/<int:page>''',
-        structure_ids = contracts.get_all_structures()
+        if len(contracts) == 1 and payslip.struct_id:
-            expense_sheets = self.env['hr.expense.sheet'].search([('account_move_id', 'in', account_move_ids)])
+            expense_sheets = self.env['hr.expense.sheet'].search([
-        'invoice_id.date_invoice')
+        'invoice_id.date_invoice', 'invoice_id.date')
-            price_subtotal_signed = self.invoice_id.currency_id.with_context(date=self.invoice_id.date_invoice).compute(price_subtotal_signed, self.invoice_id.company_id.currency_id)
+            price_subtotal_signed = self.invoice_id.currency_id.with_context(date=self.invoice_id._get_currency_rate_date()).compute(price_subtotal_signed, self.invoice_id.company_id.currency_id)
-    _order = "statement_id desc, sequence, id desc"
+    _order = "statement_id desc, date desc, sequence, id desc"
-        'product_id', 'invoice_id.partner_id', 'invoice_id.currency_id', 'invoice_id.company_id')
+        'product_id', 'invoice_id.partner_id', 'invoice_id.currency_id', 'invoice_id.company_id',
-            price_subtotal_signed = self.invoice_id.currency_id.compute(price_subtotal_signed, self.invoice_id.company_id.currency_id)
+            price_subtotal_signed = self.invoice_id.currency_id.with_context(date=self.invoice_id.date_invoice).compute(price_subtotal_signed, self.invoice_id.company_id.currency_id)
-        values = super(WebsitePortal, self).sudo()._prepare_portal_layout_values()
+        values = super(WebsitePortal, self)._prepare_portal_layout_values()
-        values['purchase_count'] = request.env['purchase.order'].search_count([
+        values['purchase_count'] = request.env['purchase.order'].sudo().search_count([
-        values = super(WebsitePortal, self)._prepare_portal_layout_values()
+        values = super(WebsitePortal, self).sudo()._prepare_portal_layout_values()
-                    if date_deadline < date.today() and not opp.date_closed:
+                    if date_deadline < date.today():
-        user_pids = [user.partner_id.id for user in self.env['res.users'].sudo().browse(user_ids)]
+        user_pids = [user.partner_id.id for user in self.env['res.users'].sudo().browse(user_ids) if user.partner_id.active]
-from datetime import datetime
+from datetime import datetime, timedelta
-        if not date_today - datetime.timedelta(hours=24) <= session_start:
+        if not date_today - timedelta(hours=24) <= session_start:
-            request.website = request.website.with_context(context)
+            request.website = request.website.with_context(request.context)
-                amount = self.currency_id.with_context(date=line.date).compute(amount, line.company_currency_id)
+                amount = line.currency_id.with_context(date=line.date).compute(amount, line.company_currency_id)
-            line.credit = amount < 0 and -amount or 0.0
+                line.debit = amount > 0 and amount or 0.0
-        for inventory in self:
+        for inventory in self.filtered(lambda x: x.state not in ('done','cancel')):
-        return True
+        if self.env.context.get('planned_picking') and len(self) == 1:
-                              "the first inventory adjustement with this product before creating another one.") % (res.product_id.name, res.location_id.name))
+                              "the first inventory adjustement with this product before creating another one.") % (res.product_id.display_name, res.location_id.name))
-            error_key = json.loads(error.response.json()).get("error", "nc")
+            error_key = error.response.json().get("error", "nc")
-        help="If specified, this action will be opened at log on for this user, in addition to the standard menu.", domain=lambda self: [('id', '!=', self.env.ref('base.action_open_website').id)])
+        help="If specified, this action will be opened at log on for this user, in addition to the standard menu.")
-                       for module in category_mods):
+        exclusives = self.env['ir.module.category'].search([('exclusive', '=', True)])
-                    for module in category_mods
+                    for module in modules
-            not_real_cost_method_products = stock_history.mapped('product_id').filtered(lambda product: product.cost_method != 'real')
+            not_real_cost_method_products = self.env['product.product'].browse(
-                        price = stock_history.price_unit_on_quant
+                    history_data = stock_history_data[stock_history.id]
-                    inv_value += price * stock_history.quantity
+                        price = histories_dict.get((product_id, history_data['company_id']), 0.0)
-        help="If specified, this action will be opened at log on for this user, in addition to the standard menu.")
+        help="If specified, this action will be opened at log on for this user, in addition to the standard menu.", domain=lambda self: [('id', '!=', self.env.ref('base.action_open_website').id)])
-                'context': context,
+                'type': 'ir.actions.client',
-                product_return_moves.append((0, 0, {'product_id': move.product_id.id, 'quantity': quantity, 'move_id': move.id}))
+                quantity = float_round(quantity, precision_rounding=move.product_uom.rounding)
-                currency = self.currency_id.with_context(date=self.date or self.date_invoice or fields.Date.context_today(self))
+                currency = self.currency_id.with_context(date=self._get_currency_rate_date() or fields.Date.context_today(self))
-                ctx['date'] = inv.date or inv.date_invoice
+                ctx['date'] = inv._get_currency_rate_date()
-from datetime import datetime
+from datetime import datetime, timedelta
-        if not date_today - datetime.timedelta(hours=24) <= session_start:
+        if not date_today - timedelta(hours=24) <= session_start:
-    (this can be done manually, but a default value is automatically set if you have defined a bank account).
+      (this can be done manually, but a default value is automatically set if you have defined a bank account).
-                        average_price_unit += self._compute_average_price(prod_qty_done, prod_quantity, prod_moves)
+                        average_price_unit += factor * self._compute_average_price(prod_qty_done, prod_quantity, prod_moves)
-        too short. The 15 other characters contain an internal reference identifying
+        too short. The next 14 characters contain an internal reference identifying
-        this number with zeros.
+        this number with zeros. The last character of the ISR number is the result
-                internal_ref = invoice_ref.zfill(l10n_ch_ISR_NUMBER_LENGTH - l10n_ch_ISR_NUMBER_ISSUER_LENGTH)
+                internal_ref = invoice_ref.zfill(l10n_ch_ISR_NUMBER_LENGTH - l10n_ch_ISR_NUMBER_ISSUER_LENGTH - 1) # -1 for mod10r check character
-                record.l10n_ch_isr_number = invoice_issuer_ref + internal_ref
+                record.l10n_ch_isr_number = mod10r(invoice_issuer_ref + internal_ref)
-    driver_id = fields.Many2one('res.partner', 'Driver', help='Driver of the vehicle')
+    driver_id = fields.Many2one('res.partner', 'Driver', help='Driver of the vehicle', copy=False)
-    @api.depends('name', 'brand_id')
+    @api.depends('name', 'brand_id', 'default_total_depreciated_cost')
-    company_car_total_depreciated_cost = fields.Float(compute='_compute_car_atn_and_costs')
+    car_atn = fields.Float(compute='_compute_car_atn_and_costs', string='ATN Company Car', store=True)
-                new_res.append((res_item[0], res_item[1] + u" \u2022 " + str(model.default_total_depreciated_cost)))
+                new_res.append((res_item[0], res_item[1] + u" \u2022 " + str(round(model.default_total_depreciated_cost, 2))))
-    @api.depends('model_id', 'license_plate', 'log_contracts', 'total_depreciated_cost', 'acquisition_date')
+    @api.depends('model_id', 'license_plate', 'log_contracts', 'acquisition_date',
-            acquisition_date = self._get_acquisition_date()
+            acquisition_date = vehicle._get_acquisition_date()
-    @http.route('/web/tests', type='http', auth="none")
+    @http.route('/web/tests', type='http', auth="user")
-            date = self._context.get('date') or fields.Date.today()
+            date = self._context.get('date') or fields.Date.context_today(self)
-                    if picking._check_move_lines_map_quant_package(ml.package_id):
+                    if picking.state in ('done', 'cancel') or picking._check_move_lines_map_quant_package(ml.package_id):
-            raise UserError(_("Expenses must have been paid by the same entity (Company or employee)"))
+        for rec in self:
-        self.check_consistency()
+        sheet.check_consistency()
-    @api.constrains('expense_line_ids')
+    @api.constrains('expense_line_ids', 'employee_id')
-            ml = self.move_line_ids.filtered(lambda ml: ml.lot_id == lot and not ml.lot_produced_id)
+            move_lines = self.move_line_ids.filtered(lambda ml: ml.lot_id == lot and not ml.lot_produced_id)
-            if new_quantity_done >= ml.product_uom_qty:
+            move_lines = self.move_line_ids.filtered(lambda ml: not ml.lot_id and not ml.lot_produced_id)
-        else:
+
-        
+
-                                    'product_uom_id': self.product_6.uom_id.id, 
+                                    'product_tmpl_id': self.product_6.product_tmpl_id.id,
-        
+
-    @unittest.skip('failing test: is up to date?')
+        bom = self.env['mrp.bom'].browse(self.ref("mrp.mrp_bom_desk"))
-            'bom_id': self.ref("mrp.mrp_bom_desk")
+            'bom_id': bom.id,
-        workorders[0].active_move_lot_ids[0].write({'lot_id': lot_sheet.id, 'quantity_done': 1})
+        workorders[0].active_move_line_ids[0].write({'lot_id': lot_sheet.id, 'qty_done': 1})
-        move_table_sheet = production_table.move_raw_ids.filtered(lambda x : x.product_id == product_table_sheet)
+        move_table_sheet = production_table.move_raw_ids.filtered(lambda p: p.product_id == product_table_sheet)
-        workorders[1].active_move_lot_ids[0].write({'lot_id': lot_leg.id, 'quantity_done': 4})
+        workorders[1].active_move_line_ids[0].write({'lot_id': lot_leg.id, 'qty_done': 4})
-        move_leg = production_table.move_raw_ids.filtered(lambda x : x.product_id == product_table_leg)
+        move_leg = production_table.move_raw_ids.filtered(lambda p: p.product_id == product_table_leg)
-        move_table_bolt = production_table.move_raw_ids.filtered(lambda x : x.product_id.id == product_bolt.id)
+        move_lot = workorders[2].active_move_line_ids[0]
-        self.assertEqual(sum(move_table_bolt.quant_ids.mapped('qty')), 4, "Wrong quantity of consumed product %s" % move_table_bolt.product_id.name)
+        self.assertEqual(sum(move_table_sheet.mapped('quantity_done')), 1, "Wrong quantity of consumed product %s" % move_table_sheet.product_id.name)
-from models.res_company import UNALTERABLE_COUNTRIES
+from .models.res_company import UNALTERABLE_COUNTRIES
-import models
+from . import models
-import pos
+from . import account_bank_statement
-import models
+from . import models
-import account_closing
+from . import res_company
-                    candidate.unlink()
+                    if candidate.qty_done:
-                return split_value[currency_index + 1 % 2] if not negative else '-' + split_value[currency_index + 1 % 2]
+                return split_value[(currency_index + 1) % 2] if not negative else '-' + split_value[(currency_index + 1) % 2]
-                'purchase_tax_id': self.default_purchase_tax_id.id,
+            wizard.onchange_chart_template_id()
-        token = request.env['payment.token'].browse(pm_id)
+        token = request.env['payment.token'].sudo().browse(pm_id)
-    _order = 'priority desc, date_planned asc'
+    _order = 'priority desc, date_planned asc, id'
-    'depends': ['l10n_fr_certification', 'point_of_sale'],
+    'depends': ['l10n_fr_sale_closing', 'point_of_sale'],
-            wo.qty_remaining = float_round(wo.qty_production - wo.qty_produced, precision_rounding=wo.production_id.product_uom_id)
+            wo.qty_remaining = float_round(wo.qty_production - wo.qty_produced, precision_rounding=wo.production_id.product_uom_id.rounding)
-
+from models.res_company import UNALTERABLE_COUNTRIES
-    fr_companies = env['res.company'].search([('partner_id.country_id.code', '=', 'FR')])
+    fr_companies = env['res.company'].search([('partner_id.country_id.code', 'in', UNALTERABLE_COUNTRIES)])
-        fr_companies._create_secure_sequence()
+        fr_companies._create_secure_sequence(['l10n_fr_secure_sequence_id'])
-            journal.write({'update_posted': False})
+        journals.write({'update_posted': False})
-    'name': 'France - Accounting - Certified CGI 286 I-3 bis',
+    'name': 'France - VAT Anti-Fraud Certification (CGI 286 I-3 bis)',
-    'application': True,
+    'application': False,
-        'views/no_cancel.xml',
+        'views/res_config.xml',
-    l10n_fr_hash = fields.Char(readonly=True, copy=False)
+    # TO DO in master : refactor hashing algo to go into a mixin
-               _('Error occured when computing the hash. Impossible to get the unique previous posted move'))
+               _('An error occured when computing the inalterability. Impossible to get the unique previous posted journal entry.'))
-            if move.company_id.country_id.code == 'FR':
+            if move.company_id._is_accounting_unalterable():
-                    raise UserError(ERR_MSG % (self._name, ', '.join(MOVE_FIELDS)))
+                    raise UserError(_("According to the French law, you cannot modify a journal entry in order for its posted data to be updated or deleted. Unauthorized field: %s.") % ', '.join(MOVE_FIELDS))
-                                      not (m.l10n_fr_secure_sequence_number or m.l10n_fr_hash)):
+            for move in self.filtered(lambda m: m.company_id._is_accounting_unalterable() and
-            raise UserError(_('You cannot modify a posted entry of a journal.'))
+        if self.company_id._is_accounting_unalterable():
-            raise UserError(_('Warning: impossible to find any move with a hash.'))
+            raise UserError(_('There isn\'t any journal entry flagged for data inalterability yet for the company %s. This mechanism only runs for journal entries generated after the installation of the module France - Certification CGI 286 I-3 bis.') % self.env.user.company_id.name)
-                raise UserError(_('Corrupted Data on move %s.') % move.id)
+                raise UserError(_('Corrupted data on journal entry with id %s.') % move.id)
-                start_move_info = [move.date, move.l10n_fr_secure_sequence_number]
+                start_move_info = build_move_info(move)
-        raise UserError(_('''Successfully checked the integrity of account moves.
+        end_move_info = build_move_info(move)
-                         ) % (start_move_info[0], start_move_info[1], end_move_info[0], end_move_info[1]))
+                         The journal entries are guaranteed to be in their original and inalterable state
-                raise UserError(ERR_MSG % (self._name, ', '.join(LINE_FIELDS)))
+            if any(l.company_id._is_accounting_unalterable() and l.move_id.state == 'posted' for l in self):
-            raise UserError(ERR_MSG % (self._name, 'update_posted'))
+        for journal in self:
-            raise UserError(ERR_MSG % (self._name, 'update_posted'))
+        if self.company_id._is_accounting_unalterable():
-            company._create_secure_sequence()
+        if company._is_accounting_unalterable():
-            self.filtered(lambda c: not c.l10n_fr_secure_sequence_id)._create_secure_sequence()
+        for company in self:
-    def _create_secure_sequence(self):
+    def _create_secure_sequence(self, sequence_fields):
-            company.write({'l10n_fr_secure_sequence_id': seq.id})
+            vals_write = {}
-        for move_line in self.move_line_ids:
+        for move_line in self.move_line_ids.filtered(lambda ml: not ml.owner_id):
-        for move_line in self.move_line_ids:
+        for move_line in self.move_line_ids.filtered(lambda ml: not ml.owner_id):
-        valued_move_lines = move.move_line_ids.filtered(lambda ml: ml.location_id._should_be_valued() and not ml.location_dest_id._should_be_valued())
+        valued_move_lines = move.move_line_ids.filtered(lambda ml: ml.location_id._should_be_valued() and not ml.location_dest_id._should_be_valued() and not ml.owner_id)
-            valued_move_lines = self.move_line_ids.filtered(lambda ml: not ml.location_id._should_be_valued() and ml.location_dest_id._should_be_valued())
+            valued_move_lines = self.move_line_ids.filtered(lambda ml: not ml.location_id._should_be_valued() and ml.location_dest_id._should_be_valued() and not ml.owner_id)
-            valued_move_lines = self.move_line_ids.filtered(lambda ml: ml.location_id._should_be_valued() and not ml.location_dest_id._should_be_valued())
+            valued_move_lines = self.move_line_ids.filtered(lambda ml: ml.location_id._should_be_valued() and not ml.location_dest_id._should_be_valued() and not ml.owner_id)
-            seq.write({'number_next': seq.number_next_actual or 0})
+            seq.write({'number_next': seq.number_next_actual or 1})
-            seq.write({'number_next': seq.number_next_actual or 0})
+            seq.write({'number_next': seq.number_next_actual or 1})
-        check = u"%s%s%s" % (json.dumps(self.files), u",".join(self.remains), self.last_modified)
+        check = u"%s%s%s" % (json.dumps(self.files, sort_keys=True), u",".join(self.remains), self.last_modified)
-    disabled_children_number = fields.Integer('Number of disabled children')
+    ], string='Tax status for spouse', groups="hr.group_hr_user")
-    spouse_net_revenue = fields.Float(string="Spouse Net Revenue", help="Own professional income, other than pensions, annuities or similar income")
+    other_dependent_people = fields.Boolean(string="Other Dependent People", help="If other people are dependent on the employee", groups="hr.group_hr_user")
-        help='Own professional income which is exclusively composed of pensions, annuities or similar income')
+        help='Own professional income which is exclusively composed of pensions, annuities or similar income', groups="hr.group_hr_user")
-                        self.action_cancel(cr, uid, [move.move_dest_id.id], context=context)
+                        if move.move_dest_id.state not in ('done', 'cancel'):
-                self.move_dest_id.action_cancel()
+                if self.move_dest_id.state not in ('done', 'cancel'):
-            record.write({'number_next': record.number_next_actual or 0})
+            record.write({'number_next': record.number_next_actual or 1})
-    dependent_children = fields.Integer(compute='_compute_dependent_children', string='Considered number of dependent children')
+    dependent_children = fields.Integer(compute='_compute_dependent_children', string='Considered number of dependent children', groups="hr.group_hr_user")
-            self.browse(menu['id']).write(menu)
+            menu_id.write(menu)
-            request.redirect = lambda url, code=302: werkzeug.utils.redirect(url_for(url), code)
+        # only called for is_frontend request
-                                  or cls._get_default_lang().code)
+            langs = [lg.code for lg in cls._get_languages()]
-                request.lang = context['lang'] = nearest_lang or preferred_lang
+            request.lang = context['lang'] = nearest_lang or preferred_lang
-            context = dict(request.context)
+                context = dict(request.context)
-            request.context = context
+                request.context = context
-            context['website_id'] = request.website.id
+        context = dict(request.context)
-        if request.is_frontend and request.routing_iteration == 1:
+        if request.routing_iteration == 1:
-        if request.website:
+        if getattr(request, 'website', False):
-https://www.odoo.com/documentation/9.0/reference/http.html#csrf for
+https://www.odoo.com/documentation/11.0/reference/http.html#csrf for
-                'time', 'datetime', 'relativedelta', 'current_date'}
+        return {
-            result = super(Partner, self).sudo().write({'is_company': vals.get('is_company')})
+            result = super(Partner, self.sudo()).write({'is_company': vals.get('is_company')})
-                procurements = ProcurementSudo.search([('id', 'not in', procurements.ids), ('state', '=', 'confirmed')] + (company_id and [('company_id', '=', company_id)] or []))
+                procurements = ProcurementSudo.search([('id', 'not in', run_procurements), ('state', '=', 'confirmed')] + (company_id and [('company_id', '=', company_id)] or []))
-                procurements = ProcurementSudo.search([('id', 'not in', procurements.ids), ('state', '=', 'running')] + (company_id and [('company_id', '=', company_id)] or []))
+            procurements.check(autocommit=use_new_cursor)
-        self.is_produced = self.qty_produced >= self.production_id.product_qty
+        rounding = self.production_id.product_uom_id.rounding
-            new_qty = move.unit_factor * self.qty_producing
+            rounding = move.product_uom.rounding
-                    while float_compare(qty_todo, 0.0, precision_rounding=move.product_uom.rounding) > 0:
+                qty_todo = float_round(new_qty - sum(move_lots.mapped('qty_done')), precision_rounding=rounding)
-                elif float_compare(qty_todo, 0.0, precision_rounding=move.product_uom.rounding) < 0:
+                elif float_compare(qty_todo, 0.0, precision_rounding=rounding) < 0:
-                        if qty_todo <= 0:
+                        if float_compare(qty_todo, 0, precision_rounding=rounding) <= 0:
-                            qty_todo = qty_todo - move_lot.qty_done
+                        if not move_lot.lot_id and float_compare(qty_todo, move_lot.qty_done, precision_rounding=rounding) >= 0:
-                            if move_lot.qty_done - qty_todo > 0:
+                            if float_compare(move_lot.qty_done - qty_todo, 0, precision_rounding=rounding) == 1:
-        if self.qty_produced >= self.production_id.product_qty:
+        rounding = self.production_id.product_uom_id.rounding
-            self.qty_producing = self.production_id.product_qty - self.qty_produced
+            self.qty_producing = float_round(self.production_id.product_qty - self.qty_produced, precision_rounding=rounding)
-        if self.qty_produced >= self.production_id.product_qty:
+        if float_compare(self.qty_produced, self.production_id.product_qty, precision_rounding=rounding) >= 0:
-            wo.qty_remaining = wo.qty_production - wo.qty_produced
+            wo.qty_remaining = float_round(wo.qty_production - wo.qty_produced, precision_rounding=wo.production_id.product_uom_id)
-                move.state = 'confirmed'
+        self.mapped('move_line_ids').unlink()
-                if move.move_orig_ids:
+                if move.procure_method == 'make_to_order' and not move.move_orig_ids:
-        return super(StockMoveLine, self).unlink()
+        moves = self.mapped('move_id')
-        self.assertEquals(move_mto_alone.state, "waiting")
+        self.assertEquals(move_mto_alone.state, "draft")
-            record._cache[self] = value
+            env.cache[self][record.id] = value
-                record._set_dirty(self.name)
+                env.dirty[record].add(self.name)
-                record._cache[self] = value
+                env.cache[self][record.id] = value
-            weight += sml.product_uom_id._compute_quantity(sml.qty_done, sml.product_id.uom_id) * sml.product_id.weight
+        if self.env.context.get('picking_id'):
-        self.has_packages = has_packages
+        self.has_packages = self.move_line_ids.filtered(lambda ml: ml.result_package_id)
-                    packops.write({'result_package_id': pack.id})
+                if picking._check_move_lines_map_quant_package(pack):
-            self.current_picking_id = False
+            self.ensure_one()
-    @api.depends('name', 'location_id.name')
+    @api.depends('name', 'location_id.complete_name')
-        self.complete_name = name
+        if self.location_id.complete_name:
-            price += bom.product_uom_id._compute_price(total_cost, bom.product_id.uom_id)
+            # FIXME master: remove me
-    @api.one
+    @api.multi
-        self.reserved_availability = sum(self.mapped('reserved_quant_ids').mapped('qty'))
+        result = {data['reservation_id'][0]: data['qty'] for data in 
-                
+
-            stage_data = self.env['crm.stage'].browse([d['label'] for d in graph_datas[0]['values']]).read(['sequence', 'name'])
+            stage_ids = [d['label'] for d in graph_datas[0]['values'] if d['label'] is not None]
-        data = json.load(urlopen(request, timeout=URLOPEN_TIMEOUT))
+        r = requests.post(
-                'inventory_availability': str(variant.inventory_availability),
+                'product_type': variant.type,
-                'custom_message': str(variant.custom_message),
+                'custom_message': variant.custom_message,
-                'uom_name': str(variant.uom_id.name),
+                'uom_name': variant.uom_id.name,
-
+    def _onchange_product_id(self):
-        with TemporaryFile('w+b') as buf:
+        with TemporaryFile('wb+') as buf:
-            description = 'Partner: {} (id: {})'.format(partner_id.name, partner_id.id)
+            description = 'Partner: %s (id: %s)' % (partner_id.name, partner_id.id)
-            'description': description or token['email']
+            'description': description or token["card"]["name"]
-            'name': 'XXXXXXXXXXXX%s - %s' % (token['card']['last4'], token['email'])
+            'name': 'XXXXXXXXXXXX%s - %s' % (token['card']['last4'], customer_params["description"])
-            'currency_precision': user_currency.digits,
+            'currency_precision': user_currency.decimal_places,
-            'description': description or 'Partner: {} (id: {})'.format(self.partner_id.name, self.partner_id.id)
+            'description': description or token['email']
-        return getattr(self.env['hr.contract.advantage.template'].search([('code', '=', code)], limit=1), attribute)
+        return self.env['hr.contract.advantage.template'].search([('code', '=', code)], limit=1)[attribute]
-                setattr(contract, code, value)
+                contract[code] = value
-                setattr(contract, code, 0.0)
+                contract[code] = 0.0
-                prop.unlink()
+                # avoid prop.unlink(), as it clears the record cache that can
-    reference = fields.Char(string='Vendor Reference',
+    reference = fields.Char(string='Vendor Reference', copy=False,
-            'error_message': [kwargs.get('error')],
+            'error_message': [kwargs['error']] if kwargs.get('error') else False,
-        self.partner_agrolait_id = self.env.ref("base.res_partner_2").id
+        partner_agrolait = self.env.ref("base.res_partner_2")
-        self.account_rsa = self.env['account.account'].search([('user_type_id', '=', self.env.ref('account.data_account_type_payable').id)], limit=1)
+        self.account_rcv = partner_agrolait.property_account_receivable_id or self.env['account.account'].search([('user_type_id', '=', self.env.ref('account.data_account_type_receivable').id)], limit=1)
-        return werkzeug.utils.redirect(post.get('return_url', '/'))
+        error = None
-        response = tx._create_stripe_charge(tokenid=post['tokenid'], email=post['email'])
+
-        res = {}
+        token = values.get('stripe_token')
-        url_customer = 'https://%s/customers' % payment_acquirer._get_stripe_api_url()
+        # when asking to create a token on Stripe servers
-                raise UserError(token['error']['message'])
+            description = values['cc_holder_name']
-        for field_name in ["cc_number", "cvc", "cc_holder_name", "cc_expiry", "cc_brand"]:
+        for field_name in ["cc_number", "cvc", "cc_holder_name", "cc_expiry", "cc_brand", "stripe_token"]:
-            'acquirers': acquirers
+            'acquirers': acquirers,
-    department_id = fields.Many2one('hr.department', string="Department", related="employee_id.department_id")
+    department_id = fields.Many2one('hr.department', string="Department", related="employee_id.department_id",
-                return value.sudo().name_get()[0]
+                return (value.id, value.sudo().display_name)
-                result.append((1, record.id, vals))
+                result.append((0, record.id.ref or 0, vals[record]))
-from odoo.tools import pycompat
+from odoo.tools import float_compare, pycompat
-            date = fields.Date.today()
+            date = fields.Date.context_today(self)
-            if quantity_uom_seller < seller.min_qty:
+            if float_compare(quantity_uom_seller, seller.min_qty, precision_digits=precision) == -1:
-                        delta = new_date - current_date
+                        delta = relativedelta.relativedelta(new_date, current_date)
-        except request.HTTPError as error:
+        except requests.HTTPError as error:
-                status = error.code
+                status = error.response.status_code
-                if error.code in (400, 401, 410):
+                if error.response.status_code in (400, 401, 410):
-                            if e.code in (401, 410,):
+                            if e.response.status_code in (401, 410,):
-            default_lang = self.env['ir.values'].search([
+            self.env['ir.values'].search([
-                default_lang.unlink()
+                ('model', '=', 'res.partner')
-        cart = request.website.sale_get_order()
+        website = getattr(request, 'website', None)
-from odoo.tools import mute_logger
+from odoo.tools import mute_logger, float_repr
-        self.assertEqual(amount, 14.7)
+        model = self.env['test_new_api.mixed']
-from odoo.tools import float_precision, float_repr, float_round, frozendict, \
+from odoo.tools import float_repr, float_round, frozendict, \
-    def convert_to_column(self, value, record):
+    def convert_to_column(self, value, record, values=None):
-    def convert_to_column(self, value, record):
+    def convert_to_column(self, value, record, values=None):
-    def convert_to_column(self, value, record):
+    def convert_to_column(self, value, record, values=None):
-    def convert_to_column(self, value, record):
+    def convert_to_column(self, value, record, values=None):
-            return float(value or 0.0)
+    def convert_to_column(self, value, record, values=None):
-            currency = record[self.currency_field]
+        # cache format: float
-        return float(value or 0.0)
+            value = record[self.currency_field].round(value)
-        return float(value)
+        return value
-    def convert_to_column(self, value, record):
+    def convert_to_column(self, value, record, values=None):
-    def convert_to_column(self, value, record):
+    def convert_to_column(self, value, record, values=None):
-    def convert_to_column(self, value, record):
+    def convert_to_column(self, value, record, values=None):
-    def convert_to_column(self, value, record):
+    def convert_to_column(self, value, record, values=None):
-    def convert_to_column(self, value, record):
+    def convert_to_column(self, value, record, values=None):
-    def convert_to_column(self, value, record):
+    def convert_to_column(self, value, record, values=None):
-                        val = field.convert_to_column(val, self)
+                        val = field.convert_to_column(val, self, vals)
-                    val = field.convert_to_column(vals[name], self)
+                    val = field.convert_to_column(vals[name], self, vals)
-            updates.append((self._inherits[parent_model], '%s', parent_id))
+            vals[self._inherits[parent_model]] = parent_id
-                updates.append((name, field.column_format, field.convert_to_column(val, self)))
+                column_val = field.convert_to_column(val, self, vals)
-
+    elif big_name in vals or medium_name in vals or small_name in vals:
-            company_id = self.sudo(user_id).company_id.id
+            company_id = self.sudo(user_id).env.user.company_id.id
-                elif so_line.product_id.invoice_policy == 'order':
+                elif so_line.product_id.invoice_policy == 'order' and so_line.product_id.service_type == 'timesheet':
-        sale_order_lines._analytic_compute_delivered_quantity()
+        sale_order_lines.with_context(sale_analytic_force_recompute=True)._analytic_compute_delivered_quantity()
-                analytic_line.write({'so_line': so_line.id})
+                analytic_line.with_context(sale_analytic_norecompute=True).write({'so_line': so_line.id})
-        # convert uom and sum all unit_amount of analytic lines to get the delivered qty of SO lines
+        # Force recompute for the "unlink last line" case: if remove the last AAL link to the SO, the read_group
-                orderby_terms.append(order_part)
+                order_split[0] = '"' + order_field + '"'
-                    quantity = 1.0 if float_is_zero(quantity, precision_digits=precision) else 0.0
+                    quantity = 1.0 if not float_is_zero(quantity, precision_digits=precision) else 0.0
-                orderby_terms.append(order_part)
+                order_split[0] = '"' + order_field + '"'
-    Header(header_text, 'utf-8')
+    return Header(header_text, 'utf-8')
-        read_group_res = self.env['product.template'].read_group([('categ_id', 'in', self.ids)], ['categ_id'], ['categ_id'])
+        read_group_res = self.env['product.template'].read_group([('categ_id', 'child_of', self.ids)], ['categ_id'], ['categ_id'])
-            categ.product_count = group_data.get(categ.id, 0)
+            product_count = 0
-        self.map_tasks(cr, uid, id, res, context=context)
+        if 'tasks' not in default:
-                '|', ("type", "=", "delivery"), ("id", "=", order.partner_id.commercial_partner_id.id)
+                '|', ("type", "in", ["delivery", "other"]), ("id", "=", order.partner_id.commercial_partner_id.id)
-                if moveline.move_id.has_tracking != 'none':
+                if moveline.product_id == order.product_id and moveline.move_id.has_tracking != 'none':
-        if (self.production_id.product_id.tracking != 'none') and not self.final_lot_id:
+        if (self.production_id.product_id.tracking != 'none') and not self.final_lot_id and self.move_raw_ids:
-                res.update({'currency_id': currency_id})
+                res.update({'currency_id': currency_id.id})
-        help="Yearly gross amount the employee receives as double holidays bonus.")
+    double_holidays = fields.Monetary(compute='_compute_holidays_advantages', string='Holiday Bonus',
-    @api.depends('yearly_cost_before_charges', 'social_security_contributions',
+    @api.depends('yearly_cost_before_charges', 'social_security_contributions', 'wage',
-    wage_with_holidays = fields.Monetary(compute='_compute_wage_with_holidays', sting="Wage update with holidays retenues")
+    wage_with_holidays = fields.Monetary(compute='_compute_wage_with_holidays', string="Wage update with holidays retenues")
-from odoo.exceptions import UserError
+from odoo.exceptions import UserError, ValidationError
-from datetime import datetime
+from datetime import datetime, timedelta
-                if not version or changes:
+                if version is None:
-from odoo.modules.loading import load_modules
+from odoo.modules.loading import load_modules, reset_modules_state
-                    odoo.modules.load_modules(registry._db, force_demo, status, update_module)
+                    try:
-        closing = u'</p>'
+        closing = u'</h3>'
-            self.body.append(self.starttag(node, 'p', CLASS='alert-title'))
+            self.body.append(self.starttag(node, 'h3', CLASS='alert-title'))
-            self.body.append(u'<h2 class="col-sm-12">')
+            self.body.append(u'<div class="col-sm-12"><h2>')
-            self.body.append(u'</h2>')
+            self.body.append(u'</h2></div>')
-        return True
+        return False
-        if backorder_wizard_dict is not None:
+        if backorder_wizard_dict:
-            aml_rec.write({'statement_line_id': self.id})
+            aml_rec.with_context(check_move_validity=False).write({'statement_line_id': self.id})
-        search='_search_activity_user_id')
+        search='_search_activity_user_id',
-        search='_search_activity_type_id')
+        search='_search_activity_type_id',
-        readonly=True, store=True)  # store to enable ordering + search
+        readonly=True, store=True,  # store to enable ordering + search
-        search='_search_activity_summary')
+        'Next Activity Summary',
-            req = requests.post(request_url, headers=headers, timeout=TIMEOUT)
+            req = requests.get(request_url, headers=headers, timeout=TIMEOUT)
-            default_sale_tax_id = False
+        # ONLY FOR v11. DO NOT FORWARD-PORT
-            default_sale_tax_id=default_sale_tax_id,
+            default_purchase_tax_id=default_purchase_tax_id[0] if default_purchase_tax_id else False,
-        main_menu = request.env.ref('website.main_menu', raise_if_not_found=False)
+        main_menu = request.website.menu_id or request.env.ref('website.main_menu', raise_if_not_found=False)
-            page = 'website.page_404'
+            page = 'website.%s' % (request.website.is_publisher() and 'page_404' or '404')
-        with open(abs_filepath, 'r') as fn:
+        with open(abs_filepath, 'rb') as fn:
-            data = json.loads(content)
+            data = json.loads(content.decode('utf8'))
-            data = pickle.loads(content)
+            data = pickle.loads(content, encoding='utf8')
-    unpickler = Unpickler(stream)
+def _pickle_load(stream, encoding='ASCII', errors=False):
-pickle.loads = lambda text: _pickle_load(io.BytesIO(text))
+pickle.loads = lambda text, encoding='ASCII': _pickle_load(io.BytesIO(text), encoding=encoding)
-            :param response str: text response, structured in the following way:
+            :param str response: text response, structured in the following way:
-                pdt_post[split[0]] = urls.url_unquote_plus(split[1]).decode('utf8')
+                pdt_post[split[0]] = urls.url_unquote_plus(split[1])
-        new_post = dict(post, cmd='_notify-validate')
+        new_post = dict(post, cmd='_notify-validate', charset='utf-8')
-        resp = urequest.content
+        resp = urequest.text
-                line.order_id.procurement_group_id = self.env['procurement.group'].create({
+            group_id = line.order_id.procurement_group_id
-            values = line._prepare_procurement_values(group_id=line.order_id.procurement_group_id)
+                line.order_id.procurement_group_id = group_id
-        request.website.sale_get_order(force_create=1)._cart_update(product_id=int(product_id), add_qty=float(add_qty), set_qty=float(set_qty))
+        request.website.sale_get_order(force_create=1)._cart_update(product_id=int(product_id), add_qty=add_qty, set_qty=set_qty)
-
+        try:
-                add_qty=int(add_qty), set_qty=int(set_qty),
+                add_qty=add_qty, set_qty=set_qty,
-                'user_activity': opp.activity_ids.filtered(lambda activity: activity.user_id == request.env.user)[:1],
+                'user_activity': opp.sudo().activity_ids.filtered(lambda activity: activity.user_id == request.env.user)[:1],
-
+from odoo.addons.base_geolocalize.models.res_partner import geo_find, geo_query_address
-            self = self.sudo()
+        if not (self.env.user.partner_id.grade_id or self.env.user.commercial_partner_id.grade_id):
-            record.l10n_ch_postal = record.sanitized_acc_number
+            else:
-            if not quant.company_id.currency_id.is_zero(valuation_update) and move._check_lock_date():
+            lock_date = max(move.company_id.period_lock_date, move.company_id.fiscalyear_lock_date)
-        self.pick_id.do_transfer()
+        return self.pick_id.do_transfer()
-    def _journal_item_count(self):
+    def _compute_journal_item_count(self):
-            partner.contracts_count = self.env['account.analytic.account'].search_count([('partner_id', '=', partner.id)])
+            partner.journal_item_count = AccountMoveLine.search_count([('partner_id', '=', partner.id)])
-    journal_item_count = fields.Integer(compute='_journal_item_count', string="Journal Items", type="integer")
+    contracts_count = fields.Integer(compute='_compute_contracts_count', string="Contracts", type='integer')
-            if move_dict['remaining_qty'] == qty_on_link:
+            if float_compare(move_dict['remaining_qty'], qty_on_link, precision_rounding=move_dict['move'].product_uom.rounding) == 0:
-        if line.state == 'sale':
+        precision = self.env['decimal.precision'].precision_get('Product Unit of Measure')
-        self = self.with_context(project_creation_in_progress=True, mail_create_nosubscribe=True)
+        self = self.with_context(mail_create_nosubscribe=True)
-                project_id = account.sudo().project_create({
+                project = Project.create({
-                project_name = '%s (%s)' % (account.name, self.sale_line_id.order_partner_id.ref) if self.sale_line_id.order_partner_id.ref else account.name
+                project_name = '%s (%s)' % (account.name, self.order_partner_id.ref) if self.order_partner_id.ref else account.name
-                    ['|', ('order_id.name', operator, name), ('product_id.name', operator, name)]
+                    ['|', ('order_id.name', operator, name), ('name', operator, name)]
-            raise UserError(_('There is no invoicable line.'))
+            raise UserError(_('There is no invoiceable line.'))
-                raise UserError(_('There is no invoicable line.'))
+                raise UserError(_('There is no invoiceable line.'))
-            if not line.move_ids:
+            if not line.move_ids.filtered(lambda m: m.state != 'cancel'):
-                default[k] = pad.get('url')
+                if self.env.context.get('pad_no_create', False):
-from odoo import fields, models
+from odoo import api, fields, models
-                        restart()
+                        if not getattr(odoo, 'phoenix', False):
-
+
-                    cell_value = re.sub("\r", " ", cell_value)
+                    cell_value = re.sub("\r", " ", pycompat.to_text(cell_value))
-        return "attachment; filename*=UTF-8''%s" % escaped
+    escaped = urls.url_quote(filename)
-        if not message.is_multipart() or message.get('content-type', '').startswith("text/"):
+        if message.get_content_maintype() == 'text':
-            'difference': (last_balance-account_sum) and formatLang(self.env, last_balance-account_sum, currency_obj=self.currency_id or self.company_id.currency_id) or False,
+            'account_balance': formatLang(self.env, currency.round(account_sum) + 0.0, currency_obj=currency),
-            'currency_id': self.currency_id and self.currency_id.id or self.company_id.currency_id.id,
+            'sum_draft': formatLang(self.env, currency.round(sum_draft) + 0.0, currency_obj=currency),
-            raise ValidationError(_('Authorize.net Error Message(s):\n %s') % '\n'.join(messages))
+        (has_error, error_msg) = error_check(response)
-            'reference': 'test_ref_%s' % odoo.fields.Date.today(),
+            'reference': 'test_ref_%s' % int(time.time()),
-                            default={'product_uom_qty': operation.qty_done, 'qty_done': operation.qty_done})
+                            default={'product_uom_qty': 0, 'qty_done': operation.qty_done})
-            elif record.acc_type == 'iban':
+            if record.acc_type == 'iban':
-from . import res_company
+    def _default_project_id(self):
-    timesheet_task_id = fields.Many2one('project.task', string="Internal Task for timesheet", domain="[('project_id', '=', timesheet_project_id)]")
+    timesheet_project_id = fields.Many2one('project.project', string="Internal Project", default=_default_project_id, help="The project will contain the timesheet generated when a leave is validated.")
-        registrations = Registration.search([('sale_order_line_id', 'in', self.ids)])
+        registrations = Registration.search([('sale_order_line_id', 'in', self.ids), ('state', '!=', 'cancel')])
-from odoo.tools import convert_file, exception_to_unicode
+from odoo.tools import convert_file, exception_to_unicode, pycompat
-                    url_path = url_path.decode(sys.getfilesystemencoding())
+                    url_path = '/{}{}'.format(module, full_path.split(path)[1].replace(os.path.sep, '/'))
-                    wo.active_move_lot_ids.unlink()
+                    wo.active_move_line_ids.unlink()
-            lines |= finished_move_lines.filtered(lambda ml: ml.product_id == self.product_id and (ml.lot_id or ml.lot_name))
+            lines |= finished_move_lines.filtered(lambda ml: ml.product_id == self.product_id and (ml.lot_id or ml.lot_name) and ml.done_wo == self.done_wo)
-            lines |= raw_moves_lines.filtered(lambda ml: ml.product_id == self.product_id and (ml.lot_id or ml.lot_name))
+            lines |= raw_moves_lines.filtered(lambda ml: ml.product_id == self.product_id and (ml.lot_id or ml.lot_name) and ml.done_wo == self.done_wo)
-        gross = remaining_for_gross / (12.0 * 0.05 + 13.0 + 13.0 * 0.3507 + 0.92)
+        gross = remaining_for_gross / (13.0 + 13.0 * 0.3507 + 0.92)
-            ]])
+            [
-            ]])
+            [
-                ['', u'13', ''],
+            [
-            ]])
+            [
-                        fields2 = [(p[1:] if p and p[0] == name else []) for p in fields]
+                        # recursively export the fields that follow name; use
-                                lines += lines2[1:]
+                            # append the other lines at the end
-            self.name = name
+            record.name = name
-            'cache': base64.encodestring(json.dumps(res)),
+            'cache': base64.encodestring(json.dumps(res).encode('utf-8')),
-        return json.loads(base64.decodestring(self.cache))
+        return json.loads(base64.decodestring(self.cache).decode('utf-8'))
-                    raise UserError(_('You need to supply a lot/serial number for %s.') % product.name)
+                if product and product.tracking != 'none':
-            raise UserError(_('It is not possible to reserve more products than you have in stock.'))
+            raise UserError(_('It is not possible to reserve more products of %s than you have in stock.') % (', '.join(quants.mapped('product_id').mapped('display_name'))))
-            raise UserError(_('It is not possible to unreserve more products than you have in stock.'))
+            raise UserError(_('It is not possible to unreserve more products of %s than you have in stock.') % (', '.join(quants.mapped('product_id').mapped('display_name'))))
-    _order = 'sequence'
+    _order = 'sequence,id'
-            if quant.quantity > 1 and quant.lot_id and quant.product_id.tracking == 'serial':
+            if float_compare(quant.quantity, 1, precision_rounding=quant.product_uom_id.rounding) > 0 and quant.lot_id and quant.product_id.tracking == 'serial':
-                return available_quantity if available_quantity >= 0.0 else 0.0
+                return available_quantity if float_compare(available_quantity, 0.0, precision_rounding=rounding) >= 0.0 else 0.0
-                return sum([available_quantity for available_quantity in availaible_quantities.values() if available_quantity > 0])
+                return sum([available_quantity for available_quantity in availaible_quantities.values() if float_compare(available_quantity, 0, precision_rounding=rounding) > 0])
-                    if quant.quantity == 0 and quant.reserved_quantity == 0:
+                    if float_is_zero(quant.quantity, precision_rounding=rounding) and float_is_zero(quant.reserved_quantity, precision_rounding=rounding):
-        if quantity > 0 and quantity > available_quantity:
+        if float_compare(quantity, 0, precision_rounding=rounding) > 0 and float_compare(quantity, available_quantity, precision_rounding=rounding) > 0:
-        elif quantity < 0 and abs(quantity) > sum(quants.mapped('reserved_quantity')):
+        elif float_compare(quantity, 0, precision_rounding=rounding) < 0 and float_compare(abs(quantity), sum(quants.mapped('reserved_quantity')), precision_rounding=rounding) > 0:
-            if quantity > 0:
+            if float_compare(quantity, 0, precision_rounding=rounding) > 0:
-                if max_quantity_on_quant <= 0:
+                if float_compare(max_quantity_on_quant, 0, precision_rounding=rounding) <= 0:
-            if quantity == 0 or available_quantity == 0:
+            if float_is_zero(quantity, precision_rounding=rounding) or float_is_zero(available_quantity, precision_rounding=rounding):
-    tax_id = fields.Many2one('account.tax', string='Tax', ondelete='restrict', domain=[('type_tax_use', '=', 'purchase')])
+    tax_id = fields.Many2one('account.tax', string='Tax', ondelete='restrict')
-            'size': "%sx%s" % (height, width),
+            'size': "%sx%s" % (width, height),
-            image = parent_image and parent_image.decode('base64') or None
+            image = parent_image and base64.b64decode(parent_image) or None
-        request = Request(self.url, data_tree)
+        data = etree.tostring(data, xml_declaration=True, encoding='utf-8')
-from odoo import api, fields, models
+from odoo import _, api, fields, models
-                    _logger.warning('<%s> transaction MISMATCH for order %s (ID %s)', acquirer_name, tx.sale_order_id.name, tx.sale_order_id.id)
+                    _logger.warning(
-                                valuation_price_unit_total += val_stock_move.price_unit * val_stock_move.product_qty
+                                valuation_price_unit_total += abs(val_stock_move.price_unit) * val_stock_move.product_qty
-        request = Request(self.url, data)
+        data_tree = etree.tostring(data, xml_declaration=True, encoding='utf-8')
-        re_only = re.compile('QUnit\.only\(')
+        self._check_only_call('web.qunit_suite')
-        for asset in self.env['ir.qweb']._get_asset_content('web.qunit_suite', options={})[0]:
+        for asset in self.env['ir.qweb']._get_asset_content(suite, options={})[0]:
-                if re_only.search(fp.read()):
+                if RE_ONLY.search(fp.read()):
-            raise UserError(ERR_MSG % (self._name, 'update_posted'))
+        for rec in self:
-            if move_line.production_id and 'lot_id' in vals:
+            if move_line.move_id.production_id and 'lot_id' in vals:
-        valued_quantity = sum(valued_move_lines.mapped('qty_done'))
+        valued_quantity = 0
-            valued_quantity = sum(valued_move_lines.mapped('qty_done'))
+            valued_quantity = 0
-                qcontext['error'] = e.message or e.name
+                qcontext['error'] = e.name or e.value
-        max_unused_cars = params.get_param('l10n_be_hr_payroll_fleet.max_unused_cars', default=3)
+        max_unused_cars = params.get_param('l10n_be_hr_payroll_fleet.max_unused_cars', default=1000)
-        max_unused_cars = params.get_param('l10n_be_hr_payroll_fleet.max_unused_cars', default=3)
+        max_unused_cars = params.get_param('l10n_be_hr_payroll_fleet.max_unused_cars', default=1000)
-    @api.depends('yearly_cost_before_charges', 'ucm_insurance', 'social_security_contributions',
+    @api.depends('yearly_cost_before_charges', 'social_security_contributions',
-                yearly_cost = contract.final_yearly_costs * (1.0 - (contract.holidays - 20.0) / 220.0)
+                yearly_cost = contract.final_yearly_costs * (1.0 - (contract.holidays - 20.0) / 231.0)
-                decrease_amount = contract.final_yearly_costs * (20.0 - contract.holidays) / 220.0
+                decrease_amount = contract.final_yearly_costs * (20.0 - contract.holidays) / 231.0
-                balance += line[2]['debit'] - line[2]['credit']
+                balance += line[2].get('debit', 0) - line[2].get('credit', 0)
-    @api.depends('invoice_lines',
+    @api.depends('state',
-            line.amt_to_invoice = line.price_total - invoiced_amount_total
+            line.amt_to_invoice = (total_sale_line - invoiced_amount_total) if line.state in ['sale', 'done'] else 0.0
-    amt_invoiced = fields.Monetary(string='Amount Invoiced', compute='_compute_invoice_amount', store=True)
+    amt_to_invoice = fields.Monetary(string='Amount To Invoice', compute='_compute_invoice_amount', compute_sudo=True, store=True)
-        """ Testing amount to invoice and amount to be invoiced. """
+        """ Testing amount to invoice and amount to be invoiced, with advances. """
-        dashboard_values['money_amount']['to_invoice'] = sum([sol.currency_id.compute(sol.price_unit * sol.qty_to_invoice, currency) for sol in so_lines]) + sum([i.currency_id.with_context(date=i.invoice_id.date_invoice).compute(i.price_unit * i.quantity, currency) for i in invoice_lines.filtered(lambda line: line.invoice_id.state == 'draft')])
+        dashboard_values['money_amount']['to_invoice'] = sum([sol.currency_id.compute(sol.price_unit * (1 - (sol.discount or 0.0) / 100.0) * sol.qty_to_invoice, currency) for sol in so_lines]) + sum([i.currency_id.with_context(date=i.invoice_id.date_invoice).compute(i.price_unit * i.quantity, currency) for i in invoice_lines.filtered(lambda line: line.invoice_id.state == 'draft')])
-            return None
+            return self.env['sale.order']
-            self.date_begin_located = format_tz(self.with_context({'use_babel': True}).env, self.date_begin, tz=self.date_tz)
+            self.date_begin_located = format_tz(self.with_context(use_babel=True).env, self.date_begin, tz=self.date_tz)
-            self.date_end_located = format_tz(self.with_context({'use_babel': True}).env, self.date_end, tz=self.date_tz)
+            self.date_end_located = format_tz(self.with_context(use_babel=True).env, self.date_end, tz=self.date_tz)
-            aml_rec.write({'statement_id': self.statement_id.id})
+            aml_rec.with_context(check_move_validity=False).write({'statement_id': self.statement_id.id})
-            startdate = datetime.now()
+        event_date = pytz.UTC.localize(FieldDatetime.from_string(reference_date))  # Add "+hh:mm" timezone
-        ## Convert the start date to saved timezone (or context tz) as it'll
+        ## Convert the event date to saved timezone (or context tz) as it'll
-        rset1 = rrule.rrulestr(str(event.rrule), dtstart=startdate, forceset=True)
+        event_date = event_date.astimezone(timezone)  # transform "+hh:mm" timezone
-            rdates = self.get_recurrent_date_by_event(cr, uid, ev, context=context)
+            rdates = self._get_recurrent_dates_by_event(cr, uid, ev, context=context)
-            for r_date in rdates:
+            for r_start_date, r_stop_date in rdates:
-                            ok = r_date.strftime('%Y-%m-%d') == arg[2]
+                            ok = r_date.strftime(dformat) == arg[2]
-                            ok = r_date.strftime('%Y-%m-%d') > arg[2]
+                            ok = r_date.strftime(dformat) > arg[2]
-                            ok = r_date.strftime('%Y-%m-%d') < arg[2]
+                            ok = r_date.strftime(dformat) < arg[2]
-                            ok = r_date.strftime('%Y-%m-%d') >= arg[2]
+                            ok = r_date.strftime(dformat) >= arg[2]
-                            ok = r_date.strftime('%Y-%m-%d') <= arg[2]
+                            ok = r_date.strftime(dformat) <= arg[2]
-            registry['account.tax'].write(cr, SUPERUSER_ID, tax_id, {'tag_ids': [(6,0,[x.id for x in tax_template.tag_ids])]})
+        registry['account.tax'].write(cr, SUPERUSER_ID, tax_id, {'tag_ids': [(6,0,[x.id for x in tax_template.tag_ids])]})
-                                 "automatically generate a back order.")}
+            warning_mess = {
-            request.env['payment.transaction'].sudo().form_feedback(response, 'stripe')
+            request.env['payment.transaction'].sudo().with_context(lang=None).form_feedback(response, 'stripe')
-        res = map(lambda l: (l[0].name, l[1]), res)
+        res = [(
-    lang = env.user.company_id.partner_id.lang or 'en_US'
+    lang = env.context.get('lang') or env.user.company_id.partner_id.lang or 'en_US'
-        pl = Property.get('property_product_pricelist', Partner._name, '%s,%s' % (Partner._name, p.id)) or Property.get('property_product_pricelist', 'res.partner')
+        pl = Property.get('property_product_pricelist', Partner._name, '%s,%s' % (Partner._name, p.id))
-                raise ValidationError(_('A product cannot be stored in a "view" location.'))
+                raise ValidationError(_('You cannot take products from or deliver products to a location of type "view".'))
-        if new_standard_price:
+        if new_standard_price and move.product_id.cost_method == 'fifo':
-            else:  # standard
+            # Note: we always compute the fifo `remaining_value` and `remaining_qty` fields no
-                self.write({
+                vals.update({
-            elif self.product_id.cost_method in ['standard', 'average']:
+            self.env['stock.move']._run_fifo(self, quantity=quantity)
-        self.product1.with_context(debug=True).product_tmpl_id.cost_method = 'average'
+        self.product1.product_tmpl_id.cost_method = 'average'
-        if self.purchase_line_id:
+        if self.purchase_line_id and self.product_id.id == self.purchase_line_id.product_id.id:
-            })
+            return self.copy(default=self._prepare_phantom_move_values(bom_line, quantity))
-                           "method used is 'average price' or 'real'). Value given in company currency and in product uom.")  # as it's a technical field, we intentionally don't provide the digits attribute
+                           "method used is 'average price' or 'real'). Value given in company currency and in product uom.", copy=False)  # as it's a technical field, we intentionally don't provide the digits attribute
-        return not self.location_id._should_be_valued() and self.location_dest_id._should_be_valued()
+        for move_line in self.move_line_ids:
-        return self.location_id._should_be_valued() and not self.location_dest_id._should_be_valued()
+        for move_line in self.move_line_ids:
-        company_to = location_to._should_be_valued() and location_to.company_id or False
+        company_from = self._is_out() and self.mapped('move_line_ids.location_id.company_id') or False
-        if company_to and (self._is_in() or company_from != company_to):
+        if self._is_in():
-        if company_from and (self._is_out() or company_from != company_to):
+        if self._is_out():
-        qty_to_take_on_candidates = quantity or move.product_qty
+        valued_move_lines = move.move_line_ids.filtered(lambda ml: ml.location_id._should_be_valued() and not ml.location_dest_id._should_be_valued())
-                value = price_unit * (quantity or self.product_qty)
+                value = price_unit * (quantity or valued_quantity)
-                    vals['remaining_qty'] = self.product_qty if quantity is None else self.remaining_qty + quantity
+                    vals['remaining_qty'] = valued_quantity if quantity is None else self.remaining_qty + quantity
-                value = self.product_id.standard_price * (quantity or self.product_qty)
+                value = self.product_id.standard_price * (quantity or valued_quantity)
-                value = -float_round(self.product_id.standard_price * (self.product_qty if quantity is None else quantity), precision_rounding=curr_rounding)
+                value = -float_round(self.product_id.standard_price * (valued_quantity if quantity is None else quantity), precision_rounding=curr_rounding)
-                    'price_unit': value / self.product_qty,
+                    'price_unit': value / valued_quantity,
-        return not self.location_id.company_id and self.location_dest_id.company_id.id == self.company_id.id
+        return not self.location_id._should_be_valued() and self.location_dest_id._should_be_valued()
-        return self.location_id.company_id.id == self.company_id.id and not self.location_dest_id.company_id
+        return self.location_id._should_be_valued() and not self.location_dest_id._should_be_valued()
-        company_to = location_to and (location_to.usage == 'internal') and location_to.company_id or False
+        company_from = location_from._should_be_valued() and location_from.company_id or False
-        if company_to and (self.location_id.usage not in ('internal', 'transit') and self.location_dest_id.usage == 'internal' or company_from != company_to):
+        if company_to and (self._is_in() or company_from != company_to):
-        if company_from and (self.location_id.usage == 'internal' and self.location_dest_id.usage not in ('internal', 'transit') or company_from != company_to):
+        if company_from and (self._is_out() or company_from != company_to):
-        self.assertEqual(self.product1.standard_price, 12.63)
+        self.assertEqual(self.product1.standard_price, 12.63)
-                    created_invoice.payment_ids[0].payment_transaction_id = self
+            # TDE Note: in post-v11 we could probably add an explicit parameter + update account.payment tx directly at creation, not afterwards
-                created_invoice.with_context(tx_currency_id=self.currency_id.id).pay_and_reconcile(self.acquirer_id.journal_id, pay_amount=created_invoice.amount_total)
+                # TDE Note: in post-v11 we could probably add an explicit parameter + update account.payment tx directly at creation, not afterwards
-        pl = Property.get('property_product_pricelist', Partner._name, '%s,%s' % (Partner._name, p.id))
+        pl = Property.get('property_product_pricelist', Partner._name, '%s,%s' % (Partner._name, p.id)) or Property.get('property_product_pricelist', 'res.partner')
-            taxes = partner.property_account_position_id.map_tax(p.taxes_id.filtered(lambda x: x.company_id == company_id))
+            taxes = partner.property_account_position_id.map_tax(p.sudo().taxes_id.filtered(lambda x: x.company_id == company_id))
-                            message = '\n'.join(messages)
+                            message = (b'\n').join(messages)
-        GROUP BY aml.account_id
+        GROUP BY aml.account_id, aat.type
-    date = fields.Datetime('Inventory at Date', help="Choose a date to get the inventory at that date", default=fields.Datetime.now())
+    date = fields.Datetime('Inventory at Date', help="Choose a date to get the inventory at that date", default=fields.Datetime.now)
-                qty_split = move.product_uom._compute_quantity(move.product_uom_qty - move.quantity_done, move.product_id.uom_id)
+                qty_split = move.product_uom._compute_quantity(move.product_uom_qty - move.quantity_done, move.product_id.uom_id, rounding_method='HALF-UP')
-            res['location_id'] = self.env.ref('stock.stock_location_stock').id
+            company_user = self.env.user.company_id
-        super(TestMail, cls).tearDownClass()
+        super(TestMailGroup, cls).tearDownClass()
-        required=True)
+        default='subtotal', required=True)
-            default_sale_tax_id=int(params.get_param('account.default_sale_tax_id', default=False)) or False
+            default_purchase_tax_id=default_purchase_tax_id,
-            auth_signup_template_user_id=literal_eval(get_param('auth_signup.template_user_id', 'False')),
+            auth_signup_template_user_id=auth_signup_template_user_id,
-            default_deposit_product_id=int(ICPSudo.get_param('sale.default_deposit_product_id')),
+            default_deposit_product_id=default_deposit_product_id,
-        if not cart_recovery_mail_template:
+        cart_recovery_mail_template = literal_eval(params.get_param('website_sale.cart_recovery_mail_template_id', default='False'))
-            start_date = date(start_date.year + start_date.month / 12, start_date.month % 12 + 1, 1)
+            start_date = date(start_date.year + start_date.month // 12, start_date.month % 12 + 1, 1)
-                    seq.number_next_actual = last_value
+                seq_id = "%03d" % seq.id
-                    seq.number_next_actual = last_value
+                seq_id = "%03d_%03d" % (seq.sequence_id.id, seq.id)
-                    element.number_next_actual = last_value
+                seq_id = "%03d" % element.id
-                    element.number_next_actual = last_value
+                seq_id = "%03d_%03d" % (element.sequence_id.id, element.id)
-        resource.setrlimit(resource.RLIMIT_AS, (config['limit_memory_hard'], hard))
+            # Set process memory limit as an extra safeguard
-        gevent.spawn(self.watchdog)
+            gevent.spawn(self.watchdog)
-                    seq.number_next_actual = last_value
+                seq_id = "%03d" % seq.id
-                    seq.number_next_actual = last_value
+                seq_id = "%03d_%03d" % (seq.sequence_id.id, seq.id)
-    _description = 'Brand model of the vehicle'
+    _description = 'Brand of the vehicle'
-from openerp.tools.float_utils import float_round as round, float_is_zero as is_zero
+from openerp.tools.float_utils import float_round as round
-        if (self.amount_type == 'percent' and not price_include) or (self.amount_type == 'division' and self.price_include):
+        if (self.amount_type == 'percent' and not self.price_include) or (self.amount_type == 'division' and self.price_include):
-        if self.amount_type == 'percent' and price_include:
+        if self.amount_type == 'percent' and self.price_include:
-        if self.amount_type == 'division' and not price_include:
+        if self.amount_type == 'division' and not self.price_include:
-
+        taxes = []
-            sign = -1
+        base_values = self.env.context.get('base_values')
-            tax_amount = compute_amount(tax)
+            total_excluded, total_included, base = base_values
-            # the tax base of this tax will be 100.0.
+            if tax.price_include:
-            taxes_vals.append({
+            taxes.append({
-                'base': round(sign * tax_base, prec),
+                'amount': tax_amount,
-            'base': round(sign * base, prec),
+            'taxes': sorted(taxes, key=lambda k: k['sequence']),
-
+from openerp.tests.common import TransactionCase
-
+        self.group_tax.include_base_amount = True
-        )
+        self.assertEquals(res['total_excluded'], 200.0)
-        )
+        self.assertEquals(res['total_excluded'], 200.0)
-        )
+        res_division = self.division_tax.compute_all(200.0)
-        )
+        self.assertEquals(res_division['taxes'][0]['amount'], 20.0)
-        )
+        res_division = self.division_tax.compute_all(200.0)
-        )
+        self.assertEquals(res_division['taxes'][0]['amount'], 22.22)
-        )
+        self.assertEquals(res['taxes'][0]['amount'], 22.22)
-        )
+        self.assertEquals(res['total_included'], 231.0)
-        )
+        self.assertAlmostEqual(res['total_included'], 235.2941)
-        )
+from . import portal
-        """ Exported value is empty
+        """ Exported value is the name_get of the related object
-            [['']])
+            [[name]])
-            [['']])
+            # name_get result
-            [['', u'42']])
+            [[u'export.one2many.child:42', u'42']])
-            ])
+            [[
-            ])
+            [[ # exports sub-fields of very first o2m
-            [
+            [ # completely ignores name_get request
-            [[False, '']])
+            [[False, u'export.one2many.child.2:42']])
-            [['', False]])
+            [[u'export.one2many.child.1:43', False]])
-            [['', '']])
+            [[u'export.one2many.child.1:43', u'export.one2many.child.2:42']])
-            [['']])
+            # name_get result
-            [['', u'42']])
+            [[u'export.many2many.other:42', u'42']])
-            ])
+            [[ # FIXME: hardcoded comma, import uses config.csv_internal_sep
-                            lines += lines2[1:]
+                            # check value of current field
-    @queryCount(admin=20, demo=30)
+    @queryCount(admin=20, demo=31)
-    @queryCount(admin=19, demo=29)
+    @queryCount(admin=20, demo=30)
-    @queryCount(admin=37, demo=53)
+    @queryCount(admin=38, demo=54)
-                })
+                if picking.partner_id.id != move.partner_id.id or picking.origin != move.origin:
-             'and not available when managing activities for other models.')
+             ' and not available when managing activities for other models.')
-        message = mail_channel.sudo(request_uid).with_context(mail_create_nosubscribe=True).message_post(author_id=author_id, email_from=False, body=message_content, message_type='comment', subtype='mail.mt_comment', content_subtype='plaintext', **kwargs)
+        mail_channel = request.env["mail.channel"].sudo().search([('uuid', '=', uuid)], limit=1)
-        return channel.sudo(request_uid).channel_fetch_message(last_id, limit)
+        channel = request.env["mail.channel"].sudo().search([('uuid', '=', uuid)], limit=1)
-        return request.env["mail.channel"].browse(channel_id).channel_fetch_message(limit=limit)
+        return request.env["mail.channel"].browse(channel_id).sudo().channel_fetch_message(limit=limit)
-        message = mail_channel.sudo(request_uid).with_context(mail_create_nosubscribe=True).message_post(author_id=author_id, email_from=False, body=message_content, message_type='comment', subtype='mail.mt_comment', content_subtype='plaintext', **kwargs)
+        mail_channel = request.env["mail.channel"].sudo().search([('uuid', '=', uuid)], limit=1)
-        """ Try to process one cron job.
+    def _process_jobs(cls, db_name):
-        If a job was processed, returns True, otherwise returns False.
+        :raise BadVersion: if the version is different from the worker's
-                    _logger.warning('Skipping database %s because of modules to install/upgrade/remove.', db_name)
+                    raise BadModuleState()
-        except psycopg2.ProgrammingError, e:
+                    raise BadVersion()
-                while registry.ready:
+                if registry.ready:
-                            break
+                        odoo.addons.base.ir.ir_cron.ir_cron._acquire_job(db_name)
-                if cr.fetchone():
+                # Make sure the database has the same version as the code of
-        ], 'Category', required=True, help='Choose wheter the service refer to contracts, vehicle services or both')
+        ], 'Category', required=True, help='Choose whether the service refer to contracts, vehicle services or both')
-        help='Choose wheter the contract is still valid or not',
+        help='Choose whether the contract is still valid or not',
-    ], string="Service Tracking", default="no", help="On Sales order confirmation, this product can generate project and/or task. From thoses, you can track the service you are selling.")
+    ], string="Service Tracking", default="no",
-    user_id = fields.Many2one('res.users', string='Cron User', default=lambda self: self.env.user, required=True)
+    user_id = fields.Many2one('res.users', string='Scheduler User', default=lambda self: self.env.user, required=True)
-            return {'error': _('File is too big. File size cannot exceed 25MB')}
+        # check the size only when we upload a file.
-        if alias.alias_contact == 'employees' and self.ids:
+    def _alias_check_contact_on_record(self, record, message, message_dict, alias):
-        return super(MailAlias, self)._alias_check_contact(message, message_dict, alias)
+        return super(MailAlias, self)._alias_check_contact_on_record(record, message, message_dict, alias)
-            if not hasattr(self, "message_partner_ids") or not hasattr(self, "message_channel_ids"):
+        if alias.alias_contact == 'followers':
-            accepted_partner_ids = self.message_partner_ids | self.message_channel_ids.mapped('channel_partner_ids')
+            accepted_partner_ids = record.message_partner_ids | record.message_channel_ids.mapped('channel_partner_ids')
-            check_result = obj._alias_check_contact(message, message_dict, alias)
+            if hasattr(obj, '_alias_check_contact'):
-                    'error_mesage': _('incorrectly configured alias'),
+                    'error_message': _('incorrectly configured alias'),
-                    'error_mesage': _('restricted to followers'),
+                    'error_message': _('restricted to followers'),
-from odoo import api, fields, models
+from odoo import api, exceptions, fields, models, _
-        return activity
+        # already compute default values to be sure those are computed using the current user
-        res = super(MailActivity, self).write(values)
+        self._check_access('write')
-    name = fields.Char('Name', required=True)
+    name = fields.Char('Name', translate=True, required=True)
-        trackings = self.env['mail.tracking.value']
+        message_ids = message_tree.keys()
-        }) for tracking in trackings)
+        tracking_values = self.env['mail.tracking.value'].sudo().search([('mail_message_id', 'in', message_ids)])
-                    tracking_value_ids.append(tracking_tree[tracking_value.id])
+            for tracking_value_id in message_to_tracking.get(message_id, list()):
-        for tracking_value in message.tracking_value_ids:
+        for tracking_value in self.env['mail.tracking.value'].sudo().search([('mail_message_id', '=', message.id)]):
-            data['location_name'] = self.env['stock.location_id'].browse(vals.get('location_id')).name
+            data['location_name'] = self.env['stock.location'].browse(vals.get('location_id')).name
-            data['location_dest_name'] = self.env['stock.location_id'].browse(vals.get('location_dest_id')).name
+            data['location_dest_name'] = self.env['stock.location'].browse(vals.get('location_dest_id')).name
-                            WHERE action in ('sign_in', 'sign_out')
+                            WHERE a.action in ('sign_in', 'sign_out')
-
+    def test_increase_available_quantity_6(self):
-            for partner in records:
+            for partner in partners:
-    is_service = fields.Boolean("Is service", compute='_compute_is_service', store=True, help="Sales Order item should generate a task and/or a project, depending on the product settings.")
+    is_service = fields.Boolean("Is a Service", compute='_compute_is_service', store=True, help="Sales Order item should generate a task and/or a project, depending on the product settings.")
-from odoo import fields, models
+import re
-            'partner_assigned_id': user.partner_id.id,
+            'partner_assigned_id': user.commercial_partner_id.id,
-                self.parent_state = self.move_id.state
+        for record in self.filtered('move_id'):
-            if not picking:
+            if picking:
-
+
-        xml_transaction = self.env.ref(template).render(data)
+        xml_transaction = self.env.ref(template).render(data).decode()
-            response = werkzeug.utils.unescape(r.content)
+            response = werkzeug.utils.unescape(r.content.decode())
-        xml_transaction = soap_header + misc.escape_html(xml_transaction) + soap_footer
+        xml_transaction = soap_header + misc.html_escape(xml_transaction) + soap_footer
-            view_title = '%s %s' % (_('View'), model_name)
+            view_title = _('View %s') % model_name
-        return request.website.is_publisher() and request.render('website.page_404', {'path': req_page[1:]}) or False
+        page404 = 'website.%s' % (request.website.is_publisher() and 'page_404' or '404')
-        self.ssh('net start %s' % nt_service_name)
+        self.ssh('netsh advfirewall set publicprofile state off')
-        if not o.no_testing:
+        if not o.no_testing and not (o.no_debian and o.no_rpm and o.no_tarball):
-                    incl_fixed_amount += tax.amount
+                    incl_fixed_amount += quantity * tax.amount
-    @api.model
+    @api.multi
-                raise ValidationError(_('You cannot have a receivable/payable account that is not reconciliable. (account code: %s)') % account.code)
+                raise ValidationError(_('You cannot have a receivable/payable account that is not reconcilable. (account code: %s)') % account.code)
-             "Batch Deposit: Encash several customer checks at once by generating a batch deposit to submit to your bank. When encoding the bank statement in Odoo,you are suggested to reconcile the transaction with the batch deposit. Enable this option from the settings.")
+             "Batch Deposit: Encase several customer checks at once by generating a batch deposit to submit to your bank. When encoding the bank statement in Odoo,you are suggested to reconcile the transaction with the batch deposit. Enable this option from the settings.")
-        help='Account used as counterpart for the journal entry, for taxes exigible based on payments.')
+        help='Account used as counterpart for the journal entry, for taxes eligible based on payments.')
-        "Batch Deposit: Encash several customer checks at once by generating a batch deposit to submit to your bank. When encoding the bank statement in Odoo, you are suggested to reconcile the transaction with the batch deposit.To enable batch deposit,module account_batch_deposit must be installed.\n"\
+        "Batch Deposit: Encase several customer checks at once by generating a batch deposit to submit to your bank. When encoding the bank statement in Odoo, you are suggested to reconcile the transaction with the batch deposit.To enable batch deposit,module account_batch_deposit must be installed.\n"\
-            raise UserError(_("Programmation error: wizard action executed without active_ids in context."))
+            raise UserError(_("Programming error: wizard action executed without active_ids in context."))
-        help='Account used as counterpart for the journal entry, for taxes exigible based on payments.')
+        help='Account used as counterpart for the journal entry, for taxes eligible based on payments.')
-        help="Apply only if delivery or invocing country match the group.")
+        help="Apply only if delivery or invoicing country match the group.")
-                raise UserError(_("No miscellanous journal could be found. Please create one before proceeding."))
+                raise UserError(_("No miscellaneous journal could be found. Please create one before proceeding."))
-    @api.model
+    @api.multi
-    :param str description:
+    :param description: a description of the purpose of the charge,
-    used_in_bom_count = fields.Integer('# BoM Where Used', compute='_compute_used_in_bom_count')
+    used_in_bom_count = fields.Integer('# of BoM Where is Used', compute='_compute_used_in_bom_count')
-            if move.move_dest_id:
+            if move.move_dest_id and move.move_dest_id.state not in ('done', 'cancel'):
-from openerp.tools.float_utils import float_round as round
+from openerp.tools.float_utils import float_round as round, float_is_zero as is_zero
-        base = round(price_unit * quantity, prec)
+            new_base = (base_amount - fixed_amount) / (1.0 + percent_amount / 100.0)
-        # \/  ...  |   ..   |    ..    |
+        # \/  ...   |   ..   |    ..    |
-        for tax in taxes:
+
-            tax_amount = tax.with_context(force_price_include=False)._compute_amount(base, price_unit, quantity, product, partner)
+            #
-                (5.79, 1.21),  # |  3  |    21% |   t  |     t
+                (5.79, 1.21),     # |  3  |    21% |   t  |     t
-                (110.0, 11.0),    # |  3  |    10% |      |
+                (110.0, 11.0),    # |  2  |    10% |      |
-        compute='_compute_company_type', readonly=False)
+        compute='_compute_company_type', inverse='_write_company_type')
-        return request.render('auth_signup.signup', qcontext)
+        response = request.render('auth_signup.signup', qcontext)
-    def action_confirm(self):
+    def _action_confirm(self):
-            self.action_done()
+    def action_confirm(self):
-        result = super(SaleOrder, self).action_confirm()
+    def _action_confirm(self):
-        return result
+        # Check the consistency of the result packages; there should be an unique location across
-        'Inventory Unreserve Visible', compute='_compute_unreserve_visible',
+        'Allowed to Unreserve Inventory', compute='_compute_unreserve_visible',
-        'Inventory Post Visible', compute='_compute_post_visible',
+        'Allowed to Post Inventory', compute='_compute_post_visible',
-    is_installed_sale = fields.Boolean()
+    is_installed_sale = fields.Boolean(string="Is the Sale Module Installed")
-            if _is_studio_custom(path):
+            if (unmet_dependencies == set(['web_studio']) and
-        """ Exported value is the name_get of the related object
+        """ Exported value is empty
-            [[name]])
+            [['']])
-            [[u'export.one2many.child:42']])
+            [['']])
-            [[u'export.one2many.child:42', u'42']])
+            [['', u'42']])
-            ]])
+            [
-            ]])
+            [
-            [ # completely ignores name_get request
+            [
-            [[False, u'export.one2many.child.2:42']])
+            [[False, '']])
-            [[u'export.one2many.child.1:43', False]])
+            [['', False]])
-            [[u'export.one2many.child.1:43', u'export.one2many.child.2:42']])
+            [['', '']])
-            [[u'export.many2many.other:42']])
+            [['']])
-            [[u'export.many2many.other:42', u'42']])
+            [['', u'42']])
-            ]])
+            [
-                                lines += lines2[1:]
+                            # append the other lines at the end
-            ('datetime', '<=', date or fields.Datetime.now())], limit=1)
+            ('datetime', '<=', date or fields.Datetime.now())], order='datetime desc,id desc', limit=1)
-    with open(config["translate_out"], "w") as buf:
+    with open(config["translate_out"], "wb") as buf:
-BASE_SCOPE = {
+
-}
+    'undefined': jsdoc.LiteralDoc({'name': u'undefined', 'value': None}),
-        self._namemap = {}
+        self._namemap = self._empty(mapping)
-        }
+        d = self._empty(self._namemap)
-                ('google_internal_event_id', 'in', all_event_from_google.keys())
+                ('google_internal_event_id', 'in', list(all_event_from_google))
-                qcontext['error'] = str(e)
+                qcontext['error'] = e.message or e.name
-            raise UserError(_("You cannot have two inventory adjustements in state 'in Progess' with the same product"
+            raise UserError(_("You cannot have two inventory adjustements in state 'in Progress' with the same product"
-    _description = 'Last Seen Many2many'
+    _description = 'Listeners of a Channel'
-    todo_request_count_unscheduled = fields.Integer(compute='_compute_todo_requests')
+    todo_request_ids = fields.One2many('maintenance.request', string="Requests", copy=False, compute='_compute_todo_requests')
-    next_departure = fields.Datetime(compute="_compute_next_departure", string='Next Departure')
+    next_departure = fields.Datetime(compute="_compute_next_departure", string='Scheduled date')
-    move_dest_ids = fields.One2many('stock.move', 'created_production_id')
+    move_dest_ids = fields.One2many('stock.move', 'created_production_id',
-        help='')  # TDE: some string / help ?
+        string='Consumed Disassembly Lines')
-        help='')  # TDE: some string / help ?
+        string='Processed Disassembly Lines')
-    is_produced = fields.Boolean(compute='_compute_is_produced')
+    is_produced = fields.Boolean(string="Has Been Produced",
-        'Is Current User Working', compute='_compute_is_user_working',
+        'Is the Current User Working', compute='_compute_is_user_working',
-        'mrp.unbuild', 'Unbuild Order')
+        'mrp.unbuild', 'Disassembly Order')
-        'mrp.unbuild', 'Consume Unbuild Order')
+        'mrp.unbuild', 'Consumed Disassembly Order')
-    count_mo_late = fields.Integer(compute='_get_mo_count')
+    count_mo_todo = fields.Integer(string="Number of Manufacturing Orders to Process",
-            raise UserError(_('You should at least produce some quantity'))
+            raise UserError(_("The production order for '%s' has no quantity specified") % self.product_id.display_name)
-        help="Automatically modify the kanban state when the customer replies to the feedback for this stage.\n"
+        help="Automatically modify the kanban state when the customer replies to the feedback request for this stage.\n"
-            'supplier_wh_id': supplier_warehouse.id}
+            'supplier_wh_id': supplier_warehouse.id,
-                'warehouse_id': self.id}
+                'warehouse_id': self.id,
-        website = request and request.website or None
+        website = request and hasattr(request, 'website') and request.website or None
-                website = self.search([], limit=1)
+                # In the weird case we are coming from the backend (https://github.com/odoo/odoo/issues/20245)
-from odoo.tools.misc import mute_logger
+from odoo.tools.misc import mute_logger, ustr
-        body = r.read().decode('utf-8')
+        body = ustr(r.content)
-    "installable": True
+    "installable": True,
-    html = re.sub(r'(</?)\W*(\w+)([ >])',
+    html = re.sub(r'(</?)(\w+)([ >])',
-                    price_unit = self.env['account.tax']._fix_tax_included_price_company(seller.price, procurement.purchase_line_id.product_id.supplier_taxes_id, procurement.purchase_line_id.taxes_id, self.company_id) if seller else 0.0
+                    price_unit = self.env['account.tax']._fix_tax_included_price_company(seller.price, procurement.purchase_line_id.product_id.supplier_taxes_id, procurement.purchase_line_id.taxes_id, procurement.company_id) if seller else 0.0
-                amount_currency = abs(line.amount_currency)
+                amount = debit - credit
-        })
+        tx = tx._check_or_create_sale_tx(order, acquirer, payment_token=token, tx_type=tx_type)
-        })
+        tx = tx._check_or_create_sale_tx(order, token.acquirer_id, payment_token=token, tx_type=tx_type)
-        return tx.render_sale_button(order, '/quote/%s/%s' % (order_id, token) if token else '/quote/%s' % order_id,
+        return tx.render_sale_button(order, '/quote/%s/%s' % (order_id, access_token) if access_token else '/quote/%s' % order_id,
-    def invoice_validate(self):
+    def _check_invoice_reference(self):
-        if line.state == 'sale':
+        if line.order_id.state == 'sale':
-            invoice.message_post(body=_("Invoice sent"))
+            if not invoice.sent:
-        invoice_sudo = request.env['account.invoice'].sudo().browse(invoice_id)
+        invoice_sudo = request.env['account.invoice'].sudo().browse(invoice_id).exists()
-        order_sudo = request.env['sale.order'].sudo().browse(order_id)
+        order_sudo = request.env['sale.order'].sudo().browse(order_id).exists()
-
+from odoo.addons.portal.controllers.portal import _build_url_w_params
-            return request.redirect('%s?%s' % (error_url, url_encode(params)))
+            return request.redirect(_build_url_w_params(error_url, params))
-            return request.redirect('%s?%s' % (error_url, url_encode(params)))
+            return request.redirect(_build_url_w_params(error_url, params))
-            return request.redirect('%s?%s' % (error_url, url_encode(params)))
+            return request.redirect(_build_url_w_params(error_url, params))
-        return request.redirect('%s?%s' % (success_url, url_encode(params)))
+        return request.redirect(_build_url_w_params(success_url, params))
-
+from odoo.addons.portal.controllers.portal import _build_url_w_params
-            return request.redirect('%s?%s' % (error_url, url_encode(params)))
+            return request.redirect(_build_url_w_params(error_url, params))
-            return request.redirect('%s?%s' % (error_url, url_encode(params)))
+            return request.redirect(_build_url_w_params(error_url, params))
-            return request.redirect('%s?%s' % (error_url, url_encode(params)))
+            return request.redirect(_build_url_w_params(error_url, params))
-        return request.redirect('%s?%s' % (success_url, url_encode(params)))
+        return request.redirect(_build_url_w_params(success_url, params))
-from odoo.addons.account.controllers.portal import CustomerPortal
+from odoo.addons.account.controllers.portal import PortalAccount
-class CustomerPortal(CustomerPortal):
+class PortalAccount(PortalAccount):
-        values = super(CustomerPortal, self)._invoice_get_page_view_values(invoice, access_token, **kwargs)
+        values = super(PortalAccount, self)._invoice_get_page_view_values(invoice, access_token, **kwargs)
-        mod_names = [mod.name for mod in self if mod.state in ('installed', 'to install', 'to upgrade')]
+
-        help="""Will determine if the next work order will be scheduled after the previous one or after the first Quantity To Process of the previous one.""",
+        help="Set 'no' to schedule the next work order after the previous one. Set 'yes' to produce after the quantity set in 'Quantity To Process' has been produced.",
-        # negative discounts (= surcharge) are included in the display price (= unit price)
+        context_partner = dict(self.env.context, partner_id=self.order_id.partner_id.id, date=self.order_id.date_order)
-                # new_list_price is in company's currency while price in pricelist currency
+            if self.order_id.pricelist_id.currency_id.id != currency_id:
-                vals['message_follower_ids'] += self.env['mail.followers']._add_follower_command(self._name, [], {partner.id: None}, {})[0]
+        self._create_set_followers(vals)
-            'Balance initiale PL' AS EcritureNum,
+            'OUVERTURE/' || %s AS EcritureNum,
-            sql_query, (formatted_date_from, formatted_date_from, formatted_date_from, self.date_from, company.id))
+            sql_query, (formatted_date_year, formatted_date_from, formatted_date_from, formatted_date_from, self.date_from, company.id))
-            'Balance initiale ' || MIN(aa.name) AS EcritureNum,
+            'OUVERTURE/' || %s AS EcritureNum,
-            sql_query, (formatted_date_from, formatted_date_from, formatted_date_from, self.date_from, company.id))
+            sql_query, (formatted_date_year, formatted_date_from, formatted_date_from, formatted_date_from, self.date_from, company.id))
-            'currency': request.env.user.company_id.currency_id,
+            'currency': currency,
-        dashboard_values['money_amount']['to_invoice'] = sum([sol.price_unit * sol.qty_to_invoice for sol in so_lines]) + sum([i.price_unit * i.quantity for i in invoice_lines.filtered(lambda line: line.invoice_id.state == 'draft')])
+        dashboard_values['money_amount']['invoiced'] = sum([inv_line.currency_id.with_context(date=inv_line.invoice_id.date_invoice).compute(inv_line.price_unit * inv_line.quantity, currency) for inv_line in invoice_lines.filtered(lambda line: line.invoice_id.state in ['open', 'paid'])])
-    def payment_transaction_token(self, acquirer_id, order_id, save_token=False,access_token=None):
+    def payment_transaction_token(self, acquirer_id, order_id, save_token=False,access_token=None, **kwargs):
-        return datetime.now() - timedelta(weeks=number_of_week)
+        return datetime.now() - timedelta(weeks=int(number_of_week))
-                                  help="This is a name that helps you keep track of your different campaign efforts, i.e. Fall_Drive, Christmas_Special")
+                                  help="This is a name that helps you keep track of your different campaign efforts, e.g. Fall_Drive, Christmas_Special")
-                                help="This is the source of the link, i.e. Search Engine, another domain, or name of email list")
+                                help="This is the source of the link, e.g. Search Engine, another domain, or name of email list")
-                                help="This is the method of delivery, i.e. Postcard, Email, or Banner Ad", oldname='channel_id')
+                                help="This is the method of delivery, e.g. Postcard, Email, or Banner Ad", oldname='channel_id')
-            ret_line['amount_currency_str'] = amount_currency_str
+            
-            ret_line['total_amount_currency_str'] = total_amount_currency_str
+            ret_line['amount_str'] = formatLang(self.env, abs(amount), currency_obj=target_currency)
-            unlink_move_lots = move.move_lot_ids.filtered(lambda x : (x.quantity_done == 0) and not x.workorder_id)
+            unlink_move_lots = move.move_lot_ids.filtered(lambda x : (x.quantity_done == 0) and x.done_wo)
-
+    def _get_tax_cash_basis_base_account(self, line, tax):
-                                'account_id': line.account_id.id,
+                                'account_id': account_id.id,
-                                'account_id': line.account_id.id,
+                                'account_id': account_id.id,
-    'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet': ('xlsx', xlsx, 'xlrd >= 0.8'),
+    'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet': ('xlsx', xlsx, 'xlrd >= 1.0.0'),
-            {'tag': 'xls', 'label': 'Excel', 'error': None if xlwt else "XLWT required"},
+            {'tag': 'xls', 'label': 'Excel', 'error': None if xlwt else "XLWT 1.3.0 required"},
-                })
+                response = request.render(
-                    partner_id.email
+                    partner.email
-            to_text=odoo.tools.pycompat.to_text,
+            to_text=pycompat.to_text,
-                'date_maturity': self.date_due
+                'date_maturity': self.date_due,
-
+            # Create a payment to allow the reconciliation when pay_now = 'pay_now'.
-                tools.Reverse(record[name]) if desc else record[name]
+            # first extract the values for each key column (ids need special treatment)
-        action['domain'] = ['|', ('product_id', 'in', [self.ids]), '&', ('product_id', '=', False), ('product_tmpl_id', 'in', template_ids)]
+        action['domain'] = ['|', ('product_id', 'in', self.ids), '&', ('product_id', '=', False), ('product_tmpl_id', 'in', template_ids)]
-                                  help="This is a name that helps you keep track of your different campaign efforts Ex: Fall_Drive, Christmas_Special")
+                                  help="This is a name that helps you keep track of your different campaign efforts, i.e. Fall_Drive, Christmas_Special")
-                                help="This is the source of the link Ex:Search Engine, another domain,or name of email list")
+                                help="This is the source of the link, i.e. Search Engine, another domain, or name of email list")
-                                help="This is the method of delivery.Ex: Postcard, Email, or Banner Ad", oldname='channel_id')
+                                help="This is the method of delivery, i.e. Postcard, Email, or Banner Ad", oldname='channel_id')
-            self.price = _("%s %% discount and %s surcharge") % (abs(self.price_discount), self.price_surcharge)
+            self.price = _("%s %% discount and %s surcharge") % (self.price_discount, self.price_surcharge)
-        price, rule_id = self.order_id.pricelist_id.get_product_price_rule(self.product_id, self.product_uom_qty or 1.0, self.order_id.partner_id)
+        final_price, rule_id = self.order_id.pricelist_id.get_product_price_rule(self.product_id, self.product_uom_qty or 1.0, self.order_id.partner_id)
-            return price
+        if pricelist_item.base == 'pricelist':
-            return from_currency.compute(product_price, self.order_id.pricelist_id.currency_id)
+            base_price = product[pricelist_item.base] if pricelist_item else product.lst_price
-        sale_order_lines = self.filtered(lambda move: move.procurement_id.sale_line_id and (not move.product_id.can_be_expensed or move.product_id.expense_policy=='no')).mapped('procurement_id.sale_line_id')
+        sale_order_lines = self.filtered(lambda move: move.procurement_id.sale_line_id and move.product_id.expense_policy == 'no').mapped('procurement_id.sale_line_id')
-        'Product Name', related='product_id.name', store=True)
+        'Product Name', related='product_id.name', store=True, readonly=True)
-            'product_id', 'price_unit', 'product_packaging',
+            'product_id', 'price_unit', 'product_packaging', 'procure_method',
-            move.restrict_partner_id.id, move.scrapped, move.origin_returned_move_id.id
+            move.product_id.id, move.price_unit, move.product_packaging.id, move.procure_method, 
-        sale_order_lines = self.filtered(lambda move: move.procurement_id.sale_line_id and move.product_id.expense_policy == 'no').mapped('procurement_id.sale_line_id')
+        sale_order_lines = self.filtered(lambda move: move.procurement_id.sale_line_id and (not move.product_id.can_be_expensed or move.product_id.expense_policy=='no')).mapped('procurement_id.sale_line_id')
-            Model = self.env[action_rule.model]
+            Model = self.env.get(action_rule.model)
-            raise PoolError('This connection does not below to the pool')
+            raise PoolError('This connection does not belong to the pool')
-        for partner in self.filtered(lambda partner: partner.country_id == self.env.ref('base.co') and
+        for partner in self.filtered(lambda partner: partner.vat and partner.country_id == self.env.ref('base.co') and
-             "numbers coming from the company's country are nationaly formatted."
+        help="Always encode phone numbers using international format. Otherwise "
-            if product.categ_id.property_valuation != 'manual_periodic' and accounts['stock_input']:
+            if accounts['stock_input']:
-            if tax.price_include:
+            if self._context.get('force_price_include', tax.price_include):
-            tax_amount = tax.with_context(force_price_include=False)._compute_amount(base, price_unit, quantity, product, partner)
+            # N.B: don't use the with_context if force_price_include already False in context
-            st_line.process_reconciliation(datum.get('counterpart_aml_dicts', []), payment_aml_rec, datum.get('new_aml_dicts', []))
+            st_line.with_context(ctx).process_reconciliation(datum.get('counterpart_aml_dicts', []), payment_aml_rec, datum.get('new_aml_dicts', []))
-            res = taxes.with_context(round=True).compute_all(amount,
+            res = taxes.with_context(dict(self._context, round=True)).compute_all(amount,
-    # As the packages are builded in the parent of the buildir, we move them back to build_dir
+    # As the packages are built in the parent of the buildir, we move them back to build_dir
-    op.add_option("", "--no-testing", action="store_true", help="don't test the builded packages")
+    op.add_option("", "--no-testing", action="store_true", help="don't test the built packages")
-        self.amount_tax = sum(line.amount for line in self.tax_line_ids)
+        self.amount_tax = sum(round_curr(line.amount) for line in self.tax_line_ids)
-                'purchase_tax_id': self.default_purchase_tax_id.id,
+            wizard.onchange_chart_template_id()
-from odoo.exceptions import UserError
+from odoo.exceptions import UserError, ValidationError
-
+    def test_00b_workorder_process(self):
-                    quantity = 1.0
+                    quantity = 1.0 if float_is_zero(quantity, precision_digits=precision) else 0.0
-                    quantity = wo.qty_production - wo.qty_produced
+                if float_is_zero(quantity, precision_digits=precision):
-                if wo.move_raw_ids.filtered(lambda x: x.product_id.tracking != 'none') and not wo.active_move_lot_ids:
+                if quantity > 0 and wo.move_raw_ids.filtered(lambda x: x.product_id.tracking != 'none') and not wo.active_move_lot_ids:
-                for movelot in move.move_lot_ids:
+                for movelot in move.active_move_lot_ids:
-            arguments['body'] = env['ir.qweb'].render(credit_template).decode("utf-8")
+            arguments['body'] = pycompat.to_text(env['ir.qweb'].render(credit_template))
-        full_message = _('Routing mail with Message-Id %s: route %s: %s') % (message_id, route, error_message)
+        short_message = _("Mailbox unavailable - %s") % error_message
-            _logger.info(full_message + warn_suffix and '; %s' % warn_suffix or '')
+            # sender should not see private diagnostics info, just the error
-                message = message.encode('utf-8')
+            # message_from_string works on a native str
-            arguments['body'] = env['ir.qweb'].render(credit_template)
+            arguments['body'] = env['ir.qweb'].render(credit_template).decode("utf-8")
-            return {}
+            return value
-
+                        values['warning'] = self.warning_stock
-        'stock.move.line', compute='_compute_lines', inverse='_inverse_lines',
+        'stock.move.line', compute='_compute_lines', inverse='_inverse_lines', string="Finished Product"
-            produced = sum(production.move_finished_ids.mapped('quantity_done'))
+            produced = sum(production.move_finished_ids.filtered(lambda m: m.product_id == production.product_id).mapped('quantity_done'))
-                return login_and_redirect(*credentials, redirect_url=url)
+                resp = login_and_redirect(*credentials, redirect_url=url)
-            return round((base_amount - fixed_amount) / (1.0 + percent_amount / 100.0), prec)
+            return (base_amount - fixed_amount) / (1.0 + percent_amount / 100.0)
-                'base': sign * tax_base,
+                'base': round(sign * tax_base, prec),
-            'base': sign * base,
+            'base': round(sign * base, prec),
-                    'error_mesage': _('restricted to channel members'),
+                    'error_message': _('restricted to channel members'),
-                attributes |= value.attribute_id
+                if value.attribute_id.create_variant:
-        company_name = user.company_id.name
+        company = user.company_id;
-        return [('id', op, (req, (self._uid)))]
+        return [('id', op, (req, (self._uid, )))]
-                	rec._onchange_team_type()
+                    rec._onchange_team_type()
-    cr.after("commit", partial(update_dashboard_graph_model, cr.dbname))
+    cr.after("commit", partial(update_dashboard_graph_model, cr.dbname))
-	sale_order_id = fields.Many2one('sale.order', string='Sale Order')
+    _inherit = 'procurement.group'
-	"0424:ec00",	# Standard Microsystem Corp. Other Builtin Ethernet module
+    "0424:9514",    # Standard Microsystem Corp. Builtin Ethernet module
-            	resp+= "<div class='device' data-device='"+device+"'>"+device_name+"</div>\n"
+                resp+= "<div class='device' data-device='"+device+"'>"+device_name+"</div>\n"
-    	super(SaleOrderLine, lines)._compute_qty_delivered_updateable()
+        self.mapped('product_id')
-            todo.ensure_one_open_todo()
+            self.ensure_one_open_todo()
-                todo.ensure_one_open_todo()
+            self.ensure_one_open_todo()
-        open_todo = self.search(['&', ('state', '=', 'open'), ('id', '!=', self.id)])
+        open_todo = self.search([('state', '=', 'open')], order='sequence asc, id desc', offset=1)
-        timezone = tools.ustr(timezone).encode('utf-8')  # make safe for str{p,f}time()
+        timezone = self._context.get('tz') or self.env.user.partner_id.tz or 'UTC'
-        format_date, format_time = self.with_context(tz=timezone)._get_date_formats()
+        format_date, format_time = self._get_date_formats()
-        date_deadline = fields.Datetime.context_timestamp(self.with_context(tz=timezone), fields.Datetime.from_string(stop))
+        self_tz = self.with_context(tz=timezone)
-        time_str = date.strftime(format_time).decode('utf-8')
+        to_text = pycompat.to_text
-            duration_time = duration.strftime(format_time).decode('utf-8')
+            duration_time = to_text(duration.strftime(format_time))
-            dd_time = date_deadline.strftime(format_time).decode('utf-8')
+            dd_date = to_text(date_deadline.strftime(format_date))
-        )
+        TX = request.env['payment.transaction']
-            'phone': tx_values['partner_phone'],
+            'address_line1': tx_values.get('partner_address'),
-            'metadata[reference]': self.reference
+            'metadata[reference]': self.reference,
-            charge_params['receipt_email'] = email
+            charge_params['receipt_email'] = email.strip()
-            _logger.error(error_msg)
+            stripe_error = data.get('error', {}).get('message', '')
-                    'source': token['id']
+                    'source': token['id'],
-                if line.invoice_id.date_invoice > date_from and line.invoice_id.date_invoice < date_to:
+                if line.invoice_id.date_invoice > (date_from or '0000-00-00') and line.invoice_id.date_invoice < (date_to or '0000-00-00'):
-            if date_from < (invoice_line.invoice_id.date_invoice or '0000-00-00') < date_to:
+            date_from = invoice_line.product_id.membership_date_from
-                    if mline.date_to >= today and mline.date_from <= today:
+                    if (mline.date_to or '0000-00-00') >= today and (mline.date_from or '0000-00-00') <= today:
-                        if mline.date_from < today and mline.date_to < today and mline.date_from <= mline.date_to and mline.account_invoice_line and mline.account_invoice_line.invoice_id.state == 'paid':
+                        if (mline.date_from or '0000-00-00') < today and (mline.date_to or '0000-00-00') < today and (mline.date_from or '0000-00-00') <= (mline.date_to or '0000-00-00') and mline.account_invoice_line and mline.account_invoice_line.invoice_id.state == 'paid':
-                line.qty_delivered_updateable = False
+        # prefetch field before filtering
-            pass
+        if str[0] in ['-', '+']:
-            amount_currency_str = formatLang(self.env, amount_currency_str, currency_obj=statement_currency)
+            amount_currency_str = formatLang(self.env, abs(amount_currency), currency_obj=statement_currency)
-                'currency_id': (line.currency_id and line.amount_currency) and line.currency_id.id or False,
+                'currency_id': line_currency.id,
-            line_currency = (line.currency_id and line.amount_currency) and line.currency_id or company_currency
+            amount_currency = debit - credit
-                amount_currency_str = formatLang(self.env, target_currency.compute(abs(actual_debit or actual_credit), line_currency), currency_obj=line_currency)
+                amount_currency = target_currency.compute(total_amount, line_currency)
-    qty = fields.Float('Done', default=1.0)
+    qty = fields.Float('Done', default=1.0, digits=dp.get_precision('Product Unit of Measure'))
-    qty_todo = fields.Float('To Do', default=0.0)
+    qty_todo = fields.Float('To Do', default=0.0, digits=dp.get_precision('Product Unit of Measure'))
-                    if float_compare(operation.qty_done, operation.product_qty, precision_rounding=operation.product_uom_id.rounding) >= 0:
+                    if float_compare(operation.qty_done, operation.product_uom_qty, precision_rounding=operation.product_uom_id.rounding) >= 0:
-                            operation.product_qty - operation.qty_done,
+                            operation.product_uom_qty - operation.qty_done,
-            return from_currency.compute(pricelist_item and product[pricelist_item.base] or product.lst_price, self.order_id.pricelist_id.currency_id)
+            product_price = product[pricelist_item.base] if (pricelist_item and pricelist_item.base != 'pricelist') else product.lst_price
-            domain += [('is_visible', '=', True)]
+        if not request.website.is_publisher():
-        mypage = request.env['website.page'].search(domain, limit=1)
+        mypage = pages[0] if pages else False
-
+        so.order_line._compute_product_updatable()
-
+        so.order_line._compute_product_updatable()
-            average_price_unit = (average_price_unit * (qty_delivered - qty_to_consider) + move.price_unit * qty_to_consider) / qty_delivered
+            average_price_unit = (average_price_unit * (qty_delivered - qty_to_consider) + (-1 * move.price_unit) * qty_to_consider) / qty_delivered
-        return res
+        return res
-                   move.restrict_partner_id.id, move.scrapped, move.origin_returned_move_id.id
+        distinct_fields = self._prepare_merge_moves_distinct_fields()
-            for k, g in groupby(sorted(picking.move_lines, key=_keys_sorted), key=itemgetter(*distinct_fields)):
+            for k, g in groupby(sorted(picking.move_lines, key=self._prepare_merge_move_sort_method), key=itemgetter(*distinct_fields)):
-            else:
+            elif name == 'UserError':
-            return werkzeug.utils.redirect(record_action['url'])
+            if record_action['type'] == 'ir.actions.act_url':
-        retag = '"%s"' % hashlib.md5(last_update).hexdigest()
+        retag = '"%s"' % hashlib.md5(content).hexdigest()
-        #'test/stock_landed_costs_rounding.yml',
+        '../account/test/account_minimal_test.xml',
-                line._create_accounting_entries(move, line.move_id.product_qty - line.move_id.remaining_qty)
+                new_landed_cost_value = line.move_id.landed_cost_value + line.additional_landed_cost
-            return from_currency.compute(product.lst_price, self.order_id.pricelist_id.currency_id)
+            return from_currency.compute(pricelist_item and product[pricelist_item.base] or product.lst_price, self.order_id.pricelist_id.currency_id)
-            return from_currency.compute(product[pricelist_item.base].lst_price, self.order_id.pricelist_id.currency_id)
+            return from_currency.compute(product.lst_price, self.order_id.pricelist_id.currency_id)
-            return from_currency.compute(product[pricelist_item.base], self.order_id.pricelist_id.currency_id)
+            return from_currency.compute(product[pricelist_item.base].lst_price, self.order_id.pricelist_id.currency_id)
-from odoo.tools import pycompat
+from odoo.tools import pycompat, misc
-        with open(fname, 'r') as f:
+        with misc.file_open('website_forum/data/forum_default_faq.html', 'r') as f:
-        _tz_get, string='Timezone', default=lambda self: self._context.get('tz', self.env.user.tz),
+        _tz_get, string='Timezone', default=lambda self: self._context.get('tz', self.env.user.tz or 'UTC'),
-            for move in line.move_ids:
+            for move in line.move_ids.filtered(lambda r: r.state != 'cancel'):
-import zlib
+import werkzeug.wsgi
-from odoo.tools.misc import str2bool, xlwt
+from odoo.tools.misc import str2bool, xlwt, file_open
-                      serialize_exception as _serialize_exception
+    serialize_exception as _serialize_exception, Response
-                break
+                return http.Response(
-                continue
+                _logger.debug("No moment locale for code %s", code)
-        return request.make_response(momentjs_locale, headers)
+        return request.make_response("", headers=[
-        new_move.action_confirm()
+        new_move = new_move.action_confirm()
-                    ids3 = map(lambda x:x[0], cr.fetchall())
+                    # if the o2m has a static domain we must respect it when unlinking
-        if 'type' in vals:
+        if any('type' in vals and vals['type'] != prod_tmpl.type for prod_tmpl in self):
-    mailing_model_id = fields.Many2one('ir.model', string='Recipients Model', domain="[('is_mail_thread', '=', True)]",
+    mailing_model_id = fields.Many2one('ir.model', string='Recipients Model', domain=[('model', 'in', MASS_MAILING_BUSINESS_MODELS)],
-                result = stdnum_vat.check_vies(partner.vat)
+                # Equivalent to stdnum_vat.check_vies(partner.vat).
-            dashboard_values['rates']['total'] += float_round(data.get('unit_amount') / dashboard_total_hours * 100, precision_rounding=hour_rounding)
+            dashboard_values['rates'][billable_type] = round(data.get('unit_amount') / dashboard_total_hours * 100, 2)
-                amount_field = 'balance' if not self.currency_id else 'amount_currency'
+                amount_field = 'balance' if (not self.currency_id or self.currency_id == self.company_id.currency_id) else 'amount_currency'
-            return from_currency.compute(product.lst_price, self.order_id.pricelist_id.currency_id)
+            return from_currency.compute(product[pricelist_item.base], self.order_id.pricelist_id.currency_id)
-            for line in order.lines.filtered(lambda l: l.product_id.type in ['product', 'consu'] and not float_is_zero(l.qty, precision_digits=l.product_id.uom_id.rounding)):
+            for line in order.lines.filtered(lambda l: l.product_id.type in ['product', 'consu'] and not float_is_zero(l.qty, precision_rounding=l.product_id.uom_id.rounding)):
-                record.case_mark_won()
+                record.action_set_won()
-                record.case_mark_lost()
+                record.action_set_lost()
-        with TemporaryFile('w+') as buf:
+        with TemporaryFile('w+b') as buf:
-            if fileobj.name.endswith('.po'):
+
-        help="Kit (Phantom): When processing a sales order for this product, the delivery order will contain the raw materials, instead of the finished product.")
+        ('phantom', 'Kit')], 'BoM Type',
-                if original and not original[0].lot_id:
+                if not original:
-                })
+                quantity_todo = produce_move.product_qty
-from odoo.tools import DEFAULT_SERVER_DATE_FORMAT
+from odoo.tools import DEFAULT_SERVER_DATETIME_FORMAT
-        return date_planned.strftime(DEFAULT_SERVER_DATE_FORMAT)
+        return date_planned.strftime(DEFAULT_SERVER_DATETIME_FORMAT)
-        if (self.amount_type == 'percent' and not self.price_include) or (self.amount_type == 'division' and self.price_include):
+        if (self.amount_type == 'percent' and not price_include) or (self.amount_type == 'division' and self.price_include):
-        if self.amount_type == 'percent' and self.price_include:
+        if self.amount_type == 'percent' and price_include:
-        if self.amount_type == 'division' and not self.price_include:
+        if self.amount_type == 'division' and not price_include:
-        taxes = []
+
-            total_excluded = total_included = base = round(price_unit * quantity, prec)
+        # 4) Iterate the taxes in the reversed sequence order to retrieve the initial base of the computation.
-            tax_amount = tax._compute_amount(base, price_unit, quantity, product, partner)
+            sign = 1
-            # Keep base amount used for the current tax
+            # Suppose:
-            taxes.append({
+            # The total_included amount is computed as the sum of total_excluded with all tax_amount
-                'base': tax_base,
+                'amount': sign * tax_amount,
-            'base': base,
+            'taxes': taxes_vals,
-from openerp.tools import float_compare
+
-        self.assertEquals(res['total_included'], 263.0)
+        self._check_compute_all_results(
-        self.assertEquals(res['taxes'][1]['amount'], 20.0)
+        self._check_compute_all_results(
-        self.assertEquals(res_percent['taxes'][0]['amount'], 20.0)
+        self._check_compute_all_results(
-        self.assertEquals(res_percent['taxes'][0]['amount'], 18.18)
+        self._check_compute_all_results(
-        self.assertEquals(res['taxes'][2]['amount'], 20.0)
+        self._check_compute_all_results(
-        self.assertEquals(res['total_included'], 231.0)
+        self._check_compute_all_results(
-        self.assertAlmostEqual(res['total_included'], 235.2941)
+        self._check_compute_all_results(
-    payment_id = fields.Many2one('account.payment', string="Originator Payment", help="Payment that created this entry")
+    payment_id = fields.Many2one('account.payment', string="Originator Payment", help="Payment that created this entry", copy=False)
-        inv_line.update(price_unit=line.price_unit, discount=line.discount)
+        inv_line.update(price_unit=line.price_unit, discount=line.discount, name=inv_name)
-            return werkzeug.utils.redirect("/forum/%s/question/%s?nocontent=1" % (slug(forum), post_parent and slug(post_parent)))
+            return request.render('website.http_error', {'status_code': _('Bad Request'), 'status_message': _('Question should not be empty.')})
-from odoo import api, fields, models
+from odoo import api, fields, models, _
-                price_unit = self.price_unit or self._get_price_unit()
+                price_unit = self._get_price_unit()
-            if mailing.mailing_model == 'mail.mass_mailing.contact':
+            if mailing.mailing_model == 'mail.mass_mailing.list':
-                    ('list_id', 'in', [mailing_list.id for mailing_list in mailing.contact_list_ids])
+                    ('list_ids', 'in', [mailing_list.id for mailing_list in mailing.contact_list_ids])
-            'res_id': expense_sheet.id,
+            'context': {
-        import_result = self.env[self.res_model].with_context(import_file=True).load(import_fields, data)
+
-    pass
+    toctree = None
-    end_point = get_endpoint(env)
+    endpoint = get_endpoint(env)
-        r = jsonrpc(end_point + '/iap/1/cancel', params=params)
+        r = jsonrpc(endpoint + '/iap/1/cancel', params=params)
-        r = jsonrpc(end_point + '/iap/1/capture', params=params) # noqa
+        r = jsonrpc(endpoint + '/iap/1/capture', params=params) # noqa
-                        move.move_dest_id.write({'state': 'confirmed'})
+                move._propagate_cancel()
-            new_move.write({'move_dest_id': new_move_prop})
+        self._propagate_split(new_move, qty)
-    if hasattr(e, 'args'):
+    if getattr(e, 'args', ()):
-            if rec and path.startswith(mp) and os.path.dirname(path) != mp:
+            dirname = os.path.join(os.path.dirname(path), '')
-        all_fields = self.env[self.res_model].fields_get()
+        all_fields = self.env[model].fields_get()
-
+            # Check if the field is in import_field and is a relational (followed by /)
-    module_auth_ldap = fields.Boolean("LDAP Authentification")
+    module_auth_ldap = fields.Boolean("LDAP Authentication")
-            job_name=employee.job_id.name or '',
+            job_id=job.id,
-        self.id = subprocess.check_output('docker ps -l -q', shell=True)
+        self.id = subprocess.check_output('docker ps -l -q', shell=True).strip().decode('ascii')
-        wheezy.system('pip install /opt/release/%s' % wheezy.release)
+        wheezy.system('pip3 install /opt/release/%s' % wheezy.release)
-        wheezy.system('su odoo -s /bin/bash -c "odoo --addons-path=/usr/local/lib/python2.7/dist-packages/odoo/addons -d mycompany &"')
+        wheezy.system('su odoo -s /bin/bash -c "odoo -d mycompany -i base --stop-after-init"')
-        self.icon_src = b'data:image/png;base64,' + self.favicon
+        self.icon_src = 'data:image/png;base64,' + self.favicon
-from odoo.addons.http_routing.models.ir_http import slugify
+from odoo.addons.http_routing.models.ir_http import slugify, _guess_mimetype
-
+        page_key = _('Page')
-                'link': page.url
+                'item': page.name,
-            'link': '#'
+            dependencies.setdefault(view_key, [])
-        menu_key = _('Menu')
+        menu_key = _('Menu')
-                'link': False
+                'link': '/web#id=%s&view_type=form&model=website.menu' % menu.id,
-                'link': p.website_url
+                'item': p.name,
-        page_key = self.get_unique_path(slugify(name))
+        page_key = slugify(name)
-        key = '%s.%s' % (template_module, page_key)
+        key = self.get_unique_key(page_key, template_module)
-        page = self.browse(int(data['id']))
+        if not url.startswith('/'):
-            url = slugify(url, max_length=200, path=True)
+            url = '/' + slugify(url, max_length=1024, path=True)
-            'key': 'website.' + slugify(data['name'], 50),
+            'key': page_key,
-    is_homepage = fields.Boolean(compute='_compute_homepage', string='Homepage')
+    is_homepage = fields.Boolean(compute='_compute_homepage', inverse='_set_homepage', string='Homepage')
-            'date_publish': data['date_publish'] or None
+            'date_publish': data['date_publish'] or None,
-                    if new_val['quantity']:
+                    # Make sure line still exists, it may have been deleted in super()_cartupdate because qty can be <= 0
-    payment_id = fields.Many2one('account.payment', string="Originator Payment", help="Payment that created this entry")
+    payment_id = fields.Many2one('account.payment', string="Originator Payment", help="Payment that created this entry", copy=False)
-version = '10.0'
+version = '11.0'
-release = '10.0'
+release = '11.0'
-        products = self.env['product.product'].search(self.get_product_domain())
+        Product = self.env['product.product'].sudo(self.compute_user_id.id)
-            all_partners_and_children[partner] = self.search([('id', 'child_of', partner.id)]).ids
+            all_partners_and_children[partner] = self.with_context(active_test=False).search([('id', 'child_of', partner.id)]).ids
-        string='Layout Sequence', store=True)
+    layout_category_sequence = fields.Integer(string='Layout Sequence')
-    #  Store is intentionally set in order to keep the "historic" order.
+    layout_category_sequence = fields.Integer(string='Layout Sequence')
-        '/jobs/country/<model("res.country"):country>/department/<model("hr.department"):department>',
+        '''/jobs/country/<model("res.country", "[(0, '=', 1)]"):country>''',
-        '/jobs/country/<model("res.country"):country>/department/<model("hr.department"):department>/office/<int:office_id>',
+        '''/jobs/country/<model("res.country", "[(0, '=', 1)]"):country>/office/<int:office_id>''',
-        content = self._compile_widget(el, el.attrib.pop('t-esc'), field_options, 'escape')
+        content = self._compile_widget(el, el.attrib.pop('t-esc'), field_options)
-            escaped
+            )
-        account_move_lines_to_reconcile.reconcile()
+        # DO NOT FORWARD-PORT! ONLY FOR v10
-    'depends': ['web_tour', 'crm', 'sale_timesheet', 'purchase', 'mrp', 'account_accountant'],
+    'depends': ['web_tour', 'crm', 'sale_timesheet', 'purchase', 'mrp', 'account'],
-    'depends': ['web_tour', 'crm', 'sale_timesheet', 'purchase', 'mrp', 'account'],
+    'depends': ['web_tour', 'crm', 'sale_timesheet', 'purchase', 'mrp', 'account_accountant'],
-        pricelist = self.env['website'].get_current_website().get_current_pricelist()
+        current_website = self.env['website'].get_current_website()
-            taxes = partner.property_account_position_id.map_tax(p.taxes_id)
+            taxes = partner.property_account_position_id.map_tax(p.taxes_id.sudo().filtered(lambda x: x.company_id == company_id))
-            record[self.name] = other[field.name]
+        # copy the cache of draft records into others' cache
-        page_key = self.get_unique_path(slugify(name, 50))
+        page_url = '/' + slugify(name, max_length=1024, path=True)
-            raise UserError(_("Unmet module dependencies: %s") % ', '.join(unmet_dependencies))
+            if _is_studio_custom(path):
-                if filename.endswith('.csv') and kind in ('init', 'init_xml'):
+                if ext == '.csv' and kind in ('init', 'init_xml'):
-                import odoo.modules as addons
+                import odoo.modules.module as module
-                    addons.module.ad_paths.append(module_dir)
+                    module.ad_paths.append(module_dir)
-                    addons.module.ad_paths.remove(module_dir)
+                    module.ad_paths.remove(module_dir)
-    lang = fields.Selection(_get_languages, string='Language', required=True)
+    lang = fields.Selection(_get_languages, string='Language', required=True,
-                            default=_default_language)
+
-        return csv.reader(io.TextIOWrapper(stream, encoding='utf-8'), **params)
+        return csv.reader(_reader(stream), **params)
-        return csv.writer(io.TextIOWrapper(stream, encoding='utf-8', line_buffering=True), **params)
+        return csv.writer(_writer(stream), **params)
-    'python': ('https://docs.python.org/2/', None),
+    'python': ('https://docs.python.org/3/', None),
-            taxes = expense.tax_ids.compute_all(expense.unit_amount, expense.currency_id, expense.quantity, expense.product_id)
+            taxes = expense.tax_ids.with_context(round=True).compute_all(expense.unit_amount, expense.currency_id, expense.quantity, expense.product_id)
-    todo[records._name].update(records._ids)
+    src, dst = records.env.cache, env.cache
-                        todo[field.comodel_name].update(value)
+        record = todo.pop()
-
+        raise e
-            ('partner_id', 'in', all_partner_ids), ('state', 'not in', ['draft', 'cancel']), ('company_id', '=', self.env.user.company_id.id),
+            ('partner_id', 'in', all_partner_ids), ('state', 'not in', ['draft', 'cancel']),
-                             WHERE msg.model = %s AND msg.res_id in %s AND
+                             WHERE msg.model = %s AND msg.res_id = ANY(%s) AND
-                         (partner_id, self._name, tuple(self.ids), partner_id,))
+                         (partner_id, self._name, list(self.ids), partner_id,))
-
+
-            if po.amount_total:
+            if self.env.context.get('show_total_amount') and po.amount_total:
-                'discount': line.discount,
+                'discount': 100 - ((100 - discount) * (100 - line.discount)/100),
-                         (partner_id, self._name, tuple(self.ids), partner_id,))
+                         (partner_id, self._name, tuple(self.ids) or (None,), partner_id,))
-    print "\nCLA SIGNED %s/%s (%.0f%%)" % (ok, ok+ko, ok*100.0/(ok+ko))
+    print('-'*60)
-        print i
+        print(i)
-    print "\nCLA MISSING %s/%s (%.0f%%)\n" % (ko, ok+ko, ko*100.0/(ok+ko))
+    print("\nCLA MISSING %s/%s (%.0f%%)\n" % (ko, ok+ko, ko*100.0/(ok+ko)))
-    print
+        print(i)
-    print "odoo:" + f % l
+    print("odoo:" + f % l)
-from . import jsdoc
+from .parser import jsdoc
-        print '    ' * self.level, text
+        print('    ' * self.level, text)
-        return self.members.items() or self['_members'] or []
+        return list(self.members.items()) or self['_members'] or []
-@attrs(slots=True)
+NOTHING = object()
-@attrs(slots=True)
+    __slots__ = ['id', 'comments']
-    post = attr(default=Factory(list))
+    __slots__ = ['dependencies', 'post']
-    name = attr()
+    def __init__(self, name):
-        name, comments = astuple(self.declaration)
+        name, comments = (self.declaration.id, self.declaration.comments)
-            _, comments = astuple(self.declaration)
+            comments = self.declaration.comments
-    if isinstance(obj, (unicode, bool, int, float)):
+    if isinstance(obj, (type(u''), bool, int, float)):
-            for k, v in self.attrs.iteritems()
+            for k, v in self.attrs.items()
-        assert isinstance(key, unicode), "%r is not a namespace key" % key
+        assert isinstance(key, type(u'')), "%r is not a namespace key" % key
-        print "unknown node", node.__class__.__name__
+        print("unknown node", node.__class__.__name__)
-        return filter(None, comments)
+        return [c for c in comments if c]
-    assert isWhiteSpace(' ')
+    assert isWhiteSpace(' ')
-            ('partner_id', 'in', all_partner_ids), ('state', 'not in', ['draft', 'cancel']), ('company_id', '=', self.env.user.company_id.id),
+            ('partner_id', 'in', all_partner_ids), ('state', 'not in', ['draft', 'cancel']),
-                         WHEN ai.type::text = ANY (ARRAY['out_refund'::character varying::text, 'in_invoice'::character varying::text])
+                         WHEN ai.type::text = ANY (ARRAY['in_refund'::character varying::text, 'in_invoice'::character varying::text])
-                    lines = comodel.browse([row[0] for row in comodel._cr.fetchall()])
+                    domain = self.domain(records) if callable(self.domain) else self.domain
-                        lines.unlink()
+                        comodel.search(domain).unlink()
-                        lines.write({inverse: False})
+                        comodel.search(domain).write({inverse: False})
-                    'communication': self.name or '',
+                    'communication': self._get_communication(payment_methods[0] if payment_methods else False),
-            web_base_url=self.env['ir.config_parameter'].sudo().get_param('web.base.url', default='')
+            web_base_url=self.env['ir.config_parameter'].sudo().get_param('web.base.url', default=''),
-            _logger.warning("The `vobject` Python module is not installed, so iCal file generation is unavailable. Use 'pip install vobject' to install it")
+            _logger.warning("The `vobject` Python module is not installed, so iCal file generation is unavailable. Please install the `vobject` Python module")
-                "verified. Try: pip install phonenumbers."
+                "verified. Please install the `phonenumbers` Python module."
-    psycogreen.gevent.patch_psycopg()
+
-                                              values={'self': production, 'origin': orderpoint.id},
+                                              values={'self': production, 'origin': orderpoint},
-    todo, done = set(records), set()
+    src = records.env
-                target._cache[name] = field.convert_to_cache(value, target, validate=False)
+        model_name = next(iter(todo))
-        self.is_locked = True
+        self.write({'is_locked': True})
-                             WHERE msg.model = %s AND msg.res_id in %s AND
+                             WHERE msg.model = %s AND msg.res_id = ANY(%s) AND
-                         (partner_id, self._name, tuple(self.ids), partner_id,))
+                         (partner_id, self._name, list(self.ids), partner_id,))
-        orders.mapped('order_line').mapped('procurement_ids').write({'sale_line_id': False})
+        return orders.mapped('order_line').mapped('procurement_ids').write({'sale_line_id': False})
-        self.write({'state': 'cancel'})
+        return self.write({'state': 'cancel'})
-        self.write({'state': 'done'})
+        return self.write({'state': 'done'})
-                day_date=fields.Datetime.from_string(record_dt),
+                fields.Datetime.from_string(record_dt),
-            registry._init_modules.add(package.name)
+            if package.name is not None:
-        registry._init_modules.add(package.name)
+        if package.name is not None:
-            f.write("VERSION=%s\n" % version.replace('~', '_'))
+            f.write("VERSION=%s\n" % version.replace('~', '_').replace('+', ''))
-    except (ValueError, requests.exceptions.ConnectionError, requests.exceptions.MissingSchema, urllib3.exceptions.MaxRetryError) as e:
+    except (ValueError, requests.exceptions.ConnectionError, requests.exceptions.MissingSchema) as e:
-        dashboard_values['money_amount']['to_invoice'] = sum(values['timesheet_lines'].mapped('so_line.amt_to_invoice'))
+        so_lines = values['timesheet_lines'].mapped('so_line')
-        res['context'] = {'default_res_model': 'hr.expense.sheet', 'default_res_id': self.id}
+        res['context'] = {
-            }
+            'res_id': expense_sheet.id,
-            policy = 'ordered_timesheet'
+            policy = None
-            if product.service_policy == 'ordered_timesheet':
+            if not policy:
-        least_rank = min(x['x'] for x in self.result.values.values())
+        least_rank = min(x['x'] for x in self.result.values())
-        m = l/2
+        m = l // 2
-        max_level = max(len(x) for x in self.levels.values.values())
+        max_level = max(len(x) for x in self.levels.values())
-                    first_half = list[no/2:]
+                    first_half = list[no // 2:]
-                    first_half = list[no/2+1:]
+                    first_half = list[no // 2 + 1:]
-                        self.result[list[no/2]]['y'] = mid_pos + (self.result[list[no/2]]['x']%2 * 0.5)
+                        self.result[list[no // 2]]['y'] = mid_pos + (self.result[list[no // 2]]['x']%2 * 0.5)
-                        self.result[list[no/2]]['y'] = mid_pos + factor
+                        self.result[list[no // 2]]['y'] = mid_pos + factor
-                last_half = list[:no/2]
+                last_half = list[:no // 2]
-        last_half = l[:no/2]
+        first_half = l[no // 2 + rest:]
-            mid_node = l[no/2]
+            mid_node = l[no // 2]
-            max_level = max(len(x) for x in self.levels.values.values())
+            max_level = max(len(x) for x in self.levels.values())
-            min_order = math.fabs(min(x['y'] for x in self.result.values.values()))
+            min_order = math.fabs(min(x['y'] for x in self.result.values()))
-                first_half = roots[:no/2]
+                first_half = roots[:no // 2]
-                    last_half = roots[no/2:]
+                    last_half = roots[no // 2:]
-                    last_half = roots[no/2+1:]
+                    last_half = roots[no // 2 + 1:]
-                factor = -math.floor(no/2)
+                factor = -math.floor(no // 2)
-                    self.result[roots[no/2]]['y'] = base + factor
+                    self.result[roots[no // 2]]['y'] = base + factor
-            self.max_order = max(x['y'] for x in self.result.values.values())
+            self.max_order = max(x['y'] for x in self.result.values())
-        EXTRAFIELDS = ('privacy', 'user_id', 'duration', 'allday', 'start', 'start_date', 'start_datetime', 'rrule')
+        EXTRAFIELDS = ('privacy', 'user_id', 'duration', 'allday', 'start', 'rrule')
-        EXTRAFIELDS = ('privacy', 'user_id', 'duration', 'allday', 'start', 'start_date', 'start_datetime', 'rrule')
+        EXTRAFIELDS = ('privacy', 'user_id', 'duration', 'allday', 'start', 'rrule')
-    @skip('Need to fix why start_datetime is not set randomly')
+from odoo.tools import float_is_zero
-        if not order:
+        order_line = self.sale_order_line_id.sudo()
-        time.sleep(20)
+        time.sleep(50)
-version_info = (10, 'saas~18', 0, FINAL, 0, '')
+version_info = (11, 0, 0, FINAL, 0, '')
-                   (name,))
+                   (name,), log_exceptions=False)
-                remaining_value = move_id.remaining_value + correction_value
+                        # fake return, find the last receipt and augment its qties
-                    move_vals['remaining_value'] = remaining_value if remaining_value < 0 else 0
+                    move_vals['remaining_value'] = new_remaining_value if new_remaining_value < 0 else 0
-                    move_vals['remaining_value'] = remaining_value
+                    move_vals['remaining_value'] = new_remaining_value
-                'value': -tmp_value,  # outgoing move are valued negatively
+                'value': -tmp_value if not quantity else move.value or -tmp_value,  # outgoing move are valued negatively
-                'remaining_value': negative_stock_value,
+                'remaining_qty': move.remaining_qty + -qty_to_take_on_candidates,
-                'price_unit': (-tmp_value + negative_stock_value) / move.product_qty,
+                'price_unit': (-tmp_value + negative_stock_value) / (move.product_qty or quantity),
-                    })
+            move._run_valuation()
-            ('product_id', '=', self.product1.id),
+    def test_fifo_add_move_in_done_picking_1(self):
-
+        self.assertEqual(
-                move_line._log_message(move_line.production_id, move_line, 'mrp.track_production_move_template', vals)
+            production = move_line.move_id.production_id or move_line.move_id.raw_material_production_id
-            line.credit = amount < 0 and amount or 0.0
+            line.credit = amount < 0 and -amount or 0.0
-            _logger.exception('Can not `import %s`.', module)
+        _logger.exception('Can not `import %s`.', module)
-from odoo.exceptions import UserError
+from odoo.exceptions import UserError, ValidationError
-                                                                    order='create_date', limit=1)
+                                                                    order='create_date, id', limit=1)
-                    filtered_lines = consume_move_lines.filtered(lambda x: x.lot_produced_id == moveline.lot_id or not x.lot_produced_id)
+                    filtered_lines = consume_move_lines.filtered(lambda x: x.lot_produced_id == moveline.lot_id)
-            if move.unit_factor and not move.move_line_ids.filtered(lambda m: not m.done_wo):
+        for move in self.move_raw_ids:
-                move.quantity_done += float_round(self.qty_producing * move.unit_factor, precision_rounding=rounding)
+                if self.product_id.tracking != 'none':
-                move.order_finished_lot_ids = move.raw_material_production_id.move_finished_ids.mapped('move_line_ids.lot_id').ids
+            if move.raw_material_production_id.move_finished_ids:
-            ml.qty_done = ml.product_qty
+        for pl in produce_wizard.produce_line_ids:
-                        if float_compare(move_line.product_uom_qty, move_line.qty_done, precision_rounding=move.product_uom.rounding) <= 0:
+                        if move_line.lot_produced_id or float_compare(move_line.product_uom_qty, move_line.qty_done, precision_rounding=move.product_uom.rounding) <= 0:
-                move.quantity_done += float_round(quantity * move.unit_factor, precision_rounding=rounding)
+                if self.product_id.tracking != 'none':
-                  'location_id': produce_move.location_id.id, 
+                  'location_id': produce_move.location_id.id,
-                    })
+                                    'name': order.name,
-                moves |=_line.move_ids
+                moves |= s_line.move_ids
-                values['location_id'] = self.quant_ids[0].location_id
+            if package.quant_ids:
-    industry_id = fields.Many2one('res.partner.industry', 'Sector of Activity')
+    industry_id = fields.Many2one('res.partner.industry', 'Industry')
-    _description = 'Sector of Activity'
+    _description = 'Industry'
-from odoo.exceptions import UserError
+from odoo.exceptions import AccessDenied
-                            help="disable the ability to return the list of databases")
+                            help="Disable the ability to obtain or view the list of databases. "
-        d['insecure'] = odoo.tools.config['admin_passwd'] == 'admin'
+        d['insecure'] = odoo.tools.config.verify_admin_password('admin')
-    if passwd and passwd == odoo.tools.config['admin_passwd']:
+    if passwd and odoo.tools.config.verify_admin_password(passwd):
-    odoo.tools.config['admin_passwd'] = new_password
+    odoo.tools.config.set_admin_password(new_password)
-    with tempfile.TemporaryFile() as t:
+    with tempfile.TemporaryFile(mode='w+b') as t:
-        return base64.b64encode(t.read())
+        return base64.b64encode(t.read()).decode()
-                        manifest = ast.literal_eval(open(manifest_path).read())
+                        manifest_data = open(manifest_path, 'rb').read()
-        f = tools.file_open(manifest_file)
+        f = tools.file_open(manifest_file, mode='rb')
-            info.update(ast.literal_eval(f.read()))
+            info.update(ast.literal_eval(pycompat.to_native(f.read())))
-nt_service_name = "odoo-server-" + series
+nt_service_name = "odoo-server-" + series.replace('~','-')
-version = version.split('-')[0]
+version = version.split('-')[0].replace('saas~','')
-    print (l)
+    logging.info("System call: {}".format(l))
-            print("Package test: FAILED. Not able to install dependencies of base.")
+            logging.error("Package test: FAILED. Not able to install dependencies of base.")
-            print("Package test: successfuly installed %s modules" % len(modules))
+            logging.info("Package test: successfuly installed %s modules" % len(modules))
-        print("Package test: FAILED. Not able to install base.")
+        logging.error("Package test: FAILED. Not able to install base.")
-        published.append(_publish(o, release))
+        release = glob("%s/odoo_*.%s" % (o.build_dir, extension))
-            print('Error during docker execution: printing the bash output:')
+            logging.error('Exception during docker execution: %s:' % str(e))
-                print('\n'.join(f.readlines()))
+                print('\n'.join(f.readlines()), file=stderr)
-        print("vm timeout kill",self.pid)
+        logging.warning("vm timeout kill",self.pid)
-        l="kvm -net nic,model=rtl8139 -net user,hostfwd=tcp:127.0.0.1:10022-:22,hostfwd=tcp:127.0.0.1:18069-:8069,hostfwd=tcp:127.0.0.1:15432-:5432 -m 1024 -drive".split(" ")
+        l="kvm -cpu core2duo -smp 2,sockets=2,cores=1,threads=1 -net nic,model=rtl8139 -net user,hostfwd=tcp:127.0.0.1:10022-:22,hostfwd=tcp:127.0.0.1:18069-:8069,hostfwd=tcp:127.0.0.1:15432-:5432 -m 1024 -drive".split(" ")
-        print( " ".join(l))
+        logging.info("Starting kvm: {}".format( " ".join(l)))
-    def rsync(self,args,options='--delete --exclude .bzrignore'):
+    def rsync(self,args,options='--delete --exclude .git --exclude .tx --exclude __pycache__'):
-            f.write("VERSION=%s\n" % version)
+            f.write("VERSION=%s\n" % version.replace('~', '_'))
-        print("KVMWinBuildExe.run(): done")
+        logging.info("Syncing Odoo files to virtual machine...")
-            if addon_path.split(os.path.sep)[-1] not in ADDONS_NOT_TO_PUBLISH:
+    for addon_path in glob(join(o.build_dir, 'addons/*')):
-        pass
+            except shutil.Error as e:
-        deb.logfile = stdout
+        deb.logfile = stdout.buffer
-        _gen_file(o, *command, temp_path)
+        _gen_file(o, command[0], command[-1], temp_path)
-    op.add_option("", "--vm-winxp-ssh-key", default='/home/odoo/vm/win1035/id_rsa', help="%default")
+    op.add_option("", "--vm-winxp-image", default='/home/odoo/vm/win1036/win10_winpy36.qcow2', help="%default")
-    op.add_option("", "--vm-winxp-python-version", default='3.5', help="Windows Python version installed in the VM (default: %default)")
+    op.add_option("", "--vm-winxp-python-version", default='3.6', help="Windows Python version installed in the VM (default: %default)")
-                print("Won't publish the tgz release.\n Exception: %s" % str(e))
+                logging.error("Won't publish the tgz release.\n Exception: %s" % str(e))
-                published_files = publish(o, 'debian', ['deb', 'dsc', 'changes', 'tar.gz'])
+                published_files = publish(o, 'debian', ['deb', 'dsc', 'changes', 'tar.xz'])
-                print("Won't publish the deb release.\n Exception: %s" % str(e))
+                logging.error("Won't publish the deb release.\n Exception: %s" % str(e))
-                print("Won't publish the rpm release.\n Exception: %s" % str(e))
+                logging.error("Won't publish the rpm release.\n Exception: %s" % str(e))
-                print("Won't publish the exe release.\n Exception: %s" % str(e))
+                logging.error("Won't publish the exe release.\n Exception: %s" % str(e))
-        print('Something bad happened ! : {}'.format(e), file=stderr)
+        logging.error('Something bad happened ! : {}'.format(e))
-            print('Build dir "{}" not removed'.format(o.build_dir))
+            logging.info('Build dir "{}" not removed'.format(o.build_dir))
-            print('Build dir %s removed' % o.build_dir)
+            logging.info('Build dir %s removed' % o.build_dir)
-            print('Remaining dockers removed')
+            logging.info('Remaining dockers removed')
-    debs = re.findall('python-[0-9a-z]+',debian_control)
+    debs = re.findall('python3-[0-9a-z]+',debian_control)
-    op.add_option("", "--vm-winxp-ssh-key", default='/home/odoo/vm/win1034/id_rsa', help="%default")
+    op.add_option("", "--vm-winxp-image", default='/home/odoo/vm/win1035/win10_py35.qcow2', help="%default")
-    op.add_option("", "--vm-winxp-python-version", default='3.4', help="Windows Python version installed in the VM (default: %default)")
+    op.add_option("", "--vm-winxp-python-version", default='3.5', help="Windows Python version installed in the VM (default: %default)")
-    system(['python2', 'setup.py', 'sdist', '--quiet', '--formats=gztar,zip'], o.build_dir)
+    system(['python3', 'setup.py', 'sdist', '--quiet', '--formats=gztar,zip'], o.build_dir)
-    system(['python2', 'setup.py', '--quiet', 'bdist_rpm'], o.build_dir)
+    system(['python3', 'setup.py', '--quiet', 'bdist_rpm'], o.build_dir)
-    def _gen_file(o, (command, file_name), path):
+    def _gen_file(o, command, file_name, path):
-        _gen_file(o, command, temp_path)
+        _gen_file(o, *command, temp_path)
-        print('Something bad happened ! : {}'.format(exception_text), file=stderr)
+    except Exception as e:
-        fo = open(name, mode)
+        if 'b' in mode:
-    if base_path not in ad_paths:
+    if base_path not in ad_paths and os.path.isdir(base_path):
-        if ad not in ad_paths:
+        if ad not in ad_paths and os.path.isdir(ad):
-
+from __future__ import print_function
-from sys import stdout
+from sys import stdout, stderr
-    print l
+    print (l)
-                print '\n'.join(f.readlines())
+                print('\n'.join(f.readlines()))
-        print "vm timeout kill",self.pid
+        print("vm timeout kill",self.pid)
-        l="kvm -net nic,model=rtl8139 -net user,hostfwd=tcp:127.0.0.1:10022-:22,hostfwd=tcp:127.0.0.1:18069-:8069,hostfwd=tcp:127.0.0.1:15432-:5432 -drive".split(" ")
+        l="kvm -net nic,model=rtl8139 -net user,hostfwd=tcp:127.0.0.1:10022-:22,hostfwd=tcp:127.0.0.1:18069-:8069,hostfwd=tcp:127.0.0.1:15432-:5432 -m 1024 -drive".split(" ")
-        print " ".join(l)
+        print( " ".join(l))
-        time.sleep(10)
+        time.sleep(20)
-        print "KVMWinBuildExe.run(): done"
+        print("KVMWinBuildExe.run(): done")
-    system(['mv', glob('%s/../odoo_*.tar.gz' % o.build_dir)[0], '%s' % o.build_dir])
+    if not o.no_debsign:
-    subprocess.call(['gpg', '--default-key', GPGID, '--passphrase', GPGPASSPHRASE, '--yes', '-abs', '--no-tty', '-o', 'Release.gpg', 'Release'], cwd=os.path.join(o.pub, 'deb'))
+    if not o.no_debsign:
-    op.add_option("", "--vm-winxp-ssh-key", default='/home/odoo/vm/winxp27/id_rsa', help="%default")
+    op.add_option("", "--vm-winxp-image", default='/home/odoo/vm/win1034/win10.qcow2', help="%default")
-    op.add_option("", "--vm-winxp-python-version", default='2.7', help="Windows Python version installed in the VM (default: %default)")
+    op.add_option("", "--vm-winxp-python-version", default='3.4', help="Windows Python version installed in the VM (default: %default)")
-        pass
+    except Exception, exception_text:
-        print('Build dir %s removed' % o.build_dir)
+        if o.no_remove:
-from odoo import http, fields, tools
+from odoo import http, fields, tools, _
-            return request.render('website_mail_channel.invalid_token_subscription')
+            # FIXME: remove try/except in master
-from mock import patch
+try:
-from mock import patch
+try:
-from mock import patch
+try:
-from mock import patch
+try:
-                         (partner_id, self._name, tuple(self.ids), partner_id,))
+                         (partner_id, self._name, tuple(self.ids) or (None,), partner_id,))
-        if self.cash_rounding_id:
+        if self.cash_rounding_id and self.type in ('out_invoice', 'out_refund'):
-    amount_total = fields.Monetary(compute='_compute_amount_total')
+    amount_total = fields.Monetary(string="Amount", compute='_compute_amount_total')
-This mobule will test the main workflow of Odoo.
+This module will test the main workflow of Odoo.
-from odoo.tools import misc
+from odoo.tools import config, misc, ustr
-        arguments = {'arg0': msg, "action": "update"}
+        arguments = {'arg0': ustr(msg), "action": "update"}
-from odoo.addons.website.models.ir_http import _guess_mimetype
+from odoo.addons.http_routing.models.ir_http import slug, _guess_mimetype
-            template = mimetype_template
+        View = request.env['ir.ui.view']
-        if ext and ext != '.html': # redirect non html pages to backend to edit
+        if ext_special_case: # redirect non html pages to backend to edit
-from odoo.addons.http_routing.models.ir_http import ModelConverter
+from odoo.addons.http_routing.models.ir_http import ModelConverter, _guess_mimetype
-            }, mimetype=_guess_mimetype(ext)[0])
+            }, mimetype=_guess_mimetype(ext))
-                                                                        strict=True)
+        available_qty = sum(self.env['stock.quant']._gather(self.product_id,
-#  - env: Odoo Environement
+#  - env: Odoo Environment on which the action is triggered
-#  - log : log(message), function to log debug information in logging table
+#  - record: record on which the action is triggered; may be be void
-                    and move.state != 'draft'\
+                    and (move.state != 'draft' or (not self._context.get('planned_picking') and move.state == 'draft'))\
-    @api.depends('state', 'picking_id')
+    @api.depends('state', 'picking_id', 'product_id')
-            if self._context.get('planned_picking') and move.picking_id.state == 'draft':
+            if not move.product_id:
-                mo = re.search('<body>(.*)</body>', r.content, re.DOTALL)
+                mo = re.search('<body>(.*)</body>', r.content.decode(), re.DOTALL)
-    delay_close = fields.Float(compute="_compute_day", string='Delay to Close', readonly=True, group_operator="avg", help="Number of Delay to close", store=True)
+    delay_close = fields.Float(compute="_compute_day", string='Delay to Close', readonly=True, group_operator="avg", help="Number of days to close", store=True)
-                self._cr.commit()
+            self._run_scheduler_tasks(use_new_cursor=use_new_cursor, company_id=company_id)
-        move5._fifo_vacuum()
+        self.env['stock.move']._run_fifo_vacuum()
-        move6._fifo_vacuum()
+        self.env['stock.move']._run_fifo_vacuum()
-        move1._fifo_vacuum()
+        self.env['stock.move']._run_fifo_vacuum()
-        move1._fifo_vacuum()
+        self.env['stock.move']._run_fifo_vacuum()
-        move2._fifo_vacuum()
+        self.env['stock.move']._run_fifo_vacuum()
-        (move1 + move2 + move3)._fifo_vacuum()
+        self.env['stock.move']._run_fifo_vacuum()
-        
+        """ Get recurrent dates based on Rule string and all event where recurrent_id is child
-    ], string='Recurrency', states={'done': [('readonly', True)]}, help="Let the event automatically repeat at that interval")
+    ], string='Recurrence', states={'done': [('readonly', True)]}, help="Let the event automatically repeat at that interval")
-                                  string='Recurrency', required=True, index=True, default='specific')
+                                  string='Recurrence', required=True, index=True, default='specific')
-        data['stop_date' if data['allday'] else 'stop_datetime'] = data['stop']
+import datetime
-                                  string='Recurrency', required=True, index=True, default='specific')
+                                  string='Recurrence', required=True, index=True, default='specific')
-        date_field: the field containing the reference date information for recurrency computation
+        """ Get recurrent dates based on Rule string and all event where recurrent_id is child
-    ], string='Recurrency', states={'done': [('readonly', True)]}, help="Let the event automatically repeat at that interval")
+    ], string='Recurrence', states={'done': [('readonly', True)]}, help="Let the event automatically repeat at that interval")
-        # I create a recurrent meeting with daily recurrency and fixed amount of time.
+        # In order to test recurrent meetings in Odoo, I create meetings with different recurrence using different test cases.
-                                  string='Recurrency', required=True, index=True, default='specific')
+                                  string='Recurrence', required=True, index=True, default='specific')
-from odoo.addons.http_routing.models.ir_http import slug, _guess_mimetype
+from odoo.addons.http_routing.models.ir_http import slug
-from odoo.addons.http_routing.models.ir_http import ModelConverter, _guess_mimetype
+from odoo.addons.http_routing.models.ir_http import ModelConverter
-        )
+        self.pack_location = self.env.ref('stock.location_pack_zone')
-                                                      package_id=ml.package_id, owner_id=ml.owner_id)[1]
+                                                      package_id=ml.result_package_id, owner_id=ml.owner_id)[1]
-                in_date = Quant._update_available_quantity(ml.product_id, ml.location_dest_id, -ml.qty_done, lot_id=ml.lot_id,
+                qty_done_orig = ml.move_id.product_uom._compute_quantity(ml.qty_done, ml.move_id.product_id.uom_id, rounding_method='HALF-UP')
-                Quant._update_available_quantity(ml.product_id, ml.location_id, ml.qty_done, lot_id=ml.lot_id,
+                Quant._update_available_quantity(ml.product_id, ml.location_id, qty_done_orig, lot_id=ml.lot_id,
-            picking.show_check_availability = picking.is_locked and picking.state in ('confirmed', 'waiting') and has_moves_to_reserve
+            picking.show_check_availability = picking.is_locked and picking.state in ('confirmed', 'waiting', 'assigned') and has_moves_to_reserve
-            .filtered(lambda move: move.state == 'confirmed')\
+        self.filtered(lambda picking: picking.location_id.usage in ('supplier', 'inventory', 'production') and picking.state == 'confirmed')\
-        move1._action_assign()
+        # _action_assign is automatically called
-        move1._action_assign()
+        self.assertEqual(move1.state, 'assigned')
-def _guess_mimetype(ext=False, default='text/html'):
+def _guess_mimetype(ext=False, default=False):
-        '.html': 'text/html',
+        '.css': ['text/css', 'website.default_css'],
-from odoo.addons.http_routing.models.ir_http import slug
+from odoo.addons.http_routing.models.ir_http import slug, _guess_mimetype
-        url = request.env['website'].new_page(path, add_menu=add_menu, **template)
+        page = request.env['website'].new_page(path, add_menu=add_menu, **template)
-            }, mimetype=_guess_mimetype(ext))
+            }, mimetype=_guess_mimetype(ext)[0])
-
+        result = dict({'url': page_url, 'view_id': False})
-        return page_url
+        return result
-                            newpath = self.env['website'].new_page(name + ' ' + self.name, template=xml_id, ispage=False)
+                            newpath = self.env['website'].new_page(name + ' ' + self.name, template=xml_id, ispage=False)['url']
-        help="""Will determine if the next work order will be planned after the previous one or after the first Quantity To Process of the previous one.""",
+        help="""Will determine if the next work order will be scheduled after the previous one or after the first Quantity To Process of the previous one.""",
-        help="Quantity of products that are planned to arrive.\n"
+        help="Quantity of planned incoming products.\n"
-        help="Quantity of products that are planned to leave.\n"
+        help="Quantity of planned outgoing products.\n"
-            'payment_id': self.id,
+            'payment_id': self.id,
-    group_mrp_routings = fields.Boolean("Work Orders",
+    group_mrp_routings = fields.Boolean("Work Orders & Quality",
-            origin = (move.group_id and (move.group_id.name + ":") or "") + (move.rule_id and move.rule_id.name or move.origin or move.picking_id.name or "/")
+            origin = (move.group_id and move.group_id.name or (move.rule_id and move.rule_id.name or move.origin or move.picking_id.name or "/"))
-        pricelist = self.env['website'].get_current_website().get_current_pricelist()
+        current_website = self.env['website'].get_current_website()
-            taxes = partner.property_account_position_id.map_tax(p.taxes_id)
+            taxes = partner.property_account_position_id.map_tax(p.taxes_id.filtered(lambda x: x.company_id == company_id))
-        if request.env.user != request.website.user_id:
+        if not request.website.is_public_user():
-        request.env['product.wishlist']._add_to_wishlist(
+        return request.env['product.wishlist']._add_to_wishlist(
-        return True
+from . import ir_autovacuum
-from odoo import api, fields, http, models
+from datetime import datetime, timedelta
-    pricelist_id = fields.Many2one('product.pricelist', string='Pricelist', help='Pricelist when added')
+    session = fields.Char(help="Website session identifier where this product was wishlisted.")
-    website_id = fields.Many2one('website', required=True)
+    pricelist_id = fields.Many2one('product.pricelist', string='Pricelist', help='Pricelist when added')
-    active = fields.Boolean(default=True, required=True)
+    website_id = fields.Many2one('website', required=True)
-            'pricelist_id': pricelist_id,
+            'session': session,
-            'website_id': website_id,
+            'pricelist_id': pricelist_id,
-            'session': session,
+            'website_id': website_id,
-    def _garbage_collector(self):
+    def _garbage_collector(self, *args, **kwargs):
-            ("session", "not in", http.root.session_store.list()),
+            ("create_date", "<", fields.Datetime.to_string(datetime.now() - timedelta(weeks=kwargs.get('wishlist_week', 5)))),
-    def power_on(self):
+    def power_on(self, *args, **kwargs):
-    @http.route(['/shop/wishlist/add'], type='json', auth="user", website=True)
+    @http.route(['/shop/wishlist/add'], type='json', auth="public", website=True)
-            product_id
+            product_id,
-    @http.route(['/shop/wishlist'], type='http', auth="user", website=True)
+    @http.route(['/shop/wishlist'], type='http', auth="public", website=True)
-        values = request.env['product.wishlist'].with_context(display_default_code=False).search([('partner_id', '=', request.env.user.partner_id.id)])
+        values = request.env['product.wishlist'].with_context(display_default_code=False).current()
-from . import product_wishlist
+from . import product_wishlist
-
+from odoo import api, fields, http, models
-    partner_id = fields.Many2one('res.partner', string='Owner', required=True)
+    partner_id = fields.Many2one('res.partner', string='Owner')
-    def _add_to_wishlist(self, partner_id, pricelist_id, currency_id, website_id, price, product_id):
+    def current(self):
-                    url = 'mailto:%s' % self.url
+                if '@' in self.url:
-                    response.append(style.to_html())
+                        response.append(StylesheetAsset(self, url="/web/static/lib/bootstrap/css/bootstrap.css").to_html())
-            return None
+
-from odoo import models
+from odoo import models, api, fields
-from . import main
+    def is_public_user(self):
-    @classmethod
+    @api.onchange('show_operations')
-        self.write({'state': 'cancel'})
+        self.write({'state': 'cancel', 'is_locked': True})
-        self.picking_ids.action_cancel()
+        self.mapped('picking_ids').action_cancel()
-        action['domain'] = [('id', 'in', self.picking_ids.ids)]
+
-    @api.multi
+from odoo.osv import expression
-        for move in self.filtered(lambda m: m.production_id):
+        moves = self.env['stock.move']
-
+        # With the non plannified picking, draft moves could have some move lines.
-self_port = str(config['xmlrpc_port'] or 8069)
+self_port = str(config['http_port'] or 8069)
-    "web.base.url": lambda: "http://localhost:%s" % config.get('xmlrpc_port'),
+    "web.base.url": lambda: "http://localhost:%s" % config.get('http_port'),
-        self.port = config['xmlrpc_port']
+        self.interface = config['http_interface'] or '0.0.0.0'
-        if test_mode or (config['xmlrpc'] and not stop):
+        if test_mode or (config['http_enable'] and not stop):
-            (config['xmlrpc_interface'] or '0.0.0.0', config['xmlrpc_port'])
+        self.address = config['http_enable'] and \
-        if config['xmlrpc']:
+        if config['http_enable']:
-PORT = odoo.tools.config['xmlrpc_port']
+PORT = odoo.tools.config['http_port']
-                         help="Enable correct behavior when behind a reverse proxy")
+        # HTTP
-                         help="specify the TCP port for longpolling requests", type="int")
+                         help="Listen port for the longpolling HTTP service", type="int", metavar="PORT")
-                         help="Filter listed database", metavar="REGEXP")
+        group.add_option("--db-filter", dest="dbfilter", my_default='', metavar="REGEXP",
-        keys = ['xmlrpc_interface', 'xmlrpc_port', 'longpolling_port',
+        keys = ['http_interface', 'http_port', 'longpolling_port', 'http_enable',
-                'xmlrpc', 'syslog', 'without_demo',
+                'syslog', 'without_demo',
-            'stop_after_init', 'logrotate', 'without_demo', 'xmlrpc', 'syslog',
+            'stop_after_init', 'logrotate', 'without_demo', 'http_enable', 'syslog',
-def check_with_xsd(tree_or_str, xsd_path):
+
-    xml_schema_doc = etree.parse(file_open(xsd_path))
+    xml_schema_doc = etree.parse(stream)
-    def _onchange_amount(self):
+    def _compute_journal_domain_and_types(self):
-        return {'domain': {'journal_id': domain}}
+    @api.onchange('amount', 'currency_id')
-        res['domain']['journal_id'].append(('type', 'in', ('bank', 'cash')))
+        jrnl_filters = self._compute_journal_domain_and_types()
-                res['warning_message'] = _('Info:\nTotal amount of this order is above %.2f, free shipping!\n(actual cost: %.2f)') % (self.amount, res['price'])
+                res['warning_message'] = _('Info:\nThe shipping is free because the order amount exceeds %.2f.\n(The actual shipping cost is: %.2f)') % (self.amount, res['price'])
-                        if float_compare(qty_to_consume, 0.0, precision_rounding=move.product_uom.rounding) < 0:
+                        if float_compare(qty_to_consume, 0.0, precision_rounding=move.product_uom.rounding) <= 0:
-                        if float_compare(move_line.product_uom_qty, move_line.qty_done, precision_rounding=move.product_uom.rounding) < 0:
+                        if float_compare(move_line.product_uom_qty, move_line.qty_done, precision_rounding=move.product_uom.rounding) <= 0:
-                if not modifiers.get('invisible') and not modifiers.get('tree_invisible'):
+                if not modifiers.get('invisible') and not modifiers.get('column_invisible'):
-                modifiers['tree_invisible'] = v
+                modifiers['column_invisible'] = v
-    :param bool in_tree_view: triggers the ``tree_invisible`` code
+    :param bool in_tree_view: triggers the ``column_invisible`` code
-                              hidden) with ``tree_invisible``.
+                              hidden) with ``column_invisible``.
-        action = self.env.ref('stock_account.product_valuation_action').read()[0]
+        action = self.env.ref('stock_account.stock_move_valuation_action').read()[0]
-        action['domain'] = [('id', '=', self.id)]
+        action = self.env.ref('stock_account.stock_move_valuation_action').read()[0]
-    @api.depends('stock_move_ids.product_qty', 'stock_move_ids.state')
+    @api.depends('stock_move_ids.product_qty', 'stock_move_ids.state', 'product_tmpl_id.cost_method')
-                product.stock_value = sum(moves.mapped('remaining_value'))
+                product.stock_value = product._sum_remaining_values()
-        # write values of default taxes for product as super user
+        # write values of default taxes for product as super user and write in the config
-    @queryCount(admin=38, demo=54)
+    @queryCount(admin=37, demo=53)
-        self.assertItemsEqual(t(res_books_without_movie_edition), t(books_with_edition))
+        self.assertItemsEqual(t(res_books_without_movie_edition), t(books))
-        self.assertItemsEqual(t(res_books_without_one_movie_edition), t(books_with_edition))
+        self.assertItemsEqual(t(res_books_without_one_movie_edition), t(books))
-        self.assertItemsEqual(t(res_books_without_one_movie_edition_name), t(books_with_edition))
+        self.assertItemsEqual(t(res_books_without_one_movie_edition_name), t(books))
-                is_integer_m2o = comodel._fields[field.inverse_name].type == 'integer'
+                inverse_is_int = comodel._fields[field.inverse_name].type == 'integer'
-                            operator = 'not in' if operator in NEGATIVE_TERM_OPERATORS else 'in'
+                        op2 = (TERM_OPERATORS_NEGATION[operator]
-                            ids2 = comodel.search([('id', 'in', ids2)] + domain).ids
+                        ids2 = [right]
-                            push(create_substitution_leaf(leaf, FALSE_LEAF, model))
+                        ids1 = []
-                    if comodel._fields[field.inverse_name].store and not (is_integer_m2o and domain):
+                        recs = comodel.browse(ids2).sudo().with_context(prefetch_fields=False)
-                        if is_integer_m2o and domain:
+                        if inverse_is_int and domain:
-                    push(create_substitution_leaf(leaf, ('id', o2m_op, ids1), model))
+                        ids1 = unwrap_inverse(recs.mapped(field.inverse_name))
-                    ids2 = comodel.search(dom).ids
+                    domain = HIERARCHY_FUNCS[operator]('id', ids2, comodel)
-                        push(create_substitution_leaf(leaf, ('id', m2m_op, select_distinct_from_where_not_null(cr, rel_id1, rel_table)), model))
+                    # determine ids1 = records with relations
-                        push(create_substitution_leaf(leaf, ('id', 'inselect', (subquery, [])), internal=True))
+                        push(create_substitution_leaf(leaf, ('id', 'inselect', (subquery, [tuple(ids2)])), internal=True))
-                            push(create_substitution_leaf(leaf, ('id', subop, (subquery, [])), internal=True))
+                            subparams = [tuple(it for it in res_ids if it)]
-                        instr = '(%s)' % ', '.join(['%s'] * len(right))
+                        right = tuple(right)
-                    r = 'NOT NULL' if right else 'NULL'
+                if (operator == 'in' and right) or (operator == 'not in' and not right):
-                query = '(%s."%s" IS %s)' % (table_alias, left, r)
+                    query = '(%s."%s" IS NULL)' % (table_alias, left)
-
+                params = [it for it in right if it != False]
-                elif not check_nulls and operator == 'not in':
+                if (operator == 'in' and check_null) or (operator == 'not in' and not check_null):
-                elif check_nulls and operator == 'not in':
+                elif operator == 'not in' and check_null:
-            else:  # Must not happen
+            if left not in model:
-                query = '(%s OR %s."%s" IS NULL)' % (query, table_alias, left)
+                if not native_str:
-        params = []
+        stack = []                      # stack of query strings
-        for leaf in self.result:
+        for leaf in reversed(self.result):
-                params.insert(0, p)
+                q, ps = self.__leaf_to_sql(leaf)
-        return query, tools.flatten(params)
+        params.reverse()
-            'float_to_time': float_to_time,
+class FloatTimeConverter(models.AbstractModel):
-    group_multi_currency = fields.Boolean(string='Allow multi currencies',
+    group_multi_currency = fields.Boolean(string='Multi-Currencies',
-    multi_sales_price = fields.Boolean("Multiple sales price per product")
+    multi_sales_price = fields.Boolean("Multiple Sales Prices per Product")
-        ('formula', 'Price computed from formulas (discounts, margins, roundings)')
+        ('formula', 'Prices computed from formulas (discounts, margins, roundings)')
-    module_delivery_dhl = fields.Boolean("DHL USA")
+    module_delivery = fields.Boolean("Shipping Costs")
-        dashboard_values['money_amount']['to_invoice'] = sum(values['timesheet_lines'].filtered(lambda l: not l.timesheet_invoice_id).mapped('timesheet_revenue'))
+        dashboard_values['money_amount']['invoiced'] = sum(values['timesheet_lines'].mapped('so_line.amt_invoiced'))
-            if timesheet.task_id and so_line.product_id.type == 'service' and so_line.product_id.service_type == 'timesheet':
+            if timesheet.task_id and so_line.product_id.type == 'service':
-                    values['timesheet_invoice_type'] = 'billable_time'
+                    values['timesheet_invoice_type'] = 'billable_time' if so_line.product_id.service_type == 'timesheet' else 'billable_fixed'
-        self.env['account.analytic.line'].create({
+        timesheet1 = self.env['account.analytic.line'].create({
-        self.env['account.analytic.line'].create({
+        timesheet2 = self.env['account.analytic.line'].create({
-            return _('%sh%s') % (hours, '%02d' % minutes)
+            return _('%02d:%02d') % (hours, minutes)
-                    (defaults.get('res_model_id') and self.env['ir.model'].sudo().browse(defaults['res_model_id']).model == 'crm.lead'):
+            if (defaults.get('res_model') and defaults['res_model'] == 'crm.lead') or (defaults.get('res_model_id') and self.env['ir.model'].sudo().browse(defaults['res_model_id']).model == 'crm.lead'):
-                    record.embed_code = '<embed src="https://video.google.com/get_player?ps=docs&partnerid=30&docid=%s" type="application/x-shockwave-flash"></embed>' % (record.document_id)
+                    record.embed_code = '<iframe src="//drive.google.com/file/d/%s/preview" allowFullScreen="true" frameborder="0"></iframe>' % (record.document_id)
-            'context': {'default_picking_id': self.id, 'product_ids': self.move_line_ids.mapped('product_id').ids},
+            'context': {'default_picking_id': self.id, 'product_ids': products.ids},
-            'name': 'test_set_quantity_done_1',
+            'name': 'test_scrap_3',
-            'product_qty_uom': str(move_line.qty_done) + ' ' + move_line.product_id.uom_id.name,
+            'product_qty_uom': str(move_line.product_uom_id._compute_quantity(move_line.qty_done, move_line.product_id.uom_id, rounding_method='HALF-UP')) + ' ' + move_line.product_id.uom_id.name,
-                'product_qty_uom': str(move_line.qty_done) + ' ' + move_line.product_id.uom_id.name,
+                'product_qty_uom': str(move_line.product_uom_id._compute_quantity(move_line.qty_done, move_line.product_id.uom_id, rounding_method='HALF-UP')) + ' ' + move_line.product_id.uom_id.name,
-                                or move_line.product_id.tracking == 'serial' and move_line.qty_done != 0:
+                        if float_compare(qty_to_consume, 0.0, precision_rounding=move.product_uom.rounding) < 0:
-        return self.env['product.pricelist'].search([], limit=1)
+        return self.env['product.pricelist'].search([('currency_id', '=', self.env.user.company_id.currency_id.id)], limit=1)
-    _inherit = ['mail.thread']
+    _inherit = ['mail.thread', 'mail.activity.mixin']
-            if (defaults.get('res_model') and defaults['res_model'] == 'crm.lead') or self.env['ir.model'].sudo().browse(defaults['res_model_id']).model == 'crm.lead':
+            if (defaults.get('res_model') and defaults['res_model'] == 'crm.lead') or \
-            return http.send_file(data, filename=attachment['name'].encode('utf-8'), as_attachment=True)
+            return http.send_file(data, filename=attachment['name'], as_attachment=True)
-        return purchases.mapped('product_id').ids
+        return [line['product_id'][0] for line in purchases]
-        help=""""Standard Price: The products are valued at their standard cost defined on the product.
+        help="""Standard Price: The products are valued at their standard cost defined on the product.
-        ('none', 'None')], string='Availability',
+        ('none', 'None')], string='Materials Availability',
-                        source = open(path, 'rb').read() + '\n'
+                        source = open(path, 'rb').read() + b'\n'
-    for p in ('host', 'port', 'user', 'password'):
+    for p in ('host', 'port', 'user', 'password', 'sslmode'):
-                'db_name', 'db_user', 'db_password', 'db_host',
+                'db_name', 'db_user', 'db_password', 'db_host', 'db_sslmode',
-    def state_update(self, newstate, states_to_update, level=100):
+    def _state_update(self, newstate, states_to_update, level=100):
-            update_demo = update_mods.state_update(newstate, states_to_update, level=level-1)
+            update_demo = update_mods._state_update(newstate, states_to_update, level=level-1)
-            modules.state_update('to install', ['uninstalled'])
+            modules._state_update('to install', ['uninstalled'])
-    def update_translations(self, filter_lang=None):
+    def _update_translations(self, filter_lang=None):
-    def check(self):
+    def _check(self):
-        mods.with_context(overwrite=self.overwrite).update_translations(self.lang)
+        mods.with_context(overwrite=self.overwrite)._update_translations(self.lang)
-                module.check()
+                module._check()
-            module.with_context(overwrite=overwrite).update_translations()
+            module.with_context(overwrite=overwrite)._update_translations()
-                modules.update_translations(lang)
+                modules._update_translations(lang)
-            lines = [(0, 0, line) for line in self.get_payslip_lines(contract_ids, payslip.id)]
+            lines = [(0, 0, line) for line in self._get_payslip_lines(contract_ids, payslip.id)]
-    def get_payslip_lines(self, contract_ids, payslip_id):
+    def _get_payslip_lines(self, contract_ids, payslip_id):
-                if rule.satisfy_condition(localdict) and rule.id not in blacklist:
+                if rule._satisfy_condition(localdict) and rule.id not in blacklist:
-                    amount, qty, rate = rule.compute_rule(localdict)
+                    amount, qty, rate = rule._compute_rule(localdict)
-    def compute_rule(self, localdict):
+    def _compute_rule(self, localdict):
-    def satisfy_condition(self, localdict):
+    def _satisfy_condition(self, localdict):
-    module_website_sale_comparison = fields.Boolean("Product Comparator")
+    module_website_sale_comparison = fields.Boolean("Product Comparison Tool")
-                        query = sitemap_qs2dom(query, r)
+                        query = sitemap_qs2dom(query, r, self.env[converter.model]._rec_name)
-            if qs.lower() in loc:
+            if not qs or qs.lower() in loc:
-
+        _touch(path, bundle1)
-
+        _touch(path, bundle1)
-        self.counter.clear()
+    def _get_asset(self):
-        asset = AssetsBundle(self.lessbundle_xmlid, files, remains, env=self.env)
+        return AssetsBundle(self.lessbundle_xmlid, files, remains, env=self.env)
-        self._bundle(True, False)
+        self._bundle(self._get_asset(), True, False)
-        self._bundle(False, False)
+        self._bundle(self._get_asset(), False, False)
-        self._bundle(True, True)
+        asset = self._get_asset()
-        self._bundle(False, False)
+        self._bundle(self._get_asset(), False, False)
-        expected = "%s::text like %s" % (unaccent('"res_partner_bank"."sanitized_acc_number"'), unaccent('%s'))
+        expected = "%s like %s" % (unaccent('"res_partner_bank"."sanitized_acc_number"::text'), unaccent('%s'))
-        expected = "%s::text like %s" % (unaccent('"res_partner__bank_ids"."sanitized_acc_number"'), unaccent('%s'))
+        expected = "%s like %s" % (unaccent('"res_partner__bank_ids"."sanitized_acc_number"::text'), unaccent('%s'))
-        expected = "%s::text like %s" % (unaccent('"res_country"."code"'), unaccent('%s'))
+        expected = "%s like %s" % (unaccent('"res_country"."code"::text'), unaccent('%s'))
-        expected = "%s::text like %s" % (unaccent('"res_country_state__country_id"."code"'), unaccent('%s'))
+        expected = "%s like %s" % (unaccent('"res_country_state__country_id"."code"::text'), unaccent('%s'))
-        expected = "%s::text like %s" % (unaccent('"res_partner__state_id__country_id"."code"'), unaccent('%s'))
+        expected = "%s like %s" % (unaccent('"res_partner__state_id__country_id"."code"::text'), unaccent('%s'))
-        expected = "%s::text like %s" % (unaccent('"res_partner__child_ids__bank_ids"."sanitized_acc_number"'), unaccent('%s'))
+        expected = "%s like %s" % (unaccent('"res_partner__child_ids__bank_ids"."sanitized_acc_number"::text'), unaccent('%s'))
-    except Exception:
+    except werkzeug.exceptions.NotFound:
-            func and func.routing.get('multilang', func.routing['type'] == 'http')
+            (not func or (func and func.routing.get('multilang', func.routing['type'] == 'http')))
-        return False
+        return cls._serve_404()
-            url = self.page_id.url
+            url = self.page_id.sudo().url
-    @http.route('/web/signup', type='http', auth='public', website=True)
+    @http.route('/web/signup', type='http', auth='public', website=True, sitemap=False)
-    @http.route('/web/reset_password', type='http', auth='public', website=True)
+    @http.route('/web/reset_password', type='http', auth='public', website=True, sitemap=False)
-    @http.route('/web/login', type='http', auth="none")
+    @http.route('/web/login', type='http', auth="none", sitemap=False)
-import datetime
+import unittest
-            request.website = request.website.with_context(request.context)
+            request.website = request.website.with_context(context)
-    def generate(self, uid, query=None, args=None):
+    def generate(self, uid, dom=None, args=None):
-            domain.append((Model._rec_name, 'ilike', '%' + query + '%'))
+        if dom:
-import unicodedata
+from odoo.addons.website.models.ir_http import sitemap_qs2dom
-                key=lambda x: hasattr(x[1], 'domain') and (x[1].domain != '[]'))
+                key=lambda x: (hasattr(x[1], 'domain') and (x[1].domain != '[]'), rule._trace.index((True, x[0]))))
-                    for value_dict in converter.generate(uid=self.env.uid, query=query, args=val):
+                    if query:
-                yield page
+                if not query_string or query_string.lower() in url.lower():
-    ], type='http', auth="public", website=True)
+    ], type='http', auth="public", website=True, sitemap=sitemap_partners)
-from odoo.addons.http_routing.models.ir_http import unslug
+from odoo.addons.http_routing.models.ir_http import unslug, slug
-    ], type='http', auth="public", website=True)
+    ], type='http', auth="public", website=True, sitemap=sitemap_industry)
-    @http.route(['/event', '/event/page/<int:page>', '/events', '/events/page/<int:page>'], type='http', auth="public", website=True)
+    def sitemap_event(env, rule, qs):
-    @http.route(['/event/<model("event.event"):event>/page/<path:page>'], type='http', auth="public", website=True)
+    @http.route(['/event/<model("event.event"):event>/page/<path:page>'], type='http', auth="public", website=True, sitemap=False)
-    @http.route(['/event/<model("event.event"):event>/register'], type='http', auth="public", website=True)
+    @http.route(['/event/<model("event.event"):event>/register'], type='http', auth="public", website=True, sitemap=False)
-    @http.route(['''/event/<model("event.event", "[('website_track','=',1)]"):event>/agenda'''], type='http', auth="public", website=True)
+    @http.route(['''/event/<model("event.event"):event>/agenda'''], type='http', auth="public", website=True, sitemap=False)
-        ], type='http', auth="public", website=True)
+        '''/event/<model("event.event"):event>/track''',
-    @http.route(['''/event/<model("event.event", "[('website_track_proposal','=',1)]"):event>/track_proposal'''], type='http', auth="public", website=True)
+    @http.route(['''/event/<model("event.event"):event>/track_proposal'''], type='http', auth="public", website=True, sitemap=False)
-    @http.route('/forum/validate_email', type='http', auth='public', website=True)
+    @http.route('/forum/validate_email', type='http', auth='public', website=True, sitemap=False)
-                 ], type='http', auth="public", website=True)
+                 '''/forum/<model("forum.forum"):forum>/tag/<model("forum.tag"):tag>/questions''',
-    @http.route('/forum/get_tags', type='http', auth="public", methods=['GET'], website=True)
+    @http.route('/forum/get_tags', type='http', auth="public", methods=['GET'], website=True, sitemap=False)
-    @http.route(['/forum/<model("forum.forum"):forum>/tag', '/forum/<model("forum.forum"):forum>/tag/<string:tag_char>'], type='http', auth="public", website=True)
+    @http.route(['/forum/<model("forum.forum"):forum>/tag', '/forum/<model("forum.forum"):forum>/tag/<string:tag_char>'], type='http', auth="public", website=True, sitemap=False)
-    @http.route(['/forum/user/<int:user_id>/avatar'], type='http', auth="public", website=True)
+    @http.route(['/forum/user/<int:user_id>/avatar'], type='http', auth="public", website=True, sitemap=False)
-    ], type='http', auth="public", website=True)
+    ], type='http', auth="public", website=True, sitemap=sitemap_jobs)
-        "/groups/<model('mail.channel'):group>/page/<int:page>"
+        '''/groups/<model('mail.channel', "[('channel_type', '=', 'channel')]"):group>''',
-        '''/groups/<model('mail.channel'):group>/<model('mail.message', "[('model','=','mail.channel'), ('res_id','=',group[0])]"):message>''',
+        '''/groups/<model('mail.channel', "[('channel_type', '=', 'channel')]"):group>/<model('mail.message', "[('model','=','mail.channel'), ('res_id','=',group[0])]"):message>''',
-        '''/groups/<model('mail.channel'):group>/<model('mail.message', "[('model','=','mail.channel'), ('res_id','=',group[0])]"):message>/get_replies''',
+        '''/groups/<model('mail.channel', "[('channel_type', '=', 'channel')]"):group>/<model('mail.message', "[('model','=','mail.channel'), ('res_id','=',group[0])]"):message>/get_replies''',
-        '''/slides/<model("slide.channel", "[('can_see', '=', True)]"):channel>/page/<int:page>''',
+        '''/slides/<model("slide.channel"):channel>''',
-        '''/slides/<model("slide.channel", "[('can_see', '=', True)]"):channel>/<string:slide_type>/page/<int:page>''',
+        '''/slides/<model("slide.channel"):channel>/<string:slide_type>''',
-        '''/slides/<model("slide.channel", "[('can_see', '=', True)]"):channel>/tag/<model("slide.tag"):tag>/page/<int:page>''',
+        '''/slides/<model("slide.channel"):channel>/tag/<model("slide.tag"):tag>''',
-        '''/slides/<model("slide.channel", "[('can_see', '=', True)]"):channel>/category/<model("slide.category"):category>/page/<int:page>''',
+        '''/slides/<model("slide.channel"):channel>/category/<model("slide.category"):category>''',
-        type='http', auth="public", website=True)
+        '''/slides/<model("slide.channel"):channel>/category/<model("slide.category"):category>/<string:slide_type>''',
-    @http.route('''/slides/slide/<model("slide.slide", "[('channel_id.can_see', '=', True), ('datas', '!=', False), ('slide_type', '=', 'presentation')]"):slide>/pdf_content''', type='http', auth="public", website=True)
+    @http.route('''/slides/slide/<model("slide.slide"):slide>/pdf_content''',
-    def slide_download(self, slide):
+    @http.route('''/slides/slide/<model("slide.slide"):slide>/download''', type='http', auth="public", website=True)
-    @http.route('/slides/embed/<int:slide_id>', type='http', auth='public', website=True)
+    @http.route('/slides/embed/<int:slide_id>', type='http', auth='public', website=True, sitemap=False)
-            if pl.qty_done and pl.lot_id:
+            if pl.qty_done:
-            ml.qty_done = ml.product_qty
+            if ml.product_id.tracking != 'none':
-        for ml in mo.move_raw_ids.mapped('move_line_ids'):
+        for ml in mo.move_raw_ids.mapped('move_line_ids').filtered(lambda m: m.product_id.tracking != 'none'):
-            if move.product_id.tracking == 'none' and move.quantity_done < move.product_uom_qty and move.state not in ('done', 'cancel') and move.unit_factor:
+            if move.product_id.tracking == 'none' and move.state not in ('done', 'cancel') and move.unit_factor:
-        return True
+        for order in self:
-    @api.depends('move_raw_ids.quantity_done', 'move_finished_ids.quantity_done')
+    @api.depends('move_raw_ids.quantity_done', 'move_finished_ids.quantity_done', 'is_locked')
-                    any((x.quantity_done > 0 and x.state not in ['done' 'cancel']) for x in order.move_finished_ids)
+                order.post_visible = order.is_locked and any((x.quantity_done > 0 and x.state not in ['done', 'cancel']) for x in order.move_raw_ids | order.move_finished_ids)
-                order.post_visible = any((x.quantity_done > 0 and x.state not in ['done', 'cancel']) for x in order.move_finished_ids)
+                order.post_visible = order.is_locked and any((x.quantity_done > 0 and x.state not in ['done', 'cancel']) for x in order.move_finished_ids)
-    @api.depends('workorder_ids.state', 'move_finished_ids')
+    @api.depends('workorder_ids.state', 'move_finished_ids', 'is_locked')
-            production.check_to_done = done_moves and (qty_produced >= production.product_qty) and (production.state not in ('done', 'cancel')) and wo_done
+            production.check_to_done = production.is_locked and done_moves and (qty_produced >= production.product_qty) and (production.state not in ('done', 'cancel')) and wo_done
-    
+    needs_lots = fields.Boolean('Tracking', compute='_compute_needs_lots')
-    is_locked = fields.Boolean(related='picking_id.is_locked', readonly=True)
+    is_locked = fields.Boolean(compute='_compute_is_locked', readonly=True)
-        ('bom_qty_zero', 'CHECK (product_qty>0)', 'All product quantities must be greater than 0.\n'
+        ('bom_qty_zero', 'CHECK (product_qty>=0)', 'All product quantities must be greater or equal to 0.\n'
-            else:
+            elif quantity < 0:  # Do not remove 0 lines
-            lambda move: move.state not in ('done', 'cancel') and move.product_id.tracking != 'none' and move.product_id != self.production_id.product_id)
+            lambda move: move.state not in ('done', 'cancel') and move.product_id.tracking != 'none' and move.product_id != self.production_id.product_id and move.bom_line_id)
-                for move in production.move_raw_ids.filtered(lambda x: (x.product_id.tracking != 'none') and x.state not in ('done', 'cancel')):
+                for move in production.move_raw_ids.filtered(lambda x: (x.product_id.tracking != 'none') and x.state not in ('done', 'cancel') and x.bom_line_id):
-                    quantity_hour = so_line.product_uom._compute_quantity(so_line.product_uom_qty, timesheet_uom)
+                    quantity_hour = unit_amount
-    sale_line_id = fields.Many2one('sale.order.line', 'Sales Order Item', domain=[('is_service', '=', True)])
+    sale_line_id = fields.Many2one('sale.order.line', 'Sales Order Item', domain="[('is_service', '=', True), ('order_partner_id', '=', partner_id)]")
-                'sale.sale_portal_confirmation_options', default='none') not in ('pay', 'sign'):
+        if not self._portal_quote_user_can_accept(res_id):
-        return super(CustomerPortal, self).portal_quote_accept(res_id, access_token=access_token, partner_name=partner_name, signature=signature)
+    def _portal_quote_user_can_accept(self, order_id):
-            self.transifex_url = False
+            self.update({'transifex_url': False})
-        return {'type': 'ir.actions.client', 'tag': 'reload'}
+    qty_remaining = fields.Float('Quantity To Be Produced', compute='_compute_qty_remaining', digits=dp.get_precision('Product Unit of Measure'))
-            raise UserError(_('Please set the quantity you produced in the Current Qty field. It can not be 0!'))
+            raise UserError(_('Please set the quantity you are currently producing. It should be different from zero.'))
-            if move.unit_factor:
+            if move.unit_factor and not move.move_line_ids.filtered(lambda m: not m.done_wo):
-            if not move_line.lot_id:
+            if move_line.product_id.tracking != 'none' and not move_line.lot_id:
-            lots = self.move_line_ids.filtered(lambda x: (x.lot_id.id == move_line.lot_id.id) and (not x.lot_produced_id) and (not x.done_move))
+            lots = self.move_line_ids.filtered(lambda x: (x.lot_id.id == move_line.lot_id.id) and (not x.lot_produced_id) and (not x.done_move) and (x.product_id == move_line.product_id))
-        self.assertEqual(len(production_table.workorder_ids), 3)
+        self.assertEqual(len(production_table.workorder_ids), 1)
-        self.assertEqual(workorders[2].state, 'pending')
+        workorder = production_table.workorder_ids[0]
-        # Process cutting operation...
+        # Process assembly line
-        self.assertEqual(workorders[0].state, 'done')
+        workorder.write({'final_lot_id': finished_lot.id})
-        #consume_quants = move_table_sheet.quant_ids + move_leg.quant_ids + move_table_bolt.quant_ids
+
-        help='Model of the followed resource')
+    # Note. There is no integrity check on model names for performance reasons.
-        'Related Document Model Name', index=True, readonly=True, related='res_model_id.model', compute_sudo=True, store=True)
+        'Related Document Model Name', required=True, index=True)
-            '&', ('res_model_id', '=', res_model_id), ('res_id', 'in', res_ids),
+            '&', ('res_model', '=', res_model), ('res_id', 'in', res_ids),
-            generic.append([0, 0, {'res_model_id': res_model_id, 'partner_id': pid, 'subtype_ids': [(6, 0, partner_data.get(pid) or default_subtypes.ids)]}])
+            generic.append([0, 0, {'res_model': res_model, 'partner_id': pid, 'subtype_ids': [(6, 0, partner_data.get(pid) or default_subtypes.ids)]}])
-            generic.append([0, 0, {'res_model_id': res_model_id, 'channel_id': cid, 'subtype_ids': [(6, 0, channel_data.get(cid) or default_subtypes.ids)]}])
+            generic.append([0, 0, {'res_model': res_model, 'channel_id': cid, 'subtype_ids': [(6, 0, channel_data.get(cid) or default_subtypes.ids)]}])
-                        'res_model_id': res_model_id,
+                        'res_model': res_model,
-                        'res_model_id': res_model_id,
+                        'res_model': res_model,
-                         {mail_channel_model_id})
+        self.assertEqual({item['res_model'] for item in items},
-        self.env['mail.followers'].create({'partner_id': self.user_employee.partner_id.id, 'res_model_id': mail_channel_model_id, 'res_id': self.test_pigs.id})
+        self.env['mail.followers'].create({'partner_id': self.user_employee.partner_id.id, 'res_model': 'mail.test', 'res_id': self.test_pigs.id})
-        self.assertEqual(generic[0][2]['res_model_id'], mail_channel_model_id)
+        self.assertEqual(generic[0][2]['res_model'], 'mail.test')
-        self.assertEqual(specific[self.test_public.id][0][2]['res_model_id'], mail_channel_model_id)
+        self.assertEqual(specific[self.test_public.id][0][2]['res_model'], 'mail.test')
-                'res_model_id': self.env['ir.model']._get('mail.test').id,
+                'res_model': test_record._name,
-    @queryCount(admin=39, demo=55)
+    @queryCount(admin=38, demo=54)
-    'test': ['test/partner_assign.yml'],
+# -*- coding: utf-8 -*-
-        default='HALF-UP', help='These values must correspond to the rounding_method of the float_round tools method.')
+        default='HALF-UP', help='The tie-breaking rule used for float rounding operations')
-            if message['model']:
+            if message['model'] and self.env[message['model']]._original_module:
-        if vals.get('product_uom_qty'):
+        if 'product_uom_qty' in vals:
-                picking.message_post('Backorder Created') #message needs to be improved
+                picking.message_post(_('The backorder <a href=# data-oe-model=stock.picking data-oe-id=%d>%s</a> has been created.') % (backorder_picking.id, backorder_picking.name))
-        readonly=True, required=True,
+        readonly=True, required=True, track_visibility='onchange',
-                    .filtered(lambda r: r.done_wo and not r.done_move and r.lot_produced_id == movelot.lot_id)\
+        for move_line in self:
-    _description = "Sales Order"
+    _description = "Quotation"
-            msg += "<ul>"
+            msg = "<b>The ordered quantity has been updated.</b><ul>"
-            return False
+            return {'error': _('Operation not allowed')}
-
+            return {'error': _('Invalid order')}
-            }
+            return {'error': _('Order is not in a state requiring customer validation.')}
-from configparser import ConfigParser
+try:
-            self.location_id = self.production_id.move_raw_ids.filtered(lambda x: x.state not in ('done', 'cancel')) and self.production_id.location_src_id.id or self.production_id.location_dest_id.id,
+            self.location_id = self.production_id.move_raw_ids.filtered(lambda x: x.state not in ('done', 'cancel')) and self.production_id.location_src_id.id or self.production_id.location_dest_id.id
-            self.env['stock.scrap'].with_context(active_model='mrp.production', active_id=production_3.id).create({'product_id': self.product_2.id, 'scrap_qty': 1.0, 'product_uom_id': self.product_2.uom_id.id, 'location_id': location_id, 'production_id': production_3.id})
+            scrap_id.do_scrap()
-from odoo.exceptions import UserError
+from odoo.exceptions import UserError, ValidationError
-            'origin': self.origin or self.picking_id.name,
+            'origin': self.origin or self.picking_id.name or self.name,
-
+        scrap.do_scrap()
-        action['domain'] = [('id', '=', self.move_id.id)]
+    def action_get_stock_move_lines(self):
-                raise UserError(_("Serial number is required for operation line with product '%s'") % (operation.product_id.name))
+    @api.constrains('lot_id', 'product_id')
-        action['context'] = {}
+        if self.product_variant_count == 1:
-        'data/account_tax_group_data.xml',
+        'views/res_partner.xml',
-        data['form']['used_context'] = dict(used_context, lang=self.env.context.get('lang', 'en_US'))
+        data['form']['used_context'] = dict(used_context, lang=self.env.context.get('lang') or 'en_US')
-                ('code', '=', self.env.context.get('lang', 'en_US'))
+                ('code', '=', self.env.context.get('lang') or 'en_US')
-        locale = self.env.context.get('lang', 'en_US')
+        locale = self.env.context.get('lang') or 'en_US'
-        locale = self.env.context.get('lang', 'en_US')
+        locale = self.env.context.get('lang') or 'en_US'
-            locale = request.context.get('lang', 'en_US')
+            locale = request.context.get('lang') or 'en_US'
-            '1': daily_leads_dict.get(babel.dates.format_date(d, format='dd MMM yyyy', locale=request.env.context.get('lang', 'en_US')), 0)
+            '1': daily_leads_dict.get(babel.dates.format_date(d, format='dd MMM yyyy', locale=request.env.context.get('lang') or 'en_US'), 0)
-        month = babel.dates.get_month_names('abbreviated', locale=event.env.context.get('lang', 'en_US'))[start_date.month]
+        month = babel.dates.get_month_names('abbreviated', locale=event.env.context.get('lang') or 'en_US')[start_date.month]
-            '1': daily_sales_dict.get(babel.dates.format_date(d, format='dd MMM yyyy', locale=request.env.context.get('lang', 'en_US')), 0)
+            '1': daily_sales_dict.get(babel.dates.format_date(d, format='dd MMM yyyy', locale=request.env.context.get('lang') or 'en_US'), 0)
-            locale=self._context.get('lang', 'en_US')
+            locale=self._context.get('lang') or 'en_US'
-            lines |= self.move_id.production_id.move_finished_ids.mapped('move_line_ids').filtered(lambda l: l.lot_id)
+            finished_moves = self.move_id.production_id.move_finished_ids
-            lines |= self.workorder_id.active_move_line_ids
+            raw_moves = self.move_id.raw_material_production_id.move_raw_ids
-            lines |= self.move_id.picking_id.move_line_ids.filtered(lambda ml: ml.product_id == self.product_id and (ml.lot_id or ml.lot_name))
+        picking_id = self.move_id.picking_id if self.move_id else self.picking_id
-            move_lines_to_check = self._get_similar_move_lines() - self._origin
+            move_lines_to_check = self._get_similar_move_lines() - self
-            return request.render(mypage.ir_ui_view_id.id, {
+            return request.render(mypage.view_id.id, {
-                'ir_ui_view_id': view.id
+                'view_id': view.id
-            '|', ('website_ids', 'in', website_id), ('website_ids', '=', False), ('ir_ui_view_id.arch_db', 'ilike', url)
+            '|', ('website_ids', 'in', website_id), ('website_ids', '=', False), ('view_id.arch_db', 'ilike', url)
-            page_view_ids.append(page.ir_ui_view_id.id)
+            page_view_ids.append(page.view_id.id)
-                record['__priority'] = min(round(page.ir_ui_view_id.priority / 32.0, 1), 1)
+            if page.view_id and page.view_id.priority != 16:
-    _inherits = {'ir.ui.view': 'ir_ui_view_id'}
+    _inherits = {'ir.ui.view': 'view_id'}
-    ir_ui_view_id = fields.Many2one('ir.ui.view', string='View', required=True, ondelete="cascade")
+    view_id = fields.Many2one('ir.ui.view', string='View', required=True, ondelete="cascade")
-        view = self.env['ir.ui.view'].browse(self.ir_ui_view_id.id)
+        view = self.env['ir.ui.view'].browse(self.view_id.id)
-            'ir_ui_view_id': new_view.id,
+            'view_id': new_view.id,
-                [('ir_ui_view_id', '=', self.ir_ui_view_id.id), ('id', '!=', self.id)]
+                [('view_id', '=', self.view_id.id), ('id', '!=', self.id)]
-                self.env['ir.ui.view'].search([('id', '=', self.ir_ui_view_id.id)]).unlink()
+                self.env['ir.ui.view'].search([('id', '=', self.view_id.id)]).unlink()
-    # This is needed to be able to display if page is a menu in /website/page_management
+    # This is needed to be able to display if page is a menu in /website/pages
-            'name': data['name'], 'url': url,
+            'key': 'website.' + slugify(data['name'], 50),
-        new_view = view.copy()
+        # website.page's ir.ui.view should have a different key than the one it
-            'name': self.name + ' (copy)',
+            'name': '%s %s' % (self.name,  _('(copy)')),
-                new_menu.write({'url': new_page.url, 'name': menu.name + ' (copy)', 'page_id': new_page.id})
+                new_menu.write({'url': new_page.url, 'name': '%s %s' % (menu.name,  _('(copy)')), 'page_id': new_page.id})
-            pages_linked_to_iruiview = self.env['website.page'].search(
+            pages_linked_to_iruiview = self.search(
-            :param object_id : object identifier eg: menu-5
+        """ Delete a page, given its identifier
-    'depends': ['sale_stock'],
+    'depends': ['sale_stock', 'sale_management'],
-        if (payload / 1024 / 1024 > 25):
+        file_size = len(post['datas']) * 3 / 4; # base64
-                Module.update_list()
+            _logger.info('updating modules list')
-                project = self.env['project.project'].create({
+                project = self.env['project.project'].sudo().create({
-                task = self.env['project.task'].create({
+                task = self.env['project.task'].sudo().create({
-        last_month = last_month or company.fiscalyear_last_month
+        last_day = last_day or (company and company.fiscalyear_last_day) or 31
-            group[int(line[inverse])].append(line.id)
+            group[get_id(line[inverse])].append(line.id)
-            text = html2text.html2text(email_body_utf8)
+            text = html2text.html2text(email_body)
-        result['context'] = {'default_product_id': self.mapped('product_variant_ids').id}
+        result['context'] = {'default_product_id': self.mapped('product_variant_ids')[0].id}
-            self.message_subscribe([new_message.author_id.id], force=False)
+        if author_id and model and self.ids and message_type != 'notification' and not self._context.get('mail_create_nosubscribe'):
-    @queryCount(admin=20, demo=33)
+    @queryCount(admin=19, demo=29)
-    @queryCount(admin=40, demo=58)
+    @queryCount(admin=39, demo=55)
-    @tools.ormcache('frozenset(self.env.user.groups_id.ids)', 'model_name')
+    @tools.ormcache('self.env.uid', 'model_name')
-    @tools.ormcache('frozenset(self.env.user.groups_id.ids)', 'model_name')
+    @tools.ormcache('self.env.uid', 'model_name')
-    @queryCount(admin=6, demo=6)
+    @queryCount(admin=4, demo=4)
-    @queryCount(admin=8, demo=8)
+    @queryCount(admin=6, demo=6)
-    @queryCount(admin=22, demo=35)
+    @queryCount(admin=20, demo=33)
-    @queryCount(admin=42, demo=60)
+    @queryCount(admin=40, demo=58)
-        if any(picking.state != 'assigned' for picking in pickings):
+        if any(picking.state not in ('assigned') for picking in pickings):
-        return self.write({'state': 'done'})
+
-        help='Batch associated to this picking')
+        help='Batch associated to this picking', copy=False)
-            wiz = self.env['stock.immediate.transfer'].create({'pick_id': self.id})
+            wiz = self.env['stock.immediate.transfer'].create({'pick_ids': [(4, self.id)]})
-        wiz = self.env['stock.backorder.confirmation'].create({'pick_id': self.id})
+        wiz = self.env['stock.backorder.confirmation'].create({'pick_ids': [(4, p.id) for p in self]})
-        self.ensure_one()
+        """ This method will loop over all the move lines of self and
-        for move in self.move_lines:
+        for move in self.mapped('move_lines'):
-        for ops in self.move_line_ids.filtered(lambda x: x.package_id and not x.product_id and not x.move_id):
+        for ops in self.mapped('move_line_ids').filtered(lambda x: x.package_id and not x.product_id and not x.move_id):
-        for pack in self.move_line_ids.filtered(lambda x: x.product_id and not x.move_id):
+        for pack in self.mapped('move_line_ids').filtered(lambda x: x.product_id and not x.move_id):
-        return res
+    pick_ids = fields.Many2many('stock.picking', 'stock_picking_backorder_rel')
-        self.pick_id.do_transfer()
+        self.pick_ids.action_done()
-            self.pick_id.message_post(body=_("Back order <em>%s</em> <b>cancelled</b>.") % (backorder_pick.name))
+            for pick_id in self.pick_ids:
-from odoo import api, fields, models, _
+from odoo import fields, models, _
-        return res
+    pick_ids = fields.Many2many('stock.picking', 'stock_picking_transfer_rel')
-        self.pick_id.do_transfer()
+        pick_to_backorder = self.env['stock.picking']
-        time_str = date.strftime(format_time)
+        date_str = date.strftime(format_date).decode('utf-8')
-            display_time = _("%s at (%s To %s) (%s)") % (date_str, time_str, duration.strftime(format_time), timezone)
+            duration_time = duration.strftime(format_time).decode('utf-8')
-            display_time = _("%s at %s To\n %s at %s (%s)") % (date_str, time_str, date_deadline.strftime(format_date), date_deadline.strftime(format_time), timezone)
+            dd_date = date_deadline.strftime(format_date).decode('utf-8')
-    def _fiscalyear_last_day_in_month(self):
+    @api.model
-                    % (company.fiscalyear_last_day, company.fiscalyear_last_month, company.name))
+        last_day_of_month = calendar.monthrange(current_year, last_month)[1]
-    fiscalyear_last_day = fields.Integer(related="company_id.fiscalyear_last_day", required=True)
+    fiscalyear_last_day = fields.Integer(related="company_id.fiscalyear_last_day", required=True,
-                                             required=True)
+                                             required=True,
-            raise UserError(_("The found valuation amount for product %s is zero. Which means there is probably a configuration error. Check the costing method and the standard price") % (self.product_id.name,))
+            raise UserError(_("The cost of %s is currently equal to 0. Change the cost or the configuration of your product to avoid an incorrect valuation.") % (self.product_id.name,))
-            landscape, self.env.user.company_id.paperformat_id,
+            [body],
-        if any(move.quantity_done for move in self): #TODO: either put in stock, or check there is a production order related to it
+        if any(move.quantity_done and (move.raw_material_production_id or move.production_id) for move in self):
-            for lot_id, occurrences in recorded_serials_counter.items():
+            lots_map = [(ml.product_id.id, ml.lot_id.name) for ml in self]
-                        'You cannot consume the same serial number twice. Please correct the serial numbers encoded.')
+                    return _('You cannot consume the same serial number twice. Please correct the serial numbers encoded.')
-            for lot_id, occurrences in recorded_serials_counter.items():
+            lots_map = [(ml.product_id.id, ml.lot_id.name) for ml in self]
-                    return _('You cannot consume the same serial number twice. Please correct the serial numbers encoded.')
+                    return _('You cannot use the same serial number twice. Please correct the serial numbers encoded.')
-            for lot_id, occurrences in recorded_serials_counter.items():
+            lots_map = [(ml.product_id.id, ml.lot_name) for ml in self]
-                    return _('You cannot consume the same serial number twice. Please correct the serial numbers encoded.')
+                    return _('You cannot use the same serial number twice. Please correct the serial numbers encoded.')
-            matches = re.finditer(br'[^%]%\((.*?)\)[ds]', s)
+            matches = re.finditer(br'[^%]%\((.*?)\)[ds]'.decode('utf-8'), s)
-                id = m.groups()[0].decode('utf-8')
+                id = m.groups()[0]
-            s = s.replace(b'%%', b'%') # Quite wierd but it's for (somewhat) backward compatibility sake
+                s = s.replace(found, pycompat.text_type(self.idref[id]))
-                +_process(b"".join(etree.tostring(n, encoding='utf-8') for n in node))
+            return '<?xml version="1.0"?>\n'\
-            return _process(b"".join(etree.tostring(n, encoding='utf-8') for n in node))
+            return _process("".join(etree.tostring(n, encoding='unicode') for n in node))
-            return [('id', 'parent_of', packs.ids)]
+            return [('id', 'in', packs.ids)]
-                cost_to_add = line.additional_landed_cost
+                # Prorate the value at what's still in stock
-                line._create_accounting_entries(move, 0) #TODO: qty_out like you would do with the different moves
+                line.move_id.remaining_value += cost_to_add
-            if move.product_id.valuation != 'real_time' or move.product_id.cost_method not in ('average', 'fifo'):
+            if move.product_id.valuation != 'real_time' or move.product_id.cost_method != 'fifo':
-# from . import test_stock_landed_costs_purchase
+from . import test_stock_landed_costs_purchase
-        self.picking_in.do_transfer()
+        res_dict = self.picking_in.button_validate()
-        self.picking_out.do_transfer()
+
-                product.stock_value = sum(moves.mapped('value'))
+                product.stock_value = sum(moves.mapped('remaining_value'))
-            for move_line in self.filtered(lambda ml: ml.state == 'done'):
+            for move_line in self.filtered(lambda ml: ml.state == 'done' and (ml.move_id._is_in() or ml.move_id._is_out())):
-                # more/less units are available, update `value`, `remaining_value` and
+                # more/less units are available, update `remaining_value` and
-                }
+                move_vals = {'remaining_qty': move_id.remaining_qty + qty_difference}
-                        move_id.with_context(force_valuation_amount=qty_difference*move_id.price_unit)._account_entry_move()
+                    move_id.with_context(force_valuation_amount=correction_value)._account_entry_move()
-    remaining_value = fields.Float()
+    value = fields.Float(copy=False)
-    def get_price_unit(self):
+    def _get_price_unit(self):
-                    price_unit = move.price_unit or move.get_price_unit()
+                    price_unit = move.price_unit or move._get_price_unit()
-                        move.write(vals)
+                    self.env['stock.move']._run_fifo(move)
-        for move in res.filtered(lambda m: m.product_id.valuation == 'real_time'):
+        for move in res.filtered(lambda m: m.product_id.valuation == 'real_time' and (m._is_in() or m._is_out())):
-    def product_price_update_before_done(self):
+    def product_price_update_before_done(self, forced_qty=None):
-                new_std_price = move.get_price_unit()
+                new_std_price = move._get_price_unit()
-                new_std_price = ((amount_unit * product_tot_qty_available) + (move.get_price_unit() * move.product_qty)) / (product_tot_qty_available + move.product_qty)
+                qty = forced_qty or move.product_qty
-        # FIXME: sort by date (does filtered lose the order?)
+                ('remaining_qty', '>', 0),
-            domain += self._get_in_domain()
+            domain += move._get_in_domain()
-                return
+                continue
-            corrected_value = move.remaining_value + tmp_value
+            remaining_value_before_vacuum = move.remaining_value
-            return []
+            raise UserError(_("The found valuation amount for product %s is zero. Which means there is probably a configuration error. Check the costing method and the standard price") % (self.product_id.name,))
-        self.assertEqual(move1.value, 120.0)
+        self.assertEqual(move1.value, 100.0)
-        self.assertEqual(move1.value, 120)
+        self.assertEqual(move1.value, 100)
-        self.assertEqual(move1.value, 120)
+        self.assertEqual(move1.value, 100)
-        self.assertEqual(move1.value, 120)
+        self.assertEqual(move1.value, 100)
-        self.assertEqual(move1.value, 120)
+        self.assertEqual(move1.value, 100)
-        self.assertEqual(move5.value, -200.0)
+        self.assertEqual(move5.value, -160.0)
-        self.assertEqual(move6.value, 96)
+        self.assertEqual(move6.value, 120)
-        self.assertEqual(move1.value, 120)
+        self.assertEqual(move1.value, 100)
-        self.assertEqual(move5.value, -200.0)
+        self.assertEqual(move5.value, -160.0)
-        self.assertEqual(move6.value, 90)
+        self.assertEqual(move6.value, 120)
-        self.assertEqual(move1.remaining_qty, -50.0)
+        # stock values for move1
-        self.assertEqual(move1.value, -600.0)
+        # stock values for move1 and move2
-        self.assertEqual(move1.value, -850.0)
+        # stock values for move1-3
-                'location_dest_id': self.customer_location.id,
+                'location_id': self.supplier_location.id,
-            'name': '10 in',
+            'name': '12 out (2 negative)',
-        """
+    def test_average_perpetual_2(self):
-            'name': 'test_average_negative_1',
+            'name': 'Receive 10 units at 10',
-        move1.quantity_done = 10.0
+        move1._action_assign()
-        """ Send goods that you don't have in stock but received and send some units before.
+        move2 = self.env['stock.move'].create({
-            'name': '68 units @ 15.00 per unit',
+            'name': 'Receive 10 units at 10',
-            'name': 'Sale 94 units @ 19.00 per unit',
+            'name': 'send 20 units',
-            'product_uom_qty': 10.0,
+            'product_uom_qty': 20.0,
-        move2.move_line_ids.qty_done = 10.0
+        move2._force_assign()
-        self.assertEqual(move2.remaining_qty, 0.0)  # unused in average move
+        valuation_aml = self._get_stock_valuation_move_lines()
-            'name': 'Sale 94 units @ 19.00 per unit',
+        move2.quantity_done = 10.0
-        self.assertEqual(move3.remaining_qty, 0.0)  # unused in average move
+        move1._action_confirm()
-        'views/product_views.xml',
+        'data/stock_account_data.xml',
-        'data/stock_account_data.xml',
+        'views/product_views.xml',
-        action['domain'] = [('product_id.product_tmpl_id', '=', self.id)]
+        action = self.env.ref('stock_account.product_valuation_action').read()[0]
-        action['domain'] = [('product_id', '=', self.id)]
+        action = self.env.ref('stock_account.product_valuation_action').read()[0]
-from . import wizard_valuation_history
+
-        return action
+# -*- coding: utf-8 -*-
-                    qty = from_uom._compute_quantity(qty, to_uom_id=to_uom)
+                    qty = from_uom._compute_quantity(qty, to_uom)
-                    qty = from_uom._compute_quantity(qty, to_uom_id=to_uom)
+                    qty = from_uom._compute_quantity(qty, to_uom)
-            views = self.search(conditions + [('id', 'in', list(self._context.get('check_view_ids') or (0,)) + views.ids)])
+            views_cond = [('id', 'in', list(self._context.get('check_view_ids') or (0,)) + views.ids)]
-            views = self.search(conditions)
+            views = self.search(conditions, order=INHERIT_ORDER)
-            cmd_output = ''.join(result)
+            cmd_output = ''.join(misc.ustr(result))
-        # by the signal handler.) The try/except is for the win32 case.
+        # by the signal handler)
-            select.select([self.multi.socket], [], [], self.multi.beat)
+            wakeup_fd = self.eintr_pipe[0]
-            time.sleep(interval)
+
-            current._Thread__daemonic = True
+            current._Thread__daemonic = True # PY2
-    threads_info = {th.ident: {'name': th.name,
+    threads_info = {th.ident: {'repr': repr(th),
-                     threadId,
+        code.append("\n# Thread: %s (db:%s) (uid:%s) (url:%s)" %
-        return user_activities.values()
+        return list(user_activities.values())
-            return request.render("survey.nopages")
+            return request.render("survey.nopages", {'survey': survey})
-import datetime
+from odoo import api, models
-        if self.model == 'sale.order' and context.get('active_ids'):
+        if context.get('website_sale_send_recovery_email') and self.model == 'sale.order' and context.get('active_ids'):
-                ('cart_recovery_email_sent', '!=', True),
+                ('cart_recovery_email_sent', '=', False),
-        if self.model == 'sale.order':
+        if self.model == 'sale.order' and context.get('active_ids'):
-            template = self.env.ref('base.view_company_report_form')
+        discard_logo_check = self.env.context.get('discard_logo_check')
-                'context': {'default_report_name': self.report_name},
+                'context': {'default_report_name': self.report_name, 'discard_logo_check': True},
-            return base64.decodestring(save_in_attachment.values()[0].datas)
+            return base64.decodestring(list(save_in_attachment.values())[0].datas)
-        if self.state == 'draft' or no_quantities_done:
+        if no_quantities_done:
-    show_operations = fields.Boolean(related='picking_type_id.show_operations')
+    show_operations = fields.Boolean(compute='_compute_show_operations')
-            if not self.move_lines:
+            if not picking.move_lines:
-    @api.depends('state')
+    @api.depends('state', 'move_lines')
-            if self._context.get('planned_picking') and picking.state == 'draft':
+            if not self.move_lines:
-                raise UserError(_("Only a draft payment can be posted. Trying to post a payment in state %s.") % rec.state)
+                raise UserError(_("Only a draft payment can be posted."))
-        distinct_fields = ['price_unit', 'product_id', 'product_packaging',
+        distinct_fields = ['product_id', 'price_unit', 'product_packaging',
-            return tuple([getattr(move, attr) for attr in distinct_fields])
+            return move.product_id.id, move.price_unit, move.product_packaging.id, move.product_uom.id,\
-        self.assertEqual(len(picking_in.move_lines), 6, 'Wrong number of move lines.')
+        self.assertEqual(len(picking_in.move_lines), 4, 'Wrong number of move lines.')
-        self.assertEqual(set(a_done_qty), set([1.0, 3.0]), 'Wrong move quantity for product A.')
+        self.assertEqual(moves.product_uom_qty, 4.0, 'Wrong move quantity for product A.')
-        self.assertEqual(set(b_done_qty), set([4.0, 1.0]), 'Wrong move quantity for product B.')
+        self.assertEqual(moves.product_uom_qty, 5.0, 'Wrong move quantity for product B.')
-        self.assertEqual(len(picking_out.move_lines), 5, 'Wrong number of move lines')
+        self.assertEqual(len(picking_out.move_lines), 4, 'Wrong number of move lines')
-        self.assertEqual(len(back_order_in.move_lines), 4, 'Wrong number of move lines')
+        self.assertEqual(len(back_order_in.move_lines), 3, 'Wrong number of move lines')
-        self.assertEqual(set(c_done_qty), set([3.0, 3.0]), 'Wrong quantity of moves product C.')
+        self.assertEqual(movesC.product_uom_qty, 6.0, 'Wrong quantity of moves product C.')
-                self._get_click_values(dict(
+                self._get_click_values_from_route(dict(
-        elif 'opt_out' in self.env[self.mailing_model_name]._fields and not self.mailing_domain:
+        elif self.mailing_model_name and 'opt_out' in self.env[self.mailing_model_name]._fields and not self.mailing_domain:
-from psycopg2 import OperationalError
+from psycopg2 import OperationalError, Error
-        self.env.cr.execute(query)
+        try:
-                new_url = request.httprequest.path.replace('//', '/') + '?' + request.httprequest.query_string
+                new_url = request.httprequest.path.replace('//', '/') + '?' + request.httprequest.query_string.decode('utf-8')
-                    redirect = request.redirect(path + '?' + request.httprequest.query_string)
+                    redirect = request.redirect(path + '?' + request.httprequest.query_string.decode('utf-8'))
-                    path += '?' + request.httprequest.query_string
+                    path += '?' + request.httprequest.query_string.decode('utf-8')
-    @api.onchange('amount')
+    @api.onchange('amount','currency_id')
-from datetime import timedelta
+from datetime import timedelta, datetime
-        'stock.location', "Source Location Zone",
+        'stock.location', "Source Location",
-def binary_content(xmlid=None, model='ir.attachment', id=None, field='datas', unique=False, filename=None, filename_field='datas_fname', download=False, mimetype=None, default_mimetype='application/octet-stream', env=None):
+def binary_content(xmlid=None, model='ir.attachment', id=None, field='datas', unique=False,
-        download=download, mimetype=mimetype, default_mimetype=default_mimetype, env=env)
+        xmlid=xmlid, model=model, id=id, field=field, unique=unique, filename=filename,
-        status, headers, content = binary_content(xmlid=xmlid, model=model, id=id, field=field, unique=unique, filename=filename, filename_field=filename_field, download=download, mimetype=mimetype)
+    def content_common(self, xmlid=None, model='ir.attachment', id=None, field='datas',
-        status, headers, content = binary_content(xmlid=xmlid, model=model, id=id, field=field, unique=unique, filename=filename, filename_field=filename_field, download=download, mimetype=mimetype, default_mimetype='image/png')
+    def content_image(self, xmlid=None, model='ir.attachment', id=None, field='datas',
-    def binary_content(cls, xmlid=None, model='ir.attachment', id=None, field='datas', unique=False, filename=None, filename_field='datas_fname', download=False, mimetype=None, default_mimetype='application/octet-stream', env=None):
+    def binary_content(cls, xmlid=None, model='ir.attachment', id=None, field='datas',
-        return super(Http, cls).binary_content(xmlid=xmlid, model=model, id=id, field=field, unique=unique, filename=filename, filename_field=filename_field, download=download, mimetype=mimetype, default_mimetype=default_mimetype, env=env)
+        return super(Http, cls).binary_content(
-    def binary_content(cls, xmlid=None, model='ir.attachment', id=None, field='datas', unique=False, filename=None, filename_field='datas_fname', download=False, mimetype=None, default_mimetype='application/octet-stream', env=None):
+    def binary_content(cls, xmlid=None, model='ir.attachment', id=None, field='datas',
-def _special_access_object(res_model, res_id, token='', token_field=''):
+def _has_token_access(res_model, res_id, token=''):
-    return False
+    token_field = request.env[res_model]._mail_post_token_field
-def _message_post_helper(res_model='', res_id=None, message='', token='', token_field='token', nosubscribe=True, **kw):
+def _message_post_helper(res_model='', res_id=None, message='', token='', nosubscribe=True, **kw):
-        access_as_sudo = _special_access_object(res_model, res_id, token=token, token_field=token_field)
+    if token:
-            access_as_sudo = _special_access_object(res_model, res_id, token=kw.get('token'), token_field=kw.get('token_field'))
+            access_as_sudo = _has_token_access(res_model, res_id, token=kw.get('token'))
-            **({'token': access_token, 'token_field': 'access_token'} if access_token else {}))
+            **({'token': access_token} if access_token else {}))
-            _message_post_helper(res_model='sale.order', res_id=Order.id, message=body, token=token, token_field="access_token", message_type='notification', subtype="mail.mt_note", partner_ids=Order.user_id.sudo().partner_id.ids)
+            _message_post_helper(res_model='sale.order', res_id=Order.id, message=body, token=token, message_type='notification', subtype="mail.mt_note", partner_ids=Order.user_id.sudo().partner_id.ids)
-            _message_post_helper(message=message, res_id=order_id, res_model='sale.order', **{'token': token, 'token_field': 'access_token'} if token else {})
+            _message_post_helper(message=message, res_id=order_id, res_model='sale.order', **{'token': token} if token else {})
-            if not rec.name and self.payment_type != 'transfer':
+            if not rec.name and rec.payment_type != 'transfer':
-            self.total_amount = 0.0
+        total_amount = 0.0
-        child.tag in ('field', 'button', 'renamed_field')
+        child.tag in ('field', 'button')
-        child.tag in ('field', 'button')
+        child.tag in ('field', 'button', 'renamed_field')
-    @queryCount(admin=43, demo=61)
+    @queryCount(admin=42, demo=60)
-    def write(self, records, value):
+    def write(self, records, value, create=False):
-    def write(self, records, value):
+    def write(self, records, value, create=False):
-        atts = records.env['ir.attachment'].sudo().search(domain)
+        if create:
-    def write(self, records, value):
+    def write(self, records, value, create=False):
-    def write(self, records, value):
+    def write(self, records, value, create=False):
-        if clear:
+        if clear and not create:
-                field.write(self.with_context(rel_context), vals[name])
+                field.write(self.with_context(rel_context), vals[name], create=True)
-        channels_sudo = self.env['mail.channel'].sudo() | self_sudo.channel_ids
+        partners_sudo = self_sudo.partner_ids
-            followers = self.env['mail.followers'].sudo().search([
+            followers = self_sudo.env['mail.followers'].search([
-        }
+        message_values = {}
-        self.write(message_values)
+        if message_values:
-        ])._notify(self, force_send=force_send, send_after_commit=send_after_commit, user_signature=user_signature)
+        notif_partners = partners_sudo.filtered(lambda partner: 'inbox' in partner.mapped('user_ids.notification_type'))
-    @queryCount(admin=42, demo=59)
+    @queryCount(admin=22, demo=35)
-    @queryCount(admin=81, demo=107)
+    @queryCount(admin=43, demo=61)
-        lead_model_id = self.env['ir.model'].search([('model', '=', 'crm.lead')]).id
+        lead_model_id = self.env['ir.model']._get('crm.lead').id
-        lead_model_id = self.env['ir.model'].search([('model', '=', 'crm.lead')]).id
+        lead_model_id = self.env['ir.model']._get('crm.lead').id
-                        'mailing_model_id': self.env['ir.model'].search([('model', '=', self.model)], limit=1).id,
+                        'mailing_model_id': self.env['ir.model']._get(self.model).id,
-             "\n* Transit Location: Counterpart location that should be used in inter-companies or inter-warehouses operations")
+             "\n* Transit Location: Counterpart location that should be used in inter-company or inter-warehouses operations")
-                    if self.voucher_type == 'sale' else self.journal_id.default_credit_account_id
+                account_type = self.voucher_type == 'purchase' and 'payable' or 'receivable'
-            return self.env['account.journal'].search([('type', '=', self.env.context['default_journal_type'])], limit=1).id
+            return self.env['account.journal'].search([('company_id', '=', self.env.user.company_id.id), ('type', '=', self.env.context['default_journal_type'])], limit=1).id
-from . import res_config_settings
+from . import res_config_settings
-                        if float_compare(qty_to_consume, 0.0, precision_rounding=move.product_uom.rounding) < 0:
+                        if float_compare(qty_to_consume, 0.0, precision_rounding=move.product_uom.rounding) < 0\
-                lots.add(move_lot.lot_id)
+    def _get_similar_move_lines(self):
-from odoo.exceptions import UserError
+from odoo.exceptions import UserError, ValidationError
-from odoo import api, fields, models, _
+from collections import Counter
-            raise UserError(_('You should provide a lot for the final product'))
+            raise UserError(_('You should provide a lot/serial number for the final product'))
-                raise UserError(_('You should provide a lot for a component'))
+                raise UserError(_('You should provide a lot/serial number for a component'))
-            journal_type.append('general')
+            journal_type = ['general']
-            self.journal_id = self.env['account.journal'].search([('type', '=', 'general')], limit=1)
+
-        return {product.id: product.website_price // add_qty for product in products}
+        return {product.id: product.website_price / add_qty for product in products}
-                conn.simple_bind_s(dn, password.encode('utf-8'))
+                conn.simple_bind_s(dn, to_native(password))
-            results = conn.search_st(conf['ldap_base'].encode('utf-8'), ldap.SCOPE_SUBTREE, filter, retrieve_attributes, timeout=60)
+            conn.simple_bind_s(to_native(ldap_binddn), to_native(ldap_password))
-    term = (term or "").strip().encode('utf8')
+    term = (term or "").strip()
-            self.price_unit = self.env['account.tax']._fix_tax_included_price(price, self.product_id.taxes_id, tax_ids_after_fiscal_position)
+            self.price_unit = self.env['account.tax']._fix_tax_included_price_company(price, self.product_id.taxes_id, tax_ids_after_fiscal_position, self.company_id)
-        price_unit = self.env['account.tax']._fix_tax_included_price(seller.price, self.product_id.supplier_taxes_id, self.taxes_id) if seller else 0.0
+        price_unit = self.env['account.tax']._fix_tax_included_price_company(seller.price, self.product_id.supplier_taxes_id, self.taxes_id, self.company_id) if seller else 0.0
-                    price_unit = self.env['account.tax']._fix_tax_included_price(seller.price, procurement.purchase_line_id.product_id.supplier_taxes_id, procurement.purchase_line_id.taxes_id) if seller else 0.0
+                    price_unit = self.env['account.tax']._fix_tax_included_price_company(seller.price, procurement.purchase_line_id.product_id.supplier_taxes_id, procurement.purchase_line_id.taxes_id, self.company_id) if seller else 0.0
-        price_unit = self.env['account.tax']._fix_tax_included_price(seller.price, self.product_id.supplier_taxes_id, taxes_id) if seller else 0.0
+        price_unit = self.env['account.tax']._fix_tax_included_price_company(seller.price, self.product_id.supplier_taxes_id, taxes_id, self.company_id) if seller else 0.0
-                    price_unit = self.env['account.tax']._fix_tax_included_price(seller.price, line.product_id.supplier_taxes_id, line.taxes_id) if seller else 0.0
+                    price_unit = self.env['account.tax']._fix_tax_included_price_company(seller.price, line.product_id.supplier_taxes_id, line.taxes_id, self.company_id) if seller else 0.0
-            vals['price_unit'] = self.env['account.tax']._fix_tax_included_price(self._get_display_price(product), product.taxes_id, self.tax_id)
+            vals['price_unit'] = self.env['account.tax']._fix_tax_included_price_company(self._get_display_price(product), product.taxes_id, self.tax_id, self.company_id)
-            self.price_unit = self.env['account.tax']._fix_tax_included_price(self._get_display_price(product), product.taxes_id, self.tax_id)
+            self.price_unit = self.env['account.tax']._fix_tax_included_price_company(self._get_display_price(product), product.taxes_id, self.tax_id, self.company_id)
-        new_list_price = self.env['account.tax']._fix_tax_included_price(new_list_price, self.product_id.taxes_id, self.tax_id)
+        new_list_price = self.env['account.tax']._fix_tax_included_price_company(new_list_price, self.product_id.taxes_id, self.tax_id, self.company_id)
-                pu = self.env['account.tax']._fix_tax_included_price(pu, product.taxes_id, order_line[0].tax_id)
+                pu = self.env['account.tax']._fix_tax_included_price_company(pu, product.taxes_id, order_line[0].tax_id, self.company_id)
-                values['price_unit'] = self.env['account.tax']._fix_tax_included_price(
+                values['price_unit'] = self.env['account.tax']._fix_tax_included_price_company(
-                    order_line.tax_id
+                    order_line.tax_id,
-        if self.product_uom_qty and float_compare(self.quantity_done, self.product_uom_qty, precision_rounding=rounding) > 0:
+        if float_compare(self.quantity_done, self.product_uom_qty, precision_rounding=rounding) > 0:
-            .sorted(key=lambda move: sort_map.get(move.state, 0))
+            .sorted(key=lambda move: (sort_map.get(move.state, 0), move.product_uom_qty))
-            if moves_todo[0].state in ('partially_available', 'confirmed'):
+            most_important_move = moves_todo[0]
-            return moves_todo[-1].state or 'draft'
+            least_important_move = moves_todo[-1]
-            self.state = self.move_lines._get_relevant_state_among_moves()
+            relevant_move_state = self.move_lines._get_relevant_state_among_moves()
-            This tests two cases:
+            This tests three cases:
-    def test_immediate_validate_575487534895(self):
+    def test_immediate_validate_5(self):
-    def test_immediate_validate_5(self):
+    def test_immediate_validate_6(self):
-            if move.state == 'draft':
+            if self._context.get('planned_picking'):
-            elif move.state != 'done' and move.picking_id and not move.picking_id.is_locked:
+            elif not move.picking_id.is_locked and move.state != 'done' and move.picking_id:
-        return super(Picking, self).create(vals)
+        res = super(Picking, self).create(vals)
-            reassign = order.picking_ids.filtered(lambda x: x.state=='confirmed' or ((x.state in ['partially_available', 'waiting']) and not x.printed))
+            reassign = order.picking_ids.filtered(lambda x: x.state=='confirmed' or (x.state in ['waiting', 'assigned'] and not x.printed))
-            ('picking_id.state', 'in', ['draft', 'confirmed', 'waiting', 'partially_available', 'assigned']),
+            ('picking_id.state', 'in', ['draft', 'confirmed', 'waiting', 'assigned']),
-            'count_picking_backorders': [('backorder_id', '!=', False), ('state', 'in', ('confirmed', 'assigned', 'waiting', 'partially_available'))],
+            'count_picking_ready': [('state', '=', 'assigned')],
-        ('draft', 'Draft'), ('cancel', 'Cancelled'),
+        ('draft', 'Draft'),
-        ('assigned', 'Available'), ('done', 'Done')], string='Status', compute='_compute_state',
+        ('confirmed', 'Waiting'),
-             " * Cancelled: has been cancelled, can't be confirmed anymore")
+        help=" * Draft: not confirmed yet and will not be scheduled until confirmed.\n"
-          - otherwise in waiting or confirmed state
+        - Draft: only used for "planned pickings"
-        self.assertEqual(picking_client.state, 'partially_available')
+        self.assertEqual(picking_client.state, 'assigned')
-        self.assertEqual(picking_client.state, 'partially_available')
+        self.assertEqual(picking_client.state, 'assigned')
-        self.assertEqual(picking_client.state, 'partially_available', 'The state of the client should be partially available')
+        self.assertEqual(picking_client.state, 'assigned', 'The state of the client should be partially available')
-        self.assertEqual(delivery_order.state, 'partially_available')
+        self.assertEqual(delivery_order.state, 'assigned')
-        self.assertEqual(delivery_order.state, 'partially_available')
+        self.assertEqual(delivery_order.state, 'assigned')
-        self.assertEqual(delivery_order.state, 'partially_available')
+        self.assertEqual(delivery_order.state, 'assigned')
-        self.assertEqual(delivery_order.state, 'partially_available')
+        self.assertEqual(delivery_order.state, 'assigned')
-        self.assertEqual(delivery_order.state, 'partially_available')
+        self.assertEqual(delivery_order.state, 'assigned')
-        # picking: confirmed == waiting availability, partially_available = partially available
+        # picking: confirmed == waiting availability
-        self.assertEquals(picking_out.state, "partially_available")
+        self.assertEquals(picking_out.state, "assigned")
-            if tools.config['test_enable']:
+            if tools.config['test_enable'] and odoo.modules.module.current_test:
-            ]).filtered(lambda fol: self.subtype_id in fol.subtype_ids)
+                ('res_id', '=', self.res_id),
-    @queryCount(admin=44, demo=61)
+    @queryCount(admin=42, demo=59)
-    @queryCount(admin=85, demo=111)
+    @queryCount(admin=81, demo=107)
-            'rule_ids': [(4, [self.hra_rule_id, self.conv_rule_id, self.prof_tax_rule_id, self.pf_rule_id, self.mv_rule_id, self.comm_rule_id])]
+            'rule_ids': [(4, self.hra_rule_id), (4, self.conv_rule_id),
-            'employee_ids': [(4, self.richard_emp.ids)]
+            'employee_ids': [(4, self.richard_emp.id)]
-            'employee_ids': [(4, self.rahul_emp.ids)]
+            'employee_ids': [(4, self.rahul_emp.id)]
-        move_pack_cust.write({'move_orig_ids': [(4, [move_stock_pack_1.id, move_stock_pack_2.id], 0)]})
+        move_pack_cust.write({'move_orig_ids': [(4, move_stock_pack_1.id, 0), (4, move_stock_pack_2.id, 0)]})
-        move_pack_cust.write({'move_orig_ids': [(4, [move_stock_pack_1.id, move_stock_pack_2.id], 0)]})
+        move_pack_cust.write({'move_orig_ids': [(4, move_stock_pack_1.id, 0), (4, move_stock_pack_2.id, 0)]})
-        move_stock_pack.write({'move_dest_ids': [(4, move_pack_cust_1.id, move_pack_cust_2.id, 0)]})
+        move_stock_pack.write({'move_dest_ids': [(4, move_pack_cust_1.id, 0), (4, move_pack_cust_2.id, 0)]})
-        move_stock_stock_1.write({'move_orig_ids': [(4, [move_supp_stock_1.id, move_supp_stock_2.id], 0)]})
+        move_stock_stock_1.write({'move_orig_ids': [(4, move_supp_stock_1.id, 0), (4, move_supp_stock_2.id, 0)]})
-        move_stock_stock_2.write({'move_orig_ids': [(4, [move_supp_stock_1.id, move_supp_stock_2.id], 0)]})
+        move_stock_stock_2.write({'move_orig_ids': [(4, move_supp_stock_1.id, 0), (4, move_supp_stock_2.id, 0)]})
-        """ Create records with lines. """
+        """ Create records with one2many lines. """
-            cr.execute(query, [tuple(records.ids)] + params)
+        clear = False           # whether the relation should be cleared
-                link(lines.ids)
+                for record in records:
-                unlink([act[1]])
+                links[act[1]] = False
-                link([act[1]])
+                links[act[1]] = True
-                unlink_all()
+                clear = True
-                link(act[2])
+                clear = True
-        external_default_subtypes = default_subtypes.filtered(lambda subtype: not subtype.internal)
+        default_subtypes, _internal_subtypes, external_subtypes = \
-                        partner_data[pid] = external_default_subtypes.ids
+                        partner_data[pid] = external_subtypes.ids
-from odoo import fields, models
+from odoo import api, fields, models, tools
-        subtypes = self.env['mail.message.subtype'].search(['|', ('res_model', '=', False), ('parent_id.res_model', '=', self._name)])
+        subtypes, relation_fields = self.env['mail.message.subtype'].auto_subscribe_subtypes(self._name)
-        if not any(relation in updated_fields for relation in relation_fields) and not user_field_lst:
+        if not any(relation in relation_fields for relation in updated_fields) and not user_field_lst:
-    @queryCount(admin=7, demo=7)
+    @queryCount(admin=6, demo=6)
-    @queryCount(admin=9, demo=9)
+    @queryCount(admin=8, demo=8)
-    @queryCount(admin=45, demo=62)
+    @queryCount(admin=44, demo=61)
-    @queryCount(admin=87, demo=114)
+    @queryCount(admin=85, demo=111)
-                                     "as user %s" % user.login)
+                self.assertQueryCount(self.cr.sql_log_count - self._count,
-    color = fields.Integer("Color Index", default=1)
+    color = fields.Integer("Color Index", default=0)
-                    {'name': _('Vendor Bills'), 'type': 'purchase', 'code': _('BILL'), 'favorite': True, 'sequence': 6},
+        journals = [{'name': _('Customer Invoices'), 'type': 'sale', 'code': _('INV'), 'favorite': True, 'color': 11, 'sequence': 5},
-    color = fields.Integer('Color Index', default=1)
+    color = fields.Integer('Color Index')
-    color = fields.Integer("Color Index", default=1)
+    color = fields.Integer("Color Index")
-    color = fields.Integer("Color Index", default=1)
+    color = fields.Integer("Color Index", default=0)
-            color = other_pick_type and other_pick_type.color or 1
+            color = other_pick_type.color if other_pick_type else 0
-    color = fields.Integer(string='Color Index', help="The color of the channel", default=1)
+    color = fields.Integer(string='Color Index', help="The color of the channel")
-        color = available_colors and available_colors[0] or 1
+        available_colors = [zef for zef in range(0, 12) if zef not in all_used_colors]
-            exec(sys.stdin, local_vars)
+            exec(sys.stdin.read(), local_vars)
-        src_file = open(fabsolutepath, 'r')
+        src_file = open(fabsolutepath, 'rb')
-        for k, v in vals.items():
+        for k, v in list(vals.items()):
-                if move_date > self.company_id.period_lock_date and newly_created_move.date != move_date:
+                if move_date > (self.company_id.period_lock_date or '0000-00-00') and newly_created_move.date != move_date:
-                    for lot in lots_grouped.get(mapping, {}).keys()],
+                    (0, 0, {
-            for dotname in field_onchange:
+            for dotname in dotnames:
-                for dotname in field_onchange:
+                for dotname in dotnames:
-        for dotname in field_onchange:
+        for dotname in dotnames:
-            return
+        self.started = True
-dispatch = ImDispatch().start()
+dispatch = None
-         # import pdb;pdb.set_trace()
+    is_expired = fields.Boolean(compute='_compute_is_expired', string="Is expired")
-            color = other_pick_type and other_pick_type.color or 1
+            color = other_pick_type.color if other_pick_type else 1
-        color = available_colors and available_colors[0] or 1
+        available_colors = [zef for zef in [1, 3, 4, 5, 6, 7, 8, 0, 2] if zef not in all_used_colors]
-            custom_layout="account.mail_template_data_notification_email_account_invoice"
+            custom_layout="account.mail_template_data_notification_email_account_invoice",
-            'custom_layout': "purchase.mail_template_data_notification_email_purchase_order"
+            'custom_layout': "purchase.mail_template_data_notification_email_purchase_order",
-            'proforma': self.env.context.get('proforma', False)
+            'proforma': self.env.context.get('proforma', False),
-        payment = self.env['account.payment'].create({
+        payment_vals = {
-        })
+        }
-                created_invoice.pay_and_reconcile(tx.acquirer_id.journal_id, pay_amount=created_invoice.amount_total)
+                created_invoice.with_context(tx_currency_id=tx.currency_id.id).pay_and_reconcile(tx.acquirer_id.journal_id, pay_amount=created_invoice.amount_total)
-        'account',
+        'account_tax_python',
-        'account',
+        'account_tax_python',
-                rating.rating_image = base64.b64decode(open(image_path, 'rb').read())
+                rating.rating_image = base64.b64encode(open(image_path, 'rb').read())
-            if (defaults.get('res_model') and defaults['res_model'] == 'hr.applicant') or self.env['ir.model'].sudo().browse(defaults['res_model_id']).model == 'hr.applicant':
+            if (defaults.get('res_model') and defaults['res_model'] == 'hr.applicant') or (defaults.get('res_model_id') and self.env['ir.model'].sudo().browse(defaults['res_model_id']).model == 'hr.applicant'):
-__import__('pkg_resources').declare_namespace(__name__)
+# make odoo.addons a namespace package, while keeping this __init__.py
-        self.priority = self.mapped('move_lines') and max(self.mapped('move_lines').mapped('priority')) or '1'
+        if self.mapped('move_lines'):
-    def _action_confirm(self):
+    def _action_confirm(self, merge=True):
-        return super(StockMove, moves)._action_confirm()
+        return super(StockMove, moves)._action_confirm(merge=merge)
-        self.assertEqual(len(self.po.order_line.move_ids), 2, 'Two move should be created')
+        self.assertEqual(len(self.po.order_line.move_ids), 1, 'The two moves should be merged in one')
-        """ Confirms stock move or put it in waiting if it's linked to another move. """
+    def _action_confirm(self, merge=True):
-        """ Reserve stock moves by creating their stock move lines. A stock move is 
+        """ Reserve stock moves by creating their stock move lines. A stock move is
-        new_move._action_confirm()
+        # In this case we don't merge move since the new move with 0 quantity done will be used for the backorder.
-        # self.assertEqual(move1.quantity_done, 1.0)
+        self.assertEqual(move1.product_qty, 2.0)
-        self.assertEqual(move1.move_line_ids.qty_done, 1.0)
+        self.assertEqual(sum(move1.move_line_ids.mapped('qty_done')), 2.0)
-        self.assertEqual(move1.quantity_done, 1.0)
+        self.assertEqual(move1.product_qty, 3.0)
-        self.assertEqual(move1.move_line_ids.qty_done, 1.0)
+        self.assertEqual(sum(move1.move_line_ids.mapped('qty_done')), 3.0)
-        self.assertEqual(move1.quantity_done, 1.0)
+        self.assertEqual(move1.product_qty, 2.0)
-        self.assertEqual(move1.move_line_ids.qty_done, 1.0)
+        self.assertEqual(sum(move1.move_line_ids.mapped('qty_done')), 2.0)
-
+    def test_merge_moves_1(self):
-        self.assertEqual(len(back_order_in.move_lines), 3, 'Wrong number of move lines.')
+        self.assertEqual(len(back_order_in.move_lines), 2, 'Wrong number of move lines.')
-        self.assertEqual(len(packD), 2, 'Wrong number of pack operation.')
+        self.assertEqual(len(packD), 1, 'Wrong number of pack operation.')
-            'qty_done': 5,
+            'qty_done': 8,
-        self.assertEqual(len(back_order_in.move_lines), 5, 'Wrong number of move lines')
+        self.assertEqual(len(back_order_in.move_lines), 4, 'Wrong number of move lines')
-        self.assertEqual(set(d_done_qty), set([3.0, 5.0]), 'Wrong quantity of moves product D.')
+        self.assertEqual(set(d_done_qty), set([8.0]), 'Wrong quantity of moves product D.')
-        self.assertEqual(len(picking_in_B.move_lines), 6, 'Wrong number of move lines')
+        self.assertEqual(len(picking_in_B.move_lines), 5, 'Wrong number of move lines')
-        self.assertEqual(moves_gB_kg.product_uom_qty, 0.525, 'Wrong move quantity (%s found instead of 0.525)' % (moves_gB_kg.product_uom_qty))
+        self.assertEqual(moves_gB_kg.product_uom_qty, 0.526, 'Wrong move quantity (%s found instead of 0.526)' % (moves_gB_kg.product_uom_qty))
-            'product_id': self.productA.id,
+            'name': self.productB.name,
-            'product_uom': self.productA.uom_id.id,
+            'product_uom': self.productB.uom_id.id,
-            'product_id': self.productA.id,
+            'name': self.productB.name,
-            'product_uom': self.productA.uom_id.id,
+            'product_uom': self.productB.uom_id.id,
-            'product_id': self.productA.id,
+            'name': self.productC.name,
-            'product_uom': self.productA.uom_id.id,
+            'product_uom': self.productC.uom_id.id,
-                self.state = moves_todo[-1].state or 'draft'
+            self.state = self.move_lines._get_relevant_state_among_moves()
-        return {'sips_form_url': url.get(environment, url['test']), }
+    sips_merchant_id = fields.Char('Merchant ID', help="Used for production only", required_if_provider='sips', groups='base.group_user')
-            'InterfaceVersion': 'HP_2.3',
+            'InterfaceVersion': self.sips_version,
-        return self._get_sips_urls(self.environment)['sips_form_url']
+        return self.environment == 'prod' and self.sips_prod_url or self.sips_test_url
-#default_role = None
+# markdown compatibility: make `foo` behave like ``foo``, the rst default is
-         - :attr:`context`, the current context dictionary.
+        - :attr:`cr`, the current database cursor;
-        self.write(onchange_vals)
+        self.update(onchange_vals)
-version_info = (11, 0, 0, ALPHA, 1, '')
+version_info = (10, 'saas~18', 0, FINAL, 0, '')
-            production.move_raw_ids.action_confirm()
+            production.move_raw_ids._action_confirm()
-        move.action_confirm()
+        move._action_confirm()
-                move[0].action_cancel()
+                move[0]._action_cancel()
-            production.move_raw_ids.action_assign()
+            production.move_raw_ids._action_assign()
-            (finish_moves | raw_moves).action_cancel()
+            (finish_moves | raw_moves)._action_cancel()
-            moves_to_do.action_done()
+            moves_to_do._action_done()
-            moves_to_finish.action_done()
+            moves_to_finish._action_done()
-        moves_to_cancel.action_cancel()
+        moves_to_cancel._action_cancel()
-            production.move_raw_ids.filtered(lambda x: x.state not in ('done', 'cancel')).do_unreserve()
+            production.move_raw_ids.filtered(lambda x: x.state not in ('done', 'cancel'))._do_unreserve()
-        consume_move.action_done()
+        consume_move._action_done()
-        produce_moves.action_done()
+        produce_moves._action_done()
-            move.action_confirm()
+            move._action_confirm()
-        res = super(StockMove, self).action_assign()
+    def _action_assign(self):
-    def action_cancel(self):
+    def _action_cancel(self):
-        return super(StockMove, self).action_cancel()
+        return super(StockMove, self)._action_cancel()
-    def action_confirm(self):
+    def _action_confirm(self):
-        return super(StockMove, moves).action_confirm()
+        return super(StockMove, moves)._action_confirm()
-        inventory.prepare_inventory()
+        inventory.action_start()
-        (stock_inv_product_4 | stock_inv_product_2).prepare_inventory()
+        (stock_inv_product_4 | stock_inv_product_2).action_start()
-        # inventory.prepare_inventory()
+        # inventory.action_start()
-        # inventory.prepare_inventory()
+        # inventory.action_start()
-            moves.action_assign()
+            moves._action_assign()
-            move.action_confirm()
+            move._action_confirm()
-            moves.action_done()
+            moves._action_done()
-                moves.action_assign()
+                moves._action_assign()
-                moves.filtered(lambda m: m.product_id.tracking == 'none').action_done()
+                moves.filtered(lambda m: m.product_id.tracking == 'none')._action_done()
-                moves = moves.filtered(lambda x: x.state not in ('done', 'cancel')).action_confirm()
+                moves = moves.filtered(lambda x: x.state not in ('done', 'cancel'))._action_confirm()
-                moves.action_assign()
+                moves._action_assign()
-                        .action_assign()
+                        ._action_confirm()\
-        inventory.prepare_inventory()
+        inventory.action_start()
-        inventory.prepare_inventory()
+        inventory.action_start()
-        result = super(StockMove, self).action_done()
+    def _action_done(self):
-        pick.do_new_transfer()
+        pick.button_validate()
-        return_pick.do_new_transfer()
+        return_pick.button_validate()
-        move.action_confirm()
+        move._assign_picking()
-                self.env['stock.move'].browse(moves_chunk).action_assign()
+                self.env['stock.move'].browse(moves_chunk)._action_assign()
-        self.mapped('move_ids').filtered(lambda move: move.state != 'done').action_done()
+        self.mapped('move_ids').filtered(lambda move: move.state != 'done')._action_done()
-        self.mapped('move_ids').action_cancel()
+        self.mapped('move_ids')._action_cancel()
-            new_move.action_confirm()
+            new_move._action_confirm()
-                move_to_unreserve.do_unreserve()
+                move_to_unreserve._do_unreserve()
-    def do_unreserve(self):
+    def _do_unreserve(self):
-            if(move.procure_method == 'make_to_order' and not move.move_orig_ids):
+            if move.procure_method == 'make_to_order' and not move.move_orig_ids:
-            elif(move.move_orig_ids and not all(orig.state in ('done', 'cancel') for orig in move.move_orig_ids)):
+            elif move.move_orig_ids and not all(orig.state in ('done', 'cancel') for orig in move.move_orig_ids):
-    def assign_picking(self):
+    def _assign_picking(self):
-    def action_confirm(self):
+    def _action_confirm(self):
-            moves.assign_picking()
+            moves._assign_picking()
-    def force_assign(self):
+    def _force_assign(self):
-    def action_assign(self):
+    def _action_assign(self):
-    def action_cancel(self):
+    def _action_cancel(self):
-            move.do_unreserve()
+            move._do_unreserve()
-                    move.move_dest_ids.action_cancel()
+                    move.move_dest_ids._action_cancel()
-            extra_move = self.copy(default=extra_move_vals).action_confirm()
+            extra_move = self.copy(default=extra_move_vals)._action_confirm()
-        self.filtered(lambda move: move.state == 'draft').action_confirm()  # MRP allows scrapping draft moves
+    def _action_done(self):
-                new_move = move.split(qty_split)
+                new_move = move._split(qty_split)
-            move.move_line_ids.action_done()
+            move.move_line_ids._action_done()
-        moves_todo.mapped('move_dest_ids').action_assign()
+        moves_todo.mapped('move_dest_ids')._action_assign()
-            moves_to_backorder.action_assign()
+            moves_to_backorder._action_assign()
-    def split(self, qty, restrict_partner_id=False):
+    def _split(self, qty, restrict_partner_id=False):
-        new_move.action_confirm()
+        new_move._action_confirm()
-            next_moves.action_assign()
+            next_moves._do_unreserve()
-        # When editing a done move line, the reserved availability of a potential chained move is impacted. Take care of running again `action_assign` on the concerned moves.
+        # When editing a done move line, the reserved availability of a potential chained move is impacted. Take care of running again `_action_assign` on the concerned moves.
-        next_moves.action_assign()
+        next_moves._do_unreserve()
-    def action_done(self):
+    def _action_done(self):
-        self.mapped('move_lines').action_cancel()
+        self.mapped('move_lines')._action_cancel()
-        # call `action_confirm` on every draft move
+        # call `_action_confirm` on every draft move
-        # call `action_assign` on every confirmed move which location_id bypasses the reservation
+            ._action_confirm()
-            .mapped('move_lines').action_assign()
+            .mapped('move_lines')._action_assign()
-        moves.action_assign()
+        moves._action_assign()
-        self.mapped('move_lines').filtered(lambda move: move.state in ['confirmed', 'waiting', 'partially_available']).force_assign()
+        self.mapped('move_lines').filtered(lambda move: move.state in ['confirmed', 'waiting', 'partially_available'])._force_assign()
-        self.mapped('move_lines').action_cancel()
+        self.mapped('move_lines')._action_cancel()
-                    new_move.action_confirm()
+                    new_move._action_confirm()
-        todo_moves.action_done()
+        todo_moves._action_done()
-                move_line.do_unreserve()
+                move_line._do_unreserve()
-        if self.check_backorder():
+        if self._check_backorder():
-    def check_backorder(self):
+    def _check_backorder(self):
-            moves.with_context(skip_check=True).action_confirm()
+            moves.with_context(skip_check=True)._action_confirm()
-            move.action_done()
+            move._action_done()
-        inventory.prepare_inventory()
+        inventory.action_start()
-        inventory.prepare_inventory()
+        inventory.action_start()
-        inventory.prepare_inventory()
+        inventory.action_start()
-        inventory.prepare_inventory()
+        inventory.action_start()
-        inventory.prepare_inventory()
+        inventory.action_start()
-        move1.action_confirm()
+        move1._action_confirm()
-        move1.action_assign()
+        move1._action_assign()
-        move1.action_done()
+        move1._action_done()
-        move1.action_confirm()
+        move1._action_confirm()
-        move1.action_assign()
+        move1._action_assign()
-        move1.action_done()
+        move1._action_done()
-        move1.action_confirm()
+        move1._action_confirm()
-        move1.action_assign()
+        move1._action_assign()
-        move1.action_done()
+        move1._action_done()
-        move1.action_confirm()
+        move1._action_confirm()
-        move1.action_assign()
+        move1._action_assign()
-        move1.action_done()
+        move1._action_done()
-        move1.action_confirm()
+        move1._action_confirm()
-        move1.action_assign()
+        move1._action_assign()
-        move1.action_done()
+        move1._action_done()
-        move1.action_assign()
+        move1._action_confirm()
-        move1.action_assign()
+        move1._action_confirm()
-        move1.action_done()
+        move1._action_done()
-        move1.action_assign()
+        move1._action_confirm()
-        move1.action_done()
+        move1._action_done()
-        move1.action_assign()
+        move1._action_confirm()
-        move1.action_done()
+        move1._action_done()
-        move1.action_assign()
+        move1._action_confirm()
-        move1.action_done()
+        move1._action_done()
-        move1.action_assign()
+        move1._action_confirm()
-        move1.action_done()
+        move1._action_done()
-        move1.action_assign()
+        move1._action_confirm()
-        move1.action_done()
+        move1._action_done()
-        move1.action_confirm()
+        move1._action_confirm()
-        move1.action_assign()
+        move1._action_assign()
-        move1.action_assign()
+        move1._action_confirm()
-        move1.action_confirm()
+        move1._action_confirm()
-        move1.action_assign()
+        move1._action_assign()
-        move1.do_unreserve()
+        move1._do_unreserve()
-        move1.action_confirm()
+        move1._action_confirm()
-        move1.action_assign()
+        move1._action_assign()
-        move1.do_unreserve()
+        move1._do_unreserve()
-        move1.action_confirm()
+        move1._action_confirm()
-        move1.action_assign()
+        move1._action_assign()
-        move1.do_unreserve()
+        move1._do_unreserve()
-        move1.action_confirm()
+        move1._action_confirm()
-        move1.action_assign()
+        move1._action_assign()
-        move1.do_unreserve()
+        move1._do_unreserve()
-        move1.action_confirm()
+        move1._action_confirm()
-        move1.action_assign()
+        move1._action_assign()
-        move1.do_unreserve()
+        move1._do_unreserve()
-        move_stock_pack.action_assign()
+        (move_stock_pack + move_pack_cust)._action_confirm()
-        move_stock_pack.action_done()
+        move_stock_pack._action_done()
-        move_stock_pack.action_assign()
+        (move_stock_pack + move_pack_cust)._action_confirm()
-        move_stock_pack.action_done()
+        move_stock_pack._action_done()
-        (move_stock_pack_1 + move_stock_pack_2 + move_pack_cust).action_confirm()
+        (move_stock_pack_1 + move_stock_pack_2 + move_pack_cust)._action_confirm()
-        move_stock_pack_1.action_assign()
+        move_stock_pack_1._action_assign()
-        move_stock_pack_1.action_done()
+        move_stock_pack_1._action_done()
-        move_stock_pack_2.action_assign()
+        move_stock_pack_2._action_assign()
-        move_stock_pack_2.action_done()
+        move_stock_pack_2._action_done()
-        (move_stock_pack_1 + move_stock_pack_2 + move_pack_cust).action_confirm()
+        (move_stock_pack_1 + move_stock_pack_2 + move_pack_cust)._action_confirm()
-        move_stock_pack_1.action_assign()
+        move_stock_pack_1._action_assign()
-        move_stock_pack_1.action_done()
+        move_stock_pack_1._action_done()
-        move_stock_pack_2.action_assign()
+        move_stock_pack_2._action_assign()
-        move_stock_pack_2.action_done()
+        move_stock_pack_2._action_done()
-        (move_stock_pack + move_pack_cust_1 + move_pack_cust_2).action_confirm()
+        (move_stock_pack + move_pack_cust_1 + move_pack_cust_2)._action_confirm()
-        move_stock_pack.action_assign()
+        move_stock_pack._action_assign()
-        move_stock_pack.action_done()
+        move_stock_pack._action_done()
-        (move_pack_cust_1 + move_pack_cust_2).action_done()
+        (move_pack_cust_1 + move_pack_cust_2)._action_done()
-        move_supp_stock_1.action_assign()
+        (move_supp_stock_1 + move_supp_stock_2 + move_stock_stock_1 + move_stock_stock_2)._action_confirm()
-        move_supp_stock_1.action_done()
+        move_supp_stock_1._action_done()
-        move1.action_assign()
+        move1._action_confirm()
-        move2.action_assign()
+        move2._action_confirm()
-        move2.force_assign()
+        move2._force_assign()
-        move2.action_done()
+        move2._action_done()
-        move1.action_assign()
+        move1._action_confirm()
-        move2.action_assign()
+        move2._action_confirm()
-        move2.force_assign()
+        move2._force_assign()
-        move2.action_done()
+        move2._action_done()
-        move1.action_assign()
+        move1._action_confirm()
-        move1.action_assign()
+        move1._action_confirm()
-        move1.action_assign()
+        move1._action_confirm()
-        move1.action_assign()
+        move1._action_confirm()
-        move1.action_assign()
+        move1._action_confirm()
-        move1.action_assign()
+        move1._action_confirm()
-        move1.action_confirm()
+        move1._action_confirm()
-        move1.action_assign()
+        move1._action_assign()
-        move1.action_done()
+        move1._action_done()
-        move1.action_confirm()
+        move1._action_confirm()
-        move1.action_assign()
+        move1._action_assign()
-        move1.action_done()
+        move1._action_done()
-        move1.action_assign()
+        move1._action_confirm()
-        move1.action_done()
+        move1._action_done()
-        move1.action_assign()
+        move1._action_confirm()
-        move1.action_done()
+        move1._action_done()
-        move1.action_assign()
+        move1._action_confirm()
-        move1.action_done()
+        move1._action_done()
-        move1.action_assign()
+        move1._action_confirm()
-        move1.action_done()
+        move1._action_done()
-        move1.action_assign()
+        move1._action_confirm()
-        move1.action_done()
+        move1._action_done()
-        move1.action_assign()
+        move1._action_confirm()
-        move1.action_done()
+        move1._action_done()
-        move1.action_assign()
+        move1._action_confirm()
-        move1.action_done()
+        move1._action_done()
-        move2.action_assign()
+        move2._action_confirm()
-        move1.action_assign()
+        move1._action_confirm()
-        move1.action_done()
+        move1._action_done()
-        move1.action_assign()
+        move1._action_confirm()
-        move1.action_done()
+        move1._action_done()
-        move1.action_assign()
+        move1._action_confirm()
-        move1.action_done()
+        move1._action_done()
-        self.assertRaises(UserError, picking.do_new_transfer)
+        self.assertRaises(UserError, picking.button_validate)
-        picking.do_new_transfer()
+        picking.button_validate()
-        (move1 + move2).force_assign()
+        (move1 + move2)._action_confirm()
-        move1.action_assign()
+        move1._action_confirm()
-        move1.action_assign()
+        move1._action_confirm()
-        move1.action_done()
+        move1._action_done()
-        move2.action_assign()
+        move2._action_confirm()
-        move2.action_done()
+        move2._action_done()
-        move1.action_assign()
+        move1._action_confirm()
-        move1.action_done()
+        move1._action_done()
-        move2.action_assign()
+        move2._action_confirm()
-        move2.action_done()
+        move2._action_done()
-        move3.action_assign()
+        move3._action_confirm()
-        move3.action_done()
+        move3._action_done()
-        move1.action_assign()
+        move1._action_confirm()
-        move1.action_done()
+        move1._action_done()
-        move2.action_assign()
+        move2._action_confirm()
-        move2.action_done()
+        move2._action_done()
-        move3.action_assign()
+        move3._action_confirm()
-        move3.action_done()
+        move3._action_done()
-        move1.action_assign()
+        move1._action_confirm()
-        move1.action_done()
+        move1._action_done()
-        move2.action_assign()
+        move2._action_confirm()
-        move2.action_done()
+        move2._action_done()
-        move1.action_assign()
+        move1._action_confirm()
-        move1.action_done()
+        move1._action_done()
-        move1.action_assign()
+        move1._action_confirm()
-        move1.action_assign()
+        move1._action_assign()
-        move1.action_assign()
+        move1._action_confirm()
-        move1.action_assign()
+        move1._action_assign()
-        inventory.prepare_inventory()
+        inventory.action_start()
-        inventory.prepare_inventory()
+        inventory.action_start()
-        inventory.prepare_inventory()
+        inventory.action_start()
-        inventory.prepare_inventory()
+        inventory.action_start()
-        incoming_move.action_confirm()
+        incoming_move._action_confirm()
-        inventory.prepare_inventory()
+        inventory.action_start()
-        inventory.prepare_inventory()
+        inventory.action_start()
-        inventory.prepare_inventory()
+        inventory.action_start()
-        inventory.prepare_inventory()
+        inventory.action_start()
-        inventory.prepare_inventory()
+        inventory.action_start()
-        inventory2.prepare_inventory()
+        inventory2.action_start()
-        inventory3.prepare_inventory()
+        inventory3.action_start()
-        inventory4.prepare_inventory()
+        inventory4.action_start()
-        inventory5.prepare_inventory()
+        inventory5.action_start()
-        other_move.action_confirm()
+            move_mto_alone._action_confirm()
-        other_move.do_unreserve()
+        move_mto_alone._do_unreserve()
-        inventory.prepare_inventory()
+        inventory.action_start()
-        customer_move.action_confirm()
+        customer_move._action_confirm()
-        customer_move.action_done()
+        customer_move._action_done()
-        receive_move.action_confirm()
+        receive_move._action_confirm()
-        receive_move.action_done()
+        receive_move._action_done()
-        customer_move_2.action_confirm()
+        customer_move_2._action_confirm()
-        customer_move_2.action_done()
+        customer_move_2._action_done()
-        inventory.prepare_inventory()
+        inventory.action_start()
-    def _prepare_inventory_line(self):
+    def _action_start_line(self):
-            line_data = wizard._prepare_inventory_line()
+            line_data = wizard._action_start_line()
-        if self.pick_id.check_backorder():
+        if self.pick_id._check_backorder():
-            return_move.move_dest_ids.filtered(lambda m: m.state not in ('done', 'cancel')).do_unreserve()
+            return_move.move_dest_ids.filtered(lambda m: m.state not in ('done', 'cancel'))._do_unreserve()
-    def action_done(self):
+    def _action_done(self):
-        res = super(StockMove, self).action_done()
+        res = super(StockMove, self)._action_done()
-        move1.action_assign()
+        move1._action_confirm()
-        move1.action_done()
+        move1._action_done()
-        move2.action_assign()
+        move2._action_confirm()
-        move2.action_done()
+        move2._action_done()
-        move3.action_assign()
+        move3._action_confirm()
-        move3.action_done()
+        move3._action_done()
-        move4.action_assign()
+        move4._action_confirm()
-        move4.action_done()
+        move4._action_done()
-        move5.action_assign()
+        move5._action_confirm()
-        move5.action_done()
+        move5._action_done()
-        move6.action_assign()
+        move6._action_confirm()
-        move6.action_done()
+        move6._action_done()
-        move7.action_assign()
+        move7._action_confirm()
-        move7.action_done()
+        move7._action_done()
-        move1.action_assign()
+        move1._action_confirm()
-        move1.action_done()
+        move1._action_done()
-        move2.action_assign()
+        move2._action_confirm()
-        move2.action_done()
+        move2._action_done()
-        move3.action_assign()
+        move3._action_confirm()
-        move3.action_done()
+        move3._action_done()
-        move4.action_assign()
+        move4._action_confirm()
-        move4.action_done()
+        move4._action_done()
-        move5.action_assign()
+        move5._action_confirm()
-        move5.action_done()
+        move5._action_done()
-        move6.action_assign()
+        move6._action_confirm()
-        move6.action_done()
+        move6._action_done()
-        move7.action_assign()
+        move7._action_confirm()
-        move7.action_done()
+        move7._action_done()
-        move8.action_assign()
+        move8._action_confirm()
-        move8.action_done()
+        move8._action_done()
-        move9.action_assign()
+        move9._action_confirm()
-        move9.action_done()
+        move9._action_done()
-        move1.action_assign()
+        move1._action_confirm()
-        move1.action_done()
+        move1._action_done()
-        move2.action_assign()
+        move2._action_confirm()
-        move2.action_done()
+        move2._action_done()
-        move3.action_assign()
+        move3._action_confirm()
-        move3.action_done()
+        move3._action_done()
-        move4.action_assign()
+        move4._action_confirm()
-        move4.action_done()
+        move4._action_done()
-        move5.action_assign()
+        move5._action_confirm()
-        move5.action_done()
+        move5._action_done()
-        move1.action_done()
+        move1._action_confirm()
-        move2.action_done()
+        move2._action_confirm()
-        move3.action_done()
+        move3._action_confirm()
-        move1.action_done()
+        move1._action_confirm()
-        move2.action_done()
+        move2._action_confirm()
-        move1.action_assign()
+        move1._action_confirm()
-        move1.action_done()
+        move1._action_done()
-        move2.action_assign()
+        move2._action_confirm()
-        move2.action_done()
+        move2._action_done()
-        move3.action_assign()
+        move3._action_confirm()
-        move3.action_done()
+        move3._action_done()
-        move4.action_assign()
+        move4._action_confirm()
-        move4.action_done()
+        move4._action_done()
-        move5.action_assign()
+        move5._action_confirm()
-        move5.action_done()
+        move5._action_done()
-        move1.force_assign()
+        move1._action_confirm()
-        move1.action_done()
+        move1._action_done()
-        move1.action_assign()
+        move1._action_confirm()
-        move1.action_done()
+        move1._action_done()
-        move2.action_assign()
+        move2._action_confirm()
-        move2.action_done()
+        move2._action_done()
-        move3.force_assign()
+        move3._action_confirm()
-        move3.action_done()
+        move3._action_done()
-        move1.action_assign()
+        move1._action_confirm()
-        move1.action_done()
+        move1._action_done()
-        move2.action_assign()
+        move2._action_confirm()
-        move2.action_done()
+        move2._action_done()
-        move3.force_assign()
+        move3._action_confirm()
-        move3.action_done()
+        move3._action_done()
-        move1.action_assign()
+        move1._action_confirm()
-        move1.action_done()
+        move1._action_done()
-        move1.action_assign()
+        move1._action_confirm()
-        move1.action_done()
+        move1._action_done()
-        move2.action_assign()
+        move2._action_confirm()
-        move2.action_done()
+        move2._action_done()
-        move3.force_assign()
+        move3._action_confirm()
-        move3.action_done()
+        move3._action_done()
-        move4.force_assign()
+        move4._action_confirm()
-        move4.action_done()
+        move4._action_done()
-        move5.action_assign()
+        move5._action_confirm()
-        move5.action_done()
+        move5._action_done()
-        move6.force_assign()
+        move6._action_confirm()
-        move6.action_done()
+        move6._action_done()
-        move7.action_assign()
+        move7._action_confirm()
-        move7.action_done()
+        move7._action_done()
-                ('date_order', '<=', fields.Datetime.to_string(datetime.now() - timedelta(hours=1))),
+                ('is_abandoned_cart', '=', True),
-    def cart(self, **post):
+    def cart(self, access_token=None, revive='', **post):
-        values = {
+        values.update({
-        }
+        })
-        # abandoned carts are draft sales orders that have no order lines,
+        # abandoned carts to recover are draft sales orders that have no order lines,
-                ('order_line', '!=', False),
+                ('is_abandoned_cart', '=', True),
-            'domain': [('state', '=', 'draft'), ('partner_id', '!=', self.env.ref('base.public_partner').id), ('date_order', '<', time_constraint)],
+            'domain': [('is_abandoned_cart', '=', True)],
-            'context': {'search_default_team_id': self.id, 'default_team_id': self.id},
+            'context': {
-            composer.send_mail(auto_commit=True)
+            # auto-commit except in testing mode
-from odoo import api, fields, models
+from odoo import fields, models
-    # _mail_flat_thread = False
+            self.env['mail.mail.statistics'].set_opened(mail_message_ids=message_ids)
-    _mail_mass_mailing = _('Leads / Opportunities')
+
-            if mailing.mailing_model == 'mail.mass_mailing.contact':
+            if mailing.mailing_model_name == 'mail.mass_mailing.contact':
-    mailing_model = fields.Selection(selection=_mailing_model, string='Recipients Model', default='mail.mass_mailing.list')
+    mailing_model_id = fields.Many2one('ir.model', string='Recipients Model', domain="[('is_mail_thread', '=', True)]",
-    @api.depends('mailing_model')
+    @api.depends('mailing_model_id')
-            record.mailing_model_real = (record.mailing_model != 'mail.mass_mailing.list') and record.mailing_model or 'mail.mass_mailing.contact'
+            record.mailing_model_real = (record.mailing_model_name != 'mail.mass_mailing.list') and record.mailing_model_name or 'mail.mass_mailing.contact'
-    @api.onchange('mailing_model', 'contact_list_ids')
+    @api.onchange('mailing_model_id', 'contact_list_ids')
-        if self.mailing_model == 'mail.mass_mailing.list':
+        if self.mailing_model_name == 'mail.mass_mailing.list':
-        elif 'opt_out' in self.env[self.mailing_model]._fields and not self.mailing_domain:
+        elif 'opt_out' in self.env[self.mailing_model_name]._fields and not self.mailing_domain:
-                self.model in [item[0] for item in self.env['mail.mass_mailing']._get_mailing_model()]:
+                self.env['ir.model'].sudo().search([('model', '=', self.model), ('is_mail_thread', '=', True)], limit=1):
-                        'mailing_model': self.model,
+                        'mailing_model_id': self.env['ir.model'].search([('model', '=', self.model)], limit=1).id,
-                default_mailing_model='event.registration',
+                default_mailing_model_id=self.env.ref('event.model_event_registration').id,
-                default_mailing_model='event.track',
+                default_mailing_model=self.env.ref('website_event_track.model_event_track').id,
-            if mailing.mailing_model == 'mail.mass_mailing.contact':
+            if mailing.mailing_model_name == 'mail.mass_mailing.contact':
-from odoo import fields, models
+from odoo import api, fields, models
-    @api.depends('sent', 'opened', 'replied', 'bounced', 'exception')
+    @api.depends('sent', 'opened', 'clicked', 'replied', 'bounced', 'exception')
-            elif stat.opened:
+            elif stat.opened or stat.clicked:
-                if getattr(model, 'message_mass_mailing_enabled'):
+                if hasattr(model, 'message_mass_mailing_enabled'):
-            country_record = self.env['res.country'].search([('code', '=', country_code)], limit=1)
+            self.create(
-            self.create(vals)
+        return {
-    def send_mail(self):
+    def send_mail(self, res_ids=None):
-            res_ids = mailing.get_remaining_recipients()
+            if not res_ids:
-            code_proposition = ''.join(random.choice(string.letters + string.digits) for _ in range(size))
+            code_proposition = ''.join(random.choice(string.ascii_letters + string.digits) for _ in range(size))
-            code_proposition = ''.join(random.choice(string.letters + string.digits) for _ in range(size))
+            code_proposition = ''.join(random.choice(string.ascii_letters + string.digits) for _ in range(size))
-def slugify(s, max_length=None):
+def _guess_mimetype(ext=False, default='text/html'):
-
+from itertools import islice
-from odoo.http import request
+from odoo import http, models, fields, _
-from odoo.tools import pycompat, OrderedSet
+from odoo.addons.portal.controllers.portal import pager as portal_pager
-        return self.page(page)
+        homepage = request.website.homepage_id
-    def sitemap_xml_index(self):
+    def sitemap_xml_index(self, **kwargs):
-                   ('url', '=' , '/sitemap-%d.xml' % current_website.id)]
+            dom = [('type', '=', 'binary'), '|', ('url', '=like', '/sitemap-%d-%%.xml' % current_website.id),
-        url = "/page/" + re.sub(r"^website\.", '', xml_id)
+    @http.route(['/website/pages', '/website/pages/page/<int:page>'], type='http', auth="user", website=True)
-        ], type='http', auth="public", website=True)
+    ], type='http', auth="public", website=True)
-import os
+import datetime
-
+from odoo.addons.http_routing.models.ir_http import ModelConverter, _guess_mimetype
-            page=PageConverter,
+    def _serve_page(cls):
-                    to_reset = views.filtered(lambda view: view.model_data_id.noupdate is True and not view.page)
+                    to_reset = views.filtered(lambda view: view.model_data_id.noupdate is True and view.arch_fs)
-            return super(View, self).get_default_lang_code()
+            return super(View, self).get_default_lang_code()
-    def new_page(self, name, template='website.default_page', ispage=True, namespace=None):
+    def new_page(self, name=False, add_menu=False, template='website.default_page', ispage=True, namespace=None):
-
+            template_module, _ = template.split('.')
-        page_xmlid = "%s.%s" % (template_module, page_name)
+        page_url = '/' + slugify(name, max_length=200, path=True)
-        page_name += (inc and "-%s" % inc or "")
+        if not name:
-            'page': ispage,
+        website_id = self._context.get('website_id')
-        return page_xmlid
+        if ispage:
-    def page_search_dependencies(self, view_id=False):
+    def page_search_dependencies(self, page_id=False):
-        if not view_id:
+        if not page_id:
-        view = self.env['ir.ui.view'].browse(view_id)
+        page = self.env['website.page'].browse(int(page_id))
-                })
+        url = page.url
-            name = (name or "").replace("/page/website.", "").replace("/page/", "")
+            name = (name or "").replace("/website.", "").replace("/", "")
-        except:
+        except Exception:
-    def enumerate_pages(self, query_string=None):
+    def enumerate_pages(self, query_string=None, force=False):
-
+        # '/' already has a http.route & is in the routing_map so it will already have an entry in the xml
-        name = slugify(name, max_length=50)
+        name = slugify(needle, max_length=50, path=True)
-        for page in self.enumerate_pages(query_string=name):
+        for page in self.enumerate_pages(query_string=name, force=True):
-                url=node.url,
+                url=node.page_id.url if page_id else node.url,
-    website_meta_keywords = fields.Char("Website meta keywords", translate=True)
+        return True
-        return self.write({'website_published': not self.website_published})
+class WebsiteRedirect(models.Model):
-        }
+    type = fields.Selection([('301', 'Moved permanently'), ('302', 'Moved temporarily')], string='Redirection Type')
-        dep = super(Website, self).page_search_dependencies(view_id)
+    def page_search_dependencies(self, page_id=False):
-        fullname = "website.%s" % name
+        page = self.env['website.page'].browse(int(page_id))
-            '|', ('content', 'ilike', '/page/%s' % name), ('content', 'ilike', '/page/%s' % fullname)
+            ('content', 'ilike', path)
-                            url = "/event/" + slug(self) + "/page/" + newpath
+                            newpath = self.env['website'].new_page(name + ' ' + self.name, template=xml_id, ispage=False)
-            employee.website_url = '/page/website.aboutus#team'
+            employee.website_url = '/aboutus#team'
-import unicodedata
+    def _serve_fallback(cls, exception):
-                return attach
+            serve = cls._serve_fallback(exception)
-                info['last_message'] = last_message[0].get('last_message')
+            # add last message preview (only used in mobile)
-        channel_info = new_channel.channel_info('creation')[0]
+        channel_info = new_channel.channel_info('creation')[0]
-                                   r"(?P<code>[A-Za-z0-9&\xd1\xf1]{3})$")
+    __check_vat_mx_re = re.compile(br"(?P<primeras>[A-Za-z\xd1\xf1&]{3,4})" \
-#                    Pedro Manuel Baeza <pedro.baeza@serviciosbaeza.com>
+# List of contributors:
-    * Defines tax code templates
+    * Defines tax templates
-        'data/account_account_template_data.xml',
+        'data/account_chart_template_data.xml',
-        self.check_amount_in_words = self.env['account.payment']._get_check_amount_in_words(self.amount)
+        self.check_amount_in_words = self.currency_id.amount_to_text(self.amount)
-        self.check_amount_in_words = self._get_check_amount_in_words(self.amount)
+        self.check_amount_in_words = self.currency_id.amount_to_text(self.amount)
-        self.check_amount_in_words = self.env['account.payment']._get_check_amount_in_words(self.amount)
+        self.check_amount_in_words = self.currency_id.amount_to_text(self.amount)
-            'convert': self.convert,
+import logging
-
+            ('company_id', '=', company.id),
-                        raise ValidationError(tr(registry._sql_error[key], 'sql_constraint') or inst[0])
+                    if key in inst.pgerror:
-        help='Scheduled dates of requests for quotation generated from reordering rules are based on vendor lead times (defined on products).\nBy default, such a scheduling is made on calendar days. This option allow to adapt the scheduling with vendor calendars to set on reordering rules.')
+from . import models
-                del self.pool.models[name]
+        custom_models = [name for name, model_class in self.pool.items() if model_class._custom]
-            domain = [('account_id', '=', self.account_id.id), ('partner_id', '=', self.env['res.partner']._find_accounting_partner(self.partner_id).id), ('reconciled', '=', False), ('amount_residual', '!=', 0.0)]
+            domain = [('account_id', '=', self.account_id.id), ('partner_id', '=', self.env['res.partner']._find_accounting_partner(self.partner_id).id), ('reconciled', '=', False), '|', ('amount_residual', '!=', 0.0), ('amount_residual_currency', '!=', 0.0)]
-        return {'sips_form_url': url.get(environment, url['test']), }
+        icp_value = self.env['ir.config_parameter'].sudo().get_param('acquirer_sips_url_%s' % environment)
-                data['custom'] += "%s : %s\n" % (field_name.decode('utf-8'), field_value)
+                data['custom'] += u"%s : %s\n" % (field_name, field_value)
-                    subtype_id=self.env.ref('mail.mt_note').id)
+                for backorder in self.search([('backorder_id', '=', picking.id)]):
-                    sale_order_lines = self.filtered(lambda move: move.procurement_id.sale_line_id and move.product_id.expense_policy == 'no').mapped('procurement_id.sale_line_id')
+                    sale_order_lines = self.filtered(lambda move: move.sale_line_id and move.product_id.expense_policy == 'no').mapped('sale_line_id')
-                if date_action < date.today():
+                if date_action < date.today() and not opp['date_closed']:
-from . import test_expenses
+# -*- coding: utf-8 -*-
-
+            # create an analytic account if at least an expense product
-    payment_mode = fields.Selection([("own_account", "Employee (to reimburse)"), ("company_account", "Company")], default='own_account', states={'done': [('readonly', True)], 'post': [('readonly', True)]}, string="Payment By")
+    payment_mode = fields.Selection([
-    module_sale = fields.Boolean(string="Customer Billing")
+    module_sale_management = fields.Boolean(string="Customer Billing")
-                sale_order = self.env['sale.order'].search([('analytic_account_id', '=', analytic_line.account_id.id)], limit=1)
+        # determine SO : first SO open linked to AA
-                    so_line._compute_tax_id()
+                so_line = self.env['sale.order.line'].create(so_line_values)
-=========================
+Reinvoice Employee Expense
-test the features easily.
+This module allow to reinvoice employee expense, by setting the SO directly on the expense.
-from odoo import api, models
+from odoo import api, fields, models
-import imp
+from odoo.tools import pycompat
-                    mod = fp = fp2 = None
+                    mod = None
-                            migrate(self.cr, pkg.installed_version)
+                        mod = load_script(pyfile, name)
-                data['custom'] += "%s : %s\n" % (field_name.decode('utf-8'), field_value)
+                data['custom'] += u"%s : %s\n" % (field_name, field_value)
-                self.browse(new_move).quantity_done = 0.0
+            if not rec.name and self.payment_type != 'transfer':
-    ],
+    'qweb': ['static/src/xml/*.xml'],
-                <form string="Cancel Repair" version="7.0">
+                <form string="Cancel Repair">
-            res['arch'] = '''<form string="Upgrade Completed" version="7.0">
+            res['arch'] = '''<form string="Upgrade Completed">
-                <form string="Base title" version="7.0">
+                <form string="Base title">
-                    <form position="attributes" version="7.0">
+                    <form position="attributes">
-                string="Replacement title", version="7.0"))
+                string="Replacement title"))
-                <form string="Base title" version="7.0">
+                <form string="Base title">
-                    <form position="attributes" version="7.0">
+                    <form position="attributes">
-                string="Replacement title", version="7.0"
+                string="Replacement title"
-            raise UserError(_('You cannot use deprecated account.'))
+            raise UserError(_('The account %s (%s) is deprecated !') %(account.name, account.code))
-                    SUM(ail.price_subtotal_signed) AS price_total,
+                    SUM(ail.price_subtotal_signed * invoice_type.sign) AS price_total,
-             'However the ID is needed for several action and controllers.'
+             'However the ID is needed for several action and controllers.',
-        taxes = self.env['account.tax']
+        taxes = self.filtered(lambda r: r.amount_type != 'code')
-                    for i in range(0, int(move.product_qty)):
+                    for i in range(0, int(move.product_qty - move.reserved_availability)):
-                    self.env['stock.move.line'].create(move._prepare_move_line_vals(quantity=move.product_qty))
+                    to_update = move.move_line_ids.filtered(lambda ml: ml.product_uom_id == move.product_uom and
-            request.routing_failed = True
+            routing_error = e
-                    request.routing_failed = False
+                    routing_error = None
-                    request.routing_failed = False
+                    routing_error = None
-            return cls._handle_exception(e)
+        if routing_error:
-    module_delivery_dhl = fields.Boolean("DHL")
+    module_delivery_dhl = fields.Boolean("DHL USA")
-    module_delivery_dhl = fields.Boolean("DHL")
+    module_delivery_dhl = fields.Boolean("DHL USA")
-    if request and not url.netloc and not url.scheme and (url.path or force_lang):
+    if not url.netloc and not url.scheme and (url.path or force_lang):
-        lang = lang or request.context.get('lang')
+        lang = pycompat.to_text(lang or request.context.get('lang') or 'en_US')
-            ps = location.split('/')
+            ps = location.split(u'/')
-                    ps[1] = lang.encode('utf-8')
+                    ps[1] = lang
-            location = '/'.join(ps)
+                ps.insert(1, lang)
-    return location.decode('utf-8')
+    return location
-            other_google_ids = [other_att.google_internal_event_id for other_att in event.attendee_ids if other_att.google_internal_event_id]
+            other_google_ids = [other_att.google_internal_event_id for other_att in event.attendee_ids
-            other_google_ids = [other_att.google_internal_event_id for other_att in att.event_id.attendee_ids if other_att.google_internal_event_id and other_att.id != att.id]
+            other_google_ids = [other_att.google_internal_event_id for other_att in att.event_id.attendee_ids if
-            'origin': self.picking_id.name,
+            'origin': _("Return of %s") % self.picking_id.name,
-                raise UserError(_('You can not delete pack operations of a done picking'))
+                raise UserError(_('You can not delete product moves if the picking is done. You can only correct the done quantities.'))
-        string='Batch Picking Name', default='/',
+        string='Batch Picking Name', default='New',
-            vals['name'] = self.env['ir.sequence'].next_by_code('batch.picking') or '/'
+            vals['name'] = self.env['ir.sequence'].next_by_code('picking.batch') or '/'
-        "To Refund in SO", default=False,
+        "To Refund in SO", copy=False, default=False,
-            elif all(float_compare(line.qty_invoiced, line.product_qty if line.product_id.purchase_method == 'purchase' else line.qty_received, precision_digits=precision) >= 0 for line in order.order_line):
+            elif all(float_compare(line.qty_invoiced, line.product_qty if line.product_id.purchase_method == 'purchase' else line.qty_received, precision_digits=precision) >= 0 for line in order.order_line) and order.invoice_ids:
-        line = multi.lines.create({'multi': multi.id})
+        partner1 = self.env.ref('base.res_partner_1')
-            'lines': [(6, 0, [line.id])],
+            'name': partner1.name,
-        values['lines'].append((0, 0, {'name': False, 'partner': False}))
+        partner2 = self.env.ref('base.res_partner_2')
-            'name': partner.name,
+            'name': partner2.name,
-                (0, 0, {'name': partner.name, 'partner': (partner.id, partner.name)}),
+                (1, line1.id, {'name': partner2.name,
-    def convert_to_onchange(self, value, record, fnames=()):
+    def convert_to_onchange(self, value, record, names):
-            (for relational fields only)
+        :param names: a tree of field names (for relational fields only)
-    def convert_to_onchange(self, value, record, fnames=()):
+    def convert_to_onchange(self, value, record, names):
-        return super(Many2one, self).convert_to_onchange(value, record, fnames)
+        return super(Many2one, self).convert_to_onchange(value, record, names)
-    def convert_to_onchange(self, value, record, fnames=()):
+    def convert_to_onchange(self, value, record, names):
-            vals = {name: convert(record[name], record) for name, convert in converters}
+            vals = {
-        return super(One2many, self).convert_to_onchange(value, record, fnames)
+    def convert_to_onchange(self, value, record, names):
-                record.mapped(field_seq)
+            for dotname in field_onchange:
-                    record.mapped(field_seq)
+                for dotname in field_onchange:
-            name: self._fields[name].convert_to_onchange(record[name], record, subfields[name])
+            name: self._fields[name].convert_to_onchange(record[name], record, subnames[name])
-            return
+        self.started = True
-dispatch = ImDispatch().start()
+dispatch = None
-
+            values = {
-                    billable_type = 'billable_time'
+                    values['timesheet_revenue'] = analytic_account.currency_id.round(unit_amount * sale_price * (1-(so_line.discount/100)))
-                    revenue = min(
+                    values['timesheet_revenue'] = min(
-            })
+                    values['timesheet_invoice_type'] = 'billable_fixed'
-            task.effective_hours = sum(task.timesheet_ids.mapped('unit_amount'))
+            task.effective_hours = sum(task.sudo().timesheet_ids.mapped('unit_amount'))  # use 'sudo' here to allow project user (without timesheet user right) to create task
-from odoo import http
+from odoo import http, _
-        view = request.env['ir.model.data'].get_object('sale_timesheet', 'timesheet_plan')
+        view = request.env.ref('sale_timesheet.timesheet_plan')
-            'timesheet_lines': request.env['account.analytic.line'].search(domain),
+            'timesheet_lines': timesheet_lines,
-                total=0.0
+                total=0.0,
-            'name': _('Overview of %s') % self.name,
+            'name': _('Overview'),
-    company_id = fields.Many2one('res.company', string='Company')
+    company_id = fields.Many2one('res.company', string='Company', default=lambda self: self.env.user.company_id)
-from odoo import api, fields, models
+from odoo import api, fields, models, _
-    timesheet_generate = fields.Boolean('Generate Timesheet', help="If checked, when validating a leave, timesheet will be generated in the Vacation Project of the company.")
+    timesheet_generate = fields.Boolean('Generate Timesheet', default=True, help="If checked, when validating a leave, timesheet will be generated in the Vacation Project of the company.")
-        billable_types = ['non_billable', 'billable_time', 'billable_fixed']
+        billable_types = ['non_billable', 'non_billable_project', 'billable_time', 'billable_fixed']
-        ('non_billable', 'Non Billable')], string="Billable Type", readonly=True, copy=False)
+        ('non_billable', 'Non Billable'),
-            billable_type = 'non_billable'
+            billable_type = 'non_billable_project' if not timesheet.task_id else 'non_billable'
-            if so_line.product_id.type == 'service' and so_line.product_id.service_type == 'timesheet':
+            if timesheet.task_id and so_line.product_id.type == 'service' and so_line.product_id.service_type == 'timesheet':
-    timesheet_count = fields.Float(string='Timesheet activities', compute='_compute_timesheet_ids')
+    timesheet_count = fields.Float(string='Timesheet activities', compute='_compute_timesheet_ids', groups="hr_timesheet.group_hr_timesheet_user")
-    tasks_count = fields.Integer(string='Tasks', compute='_compute_tasks_ids')
+    tasks_count = fields.Integer(string='Tasks', compute='_compute_tasks_ids', groups="project.group_project_user")
-    def action_view_project_project(self):
+    def action_view_project_ids(self):
-
+        if len(self.project_ids) == 1:
-                    'name': account.name,
+                    'name': project_name,
-            'name': '%s:%s' % (self.order_id.name or '', self.product_id.name),
+            'name': '%s:%s' % (self.order_id.name or '', self.name.split('\n')[0] or self.product_id.name),
-    progress = fields.Float(compute='_hours_get', store=True, string='Working Time Recorded', group_operator="avg")
+    progress = fields.Float(compute='_hours_get', store=True, string='Progress', group_operator="avg")
-    sale_line_id = fields.Many2one('sale.order.line', 'Sales Order Line')
+    sale_line_id = fields.Many2one('sale.order.line', 'Sales Order Item', domain=[('is_service', '=', True)])
-    is_service = fields.Boolean("Is service", compute='_compute_is_service', help="Sales Order item should generate a task and/or a project, depending on the product settings.")
+    is_service = fields.Boolean("Is service", compute='_compute_is_service', store=True, help="Sales Order item should generate a task and/or a project, depending on the product settings.")
-            vals['employee_id'] = self.env['hr.employee'].search([('user_id', '=', ts_user_id)], limit=1).id
+        vals = self._timesheet_preprocess(vals)
-        vals = self._update_timesheet_values(vals)
+        vals = self._timesheet_preprocess(vals)
-        if vals.get('project_id'):
+    def _timesheet_preprocess(self, vals):
-        if vals.get('employee_id'):
+        # employee implies user
-        return super(AccountAnalyticLine, self).create(values)
+        result = super(AccountAnalyticLine, self).create(values)
-                raise UserError(_('You can not modify already invoiced timesheets.'))
+                raise UserError(_('You can not modify already invoiced timesheets (linked to a Sales order items invoiced on Time and material).'))
-            task = self.env['project.task'].browse(values['task_id'])
+    @api.model
-        return True
+        return values
-            amount_converted = employee.currency_id.compute(amount, analytic_account.currency_id)
+    @api.multi
-        return result
+    @api.multi
-                if so_line.product_uom.category_id == timesheet_uom.category_id:
+        for timesheet in self:
-        return result
+                    # compute the total revenue the SO since we are in fixed price
-                ]).with_context(create=True)  # context key required to avoid loop
+                ])
-from odoo.addons.sale.tests.test_sale_common import TestSale
+from odoo.addons.sale_timesheet.tests.common import CommonTest
-class TestSaleService(TestSale):
+
-            'pricelist_id': self.env.ref('product.list0').id,
+        """ Test task creation when confirming a sale_order with the corresponding product """
-        self.assertEqual(so.invoice_status, 'no', 'Sale Service: there should be nothing to invoice after validation')
+        sale_order = self.env['sale.order'].create(sale_order_vals)
-        task = project.task_ids.filtered(lambda t: t.name == '%s:%s' % (so.name, prod_task.name))
+        project = self.project_global
-        self.assertEqual(task.partner_id, so.partner_id, 'Sale Service: customer should be the same on task and on SO')
+        self.assertEqual(task.partner_id, sale_order.partner_id, 'Sale Service: customer should be the same on task and on SO')
-            'user_id': self.manager.id,
+            'employee_id': self.employee_manager.id,
-        line = so.order_line
+        self.assertEqual(sale_order.invoice_status, 'to invoice', 'Sale Service: there should be sale_ordermething to invoice after registering timesheets')
-        self.assertEqual(so.tasks_count, 1, "A task should have been created on SO confirmation.")
+        self.assertEqual(sale_order.invoice_status, 'invoiced', 'Sale Service: SO should be invoiced')
-            'order_id': so.id,
+            'order_id': sale_order.id,
-        self.assertEqual(so.tasks_count, 2, "Adding a new service line on a confirmer SO should create a new task.")
+        # let's log some timesheets
-from odoo.tools import float_is_zero
+from odoo.tools import float_is_zero, float_compare
-from odoo.addons.sale.tests.test_sale_common import TestSale
+from odoo.addons.sale_timesheet.tests.common import CommonTest
-class TestSaleTimesheet(TestSale):
+class TestSaleTimesheet(CommonTest):
-            'user_id': self.user.id,
+    def test_timesheet_order(self):
-            'user_id': self.manager.id,
+        so_line_ordered_global_project = self.env['sale.order.line'].create({
-        so.action_invoice_create()
+        self.assertEqual(sale_order.tasks_count, 1, "One task should have been created on SO confirmation")
-        # let's log some timesheets
+        # create invoice
-            'project_id': so.project_project_id.id,
+            'project_id': sale_order.project_project_id.id,
-        self.assertEqual(so.invoice_status, 'invoiced', 'Sale Timesheet: "invoice on order" timesheets should not modify the invoice_status of the so')
+        self.assertEqual(so_line_ordered_global_project.qty_delivered, 10.5, 'Timesheet directly on project does not increase delivered quantity on so line')
-            'project_id': so.project_project_id.id,
+            'project_id': sale_order.project_project_id.id,
-        self.assertEqual(so.invoice_status, 'invoiced', 'Sale Timesheet: "invoice on order" timesheets should not modify the invoice_status of the so')
+        self.assertEqual(so_line_ordered_global_project.qty_delivered, 50, 'Sale Timesheet: timesheet does not increase delivered quantity on so line')
-            'project_id': so.project_project_id.id,
+            'project_id': sale_order.project_project_id.id,
-        self.assertEqual(so.invoice_status, 'upselling', 'Sale Timesheet: "invoice on order" timesheets should not modify the invoice_status of the so')
+        self.assertEqual(so_line_ordered_project_only.qty_delivered, 0.0, 'Timesheet directly on project does not increase delivered quantity on so line')
-        self.assertEqual(so.invoice_status, 'no', 'Sale Timesheet: "invoice on delivery" should not need to be invoiced on so confirmation')
+        """ Test timesheet invoicing with 'invoice on delivery' timetracked products
-            'project_id': so.project_project_id.id,
+            'project_id': task_serv2.project_id.id,  # global project
-        self.assertTrue(float_is_zero(inv.amount_total - so.order_line.price_unit * 10.5, precision_digits=2), 'Sale: invoice generation on timesheets product is wrong')
+        self.assertEqual(so_line_deliver_global_project.invoice_status, 'to invoice', 'Sale Timesheet: "invoice on delivery" timesheets should set the so line in "to invoice" status when logged')
-            'project_id': so.project_project_id.id,
+            'project_id': task_serv2.project_id.id,  # global project
-        self.assertEqual(so.invoice_status, 'invoiced', 'Sale Timesheet: "invoice on delivery" timesheets should be invoiced completely by now')
+        self.assertEqual(so_line_deliver_global_project.invoice_status, 'to invoice', 'Sale Timesheet: "invoice on delivery" timesheets should set the so line in "to invoice" status when logged')
-            'unit_amount': 10,
+            'project_id': sale_order.project_project_id.id,  # global project
-        # let's log some timesheets
+         # import pdb;pdb.set_trace()
-            'unit_amount': 16,
+            'project_id': self.project_global.id,  # global project
-            'employee_id': self.employee_user.id,
+            'project_id': sale_order.project_project_id.id,  # global project
-        self.assertEqual(so.invoice_status, 'invoiced', 'Sale Timesheet: "invoice on delivery" timesheets should not modify the invoice_status of the so')
+
-            'project_id': self.project.id
+            'project_id': self.project.id,
-            'project_id': self.project.id
+            'project_id': self.project.id,
-    track_service = fields.Selection([('manual', 'Manually set quantities on order')], string='Track Service',
+    service_type = fields.Selection([('manual', 'Manually set quantities on order')], string='Track Service',
-        default='manual')
+        default='manual', oldname='track_service')
-            line.qty_delivered_updateable = (line.order_id.state == 'sale') and (line.product_id.track_service == 'manual') and (line.product_id.expense_policy == 'no')
+            line.qty_delivered_updateable = (line.order_id.state == 'sale') and (line.product_id.service_type == 'manual') and (line.product_id.expense_policy == 'no')
-            elif so_line.product_id.invoice_policy == 'order' and so_line.product_id.track_service == 'task':
+            elif so_line.product_id.invoice_policy == 'order':
-    track_service = fields.Selection(selection_add=[
+    service_policy = fields.Selection([
-        ('task', 'Create a task per order line to track hours')])
+    ])
-        help='Create a task under this project on sales order validation. This setting must be set for each company.')
+        'project.project', 'Project', company_dependent=True, domain=[('sale_line_id', '=', False)],
-            self.track_service = 'manual'
+    @api.depends('invoice_policy', 'service_type')
-    def _check_multi_timesheet(self):
+    @api.depends('order_line.product_id', 'project_project_id')
-        return {}
+            projects = order.order_line.mapped('product_id.project_id')
-            so_line.is_service = so_line.product_id.type == 'service' and so_line.product_id.track_service in ['task', 'timesheet']
+            so_line.is_service = so_line.product_id.type == 'service'
-                project_id = account.sudo().project_create({'name': account.name})
+                project_id = account.sudo().project_create({
-            if so_line.product_id.track_service == 'task':
+            # create task
-            if so_line.product_id.track_service == 'timesheet':
+            # create project
-            'track_service': 'task',
+            'service_type': 'timesheet',
-            'track_service': 'task',
+            'service_type': 'timesheet',
-            'track_service': 'task',
+            'service_type': 'timesheet',
-            sale_order = self.env['sale.order'].search([('project_id', '=', analytic_line.account_id.id), ('state', '=', 'sale')], limit=1)
+            sale_order = self.env['sale.order'].search([('analytic_account_id', '=', analytic_line.account_id.id), ('state', '=', 'sale')], limit=1)
-                sale_order = self.env['sale.order'].search([('project_id', '=', analytic_line.account_id.id)], limit=1)
+                sale_order = self.env['sale.order'].search([('analytic_account_id', '=', analytic_line.account_id.id)], limit=1)
-    project_id = fields.Many2one('account.analytic.account', 'Analytic Account', readonly=True, states={'draft': [('readonly', False)], 'sent': [('readonly', False)]}, help="The analytic account related to a sales order.", copy=False)
+    analytic_account_id = fields.Many2one('account.analytic.account', 'Analytic Account', readonly=True, states={'draft': [('readonly', False)], 'sent': [('readonly', False)]}, help="The analytic account related to a sales order.", copy=False, oldname='project_id')
-            order.project_id = analytic
+            order.analytic_account_id = analytic
-            'account_analytic_id': self.order_id.project_id.id,
+            'account_analytic_id': self.order_id.analytic_account_id.id,
-                    so.project_id AS analytic_account_id,
+                    so.analytic_account_id AS analytic_account_id,
-                    s.project_id as analytic_account_id,
+                    s.analytic_account_id as analytic_account_id,
-                    s.project_id,
+                    s.analytic_account_id,
-            'invoice_line_ids': [(0, 0, {'name': serv_cost.name, 'product_id': serv_cost.id, 'quantity': 2, 'uom_id': serv_cost.uom_id.id, 'price_unit': serv_cost.standard_price, 'account_analytic_id': so.project_id.id, 'account_id': account_income.id})],
+            'invoice_line_ids': [(0, 0, {'name': serv_cost.name, 'product_id': serv_cost.id, 'quantity': 2, 'uom_id': serv_cost.uom_id.id, 'price_unit': serv_cost.standard_price, 'account_analytic_id': so.analytic_account_id.id, 'account_id': account_income.id})],
-                'account_analytic_id': order.project_id.id or False,
+                'account_analytic_id': order.analytic_account_id.id or False,
-            'analytic_account_id': so.project_id.id,
+            'analytic_account_id': so.analytic_account_id.id,
-            'analytic_account_id': so.project_id.id,
+            'analytic_account_id': so.analytic_account_id.id,
-                ('order_id.project_id', '=', timesheet.account_id.id),
+                ('order_id.analytic_account_id', '=', timesheet.account_id.id),
-    @api.depends('project_id.line_ids')
+    @api.depends('analytic_account_id.line_ids')
-            if order.project_id:
+            if order.analytic_account_id:
-    @api.depends('project_id.project_ids')
+    @api.depends('analytic_account_id.project_ids')
-            order.project_project_id = self.env['project.project'].search([('analytic_account_id', '=', order.project_id.id)])
+            order.project_project_id = self.env['project.project'].search([('analytic_account_id', '=', order.analytic_account_id.id)])
-            account = self.order_id.project_id
+            account = self.order_id.analytic_account_id
-                account = self.order_id.project_id
+                account = self.order_id.analytic_account_id
-
+        """ On SO confirmation, some lines should generate a task or a project. """
-            order.order_line.filtered(lambda line: line.is_service_task)._timesheet_find_task()
+        self.order_line._timesheet_service_generation()
-    is_service_task = fields.Boolean("Will create a task", compute='_compute_is_service_task')
+    task_id = fields.Many2one('project.task', 'Task', help="Task generated by the sales order item")
-    def _compute_is_service_task(self):
+    def _compute_is_service(self):
-            so_line.is_service_task = so_line.product_id.type == 'service' and so_line.product_id.track_service == 'task'
+            so_line.is_service = so_line.product_id.type == 'service' and so_line.product_id.track_service in ['task', 'timesheet']
-            line._timesheet_find_task()
+        if line.state == 'sale':
-                self.order_id._create_analytic_account()
+                self.order_id._create_analytic_account(prefix=self.product_id.default_code or None)
-                project = Project.browse(project_id)
+                project_id = account.sudo().project_create({'name': account.name})
-            order.order_line.filtered(lambda line: line._is_task())._create_task()
+            order.order_line.filtered(lambda line: line.is_service_task)._timesheet_find_task()
-            line._create_task()
+            line._timesheet_find_task()
-    def _get_project(self):
+    def _timesheet_find_project(self):
-                project_id = account.project_create({'name': account.name, 'use_tasks': True})
+                project_id = account.project_create({'name': account.name})
-    def _prepare_service_task_values(self):
+    def _timesheet_create_task_prepare_values(self):
-        project = self._get_project()
+        project = self._timesheet_find_project()
-            self.write({'task_id': task.id})
+    @api.multi
-        return self.product_id.type == 'service' and self.product_id.track_service == 'task'
+    @api.multi
-from . import sale_analytic
+# -*- coding: utf-8 -*-
-            so_lines.with_context(force_so_lines=so_lines).sudo()._compute_analytic()
+    @api.multi
-        return super(AccountAnalyticLine, self)._get_sale_order_line(vals=result)
+from odoo.osv import expression
-        return super(SaleOrderLine, self)._compute_analytic(domain=domain)
+    def _analytic_compute_delivered_quantity_domain(self):
-        return True
+        return self.sudo().with_context(company_id=self.env.user.company_id.id).write({'last_time_entries_checked': time.strftime(DEFAULT_SERVER_DATETIME_FORMAT)})
-        if self.env.user.company_id.vat_check_vies:
+        if self.env.context.get('company_id'):
-            if self.env.user.company_id.vat_check_vies:
+            if self.env.context.get('company_id'):
-        ('name_company_uniq', 'unique(name, company_id, type_tax_use)', 'Tax names must be unique !'),
+        ('name_company_uniq', 'unique(name, company_id, type_tax_use, chart_template_id)', 'Tax names must be unique !'),
-        'data/account_account_types_data.xml',
+        'views/account_view.xml',
-def queryCount(count):
+def queryCount(**counters):
-            self.assertLessEqual(self.cr.sql_log_count - self._count, count)
+            for user in self.env.user + self.env.ref('base.user_demo'):
-    @queryCount(3)
+    @queryCount(admin=3, demo=3)
-    @queryCount(3)
+    @queryCount(admin=3, demo=3)
-    @queryCount(1)
+    @queryCount(admin=1, demo=1)
-    @queryCount(3)
+    @queryCount(admin=3, demo=3)
-    @queryCount(7)
+    @queryCount(admin=7, demo=7)
-    @queryCount(9)
+    @queryCount(admin=9, demo=9)
-    @queryCount(45)
+    @queryCount(admin=45, demo=62)
-    @queryCount(6)
+    @queryCount(admin=6, demo=6)
-    @queryCount(38)
+    @queryCount(admin=38, demo=38)
-    @queryCount(3)
+    @queryCount(admin=3, demo=3)
-    @queryCount(87)
+    @queryCount(admin=87, demo=114)
-        self.assertLessEqual(count1 - count0, count, message)
+
-        """ Check reading records. """
+        """ Read records. """
-                record.partner_id.country_id.name
+        for record in records:
-                record.partner_id.country_id.name
+        for record in records:
-                record.value_pc
+        for record in records:
-        """ Check reading records inheriting from 'mail.thread'. """
+        """ Read records inheriting from 'mail.thread'. """
-                record.partner_id.country_id.name
+        for record in records:
-                record.partner_id.country_id.name
+        for record in records:
-                record.value_pc
+        for record in records:
-        """ Check writing records. """
+        """ Write records (no recomputation). """
-            records.write({'name': 'X'})
+        records.write({'name': self.str('X')})
-            records.write({'value': 20})
+    @queryCount(3)
-                record.value = 30
+        records.write({'value': self.int(20)})
-        """ Check writing records inheriting from 'mail.thread'. """
+        """ Write records inheriting from 'mail.thread' (no recomputation). """
-            records.write({'name': 'X'})
+        records.write({'name': self.str('X')})
-                record.name = 'Y'
+    @queryCount(9)
-            records.write({'value': 20})
+        records.write({'value': self.int(20)})
-                record.value = 30
+    @queryCount(45)
-            records[0].track = 'X'
+        record.track = self.str('X')
-        """ Check creating records. """
+        """ Create records. """
-            })
+    @queryCount(38)
-        """ Check creating records inheriting from 'mail.thread'. """
+        """ Create records inheriting from 'mail.thread' (without field tracking). """
-            model.create({'name': 'X'})
+    @queryCount(87)
-        journal = self.env['account.journal'].browse(self._context.get('journal_id', False))
+        journal = self.env['account.journal'].browse(self.env.context.get('default_journal_id', False))
-                    'sale_id': line.order_id.id
+                    'sale_id': line.order_id.id,
-        return self.sudo().write({'last_time_entries_checked': time.strftime(DEFAULT_SERVER_DATETIME_FORMAT)})
+        if self.ids:
-                    query = 'DELETE FROM %(table)s WHERE %(column)s IN %%s' % query_dic
+                    query = 'DELETE FROM "%(table)s" WHERE "%(column)s" IN %%s' % query_dic
-        'product.uom', 'Unit of Measure', required=True, states={'done': [('readonly', True)]})
+    product_uom = fields.Many2one('product.uom', 'Unit of Measure', required=True)
-        auto_join=True, index=True, required=True, states={'done': [('readonly', True)]},
+        auto_join=True, index=True, required=True,
-        auto_join=True, index=True, required=True, states={'done': [('readonly', True)]},
+        auto_join=True, index=True, required=True,
-                                 states={'done': [('readonly', True)]})
+    quantity_done = fields.Float('Quantity Done', compute='_quantity_done_compute', digits=dp.get_precision('Product Unit of Measure'), inverse='_quantity_done_set')
-    is_editable = fields.Boolean('Is editable when done', compute='_compute_is_editable')
+    is_locked = fields.Boolean(related='picking_id.is_locked', readonly=True)
-    @api.depends('has_tracking', 'move_line_ids', 'location_id', 'location_dest_id', 'is_editable')
+    @api.depends('product_id', 'has_tracking', 'move_line_ids', 'location_id', 'location_dest_id')
-                    and move.state not in ['cancel', 'draft', 'confirmed']\
+                    and move.state != 'draft'\
-    @api.multi
+    @api.depends('state', 'picking_id')
-            move.is_initial_demand_editable = move.state not in ['done', 'cancel'] and self.user_has_groups('stock.group_stock_manager')
+            if move.state == 'draft':
-            if picking_id.state not in ['draft', 'confirmed']:
+            if picking_id.state == 'done':
-            raise UserError(_('Quantities, Units of Measure, Products and Locations cannot be modified on stock moves that have already been processed (except by the Administrator).'))
+    is_initial_demand_editable = fields.Boolean(related='move_id.is_initial_demand_editable')
-        states={'done': [('readonly', True)], 'cancel': [('readonly', True)]})
+    move_line_ids = fields.One2many('stock.move.line', 'picking_id', 'Operations')
-            price_unit = line.taxes_id.with_context(round=False).compute_all(price_unit, currency=line.order_id.currency_id, quantity=1.0)['total_excluded']
+            price_unit = line.taxes_id.with_context(round=False).compute_all(
-        taxes = self.env['account.tax']
+        taxes = self.filtered(lambda r: r.amount_type != 'code')
-        for tax in self:
+        for tax in self.filtered(lambda r: r.amount_type == 'code'):
-        domain = domain and safe_eval(str(domain)) or []
+        domain = domain or []
-        self.assertEqual(self.env['stock.quant']._get_available_quantity(p_final, self.stock_location), -5, 'You should have negative quantity for final product in stock')
+        self.assertEqual(self.env['stock.quant']._get_available_quantity(p_final, self.stock_location, allow_negative=True), -5, 'You should have negative quantity for final product in stock')
-        self.assertEqual(self.env['stock.quant']._get_available_quantity(p_final, self.stock_location, lot_id=lot), -5, 'You should have negative quantity for final product in stock')
+        self.assertEqual(self.env['stock.quant']._get_available_quantity(p_final, self.stock_location, lot_id=lot, allow_negative=True), -5, 'You should have negative quantity for final product in stock')
-        self.assertEqual(self.env['stock.quant']._get_available_quantity(p_final, self.stock_location), -5, 'You should have negative quantity for final product in stock')
+        self.assertEqual(self.env['stock.quant']._get_available_quantity(p_final, self.stock_location, allow_negative=True), -5, 'You should have negative quantity for final product in stock')
-        self.assertEqual(self.env['stock.quant']._get_available_quantity(p_final, self.stock_location, lot_id=lot_final), -5, 'You should have negative quantity for final product in stock')
+        self.assertEqual(self.env['stock.quant']._get_available_quantity(p_final, self.stock_location, lot_id=lot_final, allow_negative=True), -5, 'You should have negative quantity for final product in stock')
-    def _get_available_quantity(self, product_id, location_id, lot_id=None, package_id=None, owner_id=None, strict=False):
+    def _get_available_quantity(self, product_id, location_id, lot_id=None, package_id=None, owner_id=None, strict=False, allow_negative=False):
-        return sum(quants.mapped('quantity')) - sum(quants.mapped('reserved_quantity'))
+        if product_id.tracking == 'none':
-        return self._get_available_quantity(product_id, location_id, lot_id=lot_id, package_id=package_id, owner_id=owner_id, strict=False), fields.Datetime.from_string(in_date)
+        return self._get_available_quantity(product_id, location_id, lot_id=lot_id, package_id=package_id, owner_id=owner_id, strict=False, allow_negative=True), fields.Datetime.from_string(in_date)
-        available_quantity = quants_quantity - sum(quants.mapped('reserved_quantity'))
+        available_quantity = self._get_available_quantity(product_id, location_id, lot_id=lot_id, package_id=package_id, owner_id=owner_id, strict=strict)
-        self.assertEqual(self.env['stock.quant']._get_available_quantity(self.product1, self.supplier_location), -100.0)
+        self.assertEqual(self.env['stock.quant']._get_available_quantity(self.product1, self.supplier_location), 0.0)
-        self.assertEqual(self.env['stock.quant']._get_available_quantity(self.product3, self.supplier_location), -5.0)
+        self.assertEqual(self.env['stock.quant']._get_available_quantity(self.product3, self.supplier_location), 0.0)
-        self.assertEqual(self.env['stock.quant']._get_available_quantity(self.product2, self.supplier_location), -5.0)
+        self.assertEqual(self.env['stock.quant']._get_available_quantity(self.product2, self.supplier_location), 0.0)
-        """ Send products tracked by lot to a customer. In your stock, there two tracked and
+        """ Send products tracked by lot to a customer. In your stock, there are two tracked and
-
+    def test_availability_3(self):
-        self.assertEqual(self.env['stock.quant']._get_available_quantity(self.product1, shelf2_location), -1.0)
+        self.assertEqual(self.env['stock.quant']._get_available_quantity(self.product1, shelf2_location), 0.0)
-        self.assertEqual(self.env['stock.quant']._get_available_quantity(self.product1, self.stock_location), -1.0)
+        self.assertEqual(self.env['stock.quant']._get_available_quantity(self.product1, shelf1_location), 0.0)
-        self.assertEqual(self.env['stock.quant']._get_available_quantity(self.product1, self.stock_location), -10.0)
+        self.assertEqual(self.env['stock.quant']._get_available_quantity(self.product1, self.stock_location), 0.0)
-        self.assertEqual(self.env['stock.quant']._get_available_quantity(self.productA, pack_location), -1.0)
+        self.assertEqual(self.env['stock.quant']._get_available_quantity(self.productA, pack_location), 0.0)
-        self.assertEqual(self.env['stock.quant']._get_available_quantity(self.productA, pack_location), -2.0)
+        self.assertEqual(self.env['stock.quant']._get_available_quantity(self.productA, pack_location), 0.0)
-        self.assertEqual(self.env['stock.quant']._get_available_quantity(product1, stock_location), -5.0)
+        self.assertEqual(self.env['stock.quant']._get_available_quantity(product1, stock_location), 0.0)
-        self.assertEqual(self.env['stock.quant']._get_available_quantity(product1, stock_location, lot_id=lot1), -10.0)
+        self.assertEqual(self.env['stock.quant']._get_available_quantity(product1, stock_location, lot_id=lot1), 0.0)
-        self.assertEqual(self.env['stock.quant']._get_available_quantity(product1, stock_location), -1.0)
+        self.assertEqual(self.env['stock.quant']._get_available_quantity(product1, stock_location), 0.0)
-        recs = self.browse(self._prefetch[self._name]) - self.env.cache.get_records(self, field)
+        ids0 = self._prefetch[self._name]
-        action['context'] = {}
+        action['context'] = {'default_product_id': self.id}
-        'Show Reserved', default=True)
+        'Show Reserved', default=True, help="If this checkbox is ticked, Odoo will show which products are reserved (lot/serial number, source location, source package).")
-        action['context'] = {'search_default_locationgroup': 1, 'search_default_internal_loc': 1}
+        action['context'] = {'search_default_internal_loc': 1}
-            res = new_procurements.run(autocommit=autocommit)
+        res = True
-           AND relkind IN ('r', 'v', 'm')
+        SELECT c.relname
-    return cr.rowcount
+    return len(existing_tables(cr, {tablename})) == 1
-                    if move_line.product_qty:
+                    if move_line.product_qty and move_line.qty_done:
-        product_consume.consume_line_ids.write({'qty_done': 12})
+        product_consume.produce_line_ids.write({'qty_done': 12})
-        product_consume.consume_line_ids.write({'qty_done': 8})
+        self.assertEquals(len(product_consume.produce_line_ids), 2)
-        product_consume.consume_line_ids.filtered(lambda x : x.product_id == product_B).write({'qty_done': 20})
+        self.assertEquals(len(product_consume.produce_line_ids), 2)
-                quantity = 1.0
+                todo_quantity = 1.0
-                    else:
+                main_product_moves = production.move_finished_ids.filtered(lambda x: x.product_id.id == production.product_id.id)
-                            'product_qty': qty,
+                            'qty_to_consume': to_consume_in_line,
-                    existing_lines += move.move_line_ids.filtered(lambda x: not x.lot_produced_id).ids
+                        qty_to_consume -= to_consume_in_line
-            res['consume_line_ids'] = (existing_lines and [(6, 0, [x for x in existing_lines])] or []) + [(0, 0, x) for x in lines]
+                res['produce_line_ids'] = [(0, 0, x) for x in lines]
-    consume_line_ids = fields.Many2many('stock.move.line', 'mrp_produce_stock_move_line', string='Product to Track')
+    produce_line_ids = fields.One2many('mrp.product.produce.line', 'product_produce_id', string='Product to Track')
-                existing_move_line.product_qty += self.product_qty
+                existing_move_line.product_uom_qty += self.product_qty
-                            moveline.write({'lot_produced_id': self.lot_id.id})
+                self.env['stock.move.line'].create(vals)
-                if not original.lot_id:
+                if original and not original[0].lot_id:
-                    'lot_id': original.lot_id.id,
+                    'lot_id': original[0].lot_id.id,
-                self.env.cr.execute(query, (account_ids,))
+                query = """SELECT sum(%s) FROM account_move_line WHERE account_id in %%s AND date <= %%s;""" % (amount_field,)
-            if (values.get('start_date') or values.get('start_datetime')) and values.get('active', True):
+            if (values.get('start_date') or values.get('start_datetime') or
-            'shortcodes': request.env['mail.shortcode'].sudo().search_read([], ['shortcode_type', 'source', 'substitution', 'description']),
+            'shortcodes': request.env['mail.shortcode'].sudo().search_read([], ['shortcode_type', 'source', 'unicode_source', 'substitution', 'description']),
-                    % (rate, feedback),
+                    body="<img src='/rating/static/src/img/rating_%s.png' alt=':rating_%s' style='width:20px;height:20px;float:left;margin-right: 5px;'/>%s"
-    psycopg2.extensions.register_adapter(unicode, adapt_string)
+    for type_ in pycompat.string_types:
-            'escape': lambda x: x.replace("'", r"\'")
+            'escape': lambda x: x.replace("'", r"\'"),
-    _order = "sequence"
+    _order = "sequence, id"
-        action['res_id'] = self.env.ref('auth_signup.default_template_user').id
+        action['res_id'] = literal_eval(self.env['ir.config_parameter'].sudo().get_param('auth_signup.template_user_id', 'False'))
-            auth_signup_template_user_id=get_param('auth_signup.template_user_id', 'False').lower() == 'true',
+            auth_signup_template_user_id=literal_eval(get_param('auth_signup.template_user_id', 'False')),
-    dbs = [i for i in dbs if re.match(r, i)]
+    if odoo.tools.config['dbfilter']:
-from odoo import api, models, tools, fields
+from odoo import api, models, tools
-                        company_id=company.id)
+            for company in self.env.user.company_ids:
-            self.env['procurement.group'].run(line.product_id, product_qty, line.product_uom, line.order_id.partner_shipping_id.property_stock_customer, line.name, line.order_id.name, values)
+            try:
-        move.picking_id.action_confirm()
+        move.action_confirm()
-            msg = _('No Bill of Material found for product %s.') % (product_id.display_name,)
+            msg = _('There is no Bill of Material found for the product %s. Please define a Bill of Material for this product.') % (product_id.display_name,)
-            msg = _('No vendor associated to product %s. Unable to generate the purchase order.') % (product_id.display_name,)
+            msg = _('There is no vendor associated to the product %s. Please define a vendor for this product.') % (product_id.display_name,)
-            raise UserError(_('No procurement rule found.'))
+            raise UserError(_('No procurement rule found. Please verify the configuration of your routes'))
-                    return False
+    def _run_manufacture(self, product_id, product_qty, product_uom, location_id, name, origin, values):
-        return super(ProcurementGroup, self)._run(values, rule, doraise)
+        # create the MO as SUPERUSER because the current user may not have the rights to do it (mto product launched by a sale for example)
-    def _get_matching_bom(self, values, rule):
+    def _get_matching_bom(self, product_id, values):
-        return date_planned
+        )._bom_find(product=product_id, picking_type=self.picking_type_id)  # TDE FIXME: context bullshit
-    def _prepare_mo_vals(self, values, rule, bom):
+    def _prepare_mo_vals(self, product_id, product_qty, product_uom, location_id, name, origin, values, bom):
-            'location_dest_id': values['location_id'].id,
+            'origin': origin,
-            'date_planned_start': fields.Datetime.to_string(self._get_date_planned(values, rule)),
+            'date_planned_start': fields.Datetime.to_string(self._get_date_planned(product_id, values)),
-            'picking_type_id': rule.picking_type_id.id or values['warehouse_id'].manu_type_id.id,
+            'propagate': self.propagate,
-        res = super(SaleOrderLine, self)._action_procurement_create()
+    def _action_launch_procurement_rule(self):
-    _inherit = 'procurement.rule'
+class ProcurementGroup(models.Model):
-    action = fields.Selection(selection_add=[('buy', 'Buy')])
+    @api.model
-    _inherit = 'procurement.group'
+class ProcurementRule(models.Model):
-            partner = supplier.name
+    def _run_buy(self, product_id, product_qty, product_uom, location_id, name, origin, values):
-            domain = self._make_po_get_domain(values, rule, partner)
+        supplier = self._make_po_select_supplier(values, suppliers)
-                        po.write({'origin': po.origin})
+        domain = self._make_po_get_domain(values, partner)
-                    seller = values['product_id']._select_seller(
+                    po.write({'origin': po.origin})
-                        uom_id=values['product_id'].uom_po_id)
+                        quantity=line.product_qty + procurement_uom_po_qty,
-        return super(ProcurementGroup, self)._run(values, rule, doraise=True)
+        if not po_line:
-    def _get_purchase_schedule_date(self, values, rule):
+    def _get_purchase_schedule_date(self, values):
-        procurement_date_planned = datetime.strptime(values['date_planned'], DEFAULT_SERVER_DATETIME_FORMAT)
+        procurement_date_planned = fields.Datetime.from_string(values['date_planned'])
-    def _get_purchase_order_date(self, values, rule, partner, schedule_date):
+    def _get_purchase_order_date(self, product_id, product_qty, product_uom, values, partner, schedule_date):
-        seller = values['product_id']._select_seller(
+        seller = product_id._select_seller(
-            quantity=values['product_qty'],
+            quantity=product_qty,
-            uom_id=values['product_uom'])
+            uom_id=product_uom)
-        seller = values['product_id']._select_seller(
+    @api.multi
-            uom_id=values['product_id'].uom_po_id)
+            uom_id=product_id.uom_po_id)
-        taxes = values['product_id'].supplier_taxes_id
+        taxes = product_id.supplier_taxes_id
-        price_unit = self.env['account.tax']._fix_tax_included_price(seller.price, values['product_id'].supplier_taxes_id, taxes_id) if seller else 0.0
+        price_unit = self.env['account.tax']._fix_tax_included_price(seller.price, product_id.supplier_taxes_id, taxes_id) if seller else 0.0
-        product_lang = values['product_id'].with_context({
+        product_lang = product_id.with_context({
-            'product_uom': values['product_id'].uom_po_id.id,
+            'product_id': product_id.id,
-        purchase_date = self._get_purchase_order_date(values, rule, partner, schedule_date)
+    def _prepare_purchase_order(self, product_id, product_qty, product_uom, origin, values, partner):
-        group = (gpo == 'fixed' and rule.group_id.id) or \
+        gpo = self.group_propagation_option
-            'picking_type_id': rule.picking_type_id.id,
+            'picking_type_id': self.picking_type_id.id,
-            'origin': values['origin'],
+            'origin': origin,
-    def _make_po_select_supplier(self, values, rule, suppliers):
+    def _make_po_select_supplier(self, values, suppliers):
-        group = (gpo == 'fixed' and rule.group_id) or \
+    def _make_po_get_domain(self, values, partner):
-            ('picking_type_id', '=', rule.picking_type_id.id),
+            ('picking_type_id', '=', self.picking_type_id.id),
-        return ProcurementGroup.run(order_values)
+        return ProcurementGroup.run(product, product_qty, self.uom_unit, self.warehouse_1.lot_stock_id, product.name, '/', order_values)
-            'product_uom': self.uom_unit,
+        self.env['procurement.group'].run(self.product_1, 5.000, self.uom_unit, self.warehouse_1.lot_stock_id, 'Test scheduler for RFQ', '/', {
-            'group_id': False, #self.env['procurement.group'],
+            'group_id': False,
-        
+
-    _inherit = 'procurement.group'
+class ProcurementRule(models.Model):
-    def _run_buy(self, product_id, product_qty, product_uom, location_id, name, origin, values, log_activites=False):
+    def _run_buy(self, product_id, product_qty, product_uom, location_id, name, origin, values):
-        })
+            return super(ProcurementRule, self)._run_buy(product_id, product_qty, product_uom, location_id, name, origin, values)
-        
+        self.env['procurement.group'].run(product, 14, self.env['product.uom'].browse(self.ref('product.product_uom_unit')), warehouse.lot_stock_id, '/', '/',
-        vals = super(SaleOrderLine, self)._prepare_order_line_procurement(group_id=group_id)
+    def _prepare_procurement_values(self, group_id):
-            order.order_line._action_procurement_create()
+            order.order_line._action_launch_procurement_rule()
-            line._action_procurement_create()
+            line._action_launch_procurement_rule()
-            lines._action_procurement_create()
+            lines._action_launch_procurement_rule()
-    def _prepare_order_line_procurement(self, group_id=False):
+    def _prepare_procurement_values(self, group_id=False):
-            'product_uom': self.product_uom,
+        values.update({
-        }
+        })
-    def _action_procurement_create(self):
+    def _action_launch_procurement_rule(self):
-        procurements are created. If the quantity is decreased, no automated action is taken.
+        Launch procurement group run method with required/custom fields genrated by a
-                line.order_id.procurement_group_id = self.env["procurement.group"].create({
+                line.order_id.procurement_group_id = self.env['procurement.group'].create({
-            vals['product_qty'] = line.product_uom_qty - qty
+            values = line._prepare_procurement_values(group_id=line.order_id.procurement_group_id)
-            new_proc = self.env["procurement.group"].run(vals)
+            self.env['procurement.group'].run(line.product_id, product_qty, line.product_uom, line.order_id.partner_shipping_id.property_stock_customer, line.name, line.order_id.name, values)
-
+class ProcurementGroup(models.Model):
-        return res
+        return res
-            assert key in values
+    def run(self, product_id, product_qty, product_uom, location_id, name, origin, values):
-        rule = self._get_rule(values)
+        rule = self._get_rule(product_id, location_id, values)
-        self._run(values, rule, doraise)
+            raise UserError(_('No procurement rule found.'))
-    def _search_rule(self, values, domain):
+    def _search_rule(self, product_id, values, domain):
-            product_routes = values['product_id'].route_ids | values['product_id'].categ_id.total_route_ids
+            product_routes = product_id.route_ids | product_id.categ_id.total_route_ids
-    def _get_rule(self, values):
+    def _get_rule(self, product_id, location_id, values):
-        location = values['location_id']
+        location = location_id
-            result = self._search_rule(values, [('location_id', '=', location.id)])
+            result = self._search_rule(product_id, values, [('location_id', '=', location.id)])
-            ('group_id', '=', group_id), #extra logic?
+            ('group_id', '=', group_id), # extra logic?
-                    
+
-                self.env['procurement.group'].run(move._prepare_procurement_from_move(), doraise=False)
+                values = move._prepare_procurement_values()
-                                        orderpoint._prepare_procurement_values(qty_rounded, **group['procurement_values']), doraise=False)
+                                    values = orderpoint._prepare_procurement_values(qty_rounded, **group['procurement_values'])
-            self.env['procurement.group'].run(move._prepare_procurement_from_move())
+            values = move._prepare_procurement_values()
-    def _prepare_procurement_from_move(self):
+    def _prepare_procurement_values(self):
-            'location_id': self.location_id,
+        """ Prepare specific key for moves or other components that will be created from a procurement rule
-    _inherit = 'procurement.group'
+class ProcurementRule(models.Model):
-        res = super(ProcurementGroup, self)._prepare_purchase_order_line(values, rule, po, supplier)
+    def _prepare_purchase_order_line(self, product_id, product_qty, product_uom, values, po, supplier):
-        vals['carrier_id'] = self.group_id.sale_order_id.carrier_id.id
+        vals['carrier_id'] = self.sale_line_id.order_id.carrier_id.id
-
+    move_dest_ids = fields.One2many('stock.move', 'created_production_id')
-            'procurement_id': self.procurement_ids and self.procurement_ids[0].id or False,
+            'move_dest_ids': [(4, x.id) for x in self.move_dest_ids],
-        self.env["procurement.order"].search([('production_id', 'in', self.ids)]).check()
+from odoo.exceptions import UserError
-        return super(ProcurementOrder, self).propagate_cancels()
+class ProcurementGroup(models.Model):
-        return super(ProcurementOrder, self)._run()
+    def _run(self, values, rule, doraise=True):
-            return self.bom_id
+    def _get_matching_bom(self, values, rule):
-        )._bom_find(product=self.product_id, picking_type=self.rule_id.picking_type_id)  # TDE FIXME: context bullshit
+            company_id=values['company_id'].id, force_company=values['company_id'].id
-        date_planned = date_planned - relativedelta(days=self.company_id.manufacturing_lead)
+    def _get_date_planned(self, values, rule):
-    def _prepare_mo_vals(self, bom):
+    def _prepare_mo_vals(self, values, rule, bom):
-            'location_dest_id': self.location_id.id,
+            'origin': values['origin'],
-            'procurement_ids': [(6, 0, [self.id])],
+            'date_planned_start': fields.Datetime.to_string(self._get_date_planned(values, rule)),
-        return res
+    created_production_id = fields.Many2one('mrp.production', 'Created Production Order')
-
+from odoo.exceptions import UserError
-        self.assertEqual(procurement.state, 'running', 'Procurement order should be in state running')
+        # Check it created a purchase order
-        produce_product_4 = procurement.production_id
+        move_raw_product4 = production_product_6.move_raw_ids.filtered(lambda x: x.product_id == self.product_4)
-        self.assertEqual(len(procurement), 2)
+        # create MO, but check it raises error as components are in make to order and not everyone has 
-    'auto_install': True,
+    'installable': False,
-    _inherit = ['mail.thread']
+    _inherit = ['mail.thread', 'mail.activity.mixin']
-             "request (e.g. a sales order or an internal procurement request)")
+             "request (e.g. a sales order)")
-            line._create_or_update_picking(values)
+            line._create_or_update_picking()
-            self.filtered(lambda l: l.order_id.state == 'purchase')._create_or_update_picking(values)
+        if 'product_qty' in values:
-    procurement_ids = fields.One2many('procurement.order', 'purchase_line_id', string='Associated Procurements', copy=False)
+
-    def _create_or_update_picking(self, vals):
+    def _create_or_update_picking(self):
-                if float_compare(vals['product_qty'], line.qty_invoiced, line.product_uom.rounding) == -1:
+                # Prevent decreasing below received quantity
-                        move_vals['product_uom_qty'] = diff_purchase_uom_qty
+
-                        .create(move_vals)\
+                        .create(move_val)\
-    def _get_move_template(self, picking):
+    def _prepare_stock_moves(self, picking):
-            'move_dest_ids': False,
+            'move_dest_ids': [(4, x) for x in self.move_dest_ids.ids],
-            'price_unit': self._get_stock_move_price_unit(),
+            'price_unit': price_unit,
-                (6, 0, [x.id for x in self.order_id.picking_type_id.warehouse_id.route_ids])] or [],
+            'route_ids': self.order_id.picking_type_id.warehouse_id and [(6, 0, [x.id for x in self.order_id.picking_type_id.warehouse_id.route_ids])] or [],
-
+    action = fields.Selection(selection_add=[('buy', 'Buy')])
-    purchase_id = fields.Many2one(related='purchase_line_id.order_id', string='Purchase Order')
+class ProcurementGroup(models.Model):
-                    procurement.purchase_line_id.price_unit = price_unit
+    def _run(self, values, rule, doraise=True):
-                    procurement.purchase_line_id.unlink()
+                    self._log_next_activity(values['product_id'], msg)
-        return result
+            domain = self._make_po_get_domain(values, rule, partner)
-        return super(ProcurementOrder, self)._run()
+            if domain in cache:
-    def _get_purchase_schedule_date(self):
+            # Create Line
-        schedule_date = (procurement_date_planned - relativedelta(days=self.company_id.po_lead))
+        procurement_date_planned = datetime.strptime(values['date_planned'], DEFAULT_SERVER_DATETIME_FORMAT)
-    def _get_purchase_order_date(self, partner, schedule_date):
+    def _get_purchase_order_date(self, values, rule, partner, schedule_date):
-        seller = self.product_id._select_seller(
+        seller = values['product_id']._select_seller(
-            quantity=self.product_qty,
+            quantity=values['product_qty'],
-            uom_id=self.product_uom)
+            uom_id=values['product_uom'])
-        seller = self.product_id._select_seller(
+    @api.model
-            uom_id=self.product_id.uom_po_id)
+            uom_id=values['product_id'].uom_po_id)
-        taxes = self.product_id.supplier_taxes_id
+        taxes = values['product_id'].supplier_taxes_id
-            taxes_id = taxes_id.filtered(lambda x: x.company_id.id == self.company_id.id)
+            taxes_id = taxes_id.filtered(lambda x: x.company_id.id == values['company_id'].id)
-        price_unit = self.env['account.tax']._fix_tax_included_price(seller.price, self.product_id.supplier_taxes_id, taxes_id) if seller else 0.0
+        price_unit = self.env['account.tax']._fix_tax_included_price(seller.price, values['product_id'].supplier_taxes_id, taxes_id) if seller else 0.0
-        product_lang = self.product_id.with_context({
+        product_lang = values['product_id'].with_context({
-            'product_uom': self.product_id.uom_po_id.id,
+            'product_id': values['product_id'].id,
-            'procurement_ids': [(4, self.id)],
+            'move_dest_ids': [(4, x.id) for x in values.get('move_dest_ids', [])],
-        fpos = self.env['account.fiscal.position'].with_context(company_id=self.company_id.id).get_fiscal_position(partner.id)
+    def _prepare_purchase_order(self, values, rule, partner):
-                (gpo == 'propagate' and self.group_id.id) or False
+        gpo = rule.group_propagation_option
-            'company_id': self.company_id.id,
+            'picking_type_id': rule.picking_type_id.id,
-            'origin': self.origin,
+            'dest_address_id': values.get('partner_dest_id', False) and values['partner_dest_id'].id,
-    def _make_po_select_supplier(self, suppliers):
+    def _make_po_select_supplier(self, values, rule, suppliers):
-                (gpo == 'propagate' and self.group_id) or False
+    def _make_po_get_domain(self, values, rule, partner):
-        domain = (
+        domain += (
-            ('dest_address_id', '=', self.partner_dest_id.id))
+            ('picking_type_id', '=', rule.picking_type_id.id),
-        return action_dict
+    @api.model
-        MakeProcurement = self.env['make.procurement']
+    def _create_make_procurement(self, product, product_qty, date_planned=False):
-            'date_planned': fields.Datetime.to_string(fields.datetime.now() + timedelta(days=10))  # 10 days added to current date of procurement to get future schedule date and order date of purchase order.
+            'name': product.name, 
-        return MakeProcurement.create(order_values)
+        return ProcurementGroup.run(order_values)
-        self.assertEqual(procurement.state, 'running', 'Procurement should be in running state.')
+        date_planned = fields.Datetime.to_string(fields.datetime.now() + timedelta(days=10))
-        procurement.purchase_id.button_confirm()
+        purchase.button_confirm()
-        order_date = fields.Datetime.from_string(procurement.date_planned) - timedelta(days=company.po_lead) - timedelta(days=self.product_1.seller_ids.delay)
+        order_date = fields.Datetime.from_string(date_planned) - timedelta(days=company.po_lead) - timedelta(days=self.product_1.seller_ids.delay)
-        self.assertEqual(procurement.purchase_id.date_order, po_order_date, 'Order date should be equal to: Date of the procurement order - Purchase Lead Time - Delivery Lead Time.')
+        self.assertEqual(purchase.date_order, po_order_date, 'Order date should be equal to: Date of the procurement order - Purchase Lead Time - Delivery Lead Time.')
-        self.assertEqual(procurement.purchase_id.date_planned, po_schedule_date, 'Schedule date should be equal to: Order date of Purchase order + Delivery Lead Time.')
+        self.assertEqual(purchase.date_planned, po_schedule_date, 'Schedule date should be equal to: Order date of Purchase order + Delivery Lead Time.')
-        self.assertTrue(procurement.purchase_id.picking_ids, "Picking should be created.")
+        self.assertTrue(purchase.picking_ids, "Picking should be created.")
-        self.assertEqual(procurement.purchase_id.picking_ids.scheduled_date, po_schedule_date, 'Schedule date of In type shipment should be equal to: schedule date of purchase order.')
+        self.assertEqual(purchase.picking_ids.scheduled_date, po_schedule_date, 'Schedule date of In type shipment should be equal to: schedule date of purchase order.')
-        self.assertEqual(procurement_1.state, 'running', 'Procurement of product_1 should be in running state.')
+        date_planned1 = fields.Datetime.to_string(fields.datetime.now() + timedelta(days=10))
-        self.assertEqual(procurement_2.state, 'running', 'Procurement of product_2 should be in running state.')
+        date_planned2 = fields.Datetime.to_string(fields.datetime.now() + timedelta(days=10))
-        self.assertEqual(procurement_1.purchase_id, procurement_2.purchase_id, 'Purchase orders should be same for the two different product with same vendor.')
+        self.assertEqual(purchase1, purchase2, 'Purchase orders should be same for the two different product with same vendor.')
-        procurement_2.purchase_id.button_confirm()
+        purchase1.button_confirm()
-        order_date = fields.Datetime.from_string(procurement_1.date_planned) - timedelta(days=self.product_1.seller_ids.delay)
+        order_line_pro_1 = purchase2.order_line.filtered(lambda r: r.product_id == self.product_1)
-        self.assertEqual(procurement_2.purchase_id.date_order, po_order_date, 'Order date should be equal to: Date of the procurement order - Delivery Lead Time.')
+        self.assertEqual(purchase2.date_order, po_order_date, 'Order date should be equal to: Date of the procurement order - Delivery Lead Time.')
-        self.assertEqual(procurement_2.purchase_id.date_planned, po_schedule_date, 'Schedule date of purchase order should be minimum of schedule dates of purchase order lines.')
+        self.assertEqual(purchase2.date_planned, po_schedule_date, 'Schedule date of purchase order should be minimum of schedule dates of purchase order lines.')
-        self.assertTrue(procurement_2.purchase_id.picking_ids, "Picking should be created.")
+        # Check the picking created or not
-        self.assertEqual(procurement_2.purchase_id.picking_ids.scheduled_date, po_schedule_date, 'Schedule date of In type shipment should be same as schedule date of purchase order.')
+        self.assertEqual(purchase2.picking_ids.scheduled_date, po_schedule_date, 'Schedule date of In type shipment should be same as schedule date of purchase order.')
-            'product_id': self.product_1.id,
+        self.env['procurement.group'].run({
-            'rule_id': self.warehouse_1.buy_pull_id.id
+            'product_uom': self.uom_unit,
-        procurement.purchase_id.button_confirm()
+        
-        order_date = fields.Datetime.from_string(procurement.date_planned) - timedelta(days=self.product_1.seller_ids.delay)
+        order_date = fields.Datetime.from_string(date_planned) - timedelta(days=self.product_1.seller_ids.delay)
-        self.assertEqual(procurement.purchase_id.date_order, po_order_date, 'Order date should be equal to: Date of the procurement order - Delivery Lead Time.')
+        self.assertEqual(purchase.date_order, po_order_date, 'Order date should be equal to: Date of the procurement order - Delivery Lead Time.')
-        self.assertEqual(procurement.date_planned, po_schedule_date, 'Schedule date should be equal to: Order date of Purchase order + Delivery Lead Time.')
+        self.assertEqual(date_planned, po_schedule_date, 'Schedule date should be equal to: Order date of Purchase order + Delivery Lead Time.')
-        self.assertTrue(procurement.purchase_id.picking_ids, "Picking should be created.")
+        self.assertTrue(purchase.picking_ids, "Picking should be created.")
-        self.assertEqual(incomming_shipment.scheduled_date, po_schedule_date, 'Schedule date of In type shipment should be same as schedule date of purchase order.')
+        incoming_shipment = purchase.picking_ids.filtered(lambda r: r.picking_type_id == self.warehouse_1.in_type_id and r.location_dest_id == self.warehouse_1.wh_input_stock_loc_id)
-        self.assertEqual(incomming_shipment2.scheduled_date, incomming_shipment2_schedule_date, 'Schedule date of Internal Type shipment for quality control stock location should be equal to: schedule date of Internal type shipment for input stock location + push rule delay..')
+        incoming_shipment1 = self.env['stock.picking'].search([('move_lines.product_id', 'in', (self.product_1.id, self.product_2.id)), ('picking_type_id', '=', self.warehouse_1.int_type_id.id), ('location_id', '=', self.warehouse_1.wh_input_stock_loc_id.id), ('location_dest_id', '=', self.warehouse_1.wh_qc_stock_loc_id.id)])
-        self.assertEqual(received_qty, 10.0, 'Purchase: Received quantity should be 10.0 instead of %s after validating incomming shipment' % received_qty)
+        self.assertEqual(received_qty, 10.0, 'Purchase: Received quantity should be 10.0 instead of %s after validating incoming shipment' % received_qty)
-        self.assertEqual(self.po.order_line.mapped('qty_invoiced'), [3.0, 3.0], 'Purchase: Billed quantity should be 3.0')
+        self.assertEqual(self.po.order_line.mapped('qty_invoiced'), [3.0, 3.0], 'Purchase: Billed quantity should be 3.0')
-    procurement_id = fields.Many2one('procurement.order', string='Procurement', ondelete='set null', copy=False)
+    move_dest_id = fields.Many2one('stock.move', 'Downstream Move')
-            'procurement_ids': [(6, 0, [requisition.procurement_id.id])] if requisition.procurement_id else False,
+            'move_dest_ids': self.move_dest_id and [(4, self.move_dest_id.id)] or []
-    requisition_id = fields.Many2one('purchase.requisition', string='Latest Requisition')
+class ProcurementGroup(models.Model):
-        return res
+    def _run_buy(self, product_id, product_qty, product_uom, location_id, name, origin, values, log_activites=False):
-        ProcurementOrder.run_scheduler()
+        date_planned = fields.Datetime.now()
-            self.assertEqual(float_compare(line.product_qty, procurement.product_qty, precision_digits=2), 0, "Quantity is not correspond.")
+        line = self.env['purchase.requisition.line'].search([('product_id', '=', self.product_13_id), ('product_qty', '=', 14.0)])
-    'depends': ['sales_team', 'account', 'procurement', 'portal'],
+    'depends': ['sales_team', 'account', 'portal'],
-}
+}
-from . import sales_team
+from . import sales_team
-    amount_tax = fields.Monetary(string='Taxes', store=True, readonly=True, compute='_amount_all', track_visibility='always')
+    amount_untaxed = fields.Monetary(string='Untaxed Amount', store=True, readonly=True, compute='_amount_all', track_visibility='onchange')
-            order.order_line._action_procurement_create()
+        self.write({
-from . import procurement
+from . import sale_mrp
-            bom_delivered = all([move.state == 'done' for move in self.procurement_ids.mapped('move_ids')])
+            bom_delivered = all([move.state == 'done' for move in self.move_ids])
-                    moves |= procurement.move_ids
+                moves = s_line.move_ids
-
+        self.env['procurement.group'].run_scheduler()
-        mnf_product_d = procurement_d.production_id
+        # FP Todo: find a better way to look for the production order
-        manufacturing_order = self.env['procurement.order'].search([('product_id', '=', self.product_1.id), ('group_id', '=', order.procurement_group_id.id), ('production_id', '!=', False)]).production_id
+        manufacturing_order = self.env['mrp.production'].search([('product_id', '=', self.product_1.id), ('move_dest_ids', 'in', order.picking_ids[0].move_lines.ids)])
-        self.env['procurement.order'].run_scheduler()
+        self.env['procurement.group'].run_scheduler()
-        manufacturing_order = self.env['procurement.order'].search([('product_id', '=', self.product_1.id), ('group_id', '=', order.procurement_group_id.id), ('production_id', '!=', False)]).production_id
+        manufacturing_order = self.env['mrp.production'].search([('product_id', '=', self.product_1.id)]) 
-            self.assertEqual(procurement.move_ids[0].date_expected, right_date, "The expected date for the Stock Move is wrong")
+            self.assertEqual(line.move_ids[0].date_expected, right_date, "The expected date for the Stock Move is wrong")
-                    moves |= procurement.move_ids
+                moves |=_line.move_ids
-        help="Margin of error for dates promised to customers. Products will be scheduled for procurement and delivery that many days earlier than the actual promised date, to cope with unexpected delays in the supply chain.")
+        help="Margin of error for dates promised to customers. Products will be scheduled for delivery that many days earlier than the actual promised date, to cope with unexpected delays in the supply chain.")
-    picking_ids = fields.Many2many('stock.picking', compute='_compute_picking_ids', string='Picking associated to this sale')
+    picking_ids = fields.One2many('stock.picking', 'sale_id', string='Pickings')
-    @api.depends('procurement_group_id')
+    def action_confirm(self):
-            action['res_id'] = pickings.id
+        action['domain'] = [('id', 'in', self.picking_ids.ids)]
-        self.mapped('order_line').mapped('procurement_ids').cancel()
+        self.picking_ids.action_cancel()
-
+    move_ids = fields.One2many('stock.move', 'sale_line_id', string='Stock Moves')
-                    and all(move.state in ['done', 'cancel'] for move in line.procurement_ids.mapped('move_ids')):
+                    and line.move_ids \
-        vals = super(SaleOrderLine, self)._prepare_order_line_procurement(group_id=group_id)
+        self.ensure_one()
-            'partner_dest_id': self.order_id.partner_shipping_id.id,
+        return {
-        return vals
+            'date_planned': date_planned.strftime(DEFAULT_SERVER_DATETIME_FORMAT),
-        """Computes the delivered quantity on sales order lines, based on done stock moves related to its procurements
+    def _action_procurement_create(self):
-        for move in self.procurement_ids.mapped('move_ids').filtered(lambda r: r.state == 'done' and not r.scrapped):
+        for move in self.move_ids.filtered(lambda r: r.state == 'done' and not r.scrapped):
-
+    sale_line_id = fields.Many2one('sale.order.line', 'Sale Line')
-        for line in sale_order_lines:
+        for line in self.mapped('sale_line_id'):
-                    subtype_id=self.env.ref('mail.mt_note').id)
+class ProcurementGroup(models.Model):
-                return
+    sale_id = fields.Many2one(related="group_id.sale_id", string="Sales Order", store=True)
-                order = self.env['sale.order'].search([('procurement_group_id', '=', backorder.group_id.id)])
+            if backorder.sale_id:
-                    values={'self': backorder, 'origin': order},
+                    values={'self': backorder, 'origin': backorder.sale_id},
-        return res
+        return res
-}
+}
-    sale_line_id = fields.Many2one('sale.order.line', 'Sales Order Line', related='procurement_id.sale_line_id', store=True)
+    sale_line_id = fields.Many2one('sale.order.line', 'Sales Order Line')
-        self.procurement_id = self.parent_id.procurement_id.id
+            order.order_line.filtered(lambda line: line._is_task())._create_task()
-    'depends': ['product', 'procurement', 'barcodes', 'web_planner'],
+    'depends': ['product', 'barcodes', 'web_planner'],
-        'wizard/procurement_orderpoint_compute_views.xml',
+        'wizard/stock_scheduler_compute_views.xml',
-        'views/procurement_views.xml',
+        'views/procurement_views.xml',
-        'test/procrule.yml',
+        'test/procrule.yml',
-from . import product
+from . import product
-import logging
+from odoo.exceptions import UserError
-
+    """ A rule describe what a procurement should do; produce, buy, move, ... """
-        return self.search([('move_dest_id', 'in', cancel_moves.filtered(lambda move: move.propagate).ids)])
+class ProcurementGroup(models.Model):
-        return super(ProcurementOrder, self).cancel()
+    partner_id = fields.Many2one('res.partner', 'Partner')
-        return action
+    @api.model
-        return parent_locations
+            if doraise:
-        """ First find a rule among the ones defined on the procurement order
+    @api.model
-            domain = expression.AND([['|', ('warehouse_id', '=', self.warehouse_id.id), ('warehouse_id', '=', False)], domain])
+        if values.get('warehouse_id', False):
-            res = Pull.search(expression.AND([[('route_id', 'in', self.route_ids.ids)], domain]), order='route_sequence, sequence', limit=1)
+        if values.get('route_ids', False):
-            product_routes = self.product_id.route_ids | self.product_id.categ_id.total_route_ids
+            product_routes = values['product_id'].route_ids | values['product_id'].categ_id.total_route_ids
-            warehouse_routes = self.warehouse_id.route_ids
+            warehouse_routes = values['warehouse_id'].route_ids
-    def _get_stock_move_values(self):
+    @api.model
-        date_expected = (datetime.strptime(self.date_planned, DEFAULT_SERVER_DATETIME_FORMAT) - relativedelta(days=self.rule_id.delay or 0)).strftime(DEFAULT_SERVER_DATETIME_FORMAT)
+        date_expected = (datetime.strptime(values['date_planned'], DEFAULT_SERVER_DATETIME_FORMAT) - relativedelta(days=rule.delay or 0)).strftime(DEFAULT_SERVER_DATETIME_FORMAT)
-        qty_left = max(self.product_qty - qty_done, 0)
+        qty_left = values['product_qty']
-            'product_uom': self.product_uom.id,
+            'name': values['name'][:2000],
-            'picking_type_id': self.rule_id.picking_type_id.id,
+            'partner_id': rule.partner_address_id.id or (values['group_id'] and values['group_id'].partner_id.id) or False,
-            'warehouse_id': self.rule_id.propagate_warehouse_id.id or self.rule_id.warehouse_id.id,
+            'route_ids': [(4, route.id) for route in values.get('route_ids', [])],
-            'priority': self.priority,
+            'propagate': rule.propagate,
-                return False
+    def _run(self, values, rule, doraise=True):
-            self.env['stock.move'].sudo().create(self._get_stock_move_values())
+            # Search if picking with move for it exists already:
-        return super(ProcurementOrder, self)._run()
+        return False
-        return super(ProcurementOrder, self)._check()
+    @api.model
-        ''' Call the scheduler in order to check the running procurements (super method), to check the minimum stock rules
+        """ Call the scheduler in order to check the running procurements (super method), to check the minimum stock rules
-        super(ProcurementOrder, self).run_scheduler(use_new_cursor=use_new_cursor, company_id=company_id)
+        we run functions as SUPERUSER to avoid intercompanies and access rights issues. """
-                # TDE CLEANME: muf muf
+                    
-                substract_quantity = location_orderpoints.subtract_procurements_from_orderpoints()
+                substract_quantity = location_orderpoints._quantity_in_progress()
-                                        subtype_id=self.env.ref('mail.mt_note').id)
+                                    self.env['procurement.group'].run(
-                procurements.run()
+
-    orderpoint_ids = fields.One2many('stock.warehouse.orderpoint', 'product_id', 'Minimum Stock Rules')
+
-        for inventory in self:
+        for inventory in self.filtered(lambda x: x.state not in ('done','cancel')):
-                stock_move = line._generate_moves()
+            inventory.line_ids._generate_moves()
-                vals = self._get_move_values(abs(diff), line.product_id.property_stock_inventory.id, line.location_id.id, False)
+                vals = line._get_move_values(abs(diff), line.product_id.property_stock_inventory.id, line.location_id.id, False)
-                vals = self._get_move_values(abs(diff), line.location_id.id, line.product_id.property_stock_inventory.id, True)
+                vals = line._get_move_values(abs(diff), line.location_id.id, line.product_id.property_stock_inventory.id, True)
-        default=lambda self: self.env['res.company']._company_default_get('procurement.order'), index=True)
+        default=lambda self: self.env['res.company']._company_default_get('stock.location.path'), index=True)
-from odoo.addons.procurement.models import procurement
+PROCUREMENT_PRIORITIES = [('0', 'Not urgent'), ('1', 'Normal'), ('2', 'Urgent'), ('3', 'Very Urgent')]
-    priority = fields.Selection(procurement.PROCUREMENT_PRIORITIES, 'Priority', default='1')
+    priority = fields.Selection(PROCUREMENT_PRIORITIES, 'Priority', default='1')
-    route_ids = fields.Many2many('stock.location.route', 'stock_location_route_move', 'move_id', 'route_id', 'Destination route', help="Preferred route to be followed by the procurement order")
+    route_ids = fields.Many2many('stock.location.route', 'stock_location_route_move', 'move_id', 'route_id', 'Destination route', help="Preferred route")
-            procurements.run()
+            self.env['procurement.group'].run(move._prepare_procurement_from_move())
-        group_id = self.group_id and self.group_id.id or False
+        group_id = self.group_id or False
-                group_id = self.rule_id.group_id.id
+                group_id = self.rule_id.group_id
-            'company_id': self.company_id.id,
+            'company_id': self.company_id,
-            'product_id': self.product_id.id,
+            'product_id': self.product_id,
-            'move_dest_id': self.id,
+            'product_uom': self.product_uom,
-            'warehouse_id': self.warehouse_id.id or (self.picking_type_id and self.picking_type_id.warehouse_id.id or False),
+            'route_ids': self.route_ids,
-            'procurement_id': self.procurement_id.id,
+
-from odoo.addons.procurement.models import procurement
+from odoo.addons.stock.models.stock_move import PROCUREMENT_PRIORITIES
-        procurement.PROCUREMENT_PRIORITIES, string='Priority',
+        PROCUREMENT_PRIORITIES, string='Priority',
-from odoo.tools import DEFAULT_SERVER_DATE_FORMAT
+from odoo.tools import DEFAULT_SERVER_DATETIME_FORMAT
-    procurement_ids = fields.One2many('procurement.order', 'orderpoint_id', 'Created Procurements')
+    @api.multi
-        return date_planned.strftime(DEFAULT_SERVER_DATE_FORMAT)
+        return date_planned.strftime(DEFAULT_SERVER_DATETIME_FORMAT)
-            'product_id': self.product_id.id,
+            'product_id': self.product_id,
-            'location_id': self.location_id.id,
+            'company_id': self.company_id,
-            'group_id': group or self.group_id.id,
+            'warehouse_id': self.warehouse_id,
-
+from odoo.exceptions import UserError
-        move_mto_alone.action_confirm()
+        with self.assertRaises(UserError):
-        self.assertTrue(proc2.rule_id)
+        })
-from . import procurement_orderpoint_compute
+from . import stock_scheduler_compute
-from . import stock_backorder_confirmation
+from . import stock_backorder_confirmation
-from odoo import api, models, tools
+from odoo import api, models, tools, fields
-    _description = 'Compute Minimum Stock Rules'
+class StockSchedulerCompute(models.TransientModel):
-            scheduler_cron = self.sudo().env.ref('procurement.ir_cron_scheduler_action')
+            scheduler_cron = self.sudo().env.ref('stock.ir_cron_scheduler_action')
-                company_id=self.env.user.company_id.id)
+            if self.orderpoints_only:
-    'installable': True,
+    'installable': False,
-            })]
+        self.env['stock.warehouse.orderpoint'].create({
-        'test/cancellation_propagated.yml',
+        #'test/cancellation_propagated.yml',
-from xml.etree import ElementTree
+from lxml import etree as ElementTree
-        if self.env['ir.config_parameter'].get_param('sale.auto_done_setting'):
+        if self.env['ir.config_parameter'].sudo().get_param('sale.auto_done_setting'):
-        with self.assertMaxQueries("Write on a tracked field", 49):
+        with self.assertMaxQueries("Write on a tracked field", 48):
-        with self.assertMaxQueries("Create record with tracking fields", 88):
+        with self.assertMaxQueries("Create record with tracking fields", 87):
-        self.cache = Cache()
+        self.cache = envs.cache
-        self._data = defaultdict(dict)          # {field: {id: value}}
+        # {field: {record_id: {key: value}}}
-        return record.id in self._data[field]
+        key = field.cache_key(record)
-        value = self._data[field][record.id]
+        key = field.cache_key(record)
-        self._data[field][record.id] = value
+        key = field.cache_key(record)
-        del self._data[field][record.id]
+        key = field.cache_key(record)
-        value = self._data[field].get(record.id, SpecialValue(None))
+        key = field.cache_key(record)
-        value = self._data[field].get(record.id, SpecialValue(None))
+        key = field.cache_key(record)
-        self._data[field][record.id] = SpecialValue(getter)
+        key = field.cache_key(record)
-            if name != 'id' and record.id in self._data[field]:
+            key = field.cache_key(record)
-        return model.browse(self._data[field])
+        browse = model.browse
-                env.cache._data.clear()
+            self._data.clear()
-                            field_cache.pop(id, None)
+            data = self._data
-            for record_id, value in field_cache.items():
+        for field, field_cache in self._data.items():
-                    dump[field][record_id] = value
+                    key = field.cache_key(browse(record_id))
-        self.env.check_cache()
+        self.env.cache.check(self.env)
-        self.env.check_cache()
+        self.env.cache.check(self.env)
-        self.env.check_cache()
+        self.env.cache.check(self.env)
-        self.env.check_cache()
+        self.env.cache.check(self.env)
-        self.env.check_cache()
+        self.env.cache.check(self.env)
-        self.assertItemsEqual(partners.ids, country_id_cache)
+        for partner in partners:
-        country_ids = set(cid for cids in country_id_cache.values() for cid in cids)
+        country_ids = {cid
-        self.assertItemsEqual(country_ids, name_cache)
+        for partner in partners:
-        self.env.invalidate_all()
+        self.env.cache.invalidate()
-        self.env.invalidate_all()
+        self.env.cache.invalidate()
-        self.env.invalidate_all()
+        self.env.cache.invalidate()
-        self.env.invalidate_all()
+        self.env.cache.invalidate()
-        self.env.invalidate_all()
+        self.env.cache.invalidate()
-        self.env.invalidate_all()
+        self.env.cache.invalidate()
-        self.env.invalidate_all()
+        self.env.cache.invalidate()
-        self.env.invalidate_all()
+        self.env.cache.invalidate()
-        self.env.invalidate_all()
+        self.env.cache.invalidate()
-        self.env.invalidate_all()
+        self.env.cache.invalidate()
-        self.env.invalidate_all()
+        self.env.cache.invalidate()
-        self.env.invalidate_all()
+        self.env.cache.invalidate()
-        self.env.invalidate_all()
+        # (force `invalidate` as but appear in onchange only when we get a cache
-        self.cache = defaultdict(dict)              # {field: {id: value, ...}, ...}
+        self.cache = Cache()
-        self.invalidate_all()
+        self.cache.invalidate()
-
+class Cache(object):
-                target._cache[name] = field.convert_to_cache(value, target, validate=False)
+            for field in src.get_fields(record):
-                value = record._cache[self.name]
+                value = record.env.cache.get(record, self)
-                value = record._cache[self.name]
+                value = record.env.cache.get(record, self)
-            record._cache[self.name] = value
+            record.env.cache.set(record, self, value)
-            env.invalidate(spec)
+            env.cache.invalidate(spec)
-                record._cache[self.name] = value
+                record.env.cache.set(record, self, value)
-                record._cache[field.name] = field.convert_to_cache(False, record, validate=False)
+                cache.set(record, field, field.convert_to_cache(False, record, validate=False))
-                        record._cache.set_failed([self.name], exc)
+                        record.env.cache.set_failed(record, [self], exc)
-            record._cache[self.name] = self.convert_to_cache(False, record, validate=False)
+            record.env.cache.set(record, self, self.convert_to_cache(False, record, validate=False))
-            record._cache.set_special(self.name, lambda: null)
+            record.env.cache.set_special(record, self, lambda: null)
-                target = (target.browse(env.cache[field]) - protected).filtered(
+                target = (env.cache.get_records(target, field) - protected).filtered(
-                target = target.browse(env.cache[field]) - protected
+                target = env.cache.get_records(target, field) - protected
-            record._cache[self.name] = value.id or 0
+            cache.set(record, self, value.id or 0)
-            record._cache[self.name] = data.get(record.id, False)
+            cache.set(record, self, data.get(record.id, False))
-            record._cache[self.name] = self.convert_to_cache(value, record, validate=False)
+            cache.set(record, self, self.convert_to_cache(value, record, validate=False))
-            if self.name in record._cache:
+            if cache.contains(record, self):
-                record._cache[self.name] = val
+                cache.set(record, self, val)
-                record._cache.set_special(self.name, self._update_getter(record, value))
+                cache.set_special(record, self, self._update_getter(record, value))
-            del record._cache[self.name]
+            cache = record.env.cache
-            record._cache[self.name] = val
+            cache.set(record, self, val)
-            record._cache[self.name] = tuple(group[record.id])
+            cache.set(record, self, tuple(group[record.id]))
-            record._cache[self.name] = tuple(group[record.id])
+            cache.set(record, self, tuple(group[record.id]))
-                if f.compute or (f.name in self._cache):
+                if f.compute or self.env.cache.contains(self, f):
-        if not self._cache.has_value(field.name):
+        if not self.env.cache.contains_value(self, field):
-            if field.name not in self._cache:
+            if not self.env.cache.contains(self, field):
-                self._cache.set_failed([field.name], exc)
+                self.env.cache.set_failed(self, field, exc)
-                    record._cache.set_failed(self._fields, exc)
+                self.env.cache.set_failed(forbidden, self._fields.values(), exc)
-                record._cache.set_failed(self._fields, exc)
+            self.env.cache.set_failed(self - existing, self._fields.values(), exc)
-        recs = self.browse(ids)
+        recs = self.browse(self._prefetch[self._name]) - self.env.cache.get_records(self, field)
-                return self.env.invalidate_all()
+                return self.env.cache.invalidate()
-        self.env.invalidate(spec)
+        self.env.cache.invalidate(spec)
-        self.env.invalidate(invalids)
+        self.env.cache.invalidate(invalids)
-        return self._record.id in self._record.env.cache[field]
+        return self._record.env.cache.contains(self._record, field)
-        return value.get() if isinstance(value, SpecialValue) else value
+        return self._record.env.cache.get(self._record, field)
-        self._record.env.cache[field][self._record.id] = value
+        self._record.env.cache.set(self._record, field, value)
-        del self._record.env.cache[field][self._record.id]
+        self._record.env.cache.remove(self._record, field)
-                yield name
+        for field in self._record.env.cache.get_fields(self._record):
-        return not isinstance(value, SpecialValue)
+        return self._record.env.cache.contains_value(self._record, field)
-        return default if isinstance(value, SpecialValue) else value
+        return self._record.env.cache.get_value(self._record, field, default)
-        self._record.env.cache[field][self._record.id] = SpecialValue(getter)
+        self._record.env.cache.set_special(self._record, field, getter)
-        self.get = getter
+        fields = [self._record._fields[name] for name in names]
-            (self - existing)._cache.update(fields.FailedValue(exc))
+            for record in (self - existing):
-        from odoo.fields import SpecialValue
+        from odoo.models import SpecialValue
-                value = record._cache[self]
+                value = record._cache[self.name]
-                value = record._cache[self]
+                value = record._cache[self.name]
-            record._cache[self] = value
+            record._cache[self.name] = value
-                record._cache[self] = value
+                record._cache[self.name] = value
-                record._cache[field] = field.convert_to_cache(False, record, validate=False)
+                record._cache[field.name] = field.convert_to_cache(False, record, validate=False)
-                        record._cache[self.name] = FailedValue(exc)
+                        record._cache.set_failed([self.name], exc)
-                            target._cache.update(values)
+                                values = {f.name: source[f.name] for f in computed}
-            record._cache[self] = self.convert_to_cache(False, record, validate=False)
+            record._cache[self.name] = self.convert_to_cache(False, record, validate=False)
-            record._cache[self] = SpecialValue(null)
+            record._cache.set_special(self.name, lambda: null)
-        records._cache[self] = value.id or 0
+        for record in records:
-        records._cache[self] = self.convert_to_cache(value, records, validate=False)
+        """ Update the cached value of ``self`` for ``records`` with ``value``. """
-            if self in record._cache:
+            if self.name in record._cache:
-            record._cache[self] = val
+                record._cache.set_special(self.name, self._update_getter(record, value))
-        if field not in self._cache:
+        if not self._cache.has_value(field.name):
-                self._cache[field] = FailedValue(e)
+            if field.name not in self._cache:
-                forbidden._cache.update(FailedValue(exc))
+                for record in forbidden:
-            (self - existing)._cache.update(FailedValue(exc))
+            for record in (self - existing):
-            recs = recs.mapped(lambda rec: field.convert_to_record(rec._cache.get(field, null), rec))
+            if recs:
-            field = self._recs._fields[field]
+    """ A mapping from field names to values, to read and update the cache of a record. """
-        value = self._recs.env.cache[field].get(self._recs.id, dummy)
+        value = self._record.env.cache[field].get(self._record.id, dummy)
-            field = self._recs._fields[field]
+    def get_value(self, name, default=None):
-        value = self._recs.env.cache[field].get(self._recs.id, dummy)
+        value = self._record.env.cache[field].get(self._record.id, dummy)
-        return value.get() if isinstance(value, SpecialValue) else value
+    def set_special(self, name, getter):
-        self._recs.env.cache[field].update(values)
+    def set_failed(self, names, exception):
-            field_cache.pop(id, None)
+class SpecialValue(object):
-        return sum(1 for name in self)
+    def __init__(self, getter):
-from .fields import Field, SpecialValue, FailedValue
+from .fields import Field
-        warehouse = self.env.ref('stock.warehouse0', raise_if_not_found=False)
+        warehouse = self.env['stock.warehouse'].search([], limit=1)
-                parsed = urlparse.urlparse(url, scheme='http')
+                parsed = werkzeug.urls.url_parse(url, scheme='http')
-    'depends': ['website', 'sale', 'payment', 'website_payment', 'website_portal_sale', 'website_account', 'website_mail', 'website_form', 'website_rating'],
+    'depends': ['website', 'sale_payment', 'website_payment', 'website_portal_sale', 'website_account', 'website_mail', 'website_form', 'website_rating'],
-                default_res_model_id=self.env.ref('model_crm_lead').id,
+                default_res_model_id=self.env.ref('crm.model_crm_lead').id,
-            defaults['res_id'] = defaults['applicant_id']
+
-                    partner[field] = ''
+                    partner[field] = None
-                return dcap + '-' + to_19_fr[val % 10]
+        base = 10
-        word = to_19_fr[rem] + ' Cent'
+        word = (rem > 1 and to_19_fr[rem] + ' cents') or 'Cent'
-                return dcap + '-' + to_19_nl[val % 10]
+                return to_19_nl[val % 10] + '-en-' +  dcap
-        word = to_19_nl[rem] + ' Honderd'
+        word = (rem > 1 and to_19_nl[rem] + 'honderd') or 'Honderd'
-                        raise UserError(_('You need to supply a lot/serial number.'))
+                        raise UserError(_('You need to supply a lot/serial number for %s.') % ml.product_id.name)
-                        raise UserError(_('Some products require lots/serial numbers, so you need to specify those first!'))
+        if self.state == 'draft' or no_quantities_done:
-        'Show Operations', default=False)
+        'Show Detailed Operations', default=False,
-        'stock.production.lot', 'Current Lot', domain="[('product_id', '=', product_id)]",
+        'stock.production.lot', 'Lot/Serial Number', domain="[('product_id', '=', product_id)]",
-            'location_destination': move_line.location_dest_id.name,
+            'location': move_line.location_id.name + ' -> ' + move_line.location_dest_id.name,
-                'product_id': product_id_name,
+                'product_id': move_line.product_id.display_name,
-                'location_source': move_line.location_dest_id.name,
+                'location': move_line.location_dest_id.name,
-                'product_id': product_id_name,
+                'product_id': move_line.product_id.display_name,
-                'location_source': move_line.location_id.name,
+                'location': move_line.location_id.name,
-                            data.get('location_destination', False)],
+                            data.get('location', False)],
-                            data.get('location_destination')],
+                            data.get('location')],
-                if move.product_id.tracking == 'serial':
+                if move.product_id.tracking == 'serial' and (move.picking_type_id.use_create_lots or move.picking_type_id.use_existing_lots):
-    def _putaway_apply_fixed(self, product):
+    def putaway_apply(self, product):
-        tx = request.env['payment.transaction']._check_or_create_sale_tx(
+        tx = request.env['payment.transaction'].sudo()._check_or_create_sale_tx(
-        tx = request.env['payment.transaction'].sudo().check_or_create_sale_tx(
+        tx = request.env['payment.transaction'].sudo()._check_or_create_sale_tx(
-    def check_or_create_sale_tx(self, order, acquirer, payment_token=None, tx_type='form', add_tx_values=None, reset_draft=True):
+    def _check_or_create_sale_tx(self, order, acquirer, payment_token=None, tx_type='form', add_tx_values=None, reset_draft=True):
-        tx = tx.check_or_create_sale_tx(order, acquirer, payment_token=token, tx_type=tx_type, add_tx_values={
+        tx = tx._check_or_create_sale_tx(order, acquirer, payment_token=token, tx_type=tx_type, add_tx_values={
-        tx = tx.check_or_create_sale_tx(order, token.acquirer_id, payment_token=token, tx_type=tx_type, add_tx_values={
+        tx = tx._check_or_create_sale_tx(order, token.acquirer_id, payment_token=token, tx_type=tx_type, add_tx_values={
-        tx = tx.check_or_create_sale_tx(order, acquirer, payment_token=payment_token, tx_type=tx_type)
+        tx = tx._check_or_create_sale_tx(order, acquirer, payment_token=payment_token, tx_type=tx_type)
-        tx = tx.check_or_create_sale_tx(order, token.acquirer_id, payment_token=token, tx_type='server2server')
+        tx = tx._check_or_create_sale_tx(order, token.acquirer_id, payment_token=token, tx_type='server2server')
-        if self.env.context.get('default_res_model'):  # super default_model='crm.lead' for easier use in adddons
+        # super default_model='crm.lead' for easier use in adddons
-
+        if self.env.context.get('default_opportunity_id'):
-            defaults['res_id'] = defaults['opportunity_id']
+
-        if event.opportunity_id:
+
-        records_to_unlink = self.env['calendar.event']
+        records_to_unlink = self.env['calendar.event'].with_context(recompute=False)
-        return request.env["im_livechat.channel"].get_mail_channel(channel_id, anonymous_name)
+        return request.env["im_livechat.channel"].with_context(lang=False).get_mail_channel(channel_id, anonymous_name)
-                parsed = urlparse.urlparse(url, scheme='http')
+                parsed = werkzeug.urls.url_parse(url, scheme='http')
-        sys.exit('Unknow command. Command available: %r' % (list(cmds,))
+        sys.exit('Unknow command. Command available: %r' % (list(cmds,)))
-        if self.zip_from and (contact.zip or '') < self.zip_from:
+        if self.zip_from and (contact.zip or '').upper() < self.zip_from.upper():
-        if self.zip_to and (contact.zip or '') > self.zip_to:
+        if self.zip_to and (contact.zip or '').upper() > self.zip_to.upper():
-        quants_res = dict((item['product_id'][0], item['qty']) for item in Quant.read_group(domain_quant, ['product_id', 'qty'], ['product_id']))
+        moves_in_res = dict((item['product_id'][0], item['product_qty']) for item in Move.read_group(domain_move_in_todo, ['product_id', 'product_qty'], ['product_id'], orderby='id'))
-            moves_out_res_past = dict((item['product_id'][0], item['product_qty']) for item in Move.read_group(domain_move_out_done, ['product_id', 'product_qty'], ['product_id']))
+            moves_in_res_past = dict((item['product_id'][0], item['product_qty']) for item in Move.read_group(domain_move_in_done, ['product_id', 'product_qty'], ['product_id'], orderby='id'))
-        quants_groupby = self.env['stock.quant'].read_group(domain_quant, ['product_id', 'qty'], ['product_id'])
+        quants_groupby = self.env['stock.quant'].read_group(domain_quant, ['product_id', 'qty'], ['product_id'], orderby='id')
-        env = api.Environment(cr, SUPERUSER_ID, {})
+            env = api.Environment(cr, SUPERUSER_ID, {})
-        'views/res_company_views.xml',
+        'views/res_company_view.xml',
-from odoo import api, models
+from odoo import api, fields, models
-
+    # NB: Also defined in mass_mailing
-    social_googleplus = fields.Char('Google+ Account')
+    social_twitter = fields.Char(related="company_id.social_twitter")
-    module_website_sale_options = fields.Boolean("Optional Products", help='Installs *e-Commerce Optional Products*')
+    module_website_sale_options = fields.Boolean("Optional Products")
-    module_website_sale_comparison = fields.Boolean("Product Comparator", help='Installs *e-Commerce Comparator*')
+    module_website_sale_wishlist = fields.Boolean("Wishlists")
-    module_sale_stock = fields.Boolean("Delivery Orders")
+    module_l10n_eu_service = fields.Boolean(string="EU Digital Goods VAT")
-    module_crm_voip = fields.Boolean("Asterisk (VoIP)")
+        # Or a date/datetime if it matches the pattern
-            return ['float', 'monetary']
+            results  = ['float', 'monetary']
-            return ['date']
+            results += ['date']
-            return ['datetime']
+            results += ['datetime']
-                'advanced_mode': any([len(models.fix_import_export_id_paths(col)) > 1 for col in headers]),
+                'advanced_mode': any([len(models.fix_import_export_id_paths(col)) > 1 for col in headers or []]),
-                self.payment_tx_id._generate_and_pay_invoice(self.payment_tx_id, self.payment_acquirer_id.provider)
+                self.payment_tx_id._generate_and_pay_invoice()
-
+from . import controllers
-from odoo import fields, models
+import logging
-        raise exception
+        raise pycompat.reraise(type(exception), exception, sys.exc_info()[2])
-            }
+
-
+    # --------------------------------------------------
-                _logger.warning('<%s> transaction MISMATCH for order %s (ID %s)', tx.acquirer_id.provider, tx.sale_order_id.name, tx.sale_order_id.id)
+        """ Check tx state, confirm the potential SO """
-                return _("Payment transaction failed (Contact Administrator)")
+                _logger.warning(
-                return _("Payment transaction failed (%s)" % self.state_message)
+                _logger.warning(
-                return True
+                return self._confirm_so()
-        return _('Tx missmatch')
+                _logger.warning(
-        if not self or self.state in ['error', 'cancel']:
+        if not tx:
-        if (self and acquirer and self.acquirer_id != acquirer) or (self and self.sale_order_id != order):
+        if (tx and tx.acquirer_id != acquirer) or (tx and tx.sale_order_id != order):  # filter unmatching
-        if tx and payment_token and tx.payment_token_id and payment_token != self.payment_token_id:
+        if tx and payment_token and tx.payment_token_id and payment_token != tx.payment_token_id:  # new or distinct token
-import base64
+    @http.route(['/my/quotes/accept'], type='json', auth="public", website=True)
-from odoo import fields, http, _
+from odoo import exceptions, fields, http, _
-from odoo.addons.portal.controllers.portal import get_records_pager
+from odoo.addons.portal.controllers.portal import CustomerPortal, get_records_pager
-
+from odoo.addons.portal.controllers.mail import _message_post_helper
-    module_website_quote = fields.Boolean("Online Quotations & Templates")
+    portal_confirmation = fields.Boolean('Online Signature & Payment')
-        return super(MailController, cls)._redirect_to_record(model, res_id, access_token=None)
+        return super(MailController, cls)._redirect_to_record(model, res_id, access_token=access_token)
-}
+    used_in_bom_count = fields.Integer('# BoM Where Used', compute='_compute_used_in_bom_count')
-            return None, None
+            return [], {}
-            self.env['base_import.import']._match_headers([], [], {}), (None, None)
+            self.env['base_import.import']._match_headers([], [], {}), ([], {})
-                value['start_date'] = fields.date.context_today(self, cr, uid, context=context, timestamp=start)
+                if context.get('default_allday'):
-                value['stop_date'] = fields.date.context_today(self, cr, uid, context=context, timestamp=end)
+                if context.get('default_allday'):
-    return output_stream.getvalue().encode('base64')
+    return base64.b64encode(output_stream.getvalue())
-        return channel.sudo(request_uid).channel_fetch_message(last_id, limit)
+        if not channel:
-from odoo.tools import topological_sort, html_escape, pycompat
+from odoo.tools import crop_image, topological_sort, html_escape, pycompat
-    def content_image(self, xmlid=None, model='ir.attachment', id=None, field='datas', filename_field='datas_fname', unique=None, filename=None, mimetype=None, download=None, width=0, height=0):
+    def content_image(self, xmlid=None, model='ir.attachment', id=None, field='datas', filename_field='datas_fname', unique=None, filename=None, mimetype=None, download=None, width=0, height=0, crop=False):
-        if content and (width or height):
+
-                record.image_thumb = image.crop_image(record.image, type='top', ratio=(4, 3), thumbnail_ratio=6)
+                record.image_medium = image.crop_image(record.image, type='top', ratio=(4, 3), size=(500, 400))
-def crop_image(data, type='top', ratio=False, thumbnail_ratio=None, image_format="PNG"):
+def crop_image(data, type='top', ratio=False, size=None, image_format="PNG"):
-            e.g. thumbnail_ratio=2 will reduce your 500x500 image converted in to 250x250
+        :param size: Resize image to size
-    return base64.b64encode(output_stream.getvalue())
+    if size:
-        self.phantom_js('/web/tests?mod=web', "", "", login='admin', timeout=240)
+        self.phantom_js('/web/tests?mod=web', "", "", login='admin', timeout=300)
-        res_config_id = env['account.config.settings'].create({
+    for company in env['res.company'].search([]):
-            self.manufacturing_lead = 0.0
+            self.manufacturing_lead = 0.0
-        return super(MailController, cls)._redirect_to_record(model, res_id, access_token=None)
+        return super(MailController, cls)._redirect_to_record(model, res_id, access_token=access_token)
-            response.set_cookie('session_id', httprequest.session.sid, max_age=90 * 24 * 60 * 60)
+            response.set_cookie(
-    query = "SELECT 1 FROM information_schema.tables WHERE table_name=%s"
+    query = "SELECT 1 FROM pg_class WHERE relkind IN ('r', 'v', 'm') AND relname=%s"
-        self.phantom_js('/web/tests?mod=web', "", "", login='admin', timeout=240)
+        self.phantom_js('/web/tests?mod=web', "", "", login='admin', timeout=300)
-    module_pad = fields.Boolean("External Pads")
+    module_pad = fields.Boolean("Collaborative Pads")
-        ('delivery', 'Delivered quantities or service hours')
+        ('order', 'Invoice what is ordered'),
-    module_delivery = fields.Boolean("Shipping Costs")
+    module_delivery = fields.Boolean("Manage shipping internally")
-        "Product Prices", default='subtotal')
+    automatic_invoice = fields.Boolean("Automatic Invoice")
-    alias_prefix = fields.Char('Default Alias Name for Leads')
+    crm_alias_prefix = fields.Char('Default Alias Name for Leads')
-        self.alias_prefix = 'info' if self.generate_lead_from_alias else False
+        self.crm_alias_prefix = 'info' if self.generate_lead_from_alias else False
-            alias_prefix=alias.alias_name if alias else False,
+            crm_alias_prefix=alias.alias_name if alias else False,
-            alias.write({'alias_name': self.alias_prefix})
+            alias.write({'alias_name': self.crm_alias_prefix})
-                alias_parent_model_name='crm.team').create({'alias_name': self.alias_prefix})
+                alias_parent_model_name='crm.team').create({'alias_name': self.crm_alias_prefix})
-    alias_prefix = fields.Char('Default Alias Name for Expenses')
+    expense_alias_prefix = fields.Char('Default Alias Name for Expenses')
-            alias_prefix=self.env.ref('hr_expense.mail_alias_expense').alias_name,
+            expense_alias_prefix=self.env.ref('hr_expense.mail_alias_expense').alias_name,
-        self.env.ref('hr_expense.mail_alias_expense').write({'alias_name': self.alias_prefix})
+        self.env.ref('hr_expense.mail_alias_expense').write({'alias_name': self.expense_alias_prefix})
-            self.alias_prefix = False
+            self.expense_alias_prefix = False
-    project_id = fields.Many2one('project.project', string='Project', domain=[('use_tasks', '=', True)])
+    project_id = fields.Many2one('project.project', string='Project')
-        # Prevent double project creation when 'use_tasks' is checked
+        # Prevent double project creation
-        return vals.get('use_tasks') and 'project_creation_in_progress' not in self.env.context
+        return 'project_creation_in_progress' not in self.env.context
-            action_context['search_default_rating_tasks'] = 1
+        action_context['search_default_rating_tasks'] = 1
-                project_id = account.project_create({'name': account.name, 'use_tasks': True})
+                project_id = account.project_create({'name': account.name})
-                        order.project_id.project_create({'name': order.project_id.name, 'use_tasks': True})
+                        order.project_id.project_create({'name': order.project_id.name})
-from odoo.tools import float_compare, float_repr
+from odoo.tools import float_repr
-                    field = self.env[model].browse(res_id)
+                    field = self.env[model].browse(res_id).with_context(
-                    field = self.env[model].browse(res_id)
+                    field = self.env[model].browse(res_id).with_context(
-            action_context = {'show_mode_selector': False, 'account_ids': [self.id,]}
+            action_context = {'show_mode_selector': False, 'mode': 'accounts', 'account_ids': [self.id,]}
-            invoice.check_access_rule('read')
+            invoice_sudo = self._invoice_check_access(invoice_id, access_token)
-                return request.redirect('/my')
+            return request.redirect('/my')
-        }
+        values = self._invoice_get_page_view_values(invoice_sudo, access_token, **kw)
-            invoice.check_access_rule('read')
+            invoice_sudo = self._invoice_check_access(invoice_id, access_token)
-                return request.redirect('/my')
+            return request.redirect('/my')
-        pdf = request.env.ref('account.account_invoices').sudo().render_qweb_pdf([invoice_id])[0]
+        pdf = request.env.ref('account.account_invoices').sudo().render_qweb_pdf([invoice_sudo.id])[0]
-        'views/sale_templates.xml',
+        'views/assets.xml',
-    def orders_followup(self, order=None, access_token=None, **kw):
+    def portal_order_page(self, order=None, access_token=None, **kw):
-        return request.render("sale.orders_followup", values)
+        return request.render("sale.portal_order_page", values)
-        response = super(WebsiteSaleDigital, self).orders_followup(order=order, **post)
+    def portal_order_page(self, order=None, **post):
-            order.check_access_rule('read')
+            order_sudo = self._order_check_access(order, access_token=access_token)
-            values.update({'no_breadcrumbs': True})
+            return request.redirect('/my')
-        values.update(get_records_pager(history, order_sudo))
+        values = self._order_get_page_view_values(order_sudo, access_token, **kw)
-                if date_action < date.today():
+                if date_action < date.today() and not opp.date_closed:
-from openerp import models, SUPERUSER_ID
+from openerp import models
-                self.default_get(['medium_id']).get('medium_id') or
+                defaults.get('medium_id') or
-        if self.filtered(lambda aal: aal.so_line.product_id.invoice_policy == "delivery") and self.filtered(lambda timesheet: timesheet.timesheet_invoice_id):
+        if self.sudo().filtered(lambda aal: aal.so_line.product_id.invoice_policy == "delivery") and self.filtered(lambda timesheet: timesheet.timesheet_invoice_id):
-            if last_attendance_before_check_in and last_attendance_before_check_in.check_out and last_attendance_before_check_in.check_out >= attendance.check_in:
+            if last_attendance_before_check_in and last_attendance_before_check_in.check_out and last_attendance_before_check_in.check_out > attendance.check_in:
-                raise UserError(_("You cannot delete a posted expense."))
+            if expense.state in ['post', 'done']:
-        'views/report_overdue.xml',
+        'views/account_cash_rounding_view.xml',
-    @api.depends('invoice_line_ids.price_subtotal', 'tax_line_ids.amount', 'currency_id', 'company_id', 'date_invoice', 'type')
+    @api.depends('invoice_line_ids.price_subtotal', 'tax_line_ids.amount', 'tax_line_ids.amount_rounding',
-        self.amount_tax = sum(line.amount for line in self.tax_line_ids)
+        self.amount_tax = sum(line.amount_total for line in self.tax_line_ids)
-            if tax_line.amount:
+            if tax_line.amount_total:
-                    'price_unit': tax_line.amount,
+                    'price_unit': tax_line.amount_total,
-                    'price': tax_line.amount,
+                    'price': tax_line.amount_total,
-
+    @api.depends('amount', 'amount_rounding')
-    env = api.Environment(cr, SUPERUSER_ID, {})
+
-    'post_init_hook': 'load_translations',
+    'post_init_hook': 'post_init',
-           rounded up to 1, and the latest one always rounding up.
+       :param rounding_method: the rounding method used: 'HALF-UP', 'UP' or 'DOWN',
-    # When rounding the value up, we instead subtract the epsilon value
+    # TIE-BREAKING: UP (for ceiling[resp. flooring] operations)
-    # The math.ceil operation is applied on the absolute value in order to
+    # tie limit, this would result in incorrectly rounding up[resp. down] to the next number
-    elif rounding_method == 'UP':
+    else:
-        rounded_value = math.ceil(abs(normalized_value))*sign # ceil to integer
+        rounded_value = func(abs(normalized_value)) * sign
-        'wizard/hr_expense_register_payment.xml',
+        'wizard/hr_expense_refuse_reason_views.xml',
-        help='Expense Report State')
+    help='Expense Report State')
-    def refuse_expenses(self, reason):
+    def refuse_sheet(self, reason):
-            sheet.message_post(body=body)
+            sheet.message_post_with_view('hr_expense.hr_expense_template_refuse_reason',
-from . import hr_expense_register_payment
+from . import hr_expense_sheet_register_payment
-    _description = "Hr Expense refuse Reason wizard"
+    _description = "Expense refuse Reason wizard"
-    description = fields.Char(string='Reason', required=True)
+    reason = fields.Char(string='Reason', required=True)
-class HrExpenseRegisterPaymentWizard(models.TransientModel):
+class HrExpenseSheetRegisterPaymentWizard(models.TransientModel):
-    _description = "Hr Expense Register Payment wizard"
+    _name = "hr.expense.sheet.register.payment.wizard"
-    _inherit = "hr.expense.register.payment.wizard"
+    _inherit = "hr.expense.sheet.register.payment.wizard"
-        'views/account_config_settings_views.xml',
+        'views/res_config_settings_views.xml',
-from . import account_config_settings
+from . import res_config_settings
-class AccountConfigSettings(models.TransientModel):
+class ResConfigSettings(models.TransientModel):
-        res = super(AccountConfigSettings, self).get_values()
+        res = super(ResConfigSettings, self).get_values()
-        super(AccountConfigSettings, self).set_values()
+        super(ResConfigSettings, self).set_values()
-        return super(AccountConfigSettings, self).create(values)
+        return super(ResConfigSettings, self).create(values)
-        'views/account_config_settings_views.xml',
+        'views/res_config_settings_views.xml',
-        'views/account_config_settings_views.xml',
+        'views/res_config_settings_views.xml',
-        'views/account_config_settings_views.xml',
+        'views/res_config_settings_views.xml',
-        'views/auth_ldap_config_settings_views.xml',
+        'views/res_config_settings_views.xml',
-from . import auth_ldap_config_settings
+from . import res_config_settings
-class BaseConfigSettings(models.TransientModel):
+class ResConfigSettings(models.TransientModel):
-        'views/base_config_settings_views.xml',
+        'views/res_config_settings_views.xml',
-from . import base_config_settings
+from . import res_config_settings
-class BaseConfigSettings(models.TransientModel):
+class ResConfigSettings(models.TransientModel):
-        res = super(BaseConfigSettings, self).get_values()
+        res = super(ResConfigSettings, self).get_values()
-        super(BaseConfigSettings, self).set_values()
+        super(ResConfigSettings, self).set_values()
-        'views/base_config_settings_views.xml',
+        'views/res_config_settings_views.xml',
-from . import base_config_settings
+from . import res_config_settings
-class BaseConfigSettings(models.TransientModel):
+class ResConfigSettings(models.TransientModel):
-        res = super(BaseConfigSettings, self).get_values()
+        res = super(ResConfigSettings, self).get_values()
-        super(BaseConfigSettings, self).set_values()
+        super(ResConfigSettings, self).set_values()
-        'views/base_config_settings_views.xml',
+        'views/res_config_settings_views.xml',
-from . import base_config_settings
+from . import res_config_settings
-class BaseConfigSettings(models.TransientModel):
+class ResConfigSettings(models.TransientModel):
-        'views/base_config_settings_views.xml',
+        'views/res_config_settings_views.xml',
-from . import base_config_settings
+from . import res_config_settings
-class BaseConfigSettings(models.TransientModel):
+class ResConfigSettings(models.TransientModel):
-        res = super(BaseConfigSettings, self).get_values()
+        res = super(ResConfigSettings, self).get_values()
-        super(BaseConfigSettings, self).set_values()
+        super(ResConfigSettings, self).set_values()
-        'views/account_config_settings_views.xml',
+        'views/res_config_settings_views.xml',
-from . import account_config_settings
+from . import res_config_settings
-class AccountConfigSettings(models.TransientModel):
+class ResConfigSettings(models.TransientModel):
-        'views/crm_config_settings_views.xml',
+        'views/res_config_settings_views.xml',
-from . import crm_config_settings
+from . import res_config_settings
-class CrmConfigSettings(models.TransientModel):
+class ResConfigSettings(models.TransientModel):
-        res = super(CrmConfigSettings, self).get_values()
+        res = super(ResConfigSettings, self).get_values()
-        super(CrmConfigSettings, self).set_values()
+        super(ResConfigSettings, self).set_values()
-        'views/crm_config_settings_views.xml',
+        'views/res_config_settings_views.xml',
-from . import crm_config_settings
+from . import res_config_settings
-class CrmConfigSettings(models.TransientModel):
+class ResConfigSettings(models.TransientModel):
-        'views/sale_config_settings_views.xml',
+        'views/res_config_settings_views.xml',
-        'views/event_config_settings_views.xml',
+        'views/res_config_settings_views.xml',
-class event_config_settings(models.TransientModel):
+class ResConfigSettings(models.TransientModel):
-        'views/base_config_settings_views.xml',
+        'views/res_config_settings_views.xml',
-from . import base_config_settings
+from . import res_config_settings
-class BaseConfigSettings(models.TransientModel):
+class ResConfigSettings(models.TransientModel):
-        super(BaseConfigSettings, self).set_values()
+        super(ResConfigSettings, self).set_values()
-        res = super(BaseConfigSettings, self).get_values()
+        res = super(ResConfigSettings, self).get_values()
-        'views/base_config_settings_views.xml',
+        'views/res_config_settings_views.xml',
-from . import base_config_settings
+from . import res_config_settings
-class BaseConfigSettings(models.TransientModel):
+class ResConfigSettings(models.TransientModel):
-        res = super(BaseConfigSettings, self).get_values()
+        res = super(ResConfigSettings, self).get_values()
-        super(BaseConfigSettings, self).set_values()
+        super(ResConfigSettings, self).set_values()
-        'views/base_config_settings_views.xml',
+        'views/res_config_settings_views.xml',
-from . import base_config_settings
+from . import res_config_settings
-class BaseConfigSettings(models.TransientModel):
+class ResConfigSettings(models.TransientModel):
-        'views/hr_config_settings_views.xml',
+        'views/res_config_settings_views.xml',
-from . import hr_config_settings
+from . import res_config_settings
-class HrConfigurator(models.TransientModel):
+class ResConfigSettings(models.TransientModel):
-        'views/attendance_config_settings_views.xml',
+        'views/res_config_settings_views.xml',
-from . import attendance_config_settings
+from . import res_config_settings
-class BaseConfigSettings(models.TransientModel):
+class ResConfigSettings(models.TransientModel):
-        'views/hr_expense_config_settings_views.xml',
+        'views/res_config_settings_views.xml',
-from . import hr_expense_config_settings
+from . import res_config_settings
-class HrExpenseConfigSettings(models.TransientModel):
+class ResConfigSettings(models.TransientModel):
-        res = super(HrExpenseConfigSettings, self).get_values()
+        res = super(ResConfigSettings, self).get_values()
-        super(HrExpenseConfigSettings, self).set_values()
+        super(ResConfigSettings, self).set_values()
-        'views/hr_payroll_config_settings_views.xml',
+        'views/res_config_settings_views.xml',
-from . import hr_payroll_config_settings
+from . import res_config_settings
-class HrPayrollConfigSettings(models.TransientModel):
+class ResConfigSettings(models.TransientModel):
-        'views/hr_recruitment_config_settings_views.xml',
+        'views/res_config_settings_views.xml',
-from . import hr_recruitment_config_settings
+from . import res_config_settings
-class RecruitmentSettings(models.TransientModel):
+class ResConfigSettings(models.TransientModel):
-        'views/hr_recruitment_config_setting_views.xml',
+        'views/res_config_setting_views.xml',
-        'views/hr_timesheet_config_settings_views.xml',
+        'views/res_config_settings_views.xml',
-from . import hr_timesheet_config_settings
+from . import res_config_settings
-class HrTimesheetConfiguration(models.TransientModel):
+class ResConfigSettings(models.TransientModel):
-        'views/fleet_config_settings_views.xml',
+        'views/res_config_settings_views.xml',
-from . import fleet_config_settings
+from . import res_config_settings
-class FleetConfigSettings(models.TransientModel):
+class ResConfigSettings(models.TransientModel):
-        super(FleetConfigSettings, self).set_values()
+        super(ResConfigSettings, self).set_values()
-        res = super(FleetConfigSettings, self).get_values()
+        res = super(ResConfigSettings, self).get_values()
-        'views/account_config_settings_views.xml',
+        'views/res_config_settings_views.xml',
-from . import account_config_settings
+from . import res_config_settings
-class AccountConfigSettings(models.TransientModel):
+class ResConfigSettings(models.TransientModel):
-        'views/account_settings_config_views.xml'
+        'views/res_config_settings_views.xml'
-        'views/l10n_fr_hr_payroll_config_settings_views.xml',
+        'views/res_config_settings_views.xml',
-from . import l10n_fr_hr_payroll_config_settings
+from . import res_config_settings
-class HrPayrollConfigSettings(models.TransientModel):
+class ResConfigSettings(models.TransientModel):
-        "views/account_config_settings_views.xml",
+        "views/res_config_settings_views.xml",
-from . import account_config_settings
+from . import res_config_settings
-class AccountConfigSettings(models.TransientModel):
+class ResConfigSettings(models.TransientModel):
-        'views/base_config_settings_views.xml',
+        'views/res_config_settings_views.xml',
-from . import base_config_settings
+from . import res_config_settings
-class BaseConfigSettings(models.TransientModel):
+class ResConfigSettings(models.TransientModel):
-        res = super(BaseConfigSettings, self).get_values()
+        res = super(ResConfigSettings, self).get_values()
-        super(BaseConfigSettings, self).set_values()
+        super(ResConfigSettings, self).set_values()
-        'views/mass_mailing_config_settings_views.xml',
+        'views/res_config_settings_views.xml',
-from . import mass_mailing_config_settings
+from . import res_config_settings
-class MassMailingConfiguration(models.TransientModel):
+class ResConfigSettings(models.TransientModel):
-        'views/mrp_config_settings_views.xml',
+        'views/res_config_settings_views.xml',
-from . import mrp_config_settings
+from . import res_config_settings
-class MrpConfigSettings(models.TransientModel):
+class ResConfigSettings(models.TransientModel):
-        res = super(MrpConfigSettings, self).get_values()
+        res = super(ResConfigSettings, self).get_values()
-        super(MrpConfigSettings, self).set_values()
+        super(ResConfigSettings, self).set_values()
-        'views/base_config_settings_views.xml',
+        'views/res_config_settings_views.xml',
-from . import base_config_settings
+from . import res_config_settings
-class BaseConfigSettings(models.TransientModel):
+class ResConfigSettings(models.TransientModel):
-        'views/project_config_settings_views.xml',
+        'views/res_config_settings_views.xml',
-        'views/base_config_settings_views.xml',
+        'views/res_config_settings_views.xml',
-from . import base_config_settings
+from . import res_config_settings
-class BaseConfigSettings(models.TransientModel):
+class ResConfigSettings(models.TransientModel):
-        res = super(BaseConfigSettings, self).get_values()
+        res = super(ResConfigSettings, self).get_values()
-        super(BaseConfigSettings, self).set_values()
+        super(ResConfigSettings, self).set_values()
-        'views/project_config_settings_views.xml',
+        'views/res_config_settings_views.xml',
-from . import project_config_settings
+from . import res_config_settings
-class ProjectConfiguration(models.TransientModel):
+class ResConfigSettings(models.TransientModel):
-        'views/hr_timesheet_config_settings_views.xml',
+        'views/res_config_settings_views.xml',
-from . import hr_timesheet_config_settings
+from . import res_config_settings
-class TimesheetConfig(models.TransientModel):
+class ResConfigSettings(models.TransientModel):
-        'views/stock_config_settings_views.xml',
+        'views/res_config_settings_views.xml',
-from . import purchase_config_settings
+from . import res_config_settings
-class PurchaseConfigSettings(models.TransientModel):
+class ResConfigSettings(models.TransientModel):
-        res = super(PurchaseConfigSettings, self).get_values()
+        res = super(ResConfigSettings, self).get_values()
-        super(PurchaseConfigSettings, self).set_values()
+        super(ResConfigSettings, self).set_values()
-class StockConfigSettings(models.TransientModel):
+class ResConfigSettings(models.TransientModel):
-        res = super(StockConfigSettings, self).get_values()
+        res = super(ResConfigSettings, self).get_values()
-        super(StockConfigSettings, self).set_values()
+        super(ResConfigSettings, self).set_values()
-        'views/purchase_config_settings_views.xml',
+        'views/res_config_settings_views.xml',
-        'views/project_config_settings_views.xml',
+        'views/res_config_settings_views.xml',
-        'views/sale_config_settings_views.xml',
+        'views/res_config_settings_views.xml',
-from . import sale_config_settings
+from . import res_config_settings
-class SaleConfigSettings(models.TransientModel):
+class ResConfigSettings(models.TransientModel):
-        res = super(SaleConfigSettings, self).get_values()
+        res = super(ResConfigSettings, self).get_values()
-        super(SaleConfigSettings, self).set_values()
+        super(ResConfigSettings, self).set_values()
-        'views/stock_config_settings_views.xml',
+        'views/res_config_settings_views.xml',
-from . import stock_config_settings
+from . import res_config_settings
-class StockConfigSettings(models.TransientModel):
+class ResConfigSettings(models.TransientModel):
-    security_lead = fields.Float(related='company_id.security_lead')
+    security_lead = fields.Float(related='company_id.security_lead', string="Security Lead Time")
-        res = super(StockConfigSettings, self).get_values()
+        res = super(ResConfigSettings, self).get_values()
-        super(StockConfigSettings, self).set_values()
+        super(ResConfigSettings, self).set_values()
-        'views/res_config_views.xml',
+        'views/res_config_settings_views.xml',
-        'views/stock_config_settings_views.xml',
+        'views/res_config_settings_views.xml',
-from . import stock_config_settings
+from . import res_config_settings
-class StockConfigSettings(models.TransientModel):
+class ResConfigSettings(models.TransientModel):
-        res = super(StockConfigSettings, self).get_values()
+        res = super(ResConfigSettings, self).get_values()
-        super(StockConfigSettings, self).set_values()
+        super(ResConfigSettings, self).set_values()
-        'views/stock_config_settings_views.xml',
+        'views/res_config_settings_views.xml',
-from . import stock_config_settings
+from . import res_config_settings
-class StockConfigSettings(models.TransientModel):
+class ResConfigSettings(models.TransientModel):
-        'views/stock_config_settings_views.xml',
+        'views/res_config_settings_views.xml',
-        'views/website_config_settings_views.xml',
+        'views/res_config_settings_views.xml',
-from . import website_config_settings
+from . import res_config_settings
-class WebsiteConfigSettings(models.TransientModel):
+class ResConfigSettings(models.TransientModel):
-        res = super(WebsiteConfigSettings, self).get_values()
+        res = super(ResConfigSettings, self).get_values()
-        super(WebsiteConfigSettings, self).set_values()
+        super(ResConfigSettings, self).set_values()
-        'views/website_crm_config_settings_views.xml',
+        'views/res_config_settings_views.xml',
-from . import website_crm_config_settings
+from . import res_config_settings
-class WebsiteCrmConfigSettings(models.TransientModel):
+class ResConfigSettings(models.TransientModel):
-        'views/event_config_settings_views.xml',
+        'views/res_config_settings_views.xml',
-        'views/website_config_settings_views.xml',
+        'views/res_config_settings_views.xml',
-from . import website_config_settings
+from . import res_config_settings
-class WebsiteConfigSettings(models.TransientModel):
+class ResConfigSettings(models.TransientModel):
-        'views/mass_mailing_config_settings_views.xml',
+        'views/res_config_settings_views.xml',
-from . import mass_mailing_config_settings
+from . import res_config_settings
-class MassMailingConfiguration(models.TransientModel):
+class ResConfigSettings(models.TransientModel):
-        'views/sale_config_settings_views.xml',
+        'views/res_config_settings_views.xml',
-from .import sale_config_settings
+from .import res_config_settings
-class SaleConfiguration(models.TransientModel):
+class ResConfigSettings(models.TransientModel):
-        'views/website_config_settings_views.xml',
+        'views/res_config_settings_views.xml',
-from . import website_config_settings
+from . import res_config_settings
-class WebsiteConfigSettings(models.TransientModel):
+class ResConfigSettings(models.TransientModel):
-        res = super(WebsiteConfigSettings, self).get_values()
+        res = super(ResConfigSettings, self).get_values()
-        super(WebsiteConfigSettings, self).set_values()
+        super(ResConfigSettings, self).set_values()
-        'views/website_config_settings_views.xml',
+        'views/res_config_settings_views.xml',
-        'views/website_config_settings_views.xml',
+        'views/res_config_settings_views.xml',
-from . import website_config_settings
+from . import res_config_settings
-class WebsiteConfigSettings(models.TransientModel):
+class ResConfigSettings(models.TransientModel):
-        super(WebsiteConfigSettings, self).set_values()
+        super(ResConfigSettings, self).set_values()
-        res = super(WebsiteConfigSettings, self).get_values()
+        res = super(ResConfigSettings, self).get_values()
-        'views/website_config_settings_views.xml',
+        'views/res_config_settings_views.xml',
-from . import website_config_settings
+from . import res_config_settings
-class WebsiteConfigSettings(models.TransientModel):
+class ResConfigSettings(models.TransientModel):
-        res = super(WebsiteConfigSettings, self).get_values()
+        res = super(ResConfigSettings, self).get_values()
-        super(WebsiteConfigSettings, self).set_values()
+        super(ResConfigSettings, self).set_values()
-        'views/website_twitter_settings_views.xml',
+        'views/res_config_settings_views.xml',
-from . import website_twitter_config
+from . import res_config_settings
-class WebsiteTwitterConfig(models.TransientModel):
+class ResConfigSettings(models.TransientModel):
-        TwitterConfig = super(WebsiteTwitterConfig, self).create(vals)
+        TwitterConfig = super(ResConfigSettings, self).create(vals)
-        TwitterConfig = super(WebsiteTwitterConfig, self).write(vals)
+        TwitterConfig = super(ResConfigSettings, self).write(vals)
-        'res/res_config_settings_view.xml',
+        'res/res_config_settings_views.xml',
-    _inherit = 'base.config.settings'
+    _inherit = 'res.config.settings'
-    _inherit = 'base.config.settings'
+    _inherit = 'res.config.settings'
-    _inherit = 'base.config.settings'
+    _inherit = 'res.config.settings'
-    _inherit = 'base.config.settings'
+    _inherit = 'res.config.settings'
-    module_pad = fields.Boolean("External Pads")
+    module_pad = fields.Boolean("External Pads")
-    _inherit = 'account.config.settings'
+    _inherit = 'res.config.settings'
-    _inherit = 'crm.config.settings'
+    _inherit = 'res.config.settings'
-    crm_phone_valid_method = fields.Boolean(related="company_id.phone_international_format", required=True)
+    crm_phone_valid_method = fields.Selection(related="company_id.phone_international_format", required=True)
-        self.SaleConfigSetting = self.env['sale.config.settings']
+        self.SaleConfigSetting = self.env['res.config.settings']
-            event_config = self.env['event.config.settings'].sudo(self.user_eventmanager).create({
+            event_config = self.env['res.config.settings'].sudo(self.user_eventmanager).create({
-    _inherit = 'base.config.settings'
+    _inherit = 'res.config.settings'
-    _inherit = "base.config.settings"
+    _inherit = "res.config.settings"
-    _inherit = "base.config.settings"
+    _inherit = "res.config.settings"
-        'res.company', 'Company',
+    	'res.company', string='Company',
-    _inherit = 'base.config.settings'
+    _inherit = 'res.config.settings'
-        res.update(max_unused_cars=params.get_param('l10n_be_hr_payroll_fleet.max_unused_cars', default=3))
+        res.update(max_unused_cars=int(params.get_param('l10n_be_hr_payroll_fleet.max_unused_cars', default=3)))
-    _inherit = 'account.config.settings'
+    _inherit = 'res.config.settings'
-    _inherit = 'hr.payroll.config.settings'
+    _inherit = 'res.config.settings'
-    _inherit = 'account.config.settings'
+    _inherit = 'res.config.settings'
-    _inherit = 'base.config.settings'
+    _inherit = 'res.config.settings'
-    _inherit = 'base.config.settings'
+    _inherit = 'res.config.settings'
-        return self.env.user.company_id.phone_international_format
+            return self.company_id.phone_international_format == 'prefix'
-        always_international = company.phone_international_format if company else self._phone_get_always_international()
+        always_international = company.phone_international_format == 'prefix' if company else self._phone_get_always_international()
-        string="Enforce International Format", default=False,
+    phone_international_format = fields.Selection([
-    _inherit = 'base.config.settings'
+    _inherit = 'res.config.settings'
-    _inherit = 'hr.timesheet.config.settings'
+    _inherit = 'res.config.settings'
-    _inherit = 'account.config.settings'
+    _inherit = 'res.config.settings'
-    _inherit = 'stock.config.settings'
+    _inherit = 'res.config.settings'
-    module_print_docsaway = fields.Boolean("Docsaway")
+    @api.onchange('sale_show_tax')
-    _inherit = 'sale.config.settings'
+    _inherit = 'res.config.settings'
-    _inherit = 'stock.config.settings'
+    _inherit = 'res.config.settings'
-    _inherit = 'stock.config.settings'
+    _inherit = 'res.config.settings'
-            config = request.env['website.config.settings'].sudo().create({})
+            config = request.env['res.config.settings'].sudo().create({})
-        request.env['website.config.settings'].create({
+        request.env['res.config.settings'].create({
-    _inherit = 'website.config.settings'
+    _inherit = 'res.config.settings'
-    _inherit = 'website.config.settings'
+    _inherit = 'res.config.settings'
-    _inherit = 'mass.mailing.config.settings'
+    _inherit = 'res.config.settings'
-    _inherit = 'sale.config.settings'
+    _inherit = 'res.config.settings'
-    _inherit = 'website.config.settings'
+    _inherit = 'res.config.settings'
-    sale_show_tax = fields.Selection([
+    website_sale_show_tax = fields.Selection([
-            sale_show_tax=self.env['ir.config_parameter'].sudo().get_param('website.sale_show_tax')
+            website_sale_show_tax=self.env['ir.config_parameter'].sudo().get_param('website.website_sale_show_tax')
-        self.env['ir.config_parameter'].sudo().set_param('website.sale_show_tax', self.sale_show_tax)
+        self.env['ir.config_parameter'].sudo().set_param('website.website_sale_show_tax', self.website_sale_show_tax)
-    @api.onchange('sale_show_tax')
+    @api.onchange('website_sale_show_tax')
-        if self.sale_show_tax == "subtotal":
+        if self.website_sale_show_tax == "subtotal":
-    _inherit = 'website.config.settings'
+    _inherit = 'res.config.settings'
-    _inherit = "website.config.settings"
+    _inherit = "res.config.settings"
-    _inherit = 'website.config.settings'
+    _inherit = 'res.config.settings'
-        return self.env['base.config.settings'].open_company()
+        return self.env['res.config.settings'].open_company()
-                quantity_hour = so_line.product_uom._compute_quantity(so_line.product_uom_qty, timesheet_uom)
+                quantity_hour = unit_amount
-                    move_id.with_context(force_valuation_amount=qty_difference*move_id.price_unit)._account_entry_move()
+                    if move_id.product_id.cost_method == 'standard':
-                    'name': operation.name,
+                    'name': repair.name,
-            action['context'] = {'default_product_id': products.ids[0]}
+    def action_view_stock_move_lines(self):
-    color = fields.Integer("Color Index", default=1)
+    account_hide_setup_bar = fields.Boolean(string='Hide Setup Bar', related='company_id.account_setup_bar_closed',help="Tick if you wish to hide the setup bar on the dashboard")
-
+    #Needed for setup, as a decoration attribute needs to know that for a tree view in one of the popups, and there's no way to reference directly a xml id from there
-        # Create a record for the given model with the given vals and 
+        # Create a record for the given model with the given vals and
-                'company_id': company.id,})
+        company.get_unaffected_earnings_account()
-from datetime import timedelta
+from odoo.exceptions import UserError
-            'account.account', 'account.account.template', exceptions=['company_id', 'deprecated', 'last_time_entries_checked'])
+            'account.account', 'account.account.template', exceptions=['company_id', 'deprecated', 'last_time_entries_checked', 'opening_debit', 'opening_credit'])
-                content = base64.b64decode(sitemap)
+                content = base64.b64decode(sitemap.datas)
-                content = base64.b64decode(sitemap)
+                content = base64.b64decode(sitemap.datas)
-        query = "SELECT relname FROM pg_class WHERE relkind IN ('r','v') AND relname=%s"
+        query = "SELECT relname FROM pg_class WHERE relkind IN ('r','v','m') AND relname=%s"
-        if not self.env.user._is_admin() or not self.sequence_number_next or not self._no_existing_validated_invoice():
+        journal_sequence, domain = self._get_seq_number_next_stuff()
-            #use _get_current_sequence to manage the date range sequences
+            # use _get_current_sequence to manage the date range sequences
-            name = re.sub(r'[\[\]:*?/\\]', '', name)
+            if name:
-            name = name[:31]
+                # maximum size is 31 characters
-        self.env['ir.values'].set_default('test_new_api.foo', 'value2', 666, condition='value1=42')
+        self.env['ir.default'].set('test_new_api.foo', 'value2', 666, condition='value1=42')
-            defaults = self.env['ir.values'].get_defaults_dict(self._name, condition)
+            defaults = self.env['ir.default'].get_model_defaults(self._name, condition)
-        if self.so_line.product_id.invoice_policy != "order" and self.filtered(lambda timesheet: timesheet.timesheet_invoice_id):
+        # prevent to update invoiced timesheets if one line is of type delivery
-        # check that analytic line for product 'ordered' can be altered
+        # check that analytic line for product 'delivery' cannot be altered
-        # check that analytic line for product 'delivered' cannot be altered
+        # check that analytic line for product 'ordered' can be altered
-    state = fields.Selection(related='move_id.state')
+    state = fields.Selection(related='move_id.state', store=True)
-        ('direct', 'Partial'), ('one', 'All at once')], 'Shipping Policy',
+        ('direct', 'As soon as possible'), ('one', 'When all products are ready')], 'Shipping Policy',
-        'stock.location', "Destination Location Zone",
+        'stock.location', "Destination Location",
-        'views/stock_inventory_views.xml',
+        'views/stock_scrap_views.xml',
-        self.env.ref('hr_contract.ir_cron_data_contract_update_to_close').method_direct_trigger()
+        self.env.ref('hr_contract.ir_cron_data_contract_update_state').method_direct_trigger()
-        for template, product in zip(self, self.mapped('product_variant_id')):
+        for template, product in pycompat.izip(self, self.mapped('product_variant_id')):
-from odoo.tools import config, ustr
+from odoo.tools import config, ustr, pycompat
-    location = path_or_uri.strip()
+    current_path = request.httprequest.path     # should already be text
-                        ids.add(comodel.new(command[2]).id)
+                        ids.add(comodel.new(command[2], command[1]).id)
-                result.append((0, 0, vals))
+                result.append((0, record.id.ref or 0, vals))
-    """ Pseudo-ids for new records. """
+    """ Pseudo-ids for new records, encapsulating an optional reference. """
-    def new(self, values={}):
+    def new(self, values={}, ref=None):
-        record = self.browse([NewId()])
+        record = self.browse([NewId(ref)])
-
+
-            self.next_work_order_id.final_lot_id = self.final_lot_id.id
+        if self.final_lot_id:
-        self.final_lot_id = False
+            if self.next_work_order_id and self.production_id.product_id.tracking != 'none':
-                    move_line.product_qty += self.qty_producing
+                    move_line.product_uom_qty += self.qty_producing
-            res[g['partner_id'][0]] = g['partner_id_count']
+            res[g['product_id'][0]] = g['product_id_count']
-            post.can_view = is_admin or user.karma >= post.karma_close or (post_sudo.create_uid.karma > 0 and (post_sudo.active or post_sudo.create_uid.id == user))
+            post.can_view = is_admin or user.karma >= post.karma_close or (post_sudo.create_uid.karma > 0 and (post_sudo.active or post_sudo.create_uid == user))
-            if move.unit_factor:
+        for move in self.production_id.move_raw_ids:
-                move.quantity_done += float_round(quantity * move.unit_factor, precision_rounding=rounding)
+        for move in self.production_id.move_finished_ids:
-            self.filtered(lambda m: m.state not in ['draft', 'done', 'cancel']).do_unreserve()
+        if vals.get('product_uom_qty'):
-.. SAT: http://www.sat.gob.mx/
+.. _SAT: http://www.sat.gob.mx/
-        sha = hashlib.sha1(getattr(record, '__last_update')).hexdigest()[0:7]
+        sha = hashlib.sha1(options.get('unique', getattr(record, '__last_update'))).hexdigest()[0:7]
-    sequence_number_next = fields.Char(string='Next Number', compute="_get_sequence_prefix", inverse="_set_sequence_next")
+    sequence_number_next = fields.Char(string='Next Number', compute="_get_sequence_number_next", inverse="_set_sequence_next")
-        """ computes the number that will be assigned to the first invoice/bill/refund of a journal, in order to
+        """ computes the prefix of the number that will be assigned to the first invoice/bill/refund of a journal, in order to
-                domain = [('type', 'in', ['in_invoice', 'in_refund'])]
+            journal_sequence, domain = invoice._get_seq_number_next_stuff()
-            domain += [('journal_id', '=', invoice.journal_id.id), ('state', 'not in', ['draft', 'cancel'])]
+                invoice.sequence_number_next_prefix = False
-        self.all_lines_reconciled = all([line.journal_entry_ids.ids or line.account_id.id for line in self.line_ids])
+        self.all_lines_reconciled = all([line.journal_entry_ids.ids or line.account_id.id for line in self.line_ids if not self.currency_id.is_zero(line.amount)])
-                elif not st_line.journal_entry_ids.ids:
+                elif not st_line.journal_entry_ids.ids and not statement.currency_id.is_zero(st_line.amount):
-                        WHERE account_id IS NULL AND not exists (select 1 from account_move_line aml where aml.statement_line_id = stl.id)
+                        WHERE account_id IS NULL AND stl.amount != 0.0 AND not exists (select 1 from account_move_line aml where aml.statement_line_id = stl.id)
-            raise ValidationError(_('A transaction can\'t have a 0 amount.'))
+        # Allow to enter bank statement line with an amount of 0,
-                            WHERE st.journal_id IN %s AND st.state = 'open'
+                            WHERE st.journal_id IN %s AND st.state = 'open' AND line.amount != 0.0
-                        filtered_st_lines.append(line_vals)
+                    filtered_st_lines.append(line_vals)
-    state = fields.Selection([('draft', 'Draft'), ('posted', 'Posted'), ('sent', 'Sent'), ('reconciled', 'Reconciled'), ('cancel', 'Cancelled')], readonly=True, default='draft', copy=False, string="Status")
+    state = fields.Selection([('draft', 'Draft'), ('posted', 'Posted'), ('sent', 'Sent'), ('reconciled', 'Reconciled'), ('cancelled', 'Cancelled')], readonly=True, default='draft', copy=False, string="Status")
-            rec.state = 'cancel'
+            rec.state = 'cancelled'
-        payments.filtered(lambda r: r.state != 'sent').write({'state': 'sent'})
+        payments.filtered(lambda r: r.state not in ('sent', 'cancelled')).write({'state': 'sent'})
-
+            vals['image'] = image_resize_image(vals['image'], size=(64,64))
-        image_resize_images(vals)
+           vals['image'] = image_resize_image(vals['image'], size=(64,64))
-        return [icon for icon in icons if any(acq.website_published for acq in icon.acquirer_ids)]
+        return self.env['payment.icon'].sudo().search([('acquirer_ids.website_published', '=', True)])
-        acquirers = list(request.env['payment.acquirer'].search([('website_published', '=', True), ('registration_view_template_id', '!=', False), ('prefered_payment_type', 'in', ['s2s', 'both'])]))
+        acquirers = list(request.env['payment.acquirer'].search([('website_published', '=', True), ('registration_view_template_id', '!=', False), ('payment_flow', '=', 's2s')]))
-        ('always', 'Always (recommended for Subscriptions)')],
+        ('ask', 'Let the customer decide'),
-        Note: Subscriptions does not take this field in account, it uses server to server by default.""")
+    payment_flow = fields.Selection(selection=[('s2s','The customer encode his payment details on the website.'),
-            values['s2s_acquirers'] = [acq for acq in acquirers if acq.prefered_payment_type in ['s2s', 'both'] and acq.registration_view_template_id]
+            values['form_acquirers'] = [acq for acq in acquirers if acq.payment_flow == 'form' and acq.view_template_id]
-        values['s2s_acquirers'] = [acq for acq in acquirers if acq.prefered_payment_type in ['s2s', 'both'] and acq.registration_view_template_id]
+        values['form_acquirers'] = [acq for acq in acquirers if acq.payment_flow == 'form' and acq.view_template_id]
-        'data/payment_option_data.xml',
+        'data/payment_icon_data.xml',
-    payment_option_ids = fields.Many2many('payment.option', string='Supported Payment Option')
+    payment_icon_ids = fields.Many2many('payment.icon', string='Supported Payment Icons')
-    def get_s2s_form_name(self):
+    def get_s2s_form_xml_id(self):
-    _description = 'Payment Option'
+class PaymentIcon(models.Model):
-    acquirer_ids = fields.Many2many('payment.acquirer', string="Acquirers", help="List of Acquirers supporting this payment option.")
+    acquirer_ids = fields.Many2many('payment.acquirer', string="Acquirers", help="List of Acquirers supporting this payment icon.")
-        help="This field holds the image used for this payment option, limited to 1024x1024px")
+        help="This field holds the image used for this payment icon, limited to 1024x1024px")
-        help="Medium-sized image of this payment option. It is automatically "
+        help="Medium-sized image of this payment icon. It is automatically "
-        help="Small-sized image of this payment option. It is automatically "
+        help="Small-sized image of this payment icon. It is automatically "
-        return super(PaymentOption, self).create(vals)
+        return super(PaymentIcon, self).create(vals)
-        return super(PaymentOption, self).write(vals)
+        return super(PaymentIcon, self).write(vals)
-        """ This function returns the list of payment options which are supported by payment acquirers that are published
+    def payment_icons(self):
-        return [opt for opt in options if any(acq.website_published for acq in opt.acquirer_ids)]
+        icons = self.env['payment.icon'].sudo().search([('acquirer_ids', '!=', False)])
-    u'BIF', u'XAF', u'XPF', u'CLP', u'KMF', u'DJF', u'GNF', u'JPY', u'MGA', u'PYGÃ­', u'RWF', u'KRW',
+    u'BIF', u'XAF', u'XPF', u'CLP', u'KMF', u'DJF', u'GNF', u'JPY', u'MGA', u'PYG', u'RWF', u'KRW',
-];
+]
-            self.image_payment_form = image_resize_image(vals['image'], size=(45,30))
+            vals['image_payment_form'] = image_resize_image(vals['image'], size=(45,30))
-            self.image_payment_form = image_resize_image(vals['image'], size=(45,30))
+           vals['image_payment_form'] = image_resize_image(vals['image'], size=(45,30))
-            'bootstrap_formatting': True
+            'bootstrap_formatting': True,
-from odoo.tools import consteq, float_round, image_resize_images, ustr
+from odoo.tools import consteq, float_round, image_resize_images, image_resize_image, ustr
-            'bootstrap_formatting': True
+            'bootstrap_formatting': True,
-        self.assertEqual(tree.get('action'), 'https://www.sandbox.paypal.com/cgi-bin/webscr', 'paypal: wrong form POST url')
+
-        #                                  })
+        # return True
-        # return tx.render_sale_button(order, '/shop/payment/validate')
+        # return True
-        self.assertEqual(tree.get('action'), 'https://test.authorize.net/gateway/transact.dll', 'Authorize: wrong form POST url')
+
-            if values[1] in ['submit', 'x_fp_hash', 'return_url', 'x_state', 'x_ship_to_state']:
+            if values[1] in ['submit', 'x_fp_hash', 'return_url', 'x_state', 'x_ship_to_state', 'data_set']:
-        self.assertEqual(tree.get('action'), 'https://www.sandbox.paypal.com/cgi-bin/webscr', 'paypal: wrong form POST url')
+
-            if form_input.get('name') in ['submit']:
+            if form_input.get('name') in ['submit', 'data_set']:
-            'acquirers': acquirers
+            'acquirers': acquirers,
-        return self.registration_view_template_id.render(qweb_context, engine='ir.qweb')
+    def get_s2s_form_name(self):
-
+            return_url= '/shop/payment/validate',
-        acquirers = list(request.env['payment.acquirer'].search([('website_published', '=', True), ('registration_view_template_id', '!=', False)]))
+        acquirers = list(request.env['payment.acquirer'].search([('website_published', '=', True), ('registration_view_template_id', '!=', False), ('prefered_payment_type', 'in', ['s2s', 'both'])]))
-                    order_sudo.pricelist_id.currency_id.id,
+            acquirers = request.env['payment.acquirer'].sudo().search([('website_published', '=', True), ('company_id', '=', order_sudo.company_id.id)])
-    def payment_transaction_token(self, acquirer_id, order_id, access_token=None, tx_type=None):
+    @http.route(['/quote/<int:order_id>/transaction/'], type='json', auth="public", website=True)
-            return request.redirect("/quote/%s" % order_id)
+            return False
-                                         })
+        return True
-        values['s2s_acquirers'] = [acq for acq in acquirers if acq.registration_view_template_id]
+        values['form_acquirers'] = [acq for acq in acquirers if acq.prefered_payment_type in ['form', 'both'] and acq.view_template_id]
-            acq.form = acq.sudo()._registration_render(order.partner_id.id, {
+            acq.form = acq._registration_render(order.partner_id.id, {
-    def payment_transaction(self, acquirer_id, tx_type='form', token=None, **kwargs):
+    @http.route(['/shop/payment/transaction/',
-            return request.redirect("/shop/checkout")
+            # return request.redirect("/shop/checkout")
-            return request.env.ref('website_sale.payment_token_form').render(dict(tx=tx), engine='ir.qweb')
+        # if token:
-        return tx.render_sale_button(order, '/shop/payment/validate')
+        return True
-    def payment_token(self, pm_id=None, **kw):
+    def payment_token(self, pm_id=None, **kwargs):
-        if not pm_id:
+        if not token:
-        if payment_token and tx.payment_token_id and payment_token != self.payment_token_id:
+        if tx and payment_token and tx.payment_token_id and payment_token != self.payment_token_id:
-            values['acquirers'].append(acquirer)
+            acquirer.button = acquirer_button #TBE TODO: remove this line
-        return list(self.env['payment.acquirer'].sudo().search([('website_published', '=', True)]))
+    def payment_options(self):
-
+        self.cron_spawn()
-
+            vals['image'] = image_resize_image(vals['image'], size=(64,64))
-        image_resize_images(vals)
+           vals['image'] = image_resize_image(vals['image'], size=(64,64))
-        return [icon for icon in icons if any(acq.website_published for acq in icon.acquirer_ids)]
+        return self.env['payment.icon'].sudo().search([('acquirer_ids.website_published', '=', True)])
-    bank_journal_id = fields.Many2one('account.journal', string='Bank Journal', states={'done': [('readonly', True)], 'post': [('readonly', True)]}, default=lambda self: self.env['account.journal'].search([('type', 'in', ['case', 'bank'])], limit=1), help="The payment method used when the expense is paid by the company.")
+    bank_journal_id = fields.Many2one('account.journal', string='Bank Journal', states={'done': [('readonly', True)], 'post': [('readonly', True)]}, default=lambda self: self.env['account.journal'].search([('type', 'in', ['cash', 'bank'])], limit=1), help="The payment method used when the expense is paid by the company.")
-            quantity_done[move.product_id.id] += move.quantity_done #TODO: convert to base units
+            quantity_todo[move.product_id.id] += move.product_uom_qty
-        backorder_wizard.process()
+        wizard.process()
-        backorder_wizard.process()
+        wizard.process()
-        wizard.process()
+        res_dict_for_back_order = wizard.process()
-        wizard.process()
+        res_dict_for_back_order = wizard.process()
-        wizard.process()
+        res_dict_for_back_order = wizard.process()
-        wizard.process()
+        res_dict_for_back_order = wizard.process()
-        acquirers = list(request.env['payment.acquirer'].search([('website_published', '=', True), ('registration_view_template_id', '!=', False), ('prefered_payment_type', 'in', ['s2s', 'both'])]))
+        acquirers = list(request.env['payment.acquirer'].search([('website_published', '=', True), ('registration_view_template_id', '!=', False), ('payment_flow', '=', 's2s')]))
-        ('always', 'Always (recommended for Subscriptions)')],
+        ('ask', 'Let the customer decide'),
-        Note: Subscriptions does not take this field in account, it uses server to server by default.""")
+    payment_flow = fields.Selection(selection=[('s2s','The customer encode his payment details on the website.'),
-            values['s2s_acquirers'] = [acq for acq in acquirers if acq.prefered_payment_type in ['s2s', 'both'] and acq.registration_view_template_id]
+            values['form_acquirers'] = [acq for acq in acquirers if acq.payment_flow == 'form' and acq.view_template_id]
-        values['s2s_acquirers'] = [acq for acq in acquirers if acq.prefered_payment_type in ['s2s', 'both'] and acq.registration_view_template_id]
+        values['form_acquirers'] = [acq for acq in acquirers if acq.payment_flow == 'form' and acq.view_template_id]
-    "version" : "1.0",
+    "version" : "2.0",
-            p.website_public_price = p.product_variant_id.website_public_price
+        # First filter out the ones that have no variant:
-    'version': '1.0',
+    'version': '2.0',
-    'version': '1.0',
+    'version': '2.0',
-    'version' : '1.02',
+    'version' : '2.0',
-            res[product_id] = Production.search_count(cr,uid, [('product_id', '=', product_id)], context=context)
+        res = dict.fromkeys(ids, 0)
-            raise ValidationError(_('The payment amount must be strictly positive.'))
+        if self.amount < 0:
-            if counterpart_aml['debit']:
+            if counterpart_aml['debit'] or writeoff_line['credit']:
-            if counterpart_aml['credit']:
+            if counterpart_aml['credit'] or writeoff_line['debit']:
-        aml_obj.create(liquidity_aml_dict)
+        if not self.currency_id.is_zero(self.amount):
-            super(AccountPayment, self)._onchange_amount()
+        res = super(AccountPayment, self)._onchange_amount()
-        if self.invoice_id.currency_id and self.invoice_id.company_id and self.invoice_id.currency_id != self.invoice_id.company_id.currency_id:
+        self.price_total = taxes['total_included'] if taxes else self.price_subtotal
-        store=True, readonly=True, compute='_compute_price')
+        store=True, readonly=True, compute='_compute_price', help="Total amount without taxes")
-        'data/payment_option_data.xml',
+        'data/payment_icon_data.xml',
-    payment_option_ids = fields.Many2many('payment.option', string='Supported Payment Option')
+    payment_icon_ids = fields.Many2many('payment.icon', string='Supported Payment Icons')
-    def get_s2s_form_name(self):
+    def get_s2s_form_xml_id(self):
-    _description = 'Payment Option'
+class PaymentIcon(models.Model):
-    acquirer_ids = fields.Many2many('payment.acquirer', string="Acquirers", help="List of Acquirers supporting this payment option.")
+    acquirer_ids = fields.Many2many('payment.acquirer', string="Acquirers", help="List of Acquirers supporting this payment icon.")
-        help="This field holds the image used for this payment option, limited to 1024x1024px")
+        help="This field holds the image used for this payment icon, limited to 1024x1024px")
-        help="Medium-sized image of this payment option. It is automatically "
+        help="Medium-sized image of this payment icon. It is automatically "
-        help="Small-sized image of this payment option. It is automatically "
+        help="Small-sized image of this payment icon. It is automatically "
-        return super(PaymentOption, self).create(vals)
+        return super(PaymentIcon, self).create(vals)
-        return super(PaymentOption, self).write(vals)
+        return super(PaymentIcon, self).write(vals)
-        """ This function returns the list of payment options which are supported by payment acquirers that are published
+    def payment_icons(self):
-        return [opt for opt in options if any(acq.website_published for acq in opt.acquirer_ids)]
+        icons = self.env['payment.icon'].sudo().search([('acquirer_ids', '!=', False)])
-        # of account_move_line related field company_currency_id which can be slow depending on the number of entries 
+        # of account_move_line related field company_currency_id which can be slow depending on the number of entries
-            """.format(**locals())
+        move_line_id = self.env.context.get('move_line_id', False)
-            return lines.prepare_move_lines_for_reconciliation_widget(target_currency=target_currency)
+            rec_prop += self.browse(list(set(pairs[0])))
-        action_context = {'show_mode_selector': False, 'company_ids': [self.company_id.id], 'partner_ids': [self.partner_id.commercial_partner_id.id]}
+        move_line_id = False
-    "version" : "1.1",
+    "version" : "2.0",
-            'price_unit': line.order_id.currency_id.compute(line.price_unit, self.currency_id, round=False),
+            'price_unit': line.order_id.currency_id.with_context(date=self.date_invoice).compute(line.price_unit, self.currency_id, round=False),
-    @api.onchange('currency_id')
+    @api.onchange('currency_id', 'date_invoice')
-                line.price_unit = line.purchase_id.currency_id.compute(line.purchase_line_id.price_unit, self.currency_id, round=False)
+                line.price_unit = line.purchase_id.currency_id.with_context(date=self.date_invoice).compute(line.purchase_line_id.price_unit, self.currency_id, round=False)
-            tax_ids_after_fiscal_position = fpos.map_tax(self.tax_ids, line.product_id, line.order_id.partner_id) if fpos else self.tax_ids
+            tax_ids_after_fiscal_position = fpos.map_tax(self.tax_ids, self.product_id, self.order_id.partner_id) if fpos else self.tax_ids
-            ('visa_expire', '>=', fields.Date.to_string(date.today() + relativedelta(days=-60)))
+            ('date_end', '<=', fields.Date.to_string(date.today() + relativedelta(days=7))),
-            ('visa_expire', '>=', fields.Date.to_string(date.today() + relativedelta(days=1)))
+            ('date_end', '<=', fields.Date.to_string(date.today() + relativedelta(days=-1))),
-from openerp.exceptions import AccessError
+from openerp.exceptions import AccessError, UserError
-    'BIF', 'XAF', 'XPF', 'CLP', 'KMF', 'DJF', 'GNF', 'JPY', 'MGA', 'PYGÃ­', 'RWF', 'KRW', 'VUV',
+    'BIF', 'XAF', 'XPF', 'CLP', 'KMF', 'DJF', 'GNF', 'JPY', 'MGA', 'PYG', 'RWF', 'KRW', 'VUV',
-                    """ % {'table_name': self._name, 'column_name': column_name}
+                    """ % {'table_name': self._table, 'column_name': column_name}
-                    """ % {'table_name': self._name, 'column_name': column_name}
+                    """ % {'table_name': self._table, 'column_name': column_name}
-    'version': '1.0',
+    'version': '2.0',
-            res[line.tax_id.tax_group_id] += line.amount
+            res.setdefault(line.tax_id.tax_group_id, {'base': 0.0, 'amount': 0.0})
-        res = [(l[0].name, l[1]) for l in res]
+        res = [(l[0].name, l[1]['amount'], l[1]['base']) for l in res]
-                res.setdefault(group, 0.0)
+                res.setdefault(group, {'amount': 0.0, 'base': 0.0})
-                    res[group] += t['amount']
+                    res[group]['amount'] += t['amount']
-        res = [(l[0].name, l[1]) for l in res]
+        res = [(l[0].name, l[1]['amount'], l[1]['base'], len(res)) for l in res]
-                'src_model': src_obj,
+                'src_model': template.model_id.model,
-            })
+            template.write({'ref_ir_act_window': action.id})
-        # check template act_window and ir_values has been updated
+        # check template act_window has been updated
-        self.assertEqual(value.name, 'Send Mail (%s)' % self.email_template.name)
+        self.assertEqual(action.binding_model_id.model, 'mail.test')
-            action.write({'menu_ir_values_id': ir_values.id})
+            action.write({'binding_model_id': action.model_id.id,
-                    raise UserError(_('Deletion of the action record failed.'))
+        self.filtered('binding_model_id').write({'binding_model_id': False})
-            report.write({'ir_values_id': ir_values.id})
+            model = self.env['ir.model']._get(report.model)
-                    raise UserError(_('Deletion of the action record failed.'))
+        self.filtered('binding_model_id').write({'binding_model_id': False})
-        self.assertEqual(ir_values.model, 'res.partner', 'ir_actions_server: created ir_values should be linked to the action base model')
+        self.assertEqual(self.action.binding_model_id.model, 'res.partner')
-        self.assertEqual(len(ir_values), 0, 'ir_actions_server: unlink_action should remove the ir_values record')
+        self.assertFalse(self.action.binding_model_id)
-                x['string'] = x['name']
+            bindings = self.env['ir.actions.actions'].get_bindings(self._name)
-                'print': resprint,
+                'print': resreport,
-            self.env['ir.actions.report'].browse(id).write({'ir_values_id': action.id})
+            report = self.env['ir.actions.report'].browse(id)
-            self.env['ir.actions.report'].browse(id).write({'ir_values_id': False})
+            report = self.env['ir.actions.report'].browse(id)
-
+
-                ir_values.sudo().set_action(res['name'], action_slot=res['key2'], model=model, action=res['value'], res_id=res_id)
+            action = self.env['ir.actions.actions'].browse(int(id))
-            ir_values.sudo().set_action(values['name'], action_slot=keyword, model=model, action=value, res_id=res_id)
+            report = self.env['ir.actions.report'].browse(id)
-            ir_values.sudo().set_default('product.template', "taxes_id", list(taxes_id - set(deleted_tax.ids)), for_all_users=True, company_id=company_id)
+        IrDefault = self.env['ir.default']
-        ir_values_obj.sudo().set_default('product.template', "supplier_taxes_id", [self.default_purchase_tax_id.id] if self.default_purchase_tax_id else False, for_all_users=True, company_id=self.company_id.id)
+        IrDefault = self.env['ir.default'].sudo()
-        ir_values_obj = self.env['ir.values']
+        IrDefault = self.env['ir.default']
-            ir_values_obj.sudo().set_default('product.template', "taxes_id", [taxes_ref[self.sale_tax_id.id]], for_all_users=True, company_id=company.id)
+            IrDefault.sudo().set('product.template', "taxes_id", [taxes_ref[self.sale_tax_id.id]], company_id=company.id)
-            ir_values_obj.sudo().set_default('product.template', "supplier_taxes_id", [taxes_ref[self.purchase_tax_id.id]], for_all_users=True, company_id=company.id)
+            IrDefault.sudo().set('product.template', "supplier_taxes_id", [taxes_ref[self.purchase_tax_id.id]], company_id=company.id)
-        lang_code = request.env['ir.values'].sudo().get_default('res.partner', 'lang')
+        lang_code = request.env['ir.default'].sudo().get('res.partner', 'lang')
-            env['ir.values'].get_default('payment.transaction', 'acquirer_id', company_id=user.company_id.id) or \
+            env['ir.default'].get('payment.transaction', 'acquirer_id', company_id=user.company_id.id) or \
-        lang_code = self.env['ir.values'].get_default('res.partner', 'lang')
+        lang_code = self.env['ir.default'].get('res.partner', 'lang')
-                self.env['ir.values'].get_default('sale.order', 'warehouse_id') or
+                self.env['ir.default'].get('sale.order', 'warehouse_id', company_id=values.get('company_id')) or
-        self.env['ir.values'].sudo().set_default('product.template', 'available_threshold', self.available_threshold if self.inventory_availability == 'threshold' else None)
+        IrDefault = self.env['ir.default'].sudo()
-                   )
+        IrDefault = self.env['ir.default'].sudo()
-        IrValues = self.env['ir.values']
+        IrDefault = self.env['ir.default']
-            value = IrValues.get_default(model, field)
+            value = IrDefault.get(model, field)
-        IrValues = self.env['ir.values'].sudo()
+        IrDefault = self.env['ir.default'].sudo()
-            IrValues.set_default(model, field, value)
+            IrDefault.set(model, field, value)
-            IrValues.set_default('res.partner', 'lang', lang_code, condition=False)
+        IrDefault = self.env['ir.default']
-                default_lang.unlink()
+            # delete linked ir.default specifying default partner's language
-            self.env['ir.values'].get_defaults_dict.clear_cache(self.env['ir.values'])
+            self.env['ir.default'].clear_caches()
-                defaults[name] = ir_values_dict[name]
+            # 2. look up ir.default
-        # fails due to ir.values not being ready
+        # fails due to ir.default not being ready
-            'cache': base64.encodestring(cPickle.dumps(res)),
+            'cache': base64.encodestring(json.dumps(res)),
-        return cPickle.loads(cache)
+        return json.loads(base64.decodestring(self.cache))
-        help="This is the file created by the anonymization process. It should have the '.pickle' extention.")
+        help="This is the file created by the anonymization process. It should have the extension '.json' or '.pickle'.")
-        res['name'] = '.pickle'
+        res['name'] = '.json'
-        rel_filepath = 'field_anonymization_%s_%s.pickle' % (self.env.cr.dbname, history.id)
+        rel_filepath = 'field_anonymization_%s_%s.json' % (self.env.cr.dbname, history.id)
-        pickle.dump(data, fn, protocol=-1)
+        # save json file:
-        fn.close()
+        with open(abs_filepath, 'r') as fn:
-        data = pickle.loads(base64.decodestring(self.file_import))
+        # load the json/pickle file content into a data structure:
-        self.phantom_js('/web/tests?mod=web', "", "", login='admin', timeout=180)
+        self.phantom_js('/web/tests?mod=web', "", "", login='admin', timeout=240)
-            self.image_payment_form = image_resize_image(vals['image'], size=(45,30))
+            vals['image_payment_form'] = image_resize_image(vals['image'], size=(45,30))
-            self.image_payment_form = image_resize_image(vals['image'], size=(45,30))
+           vals['image_payment_form'] = image_resize_image(vals['image'], size=(45,30))
-            action.write({'last_run': fields.Datetime.now()})
+            action.write({'last_run': now.strftime(DEFAULT_SERVER_DATETIME_FORMAT)})
-             "Expressed in the default unit of measure of the product.")
+        help = "Cost used for stock valuation in standard price and as a first price to set in average/fifo. "
-        help="Cost of the product, in the default unit of measure of the product.")
+        help = "Cost used for stock valuation in standard price and as a first price to set in average/fifo. "
-             "The inventory variation account set on the product category will represent the current inventory value, and the stock input and stock output account will hold the counterpart moves for incoming and outgoing products.")
+        help="""Manual: The accounting entries to value the inventory are not posted automatically.
-        ('average', 'AVCO')], string='Costing Method',
+        ('fifo', 'First In First Out (FIFO)'),
-                Real Price: The cost price displayed is the price of the last outgoing product (will be use in case of inventory loss for example).""")
+        help="""Standard Price: The products are valued at their standard cost defined on the product.
-        ('real_time', 'Perpetual (automated)')], string='Inventory Valuation',
+        ('manual_periodic', 'Manual'),
-             "moves for incoming and outgoing products.")
+        help="""Manual: The accounting entries to value the inventory are not posted automatically.
-        ('average', 'AVCO')], string="Costing Method",
+        ('fifo', 'First In First Out (FIFO)'),
-             "used in case of inventory loss for example).""")
+        help=""""Standard Price: The products are valued at their standard cost defined on the product.
-        if self.compute_at_date and self.date:
+        # Call `_fifo_vacuum` on concerned moves
-                product.stock_value = value
+            if product.cost_method in ['standard', 'average']:
-                move.replay()
+            # We need to update the `value`, `remaining_value` and `remaining_qty` on the linked
-    # TODO: add constrain price_unit = 0 on done move?
+    remaining_value = fields.Float()
-        """
+    def action_get_account_moves(self):
-            move.cumulated_value -= value
+        action_ref = self.env.ref('account.action_move_journal_line')
-    @ api.model
+    def get_price_unit(self):
-    @ api.model
+    @api.model
-            average_price[move.product_id.id] = move.product_id.average_price
+        self.product_price_update_before_done()
-                    move.cumulated_value = move.product_id._get_latest_cumulated_value(exclude_move=move) + move.value
+                    price_unit = move.price_unit or move.get_price_unit()
-                    move.value = move.price_unit * move.product_qty
+                        vals['remaining_qty'] = move.product_qty
-                    tmp_value = 0
+                    # Find back incoming stock moves (called candidates here) to value this move.
-                    last_candidate = False
+                    new_standard_price = 0
-                        if candidate.remaining_qty <= qty_to_take:
+                        new_standard_price = candidate.price_unit
-                        if qty_to_take == 0:
+                            qty_taken_on_candidate = qty_to_take_on_candidates
-                elif move.product_id.cost_method == 'average':
+
-                
+                    value = -float_round(move.product_id.standard_price * move.product_qty, precision_rounding=curr_rounding)
-                'ref': self.picking_id.name})
+                'ref': self.picking_id.name,
-        # https://docs.google.com/spreadsheets/d/1NI0u9N1gFByXxYHfdiXuxQCrycXXOh76TpPQ3CWeyDw/edit?ts=58da749b#gid=0
+    def test_fifo_perpetual_3(self):
-        self.assertEqual(move5.cumulated_value, 180.0)
+    def test_fifo_negative_1(self):
-        move5.with_context(debug=True).action_done()
+        move5.action_done()
-        self.product1.product_tmpl_id.cost_method = 'fifo'
+    def test_average_negative_1(self):
-            'name': '50 out',
+            'name': 'test_average_negative_1',
-            })]
+            'product_uom_qty': 10.0,
-        self.assertEqual(move1.remaining_qty, 50.0)
+    def test_average_negative_2(self):
-            'name': '40 in @15',
+        # set a standard price
-            })]
+            'product_uom_qty': 10.0,
-        move2.action_done()
+        move1.action_confirm()
-        self.assertEqual(move2.cumulated_value, 0.0)
+        self.assertEqual(move1.value, 100.0)
-            'location_dest_id': self.stock_location.id,
+        # send 10 products
-            })]
+            'product_uom_qty': 10.0,
-        self.product1.product_tmpl_id.cost_method = 'average'
+        move2.action_confirm()
-        self.product1.standard_price = 99
+        self.assertEqual(move2.value, -100.0)
-            'name': 'test_average_negative_1',
+        # send 10 products again
-        self.assertEqual(move1.remaining_qty, 0.0)  # unused in average move
+        move3.action_confirm()
-    def test_average_negative_2(self):
+        self.assertEqual(move3.value, -100.0)  # as no move out were done for this product, fallback on latest cost
-        self.assertEqual(move3.cumulated_value, -100.0)
+
-from odoo.tools import float_is_zero
+from odoo.tools import float_is_zero, pycompat
-        for product in self:
+        """ Compute the average price of a product.product according to the latest cumulated value
-                product.average_price = last_cumulated_value / product.qty_available
+                p_set.average_price = last_cumulated_value / product.qty_available
-    
+                domain = [('product_id', '=', product.id), ('last_done_qty', '>', 0.0)] + self.env['stock.move']._get_all_base_domain()
-                qty_available[move.product_id.id] = move.product_id.with_context(company_owned=True).qty_available
+        average_price = {}
-                    move.remaining_qty = move.product_qty
+                        move.remaining_qty = move.product_qty
-                    avg_price_unit = float_round(move.product_id._get_latest_cumulated_value(exclude_move=move) / qty_available[move.product_id.id], precision_rounding=curr_rounding)
+                    avg_price_unit = average_price[move.product_id.id]
-        self.assertEqual(move1.remaining_qty, 60.0)
+        self.assertEqual(move1.remaining_qty, 0.0)  # unusedin average move
-        # Sale 190 units @ 15.00 per unit
+        # Sale 190 units @ 15.35 per unit
-        move5.action_done()
+        move5.with_context(debug=True).action_done()
-        move2.with_context(debug=True).action_done()
+        move2.action_done()
-    def _get_candidates_out_move(self):
+    def _get_fifo_candidates_out_move(self):
-    def _get_candidates_move(self):
+    def _get_fifo_candidates_in_move(self):
-                moves = product._get_candidates_move()
+                moves = product._get_fifo_candidates_in_move()
-    def _update_future_cumulated_value(self, value):
+    def _update_fifo_future_cumulated_value(self, value):
-                     ('product_id', '=', self.product_id.id)])
+        domain = self._get_all_domain()
-            move.value += value
+            # As `self` is always an out move, we decrease its value on the future moves.
-                        candidates_out = move.product_id._get_candidates_out_move()
+                        # If there are some OUT moves that we could not value in time, find them
-                                qty_taken_on_candidate = candidate.remaining_qty
+                                qty_taken_for_candidate = candidate.remaining_qty
-                            candidate._update_future_cumulated_value(move.price_unit * qty_taken_on_candidate)
+                                qty_taken_for_candidate = qty_to_take
-                    candidates = move.product_id._get_candidates_move()
+                    candidates = move.product_id._get_fifo_candidates_in_move()
-    def _get_latest_cumulated_value(self, not_move=False):
+    def _get_latest_cumulated_value(self, exclude_move=False):
-            domain += [('id', '!=', not_move.id)]
+        domain = [('product_id', '=', self.id)] + self.env['stock.move']._get_all_base_domain()
-        ], order='date, id') #TODO: case
+        domain = [('product_id', '=', self.id), ('remaining_qty', '>', 0.0)] + self.env['stock.move']._get_out_base_domain()
-        ], order='date, id') #TODO: case where 
+        domain = [('product_id', '=', self.id), ('remaining_qty', '>', 0.0)] + self.env['stock.move']._get_in_base_domain()
-                qty_available[move.product_id.id] = move.product_id.qty_available
+                qty_available[move.product_id.id] = move.product_id.with_context(company_owned=True).qty_available
-            if move.location_id.usage not in ('internal', 'transit') and move.location_dest_id.usage in ('internal', 'transit'):
+            if move._is_in():
-                    move.cumulated_value = move.product_id._get_latest_cumulated_value(not_move=move) + move.value
+                    move.cumulated_value = move.product_id._get_latest_cumulated_value(exclude_move=move) + move.value
-            elif move.location_id.usage in ('internal', 'transit') and move.location_dest_id.usage not in ('internal', 'transit'):
+            elif move._is_out():
-                    move.cumulated_value = move.product_id._get_latest_cumulated_value(not_move=move) + move.value
+                    move.cumulated_value = move.product_id._get_latest_cumulated_value(exclude_move=move) + move.value
-                    avg_price_unit = float_round(move.product_id._get_latest_cumulated_value(not_move=move) / qty_available[move.product_id.id], precision_rounding=curr_rounding)
+                    avg_price_unit = float_round(move.product_id._get_latest_cumulated_value(exclude_move=move) / qty_available[move.product_id.id], precision_rounding=curr_rounding)
-                    move.cumulated_value = move.product_id._get_latest_cumulated_value(not_move=move) + move.value
+                    move.cumulated_value = move.product_id._get_latest_cumulated_value(exclude_move=move) + move.value
-    @api.depends('stock_quant_ids', 'stock_move_ids')
+    @api.depends('stock_move_ids.product_qty', 'stock_move_ids.state')
-        # TDE FIXME: clean that brol, context seems overused
+        if self.env.context.get('company_owned', False):
-        if self.filtered(lambda timesheet: timesheet.timesheet_invoice_id):
+        # prevent to update invoiced timesheets if product_id is not of type order
-                    analytic_account.currency_id.round(unit_amount * so_line.currency_id.compute(so_line.price_unit, analytic_account.currency_id) * (1-so_line.discount)),
+                    analytic_account.currency_id.round(unit_amount * so_line.currency_id.compute(so_line.price_unit, analytic_account.currency_id) * (1-(so_line.discount/100))),
-    def portal_my_invoices_report(self, invoice_id, access_token=None, **kw):
+    def portal_my_invoice_detail(self, invoice_id, access_token=None, **kw):
-                pass
+                if self.env.context.get('force_website'):
-                    'url': '/my/invoices?',  # No controller /my/invoices/<int>, only a report pdf
+                    'url': '/my/invoices/%s?access_token=%s' % (self.id, self.access_token),
-from odoo.addons.portal.controllers.portal import CustomerPortal, pager as portal_pager
+from odoo.tools import consteq
-    def portal_my_invoices_report(self, invoice_id, **kw):
+    @http.route(['/my/invoices/<int:invoice_id>'], type='http', auth="public", website=True)
-            return request.redirect('/my')
+            if not access_token or not consteq(invoice.sudo().access_token, access_token):
-    _inherit = ['mail.thread', 'mail.activity.mixin']
+    _inherit = ['mail.thread', 'mail.activity.mixin', 'portal.mixin']
-        return '/mail/view?' + url_encode(params)
+        return self.get_share_url()
-        if tx:
+        if tx and tx.sale_order_id:
-            'bootstrap_formatting': True
+            'bootstrap_formatting': True,
-from odoo.tools import consteq, float_round, image_resize_images, ustr, pycompat
+from odoo.tools import consteq, float_round, image_resize_images, image_resize_image, ustr, pycompat
-            'bootstrap_formatting': True
+            'bootstrap_formatting': True,
-    'depends': ['http_routing', 'mail'],
+    'qweb': [
-    module_stock_picking_wave = fields.Boolean("Batch Pickings")
+    module_stock_picking_batch = fields.Boolean("Batch Pickings", oldname="module_stock_picking_wave")
-class StockPickingWave(models.Model):
+class StockPickingBatch(models.Model):
-    _name = "stock.picking.wave"
+    _name = "stock.picking.batch"
-        'stock.picking', 'wave_id', string='Pickings',
+        'stock.picking', 'batch_id', string='Pickings',
-        return super(StockPickingWave, self).create(vals)
+            vals['name'] = self.env['ir.sequence'].next_by_code('batch.picking') or '/'
-                body="<b>%s:</b> %s <a href=#id=%s&view_type=form&model=stock.picking.wave>%s</a>" % (
+                body="<b>%s:</b> %s <a href=#id=%s&view_type=form&model=stock.picking.batch>%s</a>" % (
-                    picking.wave_id.name))
+                    picking.batch_id.id,
-        return super(StockPickingWave, self)._track_subtype(init_values)
+            return 'stock_picking_batch.mt_batch_state'
-        'stock.picking.wave', string='Batch Picking',
+    batch_id = fields.Many2one(
-    _name = 'stock.picking.to.wave'
+class StockPickingToBatch(models.TransientModel):
-    wave_id = fields.Many2one('stock.picking.wave', string='Batch Picking', required=True)
+    batch_id = fields.Many2one('stock.picking.batch', string='Batch Picking', required=True, oldname="wave_id")
-        return self.env['stock.picking'].browse(picking_ids).write({'wave_id': self.wave_id.id})
+        return self.env['stock.picking'].browse(picking_ids).write({'batch_id': self.batch_id.id})
-        'wizard/stock_picking_to_wave_views.xml',
+        'views/stock_picking_batch_views.xml',
-        'data/stock_picking_wave_demo.xml',
+        'data/stock_picking_batch_demo.xml',
-from . import stock_picking_wave
+from . import stock_picking_batch
-            return 'stock_picking_wave.mt_wave_state'
+            return 'stock_picking_batch.mt_wave_state'
-from . import stock_picking_to_wave
+from . import stock_picking_to_batch
-    rules (to pack like the delivery order), on orderpoints (e.g. for wave picking
+    rules (to pack like the delivery order), on orderpoints (e.g. for batch picking
-    module_stock_picking_wave = fields.Boolean("Picking Waves")
+    module_stock_picking_wave = fields.Boolean("Batch Pickings")
-    'name': 'Warehouse Management: Waves',
+    'name': 'Warehouse Management: Batch Picking',
-================================================================
+This module adds the batch picking option in warehouse management
-    _description = "Picking Wave"
+    _description = "Batch Picking"
-        string='Picking Wave Name', default='/',
+        string='Batch Picking Name', default='/',
-        help='Name of the picking wave')
+        help='Name of the batch picking')
-        help='Person responsible for this wave')
+        help='Person responsible for this batch picking')
-        help='List of picking associated to this wave')
+        help='List of picking associated to this batch')
-            raise UserError(_('Some pickings are still waiting for goods. Please check or force their availability before setting this wave to done.'))
+            raise UserError(_('Some pickings are still waiting for goods. Please check or force their availability before setting this batch to done.'))
-                    _("Picking Wave"),
+                    _("Batch Picking"),
-        'stock.picking.wave', string='Picking Wave',
+        'stock.picking.wave', string='Batch Picking',
-        help='Picking wave associated to this picking')
+        help='Batch associated to this picking')
-    _description = 'Add pickings to a picking wave'
+    _description = 'Add pickings to a batch picking'
-    wave_id = fields.Many2one('stock.picking.wave', string='Picking Wave', required=True)
+    wave_id = fields.Many2one('stock.picking.wave', string='Batch Picking', required=True)
-        # use active_ids to add picking line to the selected wave
+        # use active_ids to add picking line to the selected batch
-        'data/email_template_data_invoice.xml',
+        'data/mail_template_data.xml',
-        "which will create an entry for this tax on a given account during reconciliation")
+    # Technical field to make the 'tax_exigibility' field invisible if the same named field is set to false in 'res.company' model
-        help='Account use when creating entry for tax cash basis')
+        help='Account used as counterpart for the journal entry, for taxes exigible based on payments.')
-    use_cash_basis = fields.Boolean(string='Cash Basis', related='company_id.use_cash_basis')
+    tax_exigibility = fields.Boolean(string='Cash Basis', related='company_id.tax_exigibility')
-    def _onchange_use_cash_basis(self):
+    @api.onchange('tax_exigibility')
-            ('company_id', '=', self.env.user.company_id.id), ('use_cash_basis', '=', True)
+            ('company_id', '=', self.env.user.company_id.id), ('tax_exigibility', '=', 'on_payment')
-            self.use_cash_basis = True
+        if not self.tax_exigibility and tax:
-            taxes = [{'use_cash_basis': self.env['account.tax'].browse(vals['tax_line_id']).use_cash_basis}]
+            taxes = [{'tax_exigibility': self.env['account.tax'].browse(vals['tax_line_id']).tax_exigibility}]
-        if taxes and any([tax['use_cash_basis'] for tax in taxes]) and not vals.get('tax_exigible'):
+        if taxes and any([tax['tax_exigibility'] == 'on_payment' for tax in taxes]) and not vals.get('tax_exigible'):
-                    if line.tax_line_id and line.tax_line_id.use_cash_basis:
+                    if line.tax_line_id and line.tax_line_id.tax_exigibility == 'on_payment':
-                    if any([tax.use_cash_basis for tax in line.tax_ids]):
+                    if any([tax.tax_exigibility == 'on_payment' for tax in line.tax_ids]):
-        "which will create an entry for this tax on a given account during reconciliation")
+    tax_exigibility = fields.Selection(
-        help='Account use when creating entry for tax cash basis')
+        help='Account used as counterpart for the journal entry, for taxes exigible based on payments.')
-            'use_cash_basis': self.use_cash_basis,
+            'tax_exigibility': self.tax_exigibility,
-            # When a CoA is being installed automatically and if it is creating account tax(es) whose field `Use Cash Basis`(use_cash_basis) is set to True by default
+        if any([tax.tax_exigibility == 'on_payment' for tax in self]):
-            company.use_cash_basis = True
+            company.tax_exigibility = True
-    use_cash_basis = fields.Boolean(string='Use Cash Basis')
+    tax_exigibility = fields.Boolean(string='Use Cash Basis')
-        return super(BankStatementLine, self).cancel()
+from . import models
-        self.assertEqual(procurement.purchase_id.picking_ids.min_date, po_schedule_date, 'Schedule date of In type shipment should be equal to: schedule date of purchase order.')
+        self.assertEqual(procurement.purchase_id.picking_ids.scheduled_date, po_schedule_date, 'Schedule date of In type shipment should be equal to: schedule date of purchase order.')
-        self.assertEqual(procurement_2.purchase_id.picking_ids.min_date, po_schedule_date, 'Schedule date of In type shipment should be same as schedule date of purchase order.')
+        self.assertEqual(procurement_2.purchase_id.picking_ids.scheduled_date, po_schedule_date, 'Schedule date of In type shipment should be same as schedule date of purchase order.')
-        self.assertEqual(incomming_shipment.min_date, po_schedule_date, 'Schedule date of In type shipment should be same as schedule date of purchase order.')
+        self.assertEqual(incomming_shipment.scheduled_date, po_schedule_date, 'Schedule date of In type shipment should be same as schedule date of purchase order.')
-        self.assertEqual(incomming_shipment1.min_date, incomming_shipment1_schedule_date, 'Schedule date of Internal Type shipment for input stock location should be equal to: schedule date of purchase order + push rule delay.')
+        self.assertEqual(incomming_shipment1.scheduled_date, incomming_shipment1_schedule_date, 'Schedule date of Internal Type shipment for input stock location should be equal to: schedule date of purchase order + push rule delay.')
-        self.assertEqual(incomming_shipment2.min_date, incomming_shipment2_schedule_date, 'Schedule date of Internal Type shipment for quality control stock location should be equal to: schedule date of Internal type shipment for input stock location + push rule delay..')
+        self.assertEqual(incomming_shipment2.scheduled_date, incomming_shipment2_schedule_date, 'Schedule date of Internal Type shipment for quality control stock location should be equal to: schedule date of Internal type shipment for input stock location + push rule delay..')
-        min_date = fields.Datetime.from_string(order.picking_ids[0].min_date)
+        min_date = fields.Datetime.from_string(order.picking_ids[0].scheduled_date)
-        out_min_date = fields.Datetime.from_string(out.min_date)
+        out_min_date = fields.Datetime.from_string(out.scheduled_date)
-        pack_min_date = fields.Datetime.from_string(pack.min_date)
+        pack_min_date = fields.Datetime.from_string(pack.scheduled_date)
-        pick_min_date = fields.Datetime.from_string(pick.min_date)
+        pick_min_date = fields.Datetime.from_string(pick.scheduled_date)
-        min_date = fields.Datetime.from_string(order.picking_ids[0].min_date)
+        min_date = fields.Datetime.from_string(order.picking_ids[0].scheduled_date)
-        out_min_date = fields.Datetime.from_string(out.min_date)
+        out_min_date = fields.Datetime.from_string(out.scheduled_date)
-        pack_min_date = fields.Datetime.from_string(pack.min_date)
+        pack_min_date = fields.Datetime.from_string(pack.scheduled_date)
-        pick_min_date = fields.Datetime.from_string(pick.min_date)
+        pick_min_date = fields.Datetime.from_string(pick.scheduled_date)
-            'count_picking_late': [('min_date', '<', time.strftime(DEFAULT_SERVER_DATETIME_FORMAT)), ('state', 'in', ('assigned', 'waiting', 'confirmed', 'partially_available'))],
+            'count_picking_late': [('scheduled_date', '<', time.strftime(DEFAULT_SERVER_DATETIME_FORMAT)), ('state', 'in', ('assigned', 'waiting', 'confirmed', 'partially_available'))],
-        'Scheduled Date', compute='_compute_dates', inverse='_set_min_date', store=True,
+    scheduled_date = fields.Datetime(
-        self.max_date = max(self.move_lines.mapped('date_expected') or [False])
+    def _compute_scheduled_date(self):
-        self.move_lines.write({'date_expected': self.min_date})
+    def _set_scheduled_date(self):
-        refs = {stl_to_assign.mapped('name')}
+        refs = set(stl_to_assign.mapped('name'))
-        self.assertEqual(tree.get('action'), 'https://www.sandbox.paypal.com/cgi-bin/webscr', 'paypal: wrong form POST url')
+
-            'hide_current_user': True,
+from . import ir_qweb
-                qty_todo = new_qty - sum(move_lots.mapped('quantity'))
+                qty_todo = new_qty - sum(move_lots.mapped('qty_done'))
-                            qty_todo = qty_todo - move_lot.quantity
+                        if not move_lot.lot_id and qty_todo >= move_lot.qty_done:
-                    keys_in = ['location_dest_id', 'lot_id', 'result_package_id', 'owner_id']
+                    keys_in_groupby = ['location_dest_id', 'lot_id', 'result_package_id', 'owner_id']
-                    for k, g in groupby(sorted(move_lines_in, key=itemgetter(*keys_in)), key=itemgetter(*keys_in)):
+                    for k, g in groupby(sorted(move_lines_in, key=_keys_in_sorted), key=itemgetter(*keys_in_groupby)):
-                    keys_out = ['location_id', 'lot_id', 'package_id', 'owner_id']
+                    keys_out_groupby = ['location_id', 'lot_id', 'package_id', 'owner_id']
-                    for k, g in groupby(sorted(move_lines_out_done, key=itemgetter(*keys_out)), key=itemgetter(*keys_out)):
+                    for k, g in groupby(sorted(move_lines_out_done, key=_keys_out_sorted), key=itemgetter(*keys_out_groupby)):
-                    for k, g in groupby(sorted(move_lines_out_reserved, key=itemgetter(*keys_out)), key=itemgetter(*keys_out)):
+                    for k, g in groupby(sorted(move_lines_out_reserved, key=_keys_out_sorted), key=itemgetter(*keys_out_groupby)):
-from odoo.tools.safe_eval import safe_eval, test_python_expr
+from odoo.exceptions import UserError, AccessError
-            pdf_content_stream = StringIO(pdf_content)
+            pdf_content_stream = io.BytesIO(pdf_content)
-                        stream = StringIO()
+                        stream = io.BytesIO()
-                streams.append(StringIO(content))
+                streams.append(io.BytesIO(content))
-        result_stream = StringIO()
+        result_stream = io.BytesIO()
-from cStringIO import StringIO
+import io
-        reader = PdfFileReader(StringIO(document), strict=False)
+        reader = PdfFileReader(io.BytesIO(document), strict=False)
-    _buffer = StringIO()
+    _buffer = io.BytesIO()
-                self.fail((b"\n" + out + b"\n" + err).decode('utf-8'))
+                self.fail("pylint test failed:\n" + (b"\n" + out + b"\n" + err).decode('utf-8').strip())
-            '--load-plugins=pylint.extensions.bad_builtin',
+            '--load-plugins=pylint.extensions.bad_builtin,_odoo_checkers',
-            process = subprocess.Popen(['pylint'] + options + paths, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
+            pylint_bin = tools.which('pylint')
-
+        # pylint: disable=next-method-called
-                'context': {'statement_ids': bank_stmt.ids},
+                'context': {'statement_ids': bank_stmt.ids, 'company_ids': self.mapped('company_id').ids},
-            action_context = {'show_mode_selector': False}
+            action_context = {'show_mode_selector': False, 'company_ids': self.mapped('company_id').ids}
-        #                                  })
+        # return True
-        # return tx.render_sale_button(order, '/shop/payment/validate')
+        # return True
-        for key, val in list(pycompat.items(arguments)):
+        for key, val in list(arguments.items()):
-        rounded_value = pycompat.round(normalized_value) # round to integer
+        rounded_value = round(normalized_value)     # round to integer
-    @api.depends('order_id.state', 'move_ids.state')
+    @api.depends('order_id.state', 'move_ids.state', 'move_ids.product_uom_qty')
-        self.assertEqual(tree.get('action'), 'https://test.authorize.net/gateway/transact.dll', 'Authorize: wrong form POST url')
+
-            if values[1] in ['submit', 'x_fp_hash', 'return_url', 'x_state', 'x_ship_to_state']:
+            if values[1] in ['submit', 'x_fp_hash', 'return_url', 'x_state', 'x_ship_to_state', 'data_set']:
-        self.assertEqual(tree.get('action'), 'https://www.sandbox.paypal.com/cgi-bin/webscr', 'paypal: wrong form POST url')
+
-            if form_input.get('name') in ['submit']:
+            if form_input.get('name') in ['submit', 'data_set']:
-            'acquirers': acquirers
+            'acquirers': acquirers,
-        return self.registration_view_template_id.render(qweb_context, engine='ir.qweb')
+    def get_s2s_form_name(self):
-
+            return_url= '/shop/payment/validate',
-        acquirers = list(request.env['payment.acquirer'].search([('website_published', '=', True), ('registration_view_template_id', '!=', False)]))
+        acquirers = list(request.env['payment.acquirer'].search([('website_published', '=', True), ('registration_view_template_id', '!=', False), ('prefered_payment_type', 'in', ['s2s', 'both'])]))
-                    order_sudo.pricelist_id.currency_id.id,
+            acquirers = request.env['payment.acquirer'].sudo().search([('website_published', '=', True), ('company_id', '=', order_sudo.company_id.id)])
-    def payment_transaction_token(self, acquirer_id, order_id, access_token=None, tx_type=None):
+    @http.route(['/quote/<int:order_id>/transaction/'], type='json', auth="public", website=True)
-            return request.redirect("/quote/%s" % order_id)
+            return False
-                                         })
+        return True
-        values['s2s_acquirers'] = [acq for acq in acquirers if acq.registration_view_template_id]
+        values['form_acquirers'] = [acq for acq in acquirers if acq.prefered_payment_type in ['form', 'both'] and acq.view_template_id]
-            acq.form = acq.sudo()._registration_render(order.partner_id.id, {
+            acq.form = acq._registration_render(order.partner_id.id, {
-    def payment_transaction(self, acquirer_id, tx_type='form', token=None, **kwargs):
+    @http.route(['/shop/payment/transaction/',
-            return request.redirect("/shop/checkout")
+            # return request.redirect("/shop/checkout")
-            return request.env.ref('website_sale.payment_token_form').render(dict(tx=tx), engine='ir.qweb')
+        # if token:
-        return tx.render_sale_button(order, '/shop/payment/validate')
+        return True
-    def payment_token(self, pm_id=None, **kw):
+    def payment_token(self, pm_id=None, **kwargs):
-        if not pm_id:
+        if not token:
-        if payment_token and tx.payment_token_id and payment_token != self.payment_token_id:
+        if tx and payment_token and tx.payment_token_id and payment_token != self.payment_token_id:
-            values['acquirers'].append(acquirer)
+            acquirer.button = acquirer_button #TBE TODO: remove this line
-        return list(self.env['payment.acquirer'].sudo().search([('website_published', '=', True)]))
+    def payment_options(self):
-                    (extract('epoch' from (t.write_date-t.create_date)))/(3600*24)  as closing_days,
+                    (extract('epoch' from (NULLIF(t.date_end, t.write_date)-t.create_date)))/(3600*24)  as closing_days,
-        out_ids = self.env['account.account'].search([('company_id', '=', company_id)], order='id')
+        in_ids, out_ids = self._get_template_from_model(company_id, 'account.account')
-        out_ids = self.env['account.tax'].search([('company_id', '=', company_id)], order='id')
+        in_ids, out_ids = self._get_template_from_model(company_id, 'account.tax')
-        out_ids = self.env['account.fiscal.position'].search([('company_id', '=', company_id)], order='id')
+        in_ids, out_ids = self._get_template_from_model(company_id, 'account.fiscal.position')
-        self.phantom_js('/web/tests?mod=web', "", "", login='admin', timeout=180)
+        self.phantom_js('/web/tests?mod=web', "", "", login='admin', timeout=240)
-        self.phantom_js('/web/tests?mod=web', "", "", login='admin', timeout=180)
+        self.phantom_js('/web/tests?mod=web', "", "", login='admin', timeout=240)
-    value1 = fields.Integer()
+    value1 = fields.Integer(change_default=True)
-        #        raise UserError(_('You can not modify already invoiced timesheets.'))
+        if self.filtered(lambda timesheet: timesheet.timesheet_invoice_id):
-        currency = list(partial_rec_set)[0].currency_id
+        currency = self[0].currency_id
-        for partial_rec in partial_rec_set:
+        seen = set()
-        partial_rec_ids = [x.id for x in partial_rec_set]
+                    if x not in seen:
-        company_id = current_website.company_id
+        pricelist = self.env['website'].get_current_website().get_current_pricelist()
-            taxes = partner.property_account_position_id.map_tax(p.taxes_id.filtered(lambda x: x.company_id == company_id))
+            taxes = partner.property_account_position_id.map_tax(p.taxes_id)
-                                                            
+
-                revenue = analytic_account.currency_id.round(unit_amount * sale_price * (1-so_line.discount))
+                revenue = analytic_account.currency_id.round(unit_amount * sale_price * (1-(so_line.discount/100)))
-                total_revenue_so = analytic_account.currency_id.round(quantity_hour * sale_price * (1-so_line.discount))
+                total_revenue_so = analytic_account.currency_id.round(quantity_hour * sale_price * (1-(so_line.discount/100)))
-                revenue = analytic_account.currency_id.round(unit_amount * sale_price_unit * (1-so_line.discount))
+                revenue = analytic_account.currency_id.round(unit_amount * sale_price * (1-so_line.discount))
-                total_revenue_so = analytic_account.currency_id.round(so_line.product_uom_qty * sale_price_unit * (1-so_line.discount))
+                total_revenue_so = analytic_account.currency_id.round(quantity_hour * sale_price * (1-so_line.discount))
-                raise UserError(_('You can not modify already invoiced timesheets.'))
+        #if self.filtered(lambda timesheet: timesheet.timesheet_invoice_id):
-                self.fail("\n" + out + "\n" + err)
+                self.fail((b"\n" + out + b"\n" + err).decode('utf-8'))
-                ready, _, _ = select.select([phantom.stdout], [], [], 0.5)
+                ready, _, _ = select.select([pid], [], [], 0.5)
-                buf.extend(s)
+            if not ready:
-            if b'\n' in buf and (not buf.startswith(b'<phantomLog>') or b'</phantomLog>' in buf):
+            while b'\n' in buf and (not buf.startswith(b'<phantomLog>') or b'</phantomLog>' in buf):
-                    buf = bytearray()
+                    line, buf = buf[12:].split(b'</phantomLog>\n', 1)
-                line = bytes(line).decode('utf-8')
+                line = line.decode('utf-8')
-                        _logger.error("phantomjs: %s", pformat(json.loads(line[prefix:])))
+                        self.fail(pformat(json.loads(line[prefix:])))
-                    break
+                        self.fail(lline)
-                    _logger.warn("phantomjs: %s", line)
+                    logger.warn(line)
-                    _logger.info("phantomjs: %s", line)
+                    logger.info(line)
-        result = False
+            self.assertTrue(
-                _logger.error("Phantom JS has crashed (segmentation fault) during testing; log may not be relevant")
+            else:
-                thread.join_retry_count = 10
+                join_retry_count = 10
-                    if thread.join_retry_count < 0:
+                    join_retry_count -= 1
-        if st_lines_left and stl_to_assign_partner and refs\
+        stl_to_assign = st_lines_left.filtered(lambda stl: not stl.partner_id)
-                params += (tuple(stl_to_assign_partner),)
+                params += (tuple(stl_to_assign.ids),)
-        if move_date > company.fiscalyear_lock_date:
+        if move_date > (company.fiscalyear_lock_date or '0000-00-00'):
-        raise
+        # otherwise "no active exception to reraise"
-            days_count += round((work_time.total_seconds() / 3600 / theoric_hours) * 4) / 4
+            days_count += float_utils.round((work_time.total_seconds() / 3600 / theoric_hours) * 4) / 4
-            days_count += round((leave_time.total_seconds() / 3600 / theoric_hours) * 4) / 4
+            days_count += float_utils.round((leave_time.total_seconds() / 3600 / theoric_hours) * 4) / 4
-        content.extend(html.tostring(child)
+        content.extend(html.tostring(child, encoding='unicode')
-            if record.move_id.product_id.id not in res:
+            if record.move_id.product_id not in res:
-URL_REGEX = r'(\bhref=[\'"](?!mailto:)([^\'"]+)[\'"])'
+URL_REGEX = r'(\bhref=[\'"](?!mailto:|tel:|sms:)([^\'"]+)[\'"])'
-        "Product Prices", default='total')
+        "Product Prices", default='subtotal')
-            del first_line_dict['tax_ids']
+        first_line_dict = self._prepare_writeoff_first_line_values(vals)
-            second_line_dict['amount_currency'] = -second_line_dict['amount_currency']
+        second_line_dict = self._prepare_writeoff_second_line_values(vals)
-    has_outstanding = fields.Boolean(compute='_get_outstanding_info_JSON')
+    outstanding_credits_debits_widget = fields.Text(compute='_get_outstanding_info_JSON', groups="account.group_account_invoice")
-from odoo.tools import float_compare
+from odoo.tools import float_compare, float_repr
-        self.assertEquals(float_compare(timesheet4.timesheet_revenue, 152.68, precision_digits=2), 0, "Revenue computation on invoice validation does not return the correct revenue !")
+        self.assertEquals(float_repr(timesheet1.timesheet_revenue, precision_digits=2), '385.85', "Revenue computation on invoice validation does not return the correct revenue !")
-            'name': self.name,
+            'name': self.name[:2000],
-            'location_src_id': new_location,
+            'location_src_id': new_location.id,
-        values = {
+        values.update({
-        }
+            'error_message': [],
-                mail_values.update(self.env[self.model].browse(res_id).message_get_email_values())
+                if self.model in self.env and hasattr(self.env[self.model], 'message_get_email_values'):
-        pricelist = self.env['website'].get_current_website().get_current_pricelist()
+        current_website = self.env['website'].get_current_website()
-            taxes = partner.property_account_position_id.map_tax(p.taxes_id)
+            taxes = partner.property_account_position_id.map_tax(p.taxes_id.filtered(lambda x: x.company_id == company_id))
-                record_id = request.env.ref(xml_id).id
+                # Get website-specific view if possible
-        ]
+            if self.model in self.env and hasattr(self.env[self.model], 'message_get_email_values'):
-        return ['lang', 'inherit_branding', 'editable', 'translatable', 'edit_translations']
+        return ['lang', 'inherit_branding', 'editable', 'translatable', 'edit_translations', 'website_id']
-        tools.ormcache('xmlid', 'options.get("lang", "en_US")', 'css', 'js', 'debug', 'async'),
+        tools.ormcache_context('xmlid', 'options.get("lang", "en_US")', 'css', 'js', 'debug', 'async', keys=("website_id",)),
-    @tools.ormcache('xmlid', 'options.get("lang", "en_US")')
+    @tools.ormcache_context('xmlid', 'options.get("lang", "en_US")', keys=("website_id",))
-        return ['lang', 'inherit_branding', 'editable', 'translatable', 'edit_translations']
+        return ['lang', 'inherit_branding', 'editable', 'translatable', 'edit_translations', 'website_id']
-        default_partner = self.env['res.partner'].browse(default_partner_id) if default_partner_id else None
+        default_partner = self.env['res.partner'].browse(default_partner_id) if default_partner_id else self.env['res.partner']
-        default_partner = self.env['res.partner'].browse(default_partner_id) if default_partner_id else None
+        default_partner = self.env['res.partner'].browse(default_partner_id) if default_partner_id else self.env['res.partner']
-    module_website_subscription = fields.Boolean("Subscriptions")
+    module_sale_subscription = fields.Boolean("Subscriptions")
-}
+from . import controllers
-from . import purchase
+from . import portal
-from odoo.addons.portal.controllers.portal import get_records_pager, CustomerPortal
+from odoo.addons.portal.controllers.portal import get_records_pager, pager as portal_pager, CustomerPortal
-class WebsitePortal(CustomerPortal):
+class CustomerPortal(CustomerPortal):
-        values = super(WebsitePortal, self)._prepare_portal_layout_values()
+        values = super(CustomerPortal, self)._prepare_portal_layout_values()
-        pager = request.website.pager(
+        pager = portal_pager(
-        return request.render("website_portal_purchase.portal_my_purchase_orders", values)
+        return request.render("purchase.portal_my_purchase_orders", values)
-            return request.render("website.403")
+            return request.redirect('/my')
-        return request.render("website_portal_purchase.portal_my_purchase_order", values)
+        return request.render("purchase.portal_my_purchase_order", values)
-                            to_reconcile_lines.reconcile()
+                    to_reconcile_lines.reconcile()
-        self.order_line.mapped('procurement_ids').cancel()
+        self.mapped('order_line').mapped('procurement_ids').cancel()
-            ir_values_obj.sudo().set_default('product.template', "supplier_taxes_id", [self.default_purchase_tax_id.id], for_all_users=True, company_id=self.company_id.id)
+        ir_values_obj.sudo().set_default('product.template', "taxes_id", [self.default_sale_tax_id.id] if self.default_sale_tax_id else False, for_all_users=True, company_id=self.company_id.id)
-    def render_qweb_pdf(self, res_ids, data=None):
+    def render_qweb_pdf(self, res_ids=None, data=None):
-        return self._post_pdf(save_in_attachment, pdf_content=pdf_content, res_ids=res_ids), 'pdf'
+        if res_ids:
-            os.write(pipe[1], '.')
+            os.write(pipe[1], b'.')
-            if e[0] not in (errno.EAGAIN, errno.ECONNABORTED):
+            if e.errno not in (errno.EAGAIN, errno.ECONNABORTED):
-            values['body'] = _image_dataurl.sub(base64_to_boundary, values['body'])
+            values['body'] = _image_dataurl.sub(base64_to_boundary, tools.ustr(values['body']))
-            except OperationalError, e:
+            except OperationalError as e:
-        except Exception, e:
+        except Exception as e:
-        except Exception, e:
+        except Exception:
-            except Exception, e:
+            except Exception as e:
-            except Exception, e:
+            except Exception as e:
-            except Exception, e:
+            except Exception as e:
-            except Exception, e:
+            except Exception as e:
-                    available_move_lines = dict((k, v) for k, v in available_move_lines.iteritems() if v)
+                    available_move_lines = dict((k, v) for k, v in available_move_lines.items() if v)
-        for field_name, field in record._fields.iteritems():
+        for field_name, field in record._fields.items():
-from odoo.tools import DEFAULT_SERVER_DATETIME_FORMAT, pycompat
+from odoo.tools import DEFAULT_SERVER_DATETIME_FORMAT
-        for onchange_method, changed_fields in pycompat.items(onchanges):
+        for onchange_method, changed_fields in onchanges.items():
-            for tax in pycompat.values(tax_grouped):
+            for tax in tax_grouped.values():
-        for tax in pycompat.values(taxes_grouped):
+        for tax in taxes_grouped.values():
-            for key, val in pycompat.items(line2):
+            for key, val in line2.items():
-            for name, field in pycompat.items(line._fields):
+            for name, field in line._fields.items():
-        res = sorted(pycompat.items(res), key=lambda l: l[0].sequence)
+        res = sorted(res.items(), key=lambda l: l[0].sequence)
-        for key, value in pycompat.items(generated_tax_res['account_dict']):
+        for key, value in generated_tax_res['account_dict'].items():
-from odoo.tools import DEFAULT_SERVER_DATETIME_FORMAT, pycompat
+from odoo.tools import DEFAULT_SERVER_DATETIME_FORMAT
-        for key, acc in list(pycompat.items(accounts)):
+        for key, acc in accounts.items():
-        for partner, child_ids in pycompat.items(all_partners_and_children):
+        for partner, child_ids in all_partners_and_children.items():
-            request = "SELECT account_id as id, " + ', '.join(pycompat.values(mapping)) + \
+            request = "SELECT account_id as id, " + ', '.join(mapping.values()) + \
-                for value in pycompat.values(res[report.id]['account']):
+                for value in res[report.id]['account'].values():
-                for value in pycompat.values(res[report.id]['account']):
+                for value in res[report.id]['account'].values():
-                for key, value in pycompat.items(res2):
+                for key, value in res2.items():
-                for key, value in pycompat.items(res2):
+                for key, value in res2.items():
-            for report_id, value in pycompat.items(comparison_res):
+            for report_id, value in comparison_res.items():
-                    for account_id, val in pycompat.items(comparison_res[report_id].get('account')):
+                    for account_id, val in comparison_res[report_id].get('account').items():
-                for account_id, value in pycompat.items(res[report.id]['account']):
+                for account_id, value in res[report.id]['account'].items():
-        self.assertEquals(sum(res['credit'] for res in pycompat.items(result)), 60.61)
+        self.assertEquals(sum(res['debit'] for res in result.values()), 60.61)
-from odoo.tools import DEFAULT_SERVER_DATE_FORMAT as DF, pycompat
+from odoo.tools import DEFAULT_SERVER_DATE_FORMAT as DF
-            for k, v in pycompat.items(vals['value']):
+            for k, v in vals['value'].items():
-            for name, values in pycompat.items(tracked_values):
+            for name, values in tracked_values.items():
-        for fname, fvalue in pycompat.items(onchange_res['value']):
+        for fname, fvalue in onchange_res['value'].items():
-                for k, v in pycompat.items(token_infos):
+                for k, v in token_infos.items():
-            for k, v in pycompat.items(vals):
+            for k, v in vals.items():
-                        self.update({key: val for key, val in pycompat.items(res['value']) if key in self._fields})
+                        self.update({key: val for key, val in res['value'].items() if key in self._fields})
-            for t_id, job in pycompat.items(jobs):
+            for t_id, job in jobs.items():
-    for mime, (ext, handler, req) in pycompat.items(FILE_TYPE_DICT)
+    for mime, (ext, handler, req) in FILE_TYPE_DICT.items()
-        for name, field in pycompat.items(model_fields):
+        for name, field in model_fields.items():
-                           for attr, value in itertools.chain.from_iterable(pycompat.values(states))):
+                           for attr, value in itertools.chain.from_iterable(states.values())):
-        for name, field in pycompat.items(all_fields):
+        for name, field in all_fields.items():
-        return next(iter(pycompat.values(self.SHEETS)))
+        return next(iter(self.SHEETS.values()))
-from odoo.tools import convert_file, exception_to_unicode, pycompat
+from odoo.tools import convert_file, exception_to_unicode
-        for mod, error in pycompat.items(errors):
+        for mod, error in errors.items():
-    interval = fields.Selection(list(pycompat.items(_interval_selection)), 'Unit', required=True, default='hours')
+    interval = fields.Selection(list(_interval_selection.items()), 'Unit', required=True, default='hours')
-        real = self.browse(set(pycompat.values(id_map)))
+        real = self.browse(set(id_map.values()))
-        real = self.browse(set(pycompat.values(id_map)))
+        real = self.browse(set(id_map.values()))
-        data.update({key: value for key, value in pycompat.items(registration) if key in self._fields})
+        data.update({key: value for key, value in registration.items() if key in self._fields})
-        for vehicle, value in pycompat.items(res):
+        for vehicle, value in res.items():
-        for definition, goals in pycompat.items(goals_by_definition):
+        for definition, goals in goals_by_definition.items():
-                    for (start_date, end_date), query_goals in pycompat.items(subqueries):
+                    for (start_date, end_date), query_goals in subqueries.items():
-                        subquery_domain.append((field_name, 'in', list(set(pycompat.values(query_goals)))))
+                        subquery_domain.append((field_name, 'in', list(set(query_goals.values()))))
-            for goal, values in pycompat.items(goals_to_write):
+            for goal, values in goals_to_write.items():
-from odoo.tools import exception_to_unicode, pycompat
+from odoo.tools import exception_to_unicode
-                     if not callable(v)}
+        methods = {k: v for k, v in attrs.items() if callable(v)}
-            for key, val in pycompat.items(attrs):
+            for key, val in attrs.items():
-            for key, val in pycompat.items(kw):
+            for key, val in kw.items():
-        for key, val in pycompat.items(kw):
+        for key, val in kw.items():
-                ('google_internal_event_id', 'in', pycompat.keys(all_event_from_google))
+                ('google_internal_event_id', 'in', all_event_from_google.keys())
-        for event in pycompat.values(all_event_from_google):
+        for event in all_event_from_google.values():
-            event_to_synchronize[base_event] = sorted(pycompat.items(event_to_synchronize[base_event]), key=operator.itemgetter(0))
+            event_to_synchronize[base_event] = sorted(event_to_synchronize[base_event].items(), key=operator.itemgetter(0))
-        for name, field in pycompat.items(self._fields):
+        for name, field in self._fields.items():
-from odoo.tools import email_split, float_is_zero, pycompat
+from odoo.tools import email_split, float_is_zero
-        for move in pycompat.values(move_group_by_sheet):
+        for move in move_group_by_sheet.values():
-            res.extend(pycompat.values(leaves))
+            res.extend(leaves.values())
-        return [value for code, value in pycompat.items(result_dict)]
+        return list(result_dict.values())
-            for payslip_id, lines_dict in pycompat.items(result):
+            for payslip_id, lines_dict in result.items():
-                for rule_categ_id, line_ids in pycompat.items(lines_dict):
+                for rule_categ_id, line_ids in lines_dict.items():
-        for payslip_id, lines_dict in pycompat.items(result):
+        for payslip_id, lines_dict in result.items():
-            for register, lines in pycompat.items(lines_dict):
+            for register, lines in lines_dict.items():
-            for key, value in pycompat.items(self._onchange_job_id_internal(job_id)['value']):
+            for key, value in self._onchange_job_id_internal(job_id)['value'].items():
-            total = sum(pycompat.values(repartition))
+            total = sum(repartition.values())
-        return list(pycompat.values(channel_infos_dict))
+        return list(channel_infos_dict.values())
-        for category_name, amount in pycompat.items(salaries):
+        for category_name, amount in salaries.items():
-            writer.writerow([pycompat.to_text(v) for v in pycompat.values(row)])
+            writer.writerow([pycompat.to_text(v) for v in row.values()])
-                for v in list(pycompat.values(row))[3:]
+                for v in list(row.values())[3:]
-            writer.writerow([pycompat.to_text(s) for s in pycompat.values(row)])
+            writer.writerow([pycompat.to_text(s) for s in row.values()])
-from odoo.tools import ustr, pycompat
+from odoo.tools import ustr
-        for fname, value in pycompat.items(create_vals):
+        for fname, value in create_vals.items():
-        return list(pycompat.values({
+        return list({
-        }))
+        }.values())
-        self.previous_order_ids = list(pycompat.values({
+        self.previous_order_ids = list({
-        }))
+        }.values())
-from odoo.tools import ormcache, pycompat
+from odoo.tools import ormcache
-        return list(pycompat.values(channels_preview))
+        return list(channels_preview.values())
-        force_mode = force or (all(data for data in pycompat.values(partner_data)) and all(data for data in pycompat.values(channel_data)))
+        force_mode = force or (all(partner_data.values()) and all(channel_data.values()))
-            for pid, data in pycompat.items(partner_data):
+            for pid, data in partner_data.items():
-            for cid, data in pycompat.items(channel_data):
+            for cid, data in channel_data.items():
-        for server_id, record_ids in pycompat.items(groups):
+        for server_id, record_ids in groups.items():
-        for key, message in pycompat.items(message_tree):
+        for key, message in message_tree.items():
-        for doc_model, doc_dict in pycompat.items(model_ids):
+        for doc_model, doc_dict in model_ids.items():
-            author_ids = [mid for mid, message in pycompat.items(message_values)
+            author_ids = [mid for mid, message in message_values.items()
-            author_ids = [mid for mid, message in pycompat.items(message_values)
+            author_ids = [mid for mid, message in message_values.items()
-            parent_ids = [message.get('parent_id') for mid, message in pycompat.items(message_values)
+            parent_ids = [message.get('parent_id') for message in message_values.values()
-            notified_ids += [mid for mid, message in pycompat.items(message_values)
+            notified_ids += [mid for mid, message in message_values.items()
-            notified_ids = [mid for mid, message in pycompat.items(message_values) if message.get('notified')]
+            notified_ids = [mid for mid, message in message_values.items() if message.get('notified')]
-            for doc_model, doc_ids in pycompat.items(model_record_ids):
+            for doc_model, doc_ids in model_record_ids.items():
-                notified_ids += [mid for mid, message in pycompat.items(message_values)
+                notified_ids += [mid for mid, message in message_values.items()
-        for model, doc_ids in pycompat.items(model_record_ids):
+        for model, doc_ids in model_record_ids.items():
-            document_related_ids += [mid for mid, message in pycompat.items(message_values)
+            document_related_ids += [mid for mid, message in message_values.items()
-        for res_id, record in pycompat.items(res_to_rec):
+        for res_id, record in res_to_rec.items():
-            for res_id, result in pycompat.items(results):
+            for res_id, result in results.items():
-        for res_id, lang in pycompat.items(langs):
+        for res_id, lang in langs.items():
-            for res_id, recipients in pycompat.items(default_recipients):
+            for res_id, recipients in default_recipients.items():
-        for res_id, values in pycompat.items(results):
+        for res_id, values in results.items():
-        for res_id, template in pycompat.items(res_ids_to_templates):
+        for res_id, template in res_ids_to_templates.items():
-        for template, template_res_ids in pycompat.items(templates_to_res_ids):
+        for template, template_res_ids in templates_to_res_ids.items():
-                for res_id, field_value in pycompat.items(generated_field_values):
+                for res_id, field_value in generated_field_values.items():
-        for key, val in pycompat.items(self._context):
+        for key, val in self._context.items():
-        for name, field in pycompat.items(self._fields):
+        for name, field in self._fields.items():
-        if not any(change for rec_id, (change, tracking_value_ids) in pycompat.items(tracking)):
+        if not any(change for rec_id, (change, tracking_value_ids) in tracking.items()):
-        for field_name, (template, post_kwargs) in pycompat.items(templates):
+        for field_name, (template, post_kwargs) in templates.items():
-        for col_name, col_info in pycompat.items(tracked_fields):
+        for col_name, col_info in tracked_fields.items():
-        for model_name, model in pycompat.items(self.env):
+        for model_name, model in self.env.items():
-        for name, field in pycompat.items(self._fields):
+        for name, field in self._fields.items():
-        for pid, subtypes in pycompat.items(new_partners):
+        for pid, subtypes in new_partners.items():
-        for cid, subtypes in pycompat.items(new_channels):
+        for cid, subtypes in new_channels.items():
-        for email_type, recipient_template_values in pycompat.items(recipients):
+        for email_type, recipient_template_values in recipients.items():
-            author_ids = [mid for mid, message in pycompat.items(message_values)
+            author_ids = [mid for mid, message in message_values.items()
-                for res_id, mail_values in pycompat.items(all_mail_values):
+                for res_id, mail_values in all_mail_values.items():
-        for fname, value in pycompat.items(values):
+        for fname, value in values.items():
-        for model, id_map in pycompat.items(workitem_map):
+        for model, id_map in workitem_map.items():
-            workcenter.workorder_count = sum(count for state, count in pycompat.items(result[workcenter.id]) if state not in ('done', 'cancel'))
+            workcenter.workorder_count = sum(count for state, count in result[workcenter.id].items() if state not in ('done', 'cancel'))
-            'domain': [('id', 'in', list(pycompat.values(new_invoice)))],
+            'domain': [('id', 'in', list(new_invoice.values()))],
-from odoo.tools import html2plaintext, pycompat
+from odoo.tools import html2plaintext
-        for k, field in pycompat.items(self._fields):
+        for k, field in self._fields.items():
-        for k, field in pycompat.items(self._fields):
+        for k, field in self._fields.items():
-        for k, v in list(pycompat.items(vals)):
+        for k, v in vals.items():
-        for k, field in pycompat.items(self._fields):
+        for k, field in self._fields.items():
-from odoo.tools import consteq, float_round, image_resize_images, ustr, pycompat
+from odoo.tools import consteq, float_round, image_resize_images, ustr
-            if any(getattr(f, 'required_if_provider', None) == acquirer.provider and not acquirer[k] for k, f in pycompat.items(self._fields)):
+            if any(getattr(f, 'required_if_provider', None) == acquirer.provider and not acquirer[k] for k, f in self._fields.items()):
-                for v in chain(pycompat.keys(parms), pycompat.values(parms))
+                for v in chain(parms.keys(), parms.values())
-        raw_values_ordered = OrderedDict(sorted(pycompat.items(raw_values), key=lambda t: t[0]))
+        raw_values_ordered = OrderedDict(sorted(raw_values.items(), key=lambda t: t[0]))
-from odoo.tools import mute_logger, pycompat
+from odoo.tools import mute_logger
-            values = list(pycompat.values(el.attrib))
+            values = list(el.attrib.values())
-        post = {key.upper(): value for key, value in pycompat.items(post)}
+        post = {key.upper(): value for key, value in post.items()}
-    return {key.upper(): val for key, val in pycompat.items(data)}
+    return {key.upper(): val for key, val in data.items()}
-            items = sorted(pycompat.items(values), key=lambda pair: pair[0].lower())
+            items = sorted(values.items(), key=lambda pair: pair[0].lower())
-from odoo.tools import float_round, DEFAULT_SERVER_DATE_FORMAT, pycompat
+from odoo.tools import float_round, DEFAULT_SERVER_DATE_FORMAT
-        items = sorted((k.upper(), v) for k, v in pycompat.items(values))
+        items = sorted((k.upper(), v) for k, v in values.items())
-from odoo.tools import float_is_zero, pycompat
+from odoo.tools import float_is_zero
-                for group_key, group_value in pycompat.items(grouped_data):
+                for group_key, group_value in grouped_data.items():
-        for group_key, group_data in pycompat.items(grouped_data):
+        for group_key, group_data in grouped_data.items():
-            'taxes': list(pycompat.values(taxes)),
+            'taxes': list(taxes.values()),
-            } for (product, price_unit, discount), qty in pycompat.items(products_sold)], key=lambda l: l['product_name'])
+            } for (product, price_unit, discount), qty in products_sold.items()], key=lambda l: l['product_name'])
-            for product_id, price in pycompat.items(subres):
+            for product_id, price in subres.items():
-            for product_id, res_tuple in pycompat.items(self._compute_price_rule(
+            for product_id, res_tuple in self._compute_price_rule(
-            ))
+            ).items()
-        return {key: price[0] for key, price in pycompat.items(self.price_rule_get(prod_id, qty, partner=partner))}
+        return {key: price[0] for key, price in self.price_rule_get(prod_id, qty, partner=partner).items()}
-        for field, value in pycompat.items(dates_dict):
+        for field, value in dates_dict.items():
-            for k, v in pycompat.items(res[val.id]):
+            for k, v in res[val.id].items():
-            rating_number = sum(pycompat.values(values))
+            rating_number = sum(values.values())
-            project.percentage_satisfaction_project = activity['great'] * 100 / sum(pycompat.values(activity)) if sum(pycompat.values(activity)) else -1
+            project.percentage_satisfaction_project = activity['great'] * 100 / sum(activity.values()) if sum(activity.values()) else -1
-        self.percentage_satisfaction_task = activity['great'] * 100 / sum(pycompat.values(activity)) if sum(pycompat.values(activity)) else -1
+        self.percentage_satisfaction_task = activity['great'] * 100 / sum(activity.values()) if sum(activity.values()) else -1
-                activity_sum = sum(pycompat.values(activity_task))
+                activity_sum = sum(activity_task.values())
-                activity_sum += sum(pycompat.values(activity_issue))
+                activity_sum += sum(activity_issue.values())
-        self.percentage_satisfaction_issue = activity['great'] * 100 / sum(pycompat.values(activity)) if sum(pycompat.values(activity)) else -1
+        self.percentage_satisfaction_issue = activity['great'] * 100 / sum(activity.values()) if sum(activity.values()) else -1
-                for name, field in pycompat.items(line._fields):
+                for name, field in line._fields.items():
-from odoo.tools import float_is_zero, float_compare, DEFAULT_SERVER_DATETIME_FORMAT, pycompat
+from odoo.tools import float_is_zero, float_compare, DEFAULT_SERVER_DATETIME_FORMAT
-        for invoice in pycompat.values(invoices):
+        for invoice in invoices.values():
-        return [inv.id for inv in pycompat.values(invoices)]
+        return [inv.id for inv in invoices.values()]
-        res = sorted(pycompat.items(res), key=lambda l: l[0].sequence)
+        res = sorted(res.items(), key=lambda l: l[0].sequence)
-        for line, qty in pycompat.items(lines):
+        for line, qty in lines.items():
-            'order_line': [(0, 0, {'name': p.name, 'product_id': p.id, 'product_uom_qty': 2, 'product_uom': p.uom_id.id, 'price_unit': p.list_price}) for (_, p) in pycompat.items(self.products)],
+            'order_line': [(0, 0, {'name': p.name, 'product_id': p.id, 'product_uom_qty': 2, 'product_uom': p.uom_id.id, 'price_unit': p.list_price}) for p in self.products.values()],
-        self.assertEqual(so.amount_total, sum([2 * p.list_price for (k, p) in pycompat.items(self.products)]), 'Sale: total amount is wrong')
+        self.assertEqual(so.amount_total, sum([2 * p.list_price for p in self.products.values()]), 'Sale: total amount is wrong')
-        self.assertEqual(inv.amount_total, sum([2 * p.list_price if p.invoice_policy == 'order' else 0 for (k, p) in pycompat.items(self.products)]), 'Sale: invoice total amount is wrong')
+        self.assertEqual(inv.amount_total, sum([2 * p.list_price if p.invoice_policy == 'order' else 0 for p in self.products.values()]), 'Sale: invoice total amount is wrong')
-        self.assertEqual(inv.amount_total, sum([2 * p.list_price if p.invoice_policy == 'delivery' else 0 for (k, p) in pycompat.items(self.products)]), 'Sale: second invoice total amount is wrong')
+        self.assertEqual(inv.amount_total, sum([2 * p.list_price if p.invoice_policy == 'delivery' else 0 for p in self.products.values()]), 'Sale: second invoice total amount is wrong')
-            'order_line': [(0, 0, {'name': p.name, 'product_id': p.id, 'product_uom_qty': 2, 'product_uom': p.uom_id.id, 'price_unit': p.list_price}) for (_, p) in pycompat.items(self.products)],
+            'order_line': [(0, 0, {'name': p.name, 'product_id': p.id, 'product_uom_qty': 2, 'product_uom': p.uom_id.id, 'price_unit': p.list_price}) for p in self.products.values()],
-            'order_line': [(0, 0, {'name': p.name, 'product_id': p.id, 'product_uom_qty': 2, 'product_uom': p.uom_id.id, 'price_unit': p.list_price}) for (_, p) in pycompat.items(self.products)],
+            'order_line': [(0, 0, {'name': p.name, 'product_id': p.id, 'product_uom_qty': 2, 'product_uom': p.uom_id.id, 'price_unit': p.list_price}) for p in self.products.values()],
-            'order_line': [(0, 0, {'name': p.name, 'product_id': p.id, 'product_uom_qty': 2, 'product_uom': p.uom_id.id, 'price_unit': p.list_price}) for (_, p) in pycompat.items(self.products)],
+            'order_line': [(0, 0, {'name': p.name, 'product_id': p.id, 'product_uom_qty': 2, 'product_uom': p.uom_id.id, 'price_unit': p.list_price}) for p in self.products.values()],
-    float_round, pycompat
+from odoo.tools import DEFAULT_SERVER_DATETIME_FORMAT, float_compare, float_round
-            for location_id, location_data in pycompat.items(location_data):
+            for location_id, location_data in location_data.items():
-from odoo.tools import float_utils, pycompat
+from odoo.tools import float_utils
-            for void_field in [item[0] for item in pycompat.items(product_data) if item[1] is None]:
+            for void_field in [item[0] for item in product_data.items() if item[1] is None]:
-from odoo.tools import DEFAULT_SERVER_DATETIME_FORMAT, pycompat
+from odoo.tools import DEFAULT_SERVER_DATETIME_FORMAT
-        for key, moves in pycompat.items(to_assign):
+        for moves in to_assign.values():
-from odoo.tools import DEFAULT_SERVER_DATETIME_FORMAT, pycompat
+from odoo.tools import DEFAULT_SERVER_DATETIME_FORMAT
-            for product, remaining_qty in pycompat.items(move_line._get_remaining_prod_quantities()):
+            for product, remaining_qty in move_line._get_remaining_prod_quantities().items():
-        return list(pycompat.items(self._compute_complete_name()))
+        return list(self._compute_complete_name().items())
-from odoo.tools import DEFAULT_SERVER_DATE_FORMAT, pycompat
+from odoo.tools import DEFAULT_SERVER_DATE_FORMAT
-        for field_name, values in pycompat.items(sub_locations):
+        for field_name, values in sub_locations.items():
-        for field_name, values in pycompat.items(data):
+        for field_name in data:
-        for picking_type, values in pycompat.items(data):
+        for picking_type, values in data.items():
-            getattr(self, field_name).write(values)
+        for field_name, values in picking_type_values.items():
-                setattr(self, key, value)
+            for key, value in self.onchange_product_id_dict(self.product_id.id).items():
-                   for cost_line, val_amount in pycompat.items(val_to_cost_lines)):
+                   for cost_line, val_amount in val_to_cost_lines.items()):
-                AdjustementLines.browse(key).write({'additional_landed_cost': value})
+        for key, value in towrite_dict.items():
-    return {k: v for k, v in pycompat.items(dictionary) if k.startswith(string)}
+    return {k: v for k, v in dictionary.items() if k.startswith(string)}
-            result_summary = {'answers': list(pycompat.values(answers)), 'comments': comments}
+            result_summary = {'answers': list(answers.values()), 'comments': comments}
-            if all(not answer.strip() for answer in pycompat.values(answer_candidates)) and answer_candidates:
+            if all(not answer.strip() for answer in answer_candidates.values()) and answer_candidates:
-        for urltype, urltxt in pycompat.items(urltypes):
+        for urltype, urltxt in urltypes.items():
-                self.assertEqual(getattr(answer, field), value, msg="Unable to answer the survey. Expected behaviour of %s is not proper." % (field))
+            for field, value in expected_values.items():
-        for action, val in pycompat.items(actions):
+        for action, val in actions.items():
-        return list(pycompat.items(dictheaders))
+        return list(dictheaders.items())
-        fields_sequence = sorted(pycompat.items(fields),
+        fields_sequence = sorted(fields.items(),
-                           for attrs in pycompat.values(field.get('states', {}))):
+                           for attrs in field.get('states', {}).values()):
-            for k, v in pycompat.items(self.fields_info(model, export_fields)))
+            for k, v in self.fields_info(model, export_fields).items())
-            for t in pycompat.values(nodes)
+            for t in nodes.values()
-            for color, expr in pycompat.items(bgcolors):
+            for color, expr in bgcolors.items():
-            for shape, expr in pycompat.items(shapes):
+            for shape, expr in shapes.items():
-        attributes = {k: v for k, v in pycompat.items(el.attrib)
+        attributes = {k: v for k, v in el.attrib.items()
-        for key, value in pycompat.items(self.args):
+        for key, value in self.args.items():
-        for key, value in pycompat.items(kw):
+        for key, value in kw.items():
-from odoo.tools import config, pycompat
+from odoo.tools import config
-        for key, val in pycompat.items(arguments):
+        for key, val in arguments.items():
-        for name, value in pycompat.items(atts):
+        for name, value in atts.items():
-            for key, val in list(pycompat.items(arguments)):
+            for key, val in list(arguments.items()):
-        converters = list(pycompat.values(rule._converters))
+        converters = list(rule._converters.values())
-                pycompat.items(converters),
+                converters.items(),
-                for key, val in pycompat.items(value):
+                for key, val in value.items():
-        for slug, expected in pycompat.items(tests):
+        for slug, expected in tests.items():
-    return {'data-oe-%s' % key: str(value) for key, value in pycompat.items(kwargs)}
+    return {'data-oe-%s' % key: str(value) for key, value in kwargs.items()}
-            'searchbar_filters': OrderedDict(sorted(pycompat.items(searchbar_filters))),
+            'searchbar_filters': OrderedDict(sorted(searchbar_filters.items())),
-        for salesman_id, leads_ids in pycompat.items(salesmans_leads):
+        for salesman_id, leads_ids in salesmans_leads.items():
-        for partner_id, partner_leads in pycompat.items(partners_leads):
+        for partner_id, partner_leads in partners_leads.items():
-            for key, search in pycompat.items(domain_search):
+            for key, search in domain_search.items():
-        for key, value in pycompat.items(details):
+        for key, value in details.items():
-            for registration in pycompat.values(registrations):
+        for key, value in global_values.items():
-        return list(pycompat.values(registrations))
+        return list(registrations.values())
-            for key, value in pycompat.items(registration):
+            for key, value in registration.items():
-        for key, value in pycompat.items(data):
+        for key, value in data.items():
-from odoo.tools import html_escape as escape, html2plaintext, pycompat
+from odoo.tools import html_escape as escape, html2plaintext
-        for day, tracks in pycompat.items(days_tracks):
+        for day, tracks in days_tracks.items():
-from odoo.tools import DEFAULT_SERVER_DATE_FORMAT, DEFAULT_SERVER_DATETIME_FORMAT, pycompat
+from odoo.tools import DEFAULT_SERVER_DATE_FORMAT, DEFAULT_SERVER_DATETIME_FORMAT
-        for field_name, field_value in pycompat.items(values):
+        for field_name, field_value in values.items():
-        missing_required_fields = [label for label, field in pycompat.items(authorized_fields) if field['required'] and not label in data['record']]
+        missing_required_fields = [label for label, field in authorized_fields.items() if field['required'] and not label in data['record']]
-            k: v for k, v in pycompat.items(self.get_authorized_fields(self.model))
+            k: v for k, v in self.get_authorized_fields(self.model).items()
-        for key, val in pycompat.items(model._inherits):
+        for key, val in model._inherits.items():
-            percentage[grade] = repartition[grade] * 100 / sum(pycompat.values(repartition)) if sum(pycompat.values(repartition)) else 0
+            percentage[grade] = repartition[grade] * 100 / sum(repartition.values()) if sum(repartition.values()) else 0
-        if [err for err in pycompat.values(error) if err == 'missing']:
+        if [err for err in error.values() if err == 'missing']:
-            'searchbar_filters': OrderedDict(sorted(pycompat.items(searchbar_filters))),
+            'searchbar_filters': OrderedDict(sorted(searchbar_filters.items())),
-            'searchbar_filters': OrderedDict(sorted(pycompat.items(searchbar_filters))),
+            'searchbar_filters': OrderedDict(sorted(searchbar_filters.items())),
-            'searchbar_filters': OrderedDict(sorted(pycompat.items(searchbar_filters))),
+            'searchbar_filters': OrderedDict(sorted(searchbar_filters.items())),
-        rows = sorted(pycompat.items(self.table))
+        rows = sorted(self.table.items())
-            cols = sorted(pycompat.items(rows[col]))
+            cols = sorted(rows[col].items())
-        return {k: v for k, v in pycompat.items(kw) if "attribute" in k}
+        return {k: v for k, v in kw.items() if "attribute" in k}
-        if [err for err in pycompat.items(error) if err == 'missing']:
+        if [err for err in error.items() if err == 'missing']:
-        for k, v in pycompat.items(values):
+        for k, v in values.items():
-            for field_name, field_value in pycompat.items(post):
+            for field_name, field_value in post.items():
-        for k, v in pycompat.items(attributes):
+        for k, v in attributes.items():
-        for country, result in pycompat.items(country_list):
+        for country, result in country_list.items():
-        for country, result in pycompat.items(country_list):
+        for country, result in country_list.items():
-        for country, result in pycompat.items(country_list):
+        for country, result in country_list.items():
-        for country, result in pycompat.items(country_list):
+        for country, result in country_list.items():
-        for k, v in pycompat.items(kw):
+        for k, v in kw.items():
-from odoo.tools import image, pycompat
+from odoo.tools import image
-                setattr(self, key, value)
+            for key, value in values.items():
-            for key, value in pycompat.items(doc_data):
+            for key, value in doc_data.items():
-            for key, value in pycompat.items(doc_data):
+            for key, value in doc_data.items():
-from odoo.tools import config, human_size, ustr, html_escape, pycompat
+from odoo.tools import config, human_size, ustr, html_escape
-        for fname, filepath in pycompat.items(checklist):
+        for fname, filepath in checklist.items():
-        for res_model, res_ids in pycompat.items(model_ids):
+        for res_model, res_ids in model_ids.items():
-        for res_model, targets in pycompat.items(model_attachments):
+        for res_model, targets in model_attachments.items():
-                ids.difference_update(itertools.chain(*pycompat.values(targets)))
+                ids.difference_update(itertools.chain(*targets.values()))
-        for key, func in pycompat.items(_default_parameters):
+        for key, func in _default_parameters.items():
-    return {k: v for k, v in pycompat.items(record) if k in REFERENCING_FIELDS}
+    return {k: v for k, v in record.items() if k in REFERENCING_FIELDS}
-    return {k: v for k, v in pycompat.items(record) if k not in REFERENCING_FIELDS}
+    return {k: v for k, v in record.items() if k not in REFERENCING_FIELDS}
-                error_params = {k: sanitize(v) for k, v in pycompat.items(error_params)}
+                error_params = {k: sanitize(v) for k, v in error_params.items()}
-            for name, field in pycompat.items(model._fields)
+            for name, field in model._fields.items()
-            for field, value in pycompat.items(record):
+            for field, value in record.items():
-        for name, arg in list(pycompat.items(arguments)):
+        for name, arg in list(arguments.items()):
-        for key, value in pycompat.items(headers):
+        for key, value in headers.items():
-            self = self.with_context({k: v for k, v in pycompat.items(self._context) if k != '__last_update'})
+            self = self.with_context({k: v for k, v in self._context.items() if k != '__last_update'})
-        diff = {key for key, val in pycompat.items(params) if field_data[key] != val}
+        diff = {key for key, val in params.items() if field_data[key] != val}
-        for field in pycompat.values(model._fields):
+        for field in model._fields.values():
-        for name, field_data in pycompat.items(fields_data):
+        for name, field_data in fields_data.items():
-        for model, id_name in pycompat.items(model_id_name):
+        for model, id_name in model_id_name.items():
-                    for parent_model, parent_field in pycompat.items(self.env[model]._inherits):
+                    for parent_model, parent_field in self.env[model]._inherits.items():
-                for parent_model, parent_field in pycompat.items(record._inherits):
+                for parent_model, parent_field in record._inherits.items():
-                for parent_model, parent_field in pycompat.items(record._inherits):
+                for parent_model, parent_field in record._inherits.items():
-                    for parent_model_name, parent_field in pycompat.items(current_model._inherits):
+                    for parent_model_name, parent_field in current_model._inherits.items():
-            for parent_model, parent_field in pycompat.items(record._inherits):
+            for parent_model, parent_field in record._inherits.items():
-from odoo.tools import func, misc, pycompat
+from odoo.tools import func, misc
-                if any(asset._content is None for asset in pycompat.values(assets)):
+                if any(asset._content is None for asset in assets.values()):
-            **{key: value for key, value in pycompat.items(options) if key in ['width', 'height', 'humanreadable']})
+            **{key: value for key, value in options.items() if key in ['width', 'height', 'humanreadable']})
-                for k, v in pycompat.items(json.loads(field_options)):
+                for k, v in json.loads(field_options).items():
-        enum = pycompat.items(enum)
+        enum = enum.items()
-        return hash(frozenset((key, freehash(val)) for key, val in pycompat.items(self)))
+        return hash(frozenset((key, freehash(val)) for key, val in self.items()))
-            for ns_prefix, ns_definition in set(pycompat.items(el.nsmap)) - set(pycompat.items(options['nsmap'])):
+            for ns_prefix, ns_definition in set(el.nsmap.items()) - set(options['nsmap'].items()):
-            ns = itertools.chain(pycompat.items(options['nsmap']), pycompat.items(el.nsmap))
+            ns = itertools.chain(options['nsmap'].items(), el.nsmap.items())
-            for key, value in pycompat.items(el.attrib):
+            for key, value in el.attrib.items():
-        tag = u'<%s%s' % (el_tag, u''.join([u' %s="%s"' % (name, escape(pycompat.to_text(value))) for name, value in pycompat.items(attrib)]))
+        tag = u'<%s%s' % (el_tag, u''.join([u' %s="%s"' % (name, escape(pycompat.to_text(value))) for name, value in attrib.items()]))
-        nsprefixmap = {v: k for k, v in itertools.chain(pycompat.items(options['nsmap']), pycompat.items(el.nsmap))}
+        nsprefixmap = {v: k for k, v in itertools.chain(options['nsmap'].items(), el.nsmap.items())}
-        for key, value in pycompat.items(el.attrib):
+        for key, value in el.attrib.items():
-        for name, value in pycompat.items(el.attrib):
+        for name, value in el.attrib.items():
-        if any(name.startswith('t-att') or not name.startswith('t-') for name, value in pycompat.items(el.attrib)):
+        if any(name.startswith('t-att') or not name.startswith('t-') for name, value in el.attrib.items()):
-            # for name, value in pycompat.items(t_attrs):
+            # for name, value in t_attrs.items():
-                        value=ast.Name(id='pycompat', ctx=ast.Load()),
+                        value=ast.Name(id='t_attrs', ctx=ast.Load()),
-                    args=[ast.Name(id='t_attrs', ctx=ast.Load())], keywords=[],
+                    args=[], keywords=[],
-            for ns_prefix, ns_definition in set(pycompat.items(el.nsmap)) - set(pycompat.items(options['nsmap'])):
+            for ns_prefix, ns_definition in set(el.nsmap.items()) - set(options['nsmap'].items()):
-        body = [self._append(ast.Str(u'<%s%s' % (el_tag, u''.join([u' %s="%s"' % (name, escape(pycompat.to_text(value))) for name, value in pycompat.items(extra_attrib)]))))]
+        body = [self._append(ast.Str(u'<%s%s' % (el_tag, u''.join([u' %s="%s"' % (name, escape(pycompat.to_text(value))) for name, value in extra_attrib.items()]))))]
-                for key, value in pycompat.items(options['nsmap']):
+                for key, value in options['nsmap'].items():
-            for key, format in pycompat.items(sequences):
+            for key, format in sequences.items():
-            for field_name, field in pycompat.items(env[model]._fields):
+            for field_name, field in env[model]._fields.items():
-        for mname, ids in pycompat.items(model_ids):
+        for mname, ids in model_ids.items():
-        for name, fld in pycompat.items(record._fields):
+        for name, fld in record._fields.items():
-        for field, nodes in pycompat.items(field_nodes):
+        for field, nodes in field_nodes.items():
-        for model_key, model_value in pycompat.items(Model._fields):
+        for model_key, model_value in Model._fields.items():
-                for node_key, node_value in pycompat.items(Node._fields):
+                for node_key, node_value in Node._fields.items():
-                for (xmod, name), (model, res_id) in pycompat.items(self.pool.model_data_reference_ids)
+                for (xmod, name), (model, res_id) in self.pool.model_data_reference_ids.items()
-        return list(pycompat.values(defaults))
+        return list(defaults.values())
-        return sorted(pycompat.values(results))
+        return sorted(results.values())
-            for module_name, url in pycompat.items(urls):
+            for module_name, url in urls.items():
-            for module_name, url in pycompat.items(urls):
+            for module_name, url in urls.items():
-            with_urls = [module_name for module_name, url in pycompat.items(urls) if url]
+            with_urls = [module_name for module_name, url in urls.items() if url]
-            return sorted(pycompat.items(self.env[model].fields_get(fnames)))
+            return sorted(self.env[model].fields_get(fnames).items())
-        for ref, id in pycompat.items(refs):
+        for ref, id in refs.items():
-        for fname, value in pycompat.items(values):
+        for fname, value in values.items():
-from odoo.tools import ustr, pycompat
+from odoo.tools import ustr
-        selectable = [name for name, field in pycompat.items(self._fields)
+        selectable = [name for name, field in self._fields.items()
-                   for module_name, to_install in pycompat.items(installer)
+                   for module_name, to_install in installer.items()
-                          for requirements, consequences in pycompat.items(self._install_if)
+                          for requirements, consequences in self._install_if.items()
-        for name, field in pycompat.items(self._fields):
+        for name, field in self._fields.items():
-            for pattern, replacement in pycompat.items(tools.DATETIME_FORMATS_MAP):
+            for pattern, replacement in tools.DATETIME_FORMATS_MAP.items():
-            if len(set(pycompat.values(order))) == len(gs):
+            if len(set(order.values())) == len(gs):
-        for app, gs in sorted(pycompat.items(by_app), key=lambda it: it[0].sequence or 0):
+        for app, gs in sorted(by_app.items(), key=lambda it: it[0].sequence or 0):
-        for key, val in pycompat.items(values):
+        for key, val in values.items():
-        for name, field in pycompat.items(partners._fields):
+        for name, field in partners._fields.items():
-        country_ids = set(cid for cids in pycompat.values(country_id_cache) for cid in cids)
+        country_ids = set(cid for cids in country_id_cache.values() for cid in cids)
-from odoo.tools import mute_logger, pycompat
+from odoo.tools import mute_logger
-        for name, cat_ids in pycompat.items(partners_config):
+        for name, cat_ids in partners_config.items():
-        base_domain = [('id', 'in', list(pycompat.values(pids)))]
+        base_domain = [('id', 'in', list(pids.values()))]
-        for name, date in pycompat.items(partners_data):
+        for name, date in partners_data.items():
-from odoo.tools import pycompat, misc, ustr
+from odoo.tools import misc, ustr
-        self.assertEqual(set(pycompat.items(result_etree.nsmap)), expected_ns)
+        self.assertEqual(set(result_etree.nsmap.items()), expected_ns)
-        ids = Cron.search([('id', 'in', list(pycompat.values(cron_ids)))], order='user_id').ids
+        ids = Cron.search([('id', 'in', list(cron_ids.values()))], order='user_id').ids
-        found_ids = Cats.search([('id', 'in', list(pycompat.values(cat_ids)))]).ids
+        found_ids = Cats.search([('id', 'in', list(cat_ids.values()))]).ids
-from odoo.tools import frozendict, classproperty, pycompat
+from odoo.tools import frozendict, classproperty
-        for item in sorted(pycompat.items(self.kwargs)):
+        for item in sorted(self.kwargs.items()):
-        for key, value in list(pycompat.items(attrs)):
+        for key, value in list(attrs.items()):
-            for field, field_cache in pycompat.items(self.cache)
+            for field, field_cache in self.cache.items()
-        for field, field_dump in pycompat.items(cache_dump):
+        for field, field_dump in cache_dump.items():
-        args = {key: val for key, val in pycompat.items(kwargs) if val is not Default}
+        args = {key: val for key, val in kwargs.items() if val is not Default}
-        for key, val in pycompat.items(self._slots):
+        for key, val in self._slots.items():
-        for attr, value in pycompat.items(field._attrs):
+        for attr, value in field._attrs.items():
-        for mname, fnames in pycompat.items(model0._depends):
+        for mname, fnames in model0._depends.items():
-                self.selection = list(pycompat.items(OrderedDict(self.selection + selection_add)))
+                self.selection = list(OrderedDict(self.selection + selection_add).items())
-            self.delegate = name in pycompat.values(model._inherits)
+            self.delegate = name in model._inherits.values()
-        arguments ={k: v for k, v in pycompat.items(arguments)
+        arguments ={k: v for k, v in arguments.items()
-            for k, v in pycompat.items(cookies):
+            for k, v in cookies.items():
-        for k, v in pycompat.items(attrs):
+        for k, v in attrs.items():
-        for f in pycompat.values(req.files):
+        for f in req.files.values():
-                for name, (storename, filename, content_type) in pycompat.items(data['files']):
+                for name, (storename, filename, content_type) in data['files'].items():
-            for f, _, _ in pycompat.values(files):
+            for f, _, _ in files.values():
-        for key, val in pycompat.items(attrs):
+        for key, val in attrs.items():
-            for mname, fnames in pycompat.items(base._depends):
+            for mname, fnames in base._depends.items():
-        cls._constraints = list(pycompat.values(cls._constraints))
+        cls._constraints = list(cls._constraints.values())
-        field_names = {name: field.string for name, field in pycompat.items(self._fields)}
+        field_names = {name: field.string for name, field in self._fields.items()}
-        for model, names in pycompat.items(parent_fields):
+        for model, names in parent_fields.items():
-        for fname, field in pycompat.items(self._fields):
+        for fname, field in self._fields.items():
-            for parent_model, parent_field in pycompat.items(self._inherits)
+            for parent_model, parent_field in self._inherits.items()
-            for name, field in pycompat.items(self._fields)
+            for name, field in self._fields.items()
-        for name, value in pycompat.items(defaults):
+        for name, value in defaults.items():
-            for key, line in pycompat.items(result):
+            for key, line in result.items():
-        return list(pycompat.values(result))
+        return list(result.values())
-        fields = fields or [f.name for f in pycompat.values(self._fields) if f.store]
+        fields = fields or [f.name for f in self._fields.values() if f.store]
-        data = ({k: self._read_group_prepare_data(k,v, groupby_dict) for k,v in pycompat.items(r)} for r in fetched_data)
+        data = ({k: self._read_group_prepare_data(k,v, groupby_dict) for k,v in r.items()} for r in fetched_data)
-        cols = [name for name, field in pycompat.items(self._fields)
+        cols = [name for name, field in self._fields.items()
-            for field in pycompat.values(self._fields):
+            for field in self._fields.values():
-        for parent_model, parent_field in pycompat.items(self._inherits):
+        for parent_model, parent_field in self._inherits.items():
-            for name, field in pycompat.items(parent._fields):
+            for name, field in parent._fields.items():
-        for name, field in pycompat.items(fields):
+        for name, field in fields.items():
-        for table, field_name in pycompat.items(self._inherits):
+        for table, field_name in self._inherits.items():
-        for field in pycompat.values(self._fields):
+        for field in self._fields.values():
-        for name, field in pycompat.items(cls._fields):
+        for name, field in cls._fields.items():
-        for field in pycompat.values(cls._fields):
+        for field in cls._fields.values():
-        for fields in pycompat.values(groups):
+        for fields in groups.values():
-            for field in pycompat.values(cls._fields):
+            for field in cls._fields.values():
-        for fname, field in pycompat.items(self._fields):
+        for fname, field in self._fields.items():
-                               for key, val in pycompat.items(description)
+                               for key, val in description.items()
-                for f in pycompat.values(self._fields)
+                for f in self._fields.values()
-        for key, val in pycompat.items(vals):
+        for key, val in vals.items():
-        for name, val in pycompat.items(vals):
+        for name, val in vals.items():
-                       for key, val in pycompat.items(self._context)
+                       for key, val in self._context.items()
-        for parent_model, parent_field in pycompat.items(self._inherits):
+        for parent_model, parent_field in self._inherits.items():
-        for key, val in pycompat.items(vals):
+        for key, val in vals.items():
-            for parent_model, parent_field in pycompat.items(self._inherits)
+            for parent_model, parent_field in self._inherits.items()
-        for name, val in list(pycompat.items(vals)):
+        for name, val in list(vals.items()):
-        for parent_model, parent_vals in pycompat.items(tocreate):
+        for parent_model, parent_vals in tocreate.items():
-        for name, field in pycompat.items(self._fields):
+        for name, field in self._fields.items():
-        for name, val in pycompat.items(vals):
+        for name, val in vals.items():
-            for name, val in pycompat.items(vals):
+            for name, val in vals.items():
-                           for key, val in pycompat.items(self._context)
+                           for key, val in self._context.items()
-        whitelist = set(name for name, field in pycompat.items(self._fields) if not field.inherited)
+        whitelist = set(name for name, field in self._fields.items() if not field.inherited)
-            for parent_model, parent_field in pycompat.items(model._inherits):
+            for parent_model, parent_field in model._inherits.items():
-            for name, field in pycompat.items(model._fields):
+            for name, field in model._fields.items():
-                          for name, field in pycompat.items(self._fields)
+                          for name, field in self._fields.items()
-        for name, field in pycompat.items(fields_to_copy):
+        for name, field in fields_to_copy.items():
-        for name, field in pycompat.items(old._fields):
+        for name, field in old._fields.items():
-                for key, val in pycompat.items(results)}
+                for key, val in results.items()}
-            for name, value in pycompat.items(values)
+            for name, value in values.items()
-            for name, value in pycompat.items(values)
+            for name, value in values.items()
-        for name, value in pycompat.items(values):
+        for name, value in values.items():
-            for name, value in pycompat.items(values):
+            for name, value in values.items():
-            fields = list(pycompat.values(self._fields))
+            fields = list(self._fields.values())
-                for vals, ids in pycompat.items(updates):
+                for vals, ids in updates.items():
-                for subinfo in pycompat.values(info['fields'][name].get('views', {})):
+                for subinfo in info['fields'][name].get('views', {}).values():
-                self.update({key: val for key, val in pycompat.items(res['value']) if key in self._fields})
+                self.update({key: val for key, val in res['value'].items() if key in self._fields})
-                for name, oldval in pycompat.items(values):
+                for name, oldval in values.items():
-            for name, field in pycompat.items(self._recs._fields):
+            for name, field in self._recs._fields.items():
-        for name, field in pycompat.items(self._recs._fields):
+        for name, field in self._recs._fields.items():
-        additional_data = {key: {'id': 0, 'state': 'uninstalled', 'dbdemo': False, 'installed_version': None} for key in pycompat.keys(self)}
+        additional_data = {key: {'id': 0, 'state': 'uninstalled', 'dbdemo': False, 'installed_version': None} for key in self.keys()}
-            for k, v in pycompat.items(additional_data[package.name]):
+        for package in self.values():
-        done = set(pycompat.keys(self))
+        done = set(self.keys())
-            level_modules = sorted((name, module) for name, module in pycompat.items(self) if module.depth==level)
+            level_modules = sorted((name, module) for name, module in self.items() if module.depth==level)
-            module_names = [k for k, v in pycompat.items(tools.config['init']) if v]
+            module_names = [k for k, v in tools.config['init'].items() if v]
-            module_names = [k for k, v in pycompat.items(tools.config['update']) if v]
+            module_names = [k for k, v in tools.config['update'].items() if v]
-                Module.browse(pycompat.values(modules_to_remove)).module_uninstall()
+                Module.browse(modules_to_remove.values()).module_uninstall()
-        for model in pycompat.values(env):
+        for model in env.values():
-                for ver, lf in pycompat.items(lv)
+                for lv in self.migrations[pkg.name].values()
-                        topological_sort, OrderedSet, pycompat)
+                        topological_sort, OrderedSet)
-            for db_name in list(pycompat.keys(cls.registries)):
+            for db_name in list(cls.registries.keys()):
-            for field in pycompat.values(model._fields)
+            for model in self.values()
-        models = list(pycompat.values(env))
+        models = list(env.values())
-            deps = {name: model._depends for name, model in pycompat.items(env)}
+            deps = {name: model._depends for name, model in env.items()}
-        for model in pycompat.values(self.models):
+        for model in self.models.values():
-    for state, modifs in pycompat.items(field.get("states",{})):
+    for state, modifs in field.get("states",{}).items():
-    for attr, default_value in pycompat.items(default_values):
+    for attr, default_value in default_values.items():
-                for key in pycompat.keys(registry._sql_error):
+                for key in registry._sql_error.keys():
-from odoo.tools import stripped_sys_argv, dumpstacks, log_ormcache_stats, pycompat
+from odoo.tools import stripped_sys_argv, dumpstacks, log_ormcache_stats
-            for db_name, registry in pycompat.items(registries):
+            for db_name, registry in registries.items():
-        for (pid, worker) in pycompat.items(self.workers):
+        for (pid, worker) in self.workers.items():
-            fd_in = list(pycompat.keys(fds)) + [self.pipe[0]]
+            fds = {w.watchdog_pipe[0]: w for w in self.workers.values()}
-    for mod_name, mod_mod in list(pycompat.items(sys.modules)):
+    for mod_name, mod_mod in list(sys.modules.items()):
-for name, typeoid in pycompat.items(types_mapping):
+for name, typeoid in types_mapping.items():
-                sqllogitems = pycompat.items(sqllogs[type])
+                sqllogitems = sqllogs[type].items()
-    for dbname, reg in pycompat.items(Registry.registries):
+    for dbname, reg in Registry.registries.items():
-    for key, count in sorted(pycompat.items(entries)):
+    for key, count in sorted(entries.items()):
-        for logger, level in pycompat.items(dict(it.split(':') for it in loggers))
+        for logger, level in dict(it.split(':') for it in loggers).items()
-        loglevelnames = dict(pycompat.izip(pycompat.values(self._LOGLEVELS), pycompat.keys(self._LOGLEVELS)))
+        loglevelnames = dict(pycompat.izip(self._LOGLEVELS.values(), self._LOGLEVELS))
-        for opt in sorted(pycompat.keys(self.options)):
+        for opt in sorted(self.options):
-        for sec in sorted(pycompat.keys(self.misc)):
+        for sec in sorted(self.misc):
-            for opt in sorted(pycompat.keys(self.misc[sec])):
+            for opt in sorted(self.misc[sec]):
-        least_rank = min(x['x'] for x in pycompat.values(self.result.values))
+        least_rank = min(x['x'] for x in self.result.values.values())
-        max_level = max(len(x) for x in pycompat.values(self.levels.values))
+        max_level = max(len(x) for x in self.levels.values.values())
-            max_level = max(len(x) for x in pycompat.values(self.levels.values))
+            max_level = max(len(x) for x in self.levels.values.values())
-            min_order = math.fabs(min(x['y'] for x in pycompat.values(self.result.values)))
+            min_order = math.fabs(min(x['y'] for x in self.result.values.values()))
-            self.max_order = max(x['y'] for x in pycompat.values(self.result.values))
+            self.max_order = max(x['y'] for x in self.result.values.values())
-                        if sec_node in pycompat.keys(self.partial_order):
+                        if sec_node in self.partial_order:
-    for name,node in pycompat.items(node_res):
+    for name, node in node_res.items():
-            yield j
+        return iter(self.d.values())
-        return list(pycompat.keys(self.d))
+        return list(self.d)
-                for key, val in pycompat.items(attrs):
+                for key, val in attrs.items():
-                el.attrib['style'] = '; '.join('%s: %s' % (key, val) for (key, val) in pycompat.items(valid_styles))
+                el.attrib['style'] = '; '.join('%s: %s' % (key, val) for (key, val) in valid_styles.items())
-        for dirname, mime in pycompat.items(_ooxml_dirs):
+        for dirname, mime in _ooxml_dirs.items():
-        for key, value in pycompat.items(kwargs):
+        for key, value in kwargs.items():
-    for threadId, stack in pycompat.items(sys._current_frames()):
+    for threadId, stack in sys._current_frames().items():
-        return hash(frozenset((key, freehash(val)) for key, val in pycompat.items(self)))
+        return hash(frozenset((key, freehash(val)) for key, val in self.items()))
-            for fk, field in pycompat.items(view_res.get('fields',{})):
+            for fk, field in view_res.get('fields',{}).items():
-        for name, value in pycompat.items(result.attrib):
+        for name, value in result.attrib.items():
-            for src, row in sorted(pycompat.items(grouped_rows)):
+            for src, row in sorted(grouped_rows.items()):
-            for mod, modrows in pycompat.items(rows_by_module):
+            for mod, modrows in rows_by_module.items():
-        for src, target in pycompat.items(pot_targets):
+        for src, target in pot_targets.items():
-            assertion, expressions = next(pycompat.items(node))
+            assertion, expressions = list(node.items())[0]
-        record, fields = next(pycompat.items(node))
+        record, fields = list(node.items())[0]
-            for field_name, field_value in pycompat.items(vals):
+            for field_name, field_value in vals.items():
-            for field_name, field_value in pycompat.items(vals):
+            for field_name, field_value in vals.items():
-            for field_name, field_elem in pycompat.items(elems):
+            for field_name, field_elem in elems.items():
-                    for key, val in pycompat.items(result.get('value', {}))
+                    for key, val in result.get('value', {}).items()
-        for field_name, expression in pycompat.items(fields):
+        for field_name, expression in fields.items():
-            for key, val in pycompat.items(record_dict)
+            for key, val in record_dict.items()
-        python, statements = next(pycompat.items(node))
+        python, statements = list(node.items())[0]
-        function, params = next(pycompat.items(node))
+        function, params = list(node.items())[0]
-        _, fields = next(pycompat.items(node))
+        _, fields = list(node.items())[0]
-        for fieldname, expression in pycompat.items(fields):
+        for fieldname, expression in fields.items():
-                args = next(pycompat.items(node))
+                args = list(node.items())[0]
-        return "<%s %s>" % (self.__class__.__name__, sorted(pycompat.items(self.__dict__)))
+        return "<%s %s>" % (self.__class__.__name__, sorted(self.__dict__.items()))
-from odoo.tools import mute_logger, pycompat
+from odoo.tools import mute_logger
-        for column, field in pycompat.items(model_fields):
+        for column, field in model_fields.items():
-            for model, field in pycompat.items(models)
+            for model, field in models.items()
-# from validate_email_module import *
+    # FIXME: decide whether urls should be bytes or text, apparently
-        url = 'http://' + url
+        url = u'http://' + url
-                buf.append(s)
+                buf.extend(s)
-                    line = buf[12:buf.index('</phantomLog>')]
+            if b'\n' in buf and (not buf.startswith(b'<phantomLog>') or b'</phantomLog>' in buf):
-                line = str(line)
+                    line, buf = buf.split(b'\n', 1)
-                        line_ = line.split('\n\n')
+                        line_ = lline.split('\n\n')
-                            _logger.info("phantomjs: \n%s", line.split('\n\n', 1)[1])
+                            _logger.info("phantomjs: \n%s", lline.split('\n\n', 1)[1])
-            if isinstance(response, pycompat.string_types):
+            if isinstance(response, (bytes, pycompat.text_type)):
-            except(Exception) as e:
+            except Exception as e:
-        if isinstance(result, pycompat.string_types):
+        if isinstance(result, (bytes, pycompat.text_type)):
-        if bin_data.startswith('%PDF-'):
+        if bin_data.startswith(b'%PDF-'):
-    location = path_or_uri.strip()
+    current_path = request.httprequest.path # should already be text
-    if request and not url.netloc and not url.scheme and (url.path or force_lang):
+    if not url.netloc and not url.scheme and (url.path or force_lang):
-        lang = lang or request.context.get('lang')
+        lang = pycompat.to_text(lang or request.context.get('lang') or 'en_US')
-            ps = location.split('/')
+            ps = location.split(u'/')
-                    ps[1] = lang.encode('utf-8')
+                    ps[1] = lang
-            location = '/'.join(ps)
+                ps.insert(1, lang)
-    return location.decode('utf-8')
+    return location
-                with closing(os.fdopen(head_file_fd, 'w')) as head_file:
+                with closing(os.fdopen(head_file_fd, 'wb')) as head_file:
-                with closing(os.fdopen(foot_file_fd, 'w')) as foot_file:
+                with closing(os.fdopen(foot_file_fd, 'wb')) as foot_file:
-            with closing(os.fdopen(content_file_fd, 'w')) as content_file:
+            with closing(os.fdopen(content_file_fd, 'wb')) as content_file:
-    try:
+    with file_open(pathname, 'rb') as fp:
-        with file_open(filename) as fileobj:
+        with file_open(filename, mode='rb') as fileobj:
-                        addons, module, i18n_dir, module + '.pot'))
+                        addons, module, i18n_dir, module + '.pot'), mode='rb')
-                result['values'] = json.loads(content)
+                result['values'] = response.json()
-                result['values'] = base64.b64encode(content)
+                result['values'] = base64.b64encode(response.content)
-                result['values'] = content
+                result['values'] = response.content
-        data = json.loads(pkgutil.get_data(self.__module__, 'contacts_big.json'))
+        data = json.loads(pkgutil.get_data(self.__module__, 'contacts_big.json').decode('utf-8'))
-        data = json.loads(pkgutil.get_data(self.__module__, 'contacts.json'))
+        data = json.loads(pkgutil.get_data(self.__module__, 'contacts.json').decode('utf-8'))
-            request = self.httprequest.stream.read()
+            request = self.httprequest.stream.read().decode(self.httprequest.charset)
-        url_redirect = r.base_url
+        url_redirect = werkzeug.urls.url_parse(r.base_url)
-        response = werkzeug.utils.redirect(url_redirect, 302)
+            # in P3, request.query_string is bytes, the rest is text, can't mix them
-                redirect = '/web?' + request.httprequest.query_string
+                redirect = b'/web?' + request.httprequest.query_string
-            return request.redirect('/page/%s?%s' % (page[8:], request.httprequest.query_string), code=301)
+            return request.redirect(b'/page/%s?%s' % (page[8:].encode('utf-8'), request.httprequest.query_string), code=301)
-                new_url = request.httprequest.path.replace('//', '/') + '?' + request.httprequest.query_string
+                new_url = request.httprequest.path.replace('//', '/').encode('utf-8') + b'?' + request.httprequest.query_string
-                    redirect = request.redirect(path + '?' + request.httprequest.query_string)
+                    redirect = request.redirect(path.encode('utf-8') + b'?' + request.httprequest.query_string)
-                    path += '?' + request.httprequest.query_string
+                    path = path.encode('utf-8') + b'?' + request.httprequest.query_string
-                uri += '?' + req.query_string
+                uri += u'?' + req.query_string.decode('utf-8')
-                redirect = '/web/proxy/post{r.path}?{r.query_string}'.format(r=req)
+                redirect = '/web/proxy/post{r.full_path}'.format(r=req)
-                    user_format = ustr(options.get('%s_format' % field['type'])).encode('utf-8')
+                    # datetime.str[fp]time takes *native strings* in both
-                                line[index] = dt.strftime(dt.strptime(ustr(line[index].strip()).encode('utf-8'), user_format), server_format)
+                                line[index] = dt.strftime(dt.strptime(pycompat.to_native(line[index].strip()), user_format), server_format)
-        format_time = lang_params.get("time_format", '%I-%M %p').encode('utf-8')
+        format_date = pycompat.to_native(lang_params.get("date_format", '%B-%d-%Y'))
-                    valarm.add('DESCRIPTION').value = alarm.name or 'Odoo'
+                    valarm.add('DESCRIPTION').value = alarm.name or u'Odoo'
-            result[meeting.id] = cal.serialize()
+                attendee_add.value = u'MAILTO:' + (attendee.email or u'')
-        return ts.strftime(format)
+        return pycompat.text_type(ts.strftime(format))
-        return "%s %s%s" % (fdate, ftime, (' (%s)' % tz) if tz else '')
+        fdate = pycompat.text_type(ts.strftime(format_date))
-                index_content = ustr("\n".join(words))
+                words = re.findall(b"[\x20-\x7E]{4,}", bin_data)
-GIF = "R0lGODdhAQABAIAAAP///////ywAAAAAAQABAAACAkQBADs="
+GIF = b"R0lGODdhAQABAIAAAP///////ywAAAAAAQABAAACAkQBADs="
-BMP = """Qk1+AAAAAAAAAHoAAABsAAAAAQAAAAEAAAABABgAAAAAAAQAAAATCwAAEwsAAAAAAAAAAAAAQkdScwAAAAAAAAAAAA
+PNG = b'iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAIAAACQd1PeAAAADElEQVQI12P4//8/AAX+Av7czFnnAAAAAElFTkSuQmCC'
-        mimetype = guess_mimetype('')
+        mimetype = guess_mimetype(b'')
-        mimetype = guess_mimetype('', default='test')
+        mimetype = guess_mimetype(b'', default='test')
-        mimetype = guess_mimetype('\0')
+        mimetype = guess_mimetype(b'\0')
-        # OCF zip files must contain a ``mimetype`` entry
+        # If a MIME media type for a document exists, then an OpenDocument
-        marcel = z.read('mimetype')
+        # The content of this file shall be the ASCII encoded MIME media type
-    elif 'Microsoft Excel' in data:
+    elif b'Microsoft Excel' in data:
-            email_to = [formataddr((partner.name, partner.email))]
+            email_to = [formataddr((partner.name or 'False', partner.email or 'False'))]
-            root = lxml.html.fromstring(html)
+            html = u'<div>%s</div>' % html
-            elif node.tag == 'img' and not node.get('src', 'data').startswith('data'):
+            elif node.tag == 'img' and not node.get('src', 'data').startswith(u'data'):
-        html = lxml.html.tostring(root, pretty_print=False, method='html')
+        html = lxml.html.tostring(root, pretty_print=False, method='html', encoding='unicode')
-        if html.startswith('<div>') and html.endswith('</div>'):
+        if html.startswith(u'<div>') and html.endswith(u'</div>'):
-                         set(['migration test', _attachments[0][1], _attachments[1][1]]))
+                         set([b'migration test', _attachments[0][1], _attachments[1][1]]))
-
+def is_ascii(s):
-
+    header_text = ustr(header_text) # FIXME: require unicode higher up?
-
+    param_text = ustr(param_text) # FIXME: require unicode higher up?
-    return [c for c in candidates if try_coerce_ascii(c)]
+    candidates = address_pattern.findall(ustr(text))
-            name = str(Header(name, 'utf-8'))
+        # If s is a <text string>, then charset is a hint specifying the
-    addresses = getaddresses([ustr(header_text).encode('utf-8')])
+    addresses = getaddresses([pycompat.to_native(ustr(header_text))])
-            smtp_password = ustr(smtp_password).encode('utf-8')
+            smtp_user = pycompat.to_native(ustr(smtp_user))
-        email_text_part = MIMEText(email_body_utf8, _subtype=subtype, _charset='utf-8')
+        email_body = ustr(body)
-            msg[ustr(key).encode('utf-8')] = encode_header(value)
+            msg[pycompat.to_native(ustr(key))] = encode_header(value)
-            text_utf8 = html2text.html2text(email_body_utf8.decode('utf-8')).encode('utf-8')
+            text = html2text.html2text(email_body_utf8)
-            alternative_part.attach(MIMEText(text_utf8, _charset='utf-8', _subtype='plain'))
+            alternative_part.attach(MIMEText(text, _charset='utf-8', _subtype='plain'))
-            alternative_body_part = MIMEText(body_alternative_utf8, _subtype=subtype_alternative, _charset='utf-8')
+            body_alternative_ = ustr(body_alternative)
-            partner.email_formatted = formataddr((partner.name, partner.email))
+            partner.email_formatted = formataddr((partner.name or u"False", partner.email or u"False"))
-            self.assertIn('<span data-o-mail-quote="1">%s' % misc.html_escape(ext.decode('utf-8')), html)
+            self.assertIn(u'<span data-o-mail-quote="1">%s' % misc.html_escape(ext), html)
-            self.assertIn('<span data-o-mail-quote="1">%s</span>' % misc.html_escape(ext.decode('utf-8')), html)
+            self.assertIn(u'<span data-o-mail-quote="1">%s</span>' % misc.html_escape(ext), html)
-                self.assertIn('<span data-o-mail-quote="1">%s</span>' % misc.html_escape(text), new_html)
+                self.assertIn(u'<span data-o-mail-quote="1">%s</span>' % misc.html_escape(text), new_html)
-            self.assertIn('<span data-o-mail-quote="1">%s</span>' % misc.html_escape(ext), html)
+            self.assertIn(u'<span data-o-mail-quote="1">%s</span>' % misc.html_escape(ext), html)
-            self.assertIn('<span data-o-mail-quote="1">%s</span>' % misc.html_escape(ext), html)
+            self.assertIn(u'<span data-o-mail-quote="1">%s</span>' % misc.html_escape(ext), html)
-            self.assertIn('<span data-o-mail-quote="1">%s</span>' % misc.html_escape(ext), html)
+            self.assertIn(u'<span data-o-mail-quote="1">%s</span>' % misc.html_escape(ext), html)
-            self.assertIn('<span data-o-mail-quote="1">%s</span>' % misc.html_escape(ext.decode('utf-8')), html)
+            self.assertIn(u'<span data-o-mail-quote="1">%s</span>' % misc.html_escape(ext), html)
-MISC_HTML_SOURCE = """
+MISC_HTML_SOURCE = u"""
-EDI_LIKE_HTML_SOURCE = """<div style="font-family: 'Lucida Grande', Ubuntu, Arial, Verdana, sans-serif; font-size: 12px; color: rgb(34, 34, 34); background-color: #FFF; ">
+EDI_LIKE_HTML_SOURCE = u"""<div style="font-family: 'Lucida Grande', Ubuntu, Arial, Verdana, sans-serif; font-size: 12px; color: rgb(34, 34, 34); background-color: #FFF; ">
-QUOTE_BLOCKQUOTE = """<html>
+QUOTE_BLOCKQUOTE = u"""<html>
-QUOTE_BLOCKQUOTE_OUT = ["""-- 
+QUOTE_BLOCKQUOTE_IN = [u"""<blockquote cite="mid:CAEJSRZvWvud8c6Qp=wfNG6O1+wK3i_jb33qVrF7XyrgPNjnyUA@mail.gmail.com" type="cite" data-o-mail-quote-node="1" data-o-mail-quote="1">"""]
-QUOTE_THUNDERBIRD_HTML = """<html>
+QUOTE_THUNDERBIRD_HTML = u"""<html>
-QUOTE_THUNDERBIRD_HTML_OUT = ["""<pre class="moz-signature" cols="72"><span data-o-mail-quote="1">-- 
+QUOTE_THUNDERBIRD_HTML_IN = [u"""<blockquote cite="mid:CAP76m_WWFH2KVrbjOxbaozvkmbzZYLWJnQ0n0sy9XpGaCWRf1g@mail.gmail.com" type="cite" data-o-mail-quote-node="1" data-o-mail-quote="1">"""]
-QUOTE_HOTMAIL_HTML = """
+QUOTE_HOTMAIL_HTML = u"""
-QUOTE_HOTMAIL_HTML_IN = ["""I don't like that.<br><br>"""]
+QUOTE_HOTMAIL_HTML_IN = [u"""I don't like that.<br><br>"""]
-    """<div dir="ltr" data-o-mail-quote="1"><b data-o-mail-quote="1"><i data-o-mail-quote="1">Test reply. The suite.</i></b>"""]
+    u"""<hr id="stopSpelling" data-o-mail-quote="1">""",
-QUOTE_THUNDERBIRD_1 = """<div>On 11/08/2012 05:29 PM,
+QUOTE_THUNDERBIRD_1 = u"""<div>On 11/08/2012 05:29 PM,
-QUOTE_THUNDERBIRD_1_OUT = ["""-- 
+    u'<a href="mailto:dummy@example.com">dummy@example.com</a> ',
-TEXT_1 = """I contact you about our meeting tomorrow. Here is the schedule I propose:
+TEXT_1 = u"""I contact you about our meeting tomorrow. Here is the schedule I propose:
-TEXT_1_IN = ["""I contact you about our meeting tomorrow. Here is the schedule I propose:
+TEXT_1_IN = [u"""I contact you about our meeting tomorrow. Here is the schedule I propose:
-TEXT_1_OUT = ["""
+TEXT_1_OUT = [u"""
-TEXT_2 = """Salut Raoul!
+TEXT_2 = u"""Salut Raoul!
-TEXT_2_OUT = ["""
+TEXT_2_IN = [u"Salut Raoul!", "Of course. This seems viable."]
-GMAIL_1 = """Hello,<div><br></div><div>Ok for me. I am replying directly in gmail, without signature.</div><div><br></div><div>Kind regards,</div><div><br></div><div>Demo.<br><br><div>On Thu, Nov 8, 2012 at 5:29 PM,  <span>&lt;<a href="mailto:dummy@example.com">dummy@example.com</a>&gt;</span> wrote:<br><blockquote><div>I contact you about our meeting for tomorrow. Here is the schedule I propose:</div><div><ul><li>9 AM: brainstorming about our new amazing business app&lt;/span&gt;&lt;/li&gt;</li>
+GMAIL_1 = u"""Hello,<div><br></div><div>Ok for me. I am replying directly in gmail, without signature.</div><div><br></div><div>Kind regards,</div><div><br></div><div>Demo.<br><br><div>On Thu, Nov 8, 2012 at 5:29 PM,  <span>&lt;<a href="mailto:dummy@example.com">dummy@example.com</a>&gt;</span> wrote:<br><blockquote><div>I contact you about our meeting for tomorrow. Here is the schedule I propose:</div><div><ul><li>9 AM: brainstorming about our new amazing business app&lt;/span&gt;&lt;/li&gt;</li>
-GMAIL_1_IN = ['Ok for me. I am replying directly in gmail, without signature.', '<blockquote data-o-mail-quote-node="1" data-o-mail-quote="1">']
+GMAIL_1_IN = [u'Ok for me. I am replying directly in gmail, without signature.', '<blockquote data-o-mail-quote-node="1" data-o-mail-quote="1">']
-HOTMAIL_1 = """<div>
+HOTMAIL_1 = u"""<div>
-HOTMAIL_1_IN = ["""<div dir="ltr"><br>
+HOTMAIL_1_IN = [u"""<div dir="ltr"><br>
-    """<pre data-o-mail-quote="1">
+    u"""<hr id="stopSpelling" data-o-mail-quote="1">""",
-MSOFFICE_1 = """
+MSOFFICE_1 = u"""
-MSOFFICE_1_OUT = ['I noticed you recently downloaded OpenERP.', 'Uou mentioned you wish to use OpenERP in your own company.', 'Belgium: +32.81.81.37.00']
+MSOFFICE_1_IN = [u'Our requirements are simple. Just looking to replace some spreadsheets for tracking quotes and possibly using the timecard module.']
-BUG1 = """<pre>Hi Migration Team,
+BUG1 = u"""<pre>Hi Migration Team,
-    'Paragraph 1'
+    u'Hi Migration Team',
-BUG_1_OUT = ["""
+BUG_1_OUT = [u"""
-REMOVE_CLASS = """
+REMOVE_CLASS = u"""
-    'An error occured in a modal and I will send you back the html to try opening one on your end']
+    u'<div style="font-size: 12pt; font-family: \'Times New Roman\'; color: #000000">',
-    '<div class="modal-header">']
+    u'<div class="modal-backdrop in">',
-    src = doctype.sub(r"", src)
+    src = doctype.sub(u"", src)
-    src = part.sub(lambda m: ('cite=' not in m.group(1) and 'alt=' not in m.group(1)) and misc.html_escape(m.group(1)) or m.group(1), src)
+    src = part.sub(lambda m: (u'cite=' not in m.group(1) and u'alt=' not in m.group(1)) and misc.html_escape(m.group(1)) or m.group(1), src)
-    src = src.replace('%>', misc.html_escape('%>'))
+    src = src.replace(u'<%', misc.html_escape(u'<%'))
-        cleaned = cleaned.replace('%&gt;', '%>')
+        cleaned = cleaned.replace(u'%24', u'$')
-        cleaned.replace(u'\xa0', '&nbsp;')
+        cleaned.replace(u'\xa0', u'&nbsp;')
-            return ""
+        if u'empty' in pycompat.text_type(e):
-        cleaned = '<p>ParserError when sanitizing</p>'
+        logger.warning(u'ParserError obtained when sanitizing %r', src, exc_info=True)
-        cleaned = '<p>Unknown error when sanitizing</p>'
+        logger.warning(u'unknown error obtained when sanitizing %r', src, exc_info=True)
-    if cleaned.startswith('<div>') and cleaned.endswith('</div>'):
+    if cleaned.startswith(u'<div>') and cleaned.endswith(u'</div>'):
-            sep = '\n            '
+            sep = u'\n            '
-                    response.append('<link href="%s" rel="stylesheet"/>' % url_for(attachment.url))
+                    response.append(u'<link href="%s" rel="stylesheet"/>' % url_for(attachment.url))
-                response.append('<script %s type="text/javascript" src="%s"></script>' % (async and 'async="async"' or '', url_for(self.js().url)))
+                response.append(u'<script %s type="text/javascript" src="%s"></script>' % (async and u'async="async"' or '', url_for(self.js().url)))
-        return hashlib.sha1(check).hexdigest()
+        check = u"%s%s%s" % (json.dumps(self.files), u",".join(self.remains), self.last_modified)
-                remains.append(el)
+                remains.append(pycompat.to_text(el))
-                    remains.append(html.tostring(el))
+                    remains.append(html.tostring(el, encoding='unicode'))
-                    remains.append(html.tostring(el))
+                    remains.append(html.tostring(el, encoding='unicode'))
-        if isinstance(expected, str):
+        if isinstance(expected, bytes):
-                          % (rec_string, etree.tostring(test), expected_value, expression_value)
+                          % (rec_string, etree.tostring(test, encoding='unicode'), expected_value, expression_value)
-                        ParseError(ustr(e), etree.tostring(rec).rstrip(), rec.getroottree().docinfo.URL, rec.sourceline),
+                        ParseError(ustr(e), etree.tostring(rec, encoding='unicode').rstrip(), rec.getroottree().docinfo.URL, rec.sourceline),
-        alias_hash = hex(crc32(alias.encode('utf-8')))[2:].decode('utf-8')
+        alias_hash = hex(crc32(alias.encode('utf-8')))[2:]
-        return s.encode('utf8')
+    assert isinstance(s, pycompat.text_type)
-            wrapped = "<div>%s</div>" % sanitized_term
+            wrapped = u"<div>%s</div>" % sanitized_term
-            sanitized_term = etree.tostring(node, encoding='UTF-8', method='text')
+            sanitized_term = etree.tostring(node, encoding='unicode', method='text')
-        xml_name = "%s.%s" % (module, encode(xml_name))
+        xml_name = "%s.%s" % (module, xml_name)
-            _logger.error("Unable to find object %r", model)
+            _logger.error(u"Unable to find object %r", model)
-            _logger.warning("Unable to find object %r with id %d", model, res_id)
+            _logger.warning(u"Unable to find object %r with id %d", model, res_id)
-        if model=='ir.model.fields':
+        if model==u'ir.model.fields':
-                field_name = encode(record.name)
+                field_name = record.name
-                _logger.error("name error in %s: %s", xml_name, str(exc))
+                _logger.error(u"name error in %s: %s", xml_name, str(exc))
-                name = "%s,%s" % (encode(record.model), field_name)
+                name = "%s,%s" % (record.model, field_name)
-                    push_translation(module, 'selection', name, 0, encode(val))
+                    push_translation(module, 'selection', name, 0, val)
-                    push_translation(module, 'model', name, xml_name, encode(term))
+                    push_translation(module, 'model', name, xml_name, term)
-            push_translation(encode(module), term_type, encode(model), 0, encode(msg))
+            push_translation(encode(module), term_type, encode(model), 0, msg)
-            action_model, action_id = value.decode('utf-8').split(',')
+            action_model, action_id = bytes(value).decode('utf-8').split(',')
-        self.assertEqual(ir_values.value, 'ir.actions.server,%s' % self.action.id, 'ir_actions_server: created ir_values should reference the server action')
+        self.assertEqual(ir_values.value, b'ir.actions.server,%d' % self.action.id, 'ir_actions_server: created ir_values should reference the server action')
-            res['arch'] = etree.tostring(doc)
+            res['arch'] = etree.tostring(doc, encoding='unicode')
-            result['arch'] = etree.tostring(doc)
+            result['arch'] = etree.tostring(doc, encoding='unicode')
-            res['arch'] = etree.tostring(eview)
+            res['arch'] = etree.tostring(eview, encoding='unicode')
-        arch = etree.tostring(doc)
+        arch = etree.tostring(doc, encoding='unicode')
-                    arch = ElementTree.tostring(xml, 'utf-8')
+                    arch = ElementTree.tostring(xml, encoding='unicode')
-                    child = remove_unauthorized_children(child)
+                    remove_unauthorized_children(child)
-        return etree.tostring(remove_unauthorized_children(archnode), pretty_print=True)
+        archnode = etree.fromstring(arch)
-            res['arch'] = etree.tostring(doc)
+            res['arch'] = etree.tostring(doc, encoding='unicode')
-        res['arch'] = etree.tostring(eview)
+        res['arch'] = etree.tostring(eview, encoding='unicode')
-            'arch': ET.tostring(self.arch, encoding='utf-8').decode('utf-8')
+            'arch': ET.tostring(self.arch, encoding='unicode')
-        ), encoding='utf-8')
+        ), encoding='unicode')
-            ET.fromstring(self.view_id.arch.encode('utf-8')),
+            ET.fromstring(self.view_id.arch),
-            attrs(model='res.company', id=company_id, field="name", expression='bob', type='char')))
+            attrs(model='res.company', id=company_id, field="name", expression='bob', type='char')),
-            inner = ''.join([etree.tostring(child) for child in field.iterchildren()])
+            inner = u''.join([etree.tostring(child, encoding='unicode') for child in field.iterchildren()])
-            return etree.tostring(node)
+            return etree.tostring(node, encoding='unicode')
-        return dict(view_data, arch=etree.tostring(arch, encoding='utf-8'))
+        return dict(view_data, arch=etree.tostring(arch, encoding='unicode'))
-        arch = etree.tostring(node, encoding="utf-8").replace(b'\t', b'')
+        arch = etree.tostring(node, encoding="unicode").replace('\t', '')
-        arch = etree.tostring(root, encoding='utf-8')
+        arch = etree.tostring(root, encoding='unicode')
-        ret_val['arch'] = etree.tostring(doc)
+        ret_val['arch'] = etree.tostring(doc, encoding='unicode')
-            arch = etree.tostring(doc)
+            arch = etree.tostring(doc, encoding='unicode')
-            xml_content = etree.tostring(xml, pretty_print=True, encoding="utf-8")
+            xml_content = etree.tostring(xml, pretty_print=True, encoding="unicode")
-        return etree.tostring(element)
+        return etree.tostring(element, encoding='unicode')
-                result['arch'] = etree.tostring(arch_etree, encoding='utf-8')
+                result['arch'] = etree.tostring(arch_etree, encoding='unicode')
-            'arch': '<t t-name="dummy"><p><h1>hello world</h1></p></t>',
+            'arch': u'<t t-name="dummy"><p><h1>hello world</h1></p></t>',
-        replacement = '<script>1 && "hello & world"</script>'
+        replacement = u'<script>1 && "hello & world"</script>'
-            replacement.replace('&', '&amp;'),
+            replacement.replace(u'&', u'&amp;'),
-            view.render(),
+            view.render().decode('utf-8'),
-        replacement = 'world &amp;amp; &amp;lt;b&amp;gt;cie'
+        replacement = u'world &amp;amp; &amp;lt;b&amp;gt;cie'
-            view.render().replace('&', '&amp;'),
+            view.render().decode('utf-8').replace(u'&', u'&amp;'),
-                arch = etree.tostring(root, encoding='utf-8')
+                arch = etree.tostring(root, encoding='unicode')
-                symbol=currency.symbol.encode('utf-8')
+                symbol=currency.symbol
-                      '<span class="oe_currency_value">0.12</span>'.format(
+                      u'<span class="oe_currency_value">0.12</span>'.format(
-                symbol=currency.symbol.encode('utf-8')
+                symbol=currency.symbol
-                      '<span class="oe_currency_value">0.12</span>'
+                      u'<span class="oe_currency_value">0.12</span>'
-                symbol=currency.symbol.encode('utf-8')
+                symbol=currency.symbol
-            ))
+            value, u'<img src="data:image/jpeg;base64,%s">' % encoded_content.decode('ascii'))
-    return response
+
-    return response
+
-            service = environ['PATH_INFO'][len('/xmlrpc/2/'):]
+            service = service[len('2/'):]
-        return xmlrpc_return(start_response, service, method, params, string_faultcode)
+        try:
-    return [response]
+    return werkzeug.exceptions.NotFound("No handler found.\n")(environ, start_response)
-                if hasattr(value, '__iter__'):
+                if not isinstance(value, pycompat.string_types) and isinstance(value, collections.Iterable):
-                    'qux,5,6\n',
+            'file': b'name,Some Value,Counter\n'
-                    'qux,5,6\n',
+            'file': b'name,Some Value,Counter\n'
-                    '"foo","2013å¹´07æ18æ¥","2016-10-12 06:06"\n',
+            'file': u'name,date,create_date\n'
-                    'qux,5,6\n',
+            'file': b'name,Some Value,Counter\n'
-                    ',5,6\n',
+            'file': b'name,Some Value,Counter\n'
-                    '\t \n',
+            'file': b'name,Some Value\n'
-                    'foo,1,2\n',
+            'file': b'name,Some Value,Counter\n'
-                    'foo,1,2\n',
+            'file': b'name,Some Value,Counter\n'
-        if str(e) != 'No module named tests':
+        if not pycompat.text_type(e).startswith(u'No module named'):
-        id = md5(img).digest()
+        id = md5(img.encode('utf-8')).digest()
-        hm = hmac.new(str(secret), token, hashlib.sha1).hexdigest()
+        hm = hmac.new(secret.encode('utf-8'), token.encode('utf-8'), hashlib.sha1).hexdigest()
-        return hmac.new(str(secret), repr(token), hashlib.sha512).hexdigest()
+        return hmac.new(secret.encode('utf-8'), repr(token).encode('utf-8'), hashlib.sha512).hexdigest()
-        return hmac.new(str(secret), token, hashlib.sha256).hexdigest()
+        return hmac.new(secret.encode('utf-8'), token.encode('utf-8'), hashlib.sha256).hexdigest()
-            hm = hmac.new(hmac_key, signing_string, hashlib.sha256)
+            hm = hmac.new(hmac_key, signing_string.encode('utf-8'), hashlib.sha256)
-        return hmac.new(str(values['x_trans_key']), data, hashlib.md5).hexdigest()
+        return hmac.new(values['x_trans_key'].encode('utf-8'), data.encode('utf-8'), hashlib.md5).hexdigest()
-        return hmac.new(str(values['x_trans_key']), data, hashlib.md5).hexdigest()
+        return hmac.new(values['x_trans_key'].encode('utf-8'), data.encode('utf-8'), hashlib.md5).hexdigest()
-        shasign = hashlib.sha512(sign).hexdigest()
+        shasign = hashlib.sha512(sign.encode('utf-8')).hexdigest()
-        shasign = sha256(data + key)
+        shasign = sha256((data + key).encode('utf-8'))
-        sha = hashlib.sha1(getattr(record, '__last_update')).hexdigest()[0:7]
+        sha = hashlib.sha1(getattr(record, '__last_update').encode('utf-8')).hexdigest()[0:7]
-        sha = hashlib.sha1(getattr(sudo_record, '__last_update')).hexdigest()[0:7]
+        sha = hashlib.sha1(getattr(sudo_record, '__last_update').encode('utf-8')).hexdigest()[0:7]
-        return hashlib.sha256('%s-%s-%s-%s' % (
+        return hashlib.sha256((u'%s-%s-%s-%s' % (
-            email)).hexdigest()
+            email
-        return hmac.new(secret.encode('utf-8'), data).hexdigest()
+        return hmac.new(secret.encode('utf-8'), data.encode('utf-8')).hexdigest()
-            bin_data = value and base64.b64decode(value) or ''
+            bin_data = base64.b64decode(value) if value else b''
-        return hashlib.sha1(bin_data or '').hexdigest()
+        return hashlib.sha1(bin_data or b'').hexdigest()
-    "database.uuid": lambda: str(uuid.uuid1()),
+    "database.secret": lambda: pycompat.text_type(uuid.uuid4()),
-            datas = attach[0]['datas'] or ''
+            datas = attach[0]['datas'] or b''
-                        last_update = str(os.path.getmtime(module_resource_path))
+                        last_update = pycompat.text_type(os.path.getmtime(module_resource_path))
-        retag = '"%s"' % hashlib.md5(last_update).hexdigest()
+        retag = '"%s"' % hashlib.md5(last_update.encode('utf-8')).hexdigest()
-        check = json.dumps(self.files) + ",".join(self.remains) + str(self.last_modified)
+        check = json.dumps(self.files) + b",".join(self.remains) + self.last_modified.encode('utf-8')
-        email_hash = hashlib.md5(email.lower()).hexdigest()
+        email_hash = hashlib.md5(email.lower().encode('utf-8')).hexdigest()
-        hm = hmac.new(str(secret), msg, hashlib.sha1).hexdigest()
+        hm = hmac.new(secret.encode('ascii'), msg.encode('utf-8'), hashlib.sha1).hexdigest()
-        hm_expected = hmac.new(str(secret), msg, hashlib.sha1).hexdigest()
+        hm_expected = hmac.new(secret.encode('ascii'), msg.encode('utf-8'), hashlib.sha1).hexdigest()
-        alias_hash = hex(crc32(alias))[2:]
+        alias_hash = hex(crc32(alias.encode('utf-8')))[2:].decode('utf-8')
-                        subquery = cr.mogrify(subquery, [tuple(ids2)])
+                        subquery = cr.mogrify(subquery, [tuple(ids2)]).decode('utf-8')
-                            subquery = cr.mogrify(subquery, [tuple(it for it in res_ids if it)])
+                            subquery = cr.mogrify(subquery, [tuple(it for it in res_ids if it)]).decode('utf-8')
-_xls_pattern = re.compile("""
+_xls_pattern = re.compile(b"""
-_ppt_pattern = re.compile("""
+_ppt_pattern = re.compile(b"""
-    if data.startswith('\xEC\xA5\xC1\x00', offset):
+    if data.startswith(b'\xEC\xA5\xC1\x00', offset):
-    _Entry('application/pdf', ['%PDF'], []),
+    _Entry('application/pdf', [b'%PDF'], []),
-    _Entry('image/bmp', ['BM'], []),
+    _Entry('image/jpeg', [b'\xFF\xD8\xFF\xE0', b'\xFF\xD8\xFF\xE2', b'\xFF\xD8\xFF\xE3', b'\xFF\xD8\xFF\xE1'], []),
-    _Entry('application/msword', ['\xD0\xCF\x11\xE0\xA1\xB1\x1A\xE1', '\x0D\x44\x4F\x43'], [
+    _Entry('application/msword', [b'\xD0\xCF\x11\xE0\xA1\xB1\x1A\xE1', b'\x0D\x44\x4F\x43'], [
-    _Entry('application/zip', ['PK\x03\x04'], [_check_ooxml, _check_open_container_format]),
+    _Entry('application/zip', [b'PK\x03\x04'], [_check_ooxml, _check_open_container_format]),
-        arch = etree.tostring(node, encoding="utf-8").replace('\t', '')
+        arch = etree.tostring(node, encoding="utf-8").replace(b'\t', b'')
-    value_unpickle = fields.Text(string='Default value or action reference',
+    value = fields.Binary(help="Default value (pickled) or reference to an action")
-        return pickle.loads(defaults.value.encode('utf-8')) if defaults else None
+        return pickle.loads(defaults.value) if defaults else None
-            value = pickle.loads(row['value'].encode('utf-8'))
+            value = pickle.loads(row['value'])
-            action_model, action_id = value.split(',')
+            action_model, action_id = value.decode('utf-8').split(',')
-        f_model = node.get('model', '').encode('utf-8')
+        f_model = node.get('model')
-            f_name = node.get("name",'').encode('utf-8')
+            f_search = node.get("search")
-        a_eval = node.get('eval','')
+        a_eval = node.get('eval')
-            done = []
+            matches = re.finditer(br'[^%]%\((.*?)\)[ds]', s)
-                id = m.groups()[0]
+                done.add(found)
-            s = s.replace('%%', '%') # Quite wierd but it's for (somewhat) backward compatibility sake
+                # So funny story: in Python 3, bytes(n: int) returns a
-                +_process("".join([etree.tostring(n, encoding='utf-8') for n in node]))
+            return b'<?xml version="1.0"?>\n'\
-            return _process("".join([etree.tostring(n, encoding='utf-8') for n in node]))
+            return _process(b"".join(etree.tostring(n, encoding='utf-8') for n in node))
-        a_eval = node.get('eval','')
+        a_eval = node.get('eval')
-        model = env[node.get('model', '')]
+        model = env[node.get('model')]
-        node_context = node.get("context",'').encode('utf8')
+        data_node_context = (len(data_node) and data_node.get('context',''))
-        d_search = rec.get("search",'').encode('utf-8')
+        d_search = rec.get("search")
-            res[dest] = rec.get(f,'').encode('utf8')
+            res[dest] = rec.get(f)
-                res[dest] = rec.get(field).encode('utf8')
+                res[dest] = rec.get(field)
-        xml_id = rec.get('id','').encode('utf8')
+        xml_id = rec.get('id','')
-        xml_id = rec.get('id','').encode('utf8')
+        name = rec.get('name')
-        type = rec.get('type','').encode('utf-8') or 'ir.actions.act_window'
+        type = rec.get('type') or 'ir.actions.act_window'
-        limit = rec.get('limit','').encode('utf-8')
+            view_id = self.id_get(rec.get('view_id'))
-            replace = rec.get('replace','') or True
+            keyword = rec.get('key2') or 'client_action_relate'
-            f_name = field.get("name",'').encode('utf-8')
+            f_name = field.get("name")
-        rec_id = rec.get("id",'').encode('ascii')
+        rec_id = rec.get("id")
-            a_action = rec.get('action','').encode('utf8')
+            a_action = rec.get('action')
-        rec_id = rec.get("id",'').encode('ascii')
+        rec_model = rec.get("model")
-        rec_src = rec.get("search",'').encode('utf8')
+        rec_src = rec.get("search")
-        rec_string = rec.get("string",'').encode('utf8') or 'unknown'
+        rec_string = rec.get("string") or 'unknown'
-                f_expr = test.get("expr",'').encode('utf-8')
+                f_expr = test.get("expr",'')
-        rec_model = rec.get("model").encode('ascii')
+        rec_model = rec.get("model")
-        rec_id = rec.get("id",'').encode('ascii')
+        rec_id = rec.get("id",'')
-            f_model = field.get("model",'').encode('utf-8')
+            f_name = field.get("name")
-            f_use = field.get("use",'').encode('utf-8') or 'id'
+            f_use = field.get("use",'') or 'id'
-        tpl_id = el.get('id', el.get('t-name', '')).encode('ascii')
+        tpl_id = el.get('id', el.get('t-name'))
-    fp = file_open(pathname)
+    fp = file_open(pathname, mode='rb')
-        csv_iterator = csv.reader(
+        csv_iterator = pycompat.csv_reader(
-            for row in csv_iterator
+            row for row in csv_iterator
-from odoo.tools import mute_logger
+from odoo.tools import mute_logger, pycompat
-        writer = csv.writer(output, quoting=csv.QUOTE_ALL)
+        writer = pycompat.csv_writer(output, quoting=1)
-        data_row = ["\tfoo\n\tbar", " \"hello\" \n\n 'world' "]
+        data_row = [u"\tfoo\n\tbar", u" \"hello\" \n\n 'world' "]
-        writer.writerow(["name", "Some Value"])
+        writer.writerow([u"name", u"Some Value"])
-        writer = csv.writer(fout, dialect=None)
+        writer = pycompat.csv_writer(fout, dialect=None)
-            ['foo', base64.b64encode(im.tobytes())]
+            [u'name', u'db_datas'],
-import csv
+from odoo.tools import pycompat
-            'Idevise',        # 17
+            u'JournalCode',    # 0
-        w = csv.writer(fecfile, delimiter='|')
+        w = pycompat.csv_writer(fecfile, delimiter='|')
-            w.writerow([s.encode("utf-8") for s in listrow])
+            w.writerow(listrow)
-            w.writerow([s.encode("utf-8") for s in unaffected_earnings_results])
+            w.writerow(unaffected_earnings_results)
-            w.writerow([s.encode("utf-8") for s in listrow])
+            w.writerow(list(row))
-        writer = csv.writer(open('account.tax.code.template-%s.csv' %
+        writer = pycompat.csv_writer(open('account.tax.code.template-%s.csv' %
-        tax_codes_iterator = self.iter_tax_codes
+        tax_codes_iterator = self.iter_tax_codes()
-            writer.writerow(pycompat.imap(_e, pycompat.values(row)))
+            writer.writerow([pycompat.to_text(v) for v in pycompat.values(row)])
-                             ''))
+            writer.writerow([
-                                 self.suffix, 'wb'))
+        writer = pycompat.csv_writer(open('account.tax.template-%s.csv' %
-            writer.writerow(list(pycompat.imap(_e, list(pycompat.values(row))[3:])) + [cur_seq])
+            writer.writerow([
-                                 self.suffix, 'wb'))
+        writer = pycompat.csv_writer(open('account.fiscal.'
-            writer.writerow(pycompat.imap(_e, pycompat.values(row)))
+            writer.writerow([pycompat.to_text(s) for s in pycompat.values(row)])
-        writer = csv.writer(fp, quoting=csv.QUOTE_ALL)
+        writer = pycompat.csv_writer(fp, quoting=1)
-        writer.writerow([name.encode('utf-8') for name in fields])
+        writer.writerow(fields)
-                if type(d) is str and d.startswith(('=', '-', '+')):
+                if isinstance(d, pycompat.string_types) and d.startswith(('=', '-', '+')):
-                row.append(d)
+                row.append(pycompat.to_text(d))
-        return data
+        return fp.getvalue()
-import csv
+import csv # pylint: disable=deprecated-module
-    head, model = os.path.split(model)
+    filename, _ext = os.path.splitext(os.path.basename(fname))
-    reader = csv.reader(input, quotechar='"', delimiter=',')
+    reader = pycompat.csv_reader(io.BytesIO(csvcontent), quotechar='"', delimiter=',')
-            _logger.error("Cannot import the line: %s", line)
+    # filter out empty lines (any([]) == False) and lines containing only empty cells
-            reader = csv.reader(csvfile, delimiter=',', quotechar='"')
+        with open(csvpath, 'rb') as csvfile:
-                result.append((ustr(row[code_index]), ustr(row[name_index])))
+            result = [
-import csv
+# these direct uses of CSV are ok.
-            writer = csv.writer(buffer, 'UNIX')
+            writer = pycompat.csv_writer(buffer, dialect='UNIX')
-            reader = csv.reader(fileobj, quotechar='"', delimiter=',')
+            reader = pycompat.csv_reader(fileobj, quotechar='"', delimiter=',')
-                break
+            fields = next(reader)
-    match = re.search('([0-9.]+)', out)
+    match = re.search(b'([0-9.]+)', out)
-        version = match.group(0)
+        version = match.group(0).decode('ascii')
-        return ustr(value)[:self.size].encode('utf8')
+        return pycompat.to_text(value)[:self.size]
-        return ustr(value)[:self.size]
+        return pycompat.to_text(value)[:self.size]
-            return str(value)
+        if isinstance(value, _BINARY):
-        else:
+        if isinstance(e, (bytes, pycompat.text_type)) or not isinstance(e, collections.Iterable):
-    if isinstance(cols, basestring):
+    if isinstance(cols, pycompat.string_types):
-                        unicode(cell.value)
+                        pycompat.text_type(cell.value)
-                        else unicode(int(cell.value))
+                        else pycompat.text_type(int(cell.value))
-                'message': unicode(error),
+                'message': pycompat.text_type(error),
-            if isinstance(s, unicode):
+            if isinstance(s, pycompat.text_type):
-        if not isinstance(channel, basestring):
+        if not isinstance(channel, pycompat.string_types):
-        if [c for c in channels if not isinstance(c, basestring)]:
+        if [c for c in channels if not isinstance(c, pycompat.string_types)]:
-    if calendar_id and isinstance(calendar_id, (basestring)):
+    if calendar_id and isinstance(calendar_id, pycompat.string_types):
-    if isinstance(ids, (basestring, pycompat.integer_types)):
+    if isinstance(ids, (pycompat.string_types, pycompat.integer_types)):
-                    if not isinstance(item, basestring):
+                    if not isinstance(item, pycompat.string_types):
-            result = unicode(date.day)
+            result = pycompat.text_type(date.day)
-        if isinstance(self.id, basestring):
+        if isinstance(self.id, pycompat.string_types):
-                    if isinstance(calendar_id, basestring):
+                    if isinstance(calendar_id, pycompat.string_types):
-                    if real_meeting.recurrency and real_meeting.end_type in ('count', unicode('count')):
+                    if real_meeting.recurrency and real_meeting.end_type == u'count':
-            if not isinstance(ls, (basestring, pycompat.integer_types)) and len(ls) >= 2:
+            if not isinstance(ls, (pycompat.string_types, pycompat.integer_types)) and len(ls) >= 2:
-                if args[index][0] == "res_id" and isinstance(args[index][2], basestring):
+                if args[index][0] == "res_id" and isinstance(args[index][2], pycompat.string_types):
-        if isinstance(vals.get('res_id'), basestring):
+        if isinstance(vals.get('res_id'), pycompat.string_types):
-                if isinstance(args[index][2], basestring):
+                if isinstance(args[index][2], pycompat.string_types):
-    assert isinstance(email, basestring) and email
+    assert isinstance(email, pycompat.string_types) and email
-
+from odoo.tools import pycompat
-    if isinstance(stuff,basestring):
+    if isinstance(stuff,pycompat.string_types):
-            self._set_Dim(item, 'EXTGO', unicode(linekey.EXGO))
+            self._set_Dim(item, 'EXSEQCODE', text_type(numlgn))
-            self._set_Dim(item, 'EXUNITS', unicode(round(amounts[2], 0)).replace(".", ","))
+                self._set_Dim(item, 'EXTPC', text_type(linekey.EXTPC))
-    elif s is None:
+    if s is None:
-        return str(s)
+    if pycompat.PY2 and type(s) == pycompat.text_type:
-from odoo.tools import consteq
+from odoo.tools import consteq, pycompat
-        elif res_id and isinstance(res_id, basestring):
+        elif res_id and isinstance(res_id, pycompat.string_types):
-            parents = [parents] if isinstance(parents, basestring) else parents
+            parents = [parents] if isinstance(parents, pycompat.string_types) else parents
-            if isinstance(template, basestring):
+            if isinstance(template, pycompat.string_types):
-        if isinstance(message, unicode):
+        # message_from_string parses from a *native string*, except apparently
-        msg_txt = email.message_from_string(message)
+        extract = getattr(email, 'message_from_bytes', email.message_from_string)
-                # we must use utf-8 strings here :-(
+            # message_from_string works on a native str, so on py2 we need to
-            if isinstance(content, unicode):
+            if isinstance(content, pycompat.text_type):
-                'datas': base64.b64encode(str(content)),
+                'datas': base64.b64encode(content),
-        if isinstance(views_or_xmlid, basestring):
+        if isinstance(views_or_xmlid, pycompat.string_types):
-        data = etree.tostring(data, xml_declaration=True, encoding='utf-8')
+        data = etree.tostring(data, encoding='utf-8')
-                unicode(values[2], "utf-8"),
+                values[2],
-            if isinstance(pricelist_id_or_name, basestring):
+            if isinstance(pricelist_id_or_name, pycompat.string_types):
-            if isinstance(pricelist_id_or_name, basestring):
+            if isinstance(pricelist_id_or_name, pycompat.string_types):
-            elif isinstance(self.env.context['location'], basestring):
+            elif isinstance(self.env.context['location'], pycompat.string_types):
-                elif isinstance(self.env.context['warehouse'], basestring):
+                elif isinstance(self.env.context['warehouse'], pycompat.string_types):
-                    answer_value = answer.value_number.__str__()
+                    answer_value = str(answer.value_number)
-                token = uuid.uuid4().__str__()
+                token = pycompat.text_type(uuid.uuid4())
-                if field.type == 'many2one' and isinstance(value, basestring) and value:
+                if field.type == 'many2one' and isinstance(value, pycompat.string_types) and value:
-                if isinstance(d, unicode):
+                if type(d) != str and isinstance(d, pycompat.string_types):
-                if isinstance(cell_value, basestring):
+                if isinstance(cell_value, pycompat.string_types):
-            if isinstance(kwargs[k], basestring) and kwargs[k].isdigit():
+            if isinstance(kwargs[k], pycompat.string_types) and kwargs[k].isdigit():
-                message = unicode(e)
+                message = pycompat.text_type(e)
-        div = u'<div name="%s" data-oe-type="snippet" data-oe-thumbnail="%s">' % (escape(ir_qweb.unicodifier(name)), escape(ir_qweb.unicodifier(thumbnail)))
+        div = u'<div name="%s" data-oe-type="snippet" data-oe-thumbnail="%s">' % (
-            div = u'<div name="%s" data-oe-type="snippet" data-module-id="%s" data-oe-thumbnail="%s"><section/></div>' % (escape(ir_qweb.unicodifier(name)), module.id, escape(ir_qweb.unicodifier(thumbnail)))
+            div = u'<div name="%s" data-oe-type="snippet" data-module-id="%s" data-oe-thumbnail="%s"><section/></div>' % (
-        if isinstance(value, basestring):
+        if isinstance(value, pycompat.string_types):
-        return ir_qweb.unicodifier(img)
+        return pycompat.to_text(img)
-        if isinstance(view_id, basestring):
+        if isinstance(view_id, pycompat.string_types):
-        if isinstance(path_or_xml_id_or_id, basestring) and '.' in path_or_xml_id_or_id:
+        if isinstance(path_or_xml_id_or_id, pycompat.string_types) and '.' in path_or_xml_id_or_id:
-        if isinstance(view_id, basestring):
+        if isinstance(view_id, pycompat.string_types):
-        current_path = current_path.encode('utf-8')
+    path_or_uri = pycompat.to_native(path_or_uri)
-            if isinstance(mid, basestring):
+            if isinstance(mid, pycompat.string_types):
-    source_suffix = source_suffix if isinstance(source_suffix, basestring) else source_suffix[0]
+    source_suffix = source_suffix if isinstance(source_suffix, pycompat.string_types) else source_suffix[0]
-        return unicode(text).translate({
+        return pycompat.text_type(text).translate({
-        tagname = unicode(tagname).lower()
+        tagname = pycompat.text_type(tagname).lower()
-        return self.encode(whitespace.sub(u' ', unicode(value)))
+    def attval(self, value, whitespace=re.compile(u'[ \t\n\f\r]+')):
-        sanitize = lambda p: p.replace('%', '%%') if isinstance(p, basestring) else p
+        sanitize = lambda p: p.replace('%', '%%') if isinstance(p, pycompat.string_types) else p
-            if isinstance(error_params, basestring):
+            if isinstance(error_params, pycompat.string_types):
-                        if isinstance(w, basestring):
+                        if isinstance(w, pycompat.string_types):
-            if value == unicode(item) or value in labels:
+            if value == pycompat.text_type(item) or value in labels:
-            {'moreinfo': [_label or unicode(item) for item, _label in selection if _label or item]}
+            {'moreinfo': [_label or pycompat.text_type(item) for item, _label in selection if _label or item]}
-            _name = encode(model_data['model'])
+            _name = pycompat.to_native(model_data['model'])
-        assert isinstance(model, basestring), 'Not a model name: %s' % (model,)
+        assert isinstance(model, pycompat.string_types), 'Not a model name: %s' % (model,)
-from .qweb import unicodifier, QWebException
+from .qweb import QWebException
-from .qweb import unicodifier
+from odoo.tools import html_escape as escape, posix_to_ldml, safe_eval, float_utils, format_date, pycompat
-    return unicodifier(string).replace(u'\n', u'<br>\n')
+    return pycompat.to_text(string).replace(u'\n', u'<br>\n')
-        return html_escape(unicodifier(value) or u'', options)
+        return html_escape(pycompat.to_text(value), options)
-        return unicodifier(self.user_lang().format('%d', value, grouping=True).replace(r'-', u'\u2011'))
+        return pycompat.to_text(self.user_lang().format('%d', value, grouping=True).replace(r'-', u'\u2011'))
-        return unicodifier(formatted)
+        return pycompat.to_text(formatted)
-        if isinstance(value, basestring):
+        if isinstance(value, pycompat.string_types):
-        return unicodifier(babel.dates.format_datetime(value, format=pattern, locale=locale))
+        return pycompat.to_text(babel.dates.format_datetime(value, format=pattern, locale=locale))
-        return html_escape(unicodifier(options['selection'][value]) or u'', options)
+        return html_escape(pycompat.to_text(options['selection'][value]) or u'', options)
-        return unicodifier(value) or u''
+        return pycompat.to_text(value)
-        return unicodifier(b'<img src="data:%s;base64,%s">' % (Image.MIME[image.format].encode('ascii'), value))
+        return u'<img src="data:%s;base64,%s">' % (Image.MIME[image.format], value.decode('ascii'))
-        if isinstance(value, basestring):
+        if isinstance(value, pycompat.string_types):
-        return unicodifier(babel.dates.format_timedelta(value - reference, add_direction=True, locale=locale))
+        return pycompat.to_text(babel.dates.format_timedelta(value - reference, add_direction=True, locale=locale))
-        return unicodifier(view.render(view._context, engine='ir.qweb'))
+        return pycompat.to_text(view.render(view._context, engine='ir.qweb'))
-            if isinstance(el, basestring):
+            if isinstance(el, pycompat.string_types):
-            else:
+            elif os.path.exists(document):
-        * unicodifier (empty string for a None or False, otherwise unicode string)
+        * to_text (empty string for a None or False, otherwise unicode string)
-            from odoo.addons.base.ir.ir_qweb.qweb import escape, unicodifier, foreach_iterator
+            from odoo.tools.pycompat import to_text, string_types
-        tag = u'<%s%s' % (el_tag, u''.join([u' %s="%s"' % (name, escape(unicodifier(value))) for name, value in pycompat.items(attrib)]))
+        tag = u'<%s%s' % (el_tag, u''.join([u' %s="%s"' % (name, escape(pycompat.to_text(value))) for name, value in pycompat.items(attrib)]))
-            #         append(escape(unicodifier((value)))
+            #         append(escape(to_text((value)))
-                                    ast.Name(id='basestring', ctx=ast.Load())
+                                    ast.Name(id='string_types', ctx=ast.Load())
-                                func=ast.Name(id='unicodifier', ctx=ast.Load()),
+                                func=ast.Name(id='to_text', ctx=ast.Load()),
-        body = [self._append(ast.Str(u'<%s%s' % (el_tag, u''.join([u' %s="%s"' % (name, escape(unicodifier(value))) for name, value in pycompat.items(extra_attrib)]))))]
+        body = [self._append(ast.Str(u'<%s%s' % (el_tag, u''.join([u' %s="%s"' % (name, escape(pycompat.to_text(value))) for name, value in pycompat.items(extra_attrib)]))))]
-            body.append(self._append(ast.Str(unicodifier(el.text))))
+            body.append(self._append(ast.Str(pycompat.to_text(el.text))))
-        return el.tail is not None and [self._append(ast.Str(unicodifier(el.tail)))] or []
+        return el.tail is not None and [self._append(ast.Str(pycompat.to_text(el.tail)))] or []
-        #   value = escape(unicodifier(value))
+        # if isinstance(value, string_types):
-                    ast.Name(id='basestring', ctx=ast.Load())
+                    ast.Name(id='string_types', ctx=ast.Load())
-                        func=ast.Name(id='unicodifier', ctx=ast.Load()),
+                        func=ast.Name(id='to_text', ctx=ast.Load()),
-        #    display the tag (unicodifier(content))
+        #    display the tag (to_text(content))
-                    func=ast.Name(id='unicodifier', ctx=ast.Load()),
+                    func=ast.Name(id='to_text', ctx=ast.Load()),
-                    if isinstance(key, basestring):
+                    if isinstance(key, pycompat.string_types):
-            func=ast.Name(id='unicodifier', ctx=ast.Load()),
+            func=ast.Name(id='to_text', ctx=ast.Load()),
-                elts.append(ast.Str(literal if isinstance(literal, unicode) else literal.decode('utf-8')))
+                elts.append(ast.Str(literal if isinstance(literal, pycompat.text_type) else literal.decode('utf-8')))
-            elts.append(ast.Str(literal if isinstance(literal, unicode) else literal.decode('utf-8')))
+            elts.append(ast.Str(literal if isinstance(literal, pycompat.text_type) else literal.decode('utf-8')))
-        if isinstance(types, basestring):
+        if isinstance(types, pycompat.string_types):
-from odoo.tools.translate import encode, xml_translate, TRANSLATED_ATTRS
+from odoo.tools.translate import xml_translate, TRANSLATED_ATTRS
-            view.arch = arch_fs or view.arch_db
+            view.arch = pycompat.to_text(arch_fs or view.arch_db)
-        name = 'name' if isinstance(value, basestring) else 'id'
+        name = 'name' if isinstance(value, pycompat.string_types) else 'id'
-            view_arch = etree.fromstring(encode(view.arch))
+            view_arch = etree.fromstring(view.arch.encode('utf-8'))
-        arch = etree.tostring(root, encoding='utf-8', xml_declaration=True)
+        arch = etree.tostring(root, encoding='utf-8')
-            value = value.encode('utf8')
+        if isinstance(value, pycompat.string_types):
-        assert isinstance(action, basestring) and ',' in action, \
+        assert isinstance(action, pycompat.string_types) and ',' in action, \
-                    updated = tools.ustr(values[key]) if isinstance(values[key], basestring) else values[key]
+                    updated = tools.ustr(values[key]) if isinstance(values[key], pycompat.string_types) else values[key]
-        if isinstance(operand, basestring):
+        if isinstance(operand, pycompat.string_types):
-        groupby_fields = set([groupby] if isinstance(groupby, basestring) else groupby)
+        groupby_fields = set([groupby] if isinstance(groupby, pycompat.string_types) else groupby)
-            xml_content = etree.tostring(xml, pretty_print=True, xml_declaration=True, encoding="utf-8")
+            xml_content = etree.tostring(xml, pretty_print=True, encoding="utf-8")
-from odoo.tools import frozendict
+from odoo.tools import frozendict, pycompat
-        @functools.partial(compose, unicode)
+        @functools.partial(compose, pycompat.text_type)
-                arch = etree.tostring(root, encoding='utf-8', xml_declaration=True)
+                arch = etree.tostring(root, encoding='utf-8')
-        self.assertIsInstance(res[0], basestring)
+        self.assertIsInstance(res[0], pycompat.string_types)
-        self.assertIsInstance(res, basestring)
+        self.assertIsInstance(res, pycompat.string_types)
-            if isinstance(name, basestring) and name.split(':')[0] == self._name:
+            if isinstance(name, pycompat.string_types) and name.split(':')[0] == self._name:
-        if isinstance(name, basestring) and name.split(':')[0] == self._name:
+        if isinstance(name, pycompat.string_types) and name.split(':')[0] == self._name:
-        if isinstance(name, basestring) and name.split(':')[0] == self._name:
+        if isinstance(name, pycompat.string_types) and name.split(':')[0] == self._name:
-            [[unicode(2**31-1)]])
+            [[pycompat.text_type(2**31-1)]])
-            [[unicode(record.id), u'42']])
+            [[pycompat.text_type(record.id), u'42']])
-from odoo.tools import mute_logger, float_repr
+from odoo.tools import mute_logger, float_repr, pycompat
-        self.assertIsInstance(discussion['name'], basestring)
+        self.assertIsInstance(discussion.name, pycompat.string_types)
-import odoo.tools.sql as sql
+from .sql_db import LazyCursor
-        if isinstance(self.compute, basestring):
+        if isinstance(self.compute, pycompat.string_types):
-        if isinstance(self.related, basestring):
+        if isinstance(self.related, pycompat.string_types):
-        return str(value)
+        return pycompat.to_native(value)
-        if isinstance(self.compute, basestring):
+        if isinstance(self.compute, pycompat.string_types):
-        if isinstance(self.inverse, basestring):
+        if isinstance(self.inverse, pycompat.string_types):
-        if isinstance(self.search, basestring):
+        if isinstance(self.search, pycompat.string_types):
-        if isinstance(value, basestring):
+        if isinstance(value, pycompat.string_types):
-        if isinstance(value, basestring):
+        if isinstance(value, pycompat.string_types):
-        if isinstance(selection, basestring):
+        if isinstance(selection, pycompat.string_types):
-        if isinstance(selection, basestring):
+        if isinstance(selection, pycompat.string_types):
-        elif isinstance(value, basestring):
+        elif isinstance(value, pycompat.string_types):
-                if isinstance(arg, (tuple, list)) and isinstance(arg[0], basestring)
+                if isinstance(arg, (tuple, list)) and isinstance(arg[0], pycompat.string_types)
-from odoo.tools import ustr, consteq, frozendict, pycompat, unique
+from .service.server import memory_info
-from odoo.modules.module import module_manifest
+from .modules.module import module_manifest
-            if isinstance(response, basestring):
+            if isinstance(response, pycompat.string_types):
-        if isinstance(result, basestring):
+        if isinstance(result, pycompat.string_types):
-    if isinstance(filepath_or_fp, (str, unicode)):
+    if isinstance(filepath_or_fp, pycompat.string_types):
-                filename.encode('utf-8') if isinstance(filename, unicode)
+                filename.encode('utf-8') if isinstance(filename, pycompat.text_type)
-    :param: hint_encoding: an optional encoding that was detecte
+    :param value: the value to convert
-    if ttype is unicode:
+    if ttype is text_type:
-    if ttype is str or issubclass(ttype, str):
+    if ttype is bytes or issubclass(ttype, bytes):
-            return unicode(value, hint_encoding, errors=errors)
+            return value.decode(hint_encoding, errors=errors)
-                return unicode(value, ln, errors=errors)
+                return value.decode(ln, errors=errors)
-        return unicode(value)
+        return text_type(value)
-        return unicode(e)
+        return text_type(e)
-IdType = pycompat.integer_types + (str, unicode, NewId)
+IdType = pycompat.integer_types + pycompat.string_types + (NewId,)
-        parents = [parents] if isinstance(parents, basestring) else (parents or [])
+        parents = [parents] if isinstance(parents, pycompat.string_types) else (parents or [])
-                message = (_('Unknown error during import:') + ' %s: %s' % (type(e), unicode(e)))
+                message = (_(u'Unknown error during import:') + u' %s: %s' % (type(e), e))
-                          message=unicode(exception.args[0]) % exc_vals)
+                          message=pycompat.text_type(exception.args[0]) % exc_vals)
-            if isinstance(value, basestring):
+            if isinstance(value, pycompat.string_types):
-        groupby = [groupby] if isinstance(groupby, basestring) else list(OrderedSet(groupby))
+        groupby = [groupby] if isinstance(groupby, pycompat.string_types) else list(OrderedSet(groupby))
-        groupby = [groupby] if isinstance(groupby, basestring) else list(OrderedSet(groupby))
+        groupby = [groupby] if isinstance(groupby, pycompat.string_types) else list(OrderedSet(groupby))
-        if isinstance(func, basestring):
+        if isinstance(func, pycompat.string_types):
-        if isinstance(func, basestring):
+        if isinstance(func, pycompat.string_types):
-        if isinstance(key, basestring):
+        if isinstance(key, pycompat.string_types):
-        elif isinstance(item, basestring):
+        elif isinstance(item, pycompat.string_types):
-    __repr__ = __str__
+    def __repr__(self):
-        if isinstance(key, basestring):
+        if isinstance(key, pycompat.string_types):
-        if isinstance(field_name, basestring) and \
+        if isinstance(field_name, pycompat.string_types) and \
-        if isinstance(field, basestring):
+        if isinstance(field, pycompat.string_types):
-        if isinstance(field, basestring):
+        if isinstance(field, pycompat.string_types):
-        if isinstance(field, basestring):
+        if isinstance(field, pycompat.string_types):
-        if isinstance(field, basestring):
+        if isinstance(field, pycompat.string_types):
-        if isinstance(field, basestring):
+        if isinstance(field, pycompat.string_types):
-        if isinstance(field, basestring):
+        if isinstance(field, pycompat.string_types):
-    return isinstance(element, basestring) and element in DOMAIN_OPERATORS
+    return isinstance(element, pycompat.string_types) and element in DOMAIN_OPERATORS
-        and ((isinstance(element[0], basestring) and element[0])
+        and ((isinstance(element[0], pycompat.string_types) and element[0])
-            if isinstance(value, basestring):
+            if isinstance(value, pycompat.string_types):
-            elif value and isinstance(value, (tuple, list)) and all(isinstance(item, basestring) for item in value):
+            elif value and isinstance(value, (tuple, list)) and all(isinstance(item, pycompat.string_types) for item in value):
-                    if isinstance(right, basestring):
+                    if isinstance(right, pycompat.string_types):
-                        if isinstance(right, basestring):
+                        if isinstance(right, pycompat.string_types):
-                            right and isinstance(right, (tuple, list)) and all(isinstance(item, basestring) for item in right):
+                    if isinstance(right, pycompat.string_types) or \
-                add_null = not str_utf8
+                native_str = pycompat.to_native(right)
-        if isinstance(params, basestring):
+        if isinstance(params, pycompat.string_types):
-    if isinstance(what, basestring):
+    if isinstance(what, pycompat.string_types):
-    assert isinstance(db, basestring)
+    assert isinstance(db, pycompat.string_types)
-import copy
+from . import pycompat
-        dir = unicode(dir)
+        dir = pycompat.text_type(dir)
-from odoo.tools import pycompat
+from . import pycompat
-        assert isinstance(self.multi, basestring), "ormcache_multi() parameter multi must be an argument name"
+        assert isinstance(self.multi, pycompat.string_types), "ormcache_multi() parameter multi must be an argument name"
-    
+
-import odoo.release as release
+from .. import release, conf, loglevels
-            elif isinstance(self.options[arg], basestring) and self.casts[arg].type in optparse.Option.TYPE_CHECKER:
+            elif isinstance(self.options[arg], pycompat.string_types) and self.casts[arg].type in optparse.Option.TYPE_CHECKER:
-        if isinstance(self.options['log_handler'], basestring):
+        if isinstance(self.options['log_handler'], pycompat.string_types):
-            elif isinstance(self.options[arg], basestring) and self.casts[arg].type in optparse.Option.TYPE_CHECKER:
+            elif isinstance(self.options[arg], pycompat.string_types) and self.casts[arg].type in optparse.Option.TYPE_CHECKER:
-        odoo.conf.addons_paths = self.options['addons_path'].split(',')
+        conf.addons_paths = self.options['addons_path'].split(',')
-        odoo.conf.server_wide_modules = [
+        conf.server_wide_modules = [
-        if key in self.options and isinstance(self.options[key], basestring) and \
+        if key in self.options and isinstance(self.options[key], pycompat.string_types) and \
-                    elif model._fields[f_name].type == 'boolean' and isinstance(f_val, basestring):
+                    elif model._fields[f_name].type == 'boolean' and isinstance(f_val, pycompat.string_types):
-    if isinstance(xmlfile, basestring):
+    if isinstance(xmlfile, pycompat.string_types):
-    if isinstance(sz,basestring):
+    if isinstance(sz,pycompat.string_types):
-            assert isinstance(logger, basestring),\
+            assert isinstance(logger, pycompat.string_types),\
-    if isinstance(value, (str, unicode)) and not value:
+    if isinstance(value, pycompat.string_types) and not value:
-    elif isinstance(value, basestring):
+    elif isinstance(value, pycompat.string_types):
-    'unicode': unicode,
+    'unicode': pycompat.text_type,
-from subprocess import Popen, PIPE
+from subprocess import Popen, PIPE
-    env = odoo.api.Environment(cr, uid, context)
+    env = api.Environment(cr, uid, context)
-        open(os.path.join(tools.config['test_report_directory'], rname+ '.'+res_format), 'wb+').write(res_data)
+    if config['test_report_directory']:
-        if res_data[:5] != '%PDF-':
+        if res_data[:5] != b'%PDF-':
-            res_text = tools.ustr(stdout)
+            res_text = ustr(stdout)
-    if not our_module and isinstance(action_id, basestring):
+    if not our_module and isinstance(action_id, pycompat.string_types):
-    env = odoo.api.Environment(cr, uid, context)
+    env = api.Environment(cr, uid, context)
-    if isinstance(action_id, basestring):
+    if isinstance(action_id, pycompat.string_types):
-        if isinstance(context1, basestring):
+        if isinstance(context1, pycompat.string_types):
-#
+# FIXME: holy shit this whole thing needs to be cleaned up hard it's a mess
-    return etree.fromstring(encode(text))
+    return etree.fromstring(text)
-    return etree.tostring(node, method='xml', encoding='utf8').decode('utf8')
+    return etree.tostring(node, method='xml', encoding='unicode')
-    return html.fragment_fromstring(encode(text), parser=_HTML_PARSER)
+    return html.fragment_fromstring(text, parser=_HTML_PARSER)
-    return etree.tostring(node, method='html', encoding='utf8').decode('utf8')
+    return etree.tostring(node, method='html', encoding='unicode')
-        root = parse_html("<div>%s</div>" % value)
+        root = parse_html(u"<div>%s</div>" % value)
-                  % (quote(source), quote(trad))
+        msg = (
-                    (isinstance(res_id, basestring) and res_id.isdigit()):
+                    (isinstance(res_id, pycompat.string_types) and res_id.isdigit()):
-from . import yaml_tag, pycompat
+from . import assertion_report, pycompat, yaml_tag
-    return isinstance(node, basestring)
+    return isinstance(node, pycompat.string_types)
-    return isinstance(node, basestring)
+    return isinstance(node, pycompat.string_types)
-        if view_id and (view_id is not True) and isinstance(view_id, basestring):
+        if view_id and (view_id is not True) and isinstance(view_id, pycompat.string_types):
-            traverse(etree.fromstring(encode(view['arch'])), elems)
+            arch = view['arch']
-        elif isinstance(python.id, basestring):
+        elif isinstance(python.id, pycompat.string_types):
-            StringIO(csv_data),
+            io.BytesIO(csv_data),
-
+import base64
-        import csv, cStringIO
+        import csv, io
-        fout = cStringIO.StringIO()
+        fout = io.BytesIO()
-            ['foo', im.tobytes().encode('base64')]
+            ['foo', base64.b64encode(im.tobytes())]
-                        data = fp.read().encode('base64')
+                    with open(full_path, 'rb') as fp:
-                                                      'datas': str(ics_file).encode('base64')})]
+                                                      'datas': base64.b64encode(ics_file)})]
-        f = StringIO(bin_data)
+        f = io.BytesIO(bin_data)
-        f = StringIO(bin_data)
+        f = io.BytesIO(bin_data)
-        f = StringIO(bin_data)
+        f = io.BytesIO(bin_data)
-        f = StringIO(bin_data)
+        f = io.BytesIO(bin_data)
-            f = StringIO(bin_data)
+            f = io.BytesIO(bin_data)
-
+import base64
-        return tools.image_resize_image_big(open(image_path, 'rb').read().encode('base64'))
+        return tools.image_resize_image_big(base64.b64encode(open(image_path, 'rb').read()))
-
+import base64
-        return tools.image_resize_image_big(open(image_path, 'rb').read().encode('base64'))
+        return tools.image_resize_image_big(base64.b64encode(open(image_path, 'rb').read()))
-import StringIO
+import io
-        fecfile = StringIO.StringIO()
+        fecfile = io.BytesIO()
-
+import base64
-        self.icon_src = 'data:image/png;base64,' + self.favicon
+        self.icon_src = b'data:image/png;base64,' + self.favicon
-            icon_base64 = icon.encode('base64').replace("\n", "")
+            icon_base64 = base64.b64encode(icon).replace(b"\n", b"").decode('ascii')
-            message = dbs[db].decode('base64')
+            message = base64.b64decode(dbs[db])
-
+import base64
-        return tools.image_resize_image_big(open(image_path, 'rb').read().encode('base64'))
+        return tools.image_resize_image_big(base64.b64encode(open(image_path, 'rb').read()))
-            message = str(message.data)
+            message = bytes(message.data)
-            ('List2', 'My second attachment')
+            ('List1', b'My first attachment'),
-        self.assertEqual(set([x.decode('base64') for x in msg.attachment_ids.mapped('datas')]),
+        self.assertEqual(set([base64.b64decode(x) for x in msg.attachment_ids.mapped('datas')]),
-
+import base64
-            'datas': 'My attachment'.encode('base64'),
+            'datas': base64.b64encode(b'My attachment'),
-            'datas': base64.b64encode('My first attachment'),
+            'datas': base64.b64encode(b'My first attachment'),
-            'datas': base64.b64encode('My second attachment'),
+            'datas': base64.b64encode(b'My second attachment'),
-        response.data = 'R0lGODlhAQABAIAAANvf7wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw=='.decode('base64')
+        response.data = base64.b64decode(b'R0lGODlhAQABAIAAANvf7wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==')
-    it = ET.iterparse(StringIO(xml))
+    it = ET.iterparse(io.BytesIO(xml))
-                'html_3ds': str(tree.HTML_ANSWER).decode('base64')
+                'html_3ds': base64.b64decode(tree.HTML_ANSWER.decode('ascii')),
-
+import base64
-                rating.rating_image = open(image_path, 'rb').read().encode('base64')
+                rating.rating_image = base64.b64decode(open(image_path, 'rb').read())
-                        image_data = StringIO(image_base64)
+                        image_base64 = base64.b64decode(row[0])
-        fp = StringIO()
+        fp = io.BytesIO()
-        fp = StringIO()
+        fp = io.BytesIO()
-import cStringIO
+import base64
-        icon = unichr(int(icon)) if icon.isdigit() else icon
+        icon = pycompat.unichr(int(icon)) if icon.isdigit() else icon
-                        image = Image.open(cStringIO.StringIO(data))
+                        image = Image.open(io.BytesIO(data))
-                        'datas': data.encode('base64'),
+                        'datas': base64.b64encode(data),
-                        content = custom_attachments.filtered(lambda a: a.url == url).datas.decode("base64")
+                        content = base64.b64decode(custom_attachments.filtered(lambda a: a.url == url).datas)
-            custom_attachment.write({"datas": content.encode("utf-8").encode("base64")})
+            custom_attachment.write({"datas": base64.b64encode(content.encode("utf-8"))})
-                datas = content.encode("utf-8").encode("base64"),
+                datas = base64.b64encode(content.encode("utf-8")),
-import cStringIO
+import base64
-                return f.read().encode('base64')
+                return base64.b64encode(f.read())
-            image = I.open(cStringIO.StringIO(req.content))
+            image = I.open(io.BytesIO(req.content))
-        out = cStringIO.StringIO()
+        out = io.BytesIO()
-        return out.getvalue().encode('base64')
+        return base64.b64encode(out.getvalue())
-
+import base64
-                'datas': content.encode('base64'),
+                'datas': base64.b64encode(content),
-                content = sitemap.datas.decode('base64')
+                content = base64.b64decode(sitemap)
-                    '/website_blog/static/src/img/anonymous.png',
+                    (b"data:image/png;base64,%s" % message.author_id.image) or \
-            content = image.encode('base64')
+            content = base64.b64encode(image)
-            values['image'] = image.encode('base64')
+            values['image'] = base64.b64encode(image)
-        attachments = [('signature.png', sign.decode('base64'))] if sign else []
+        attachments = [('signature.png', base64.b64decode(sign))] if sign else []
-from cStringIO import StringIO
+import io
-            data = StringIO(base64.standard_b64decode(attachment["datas"]))
+            data = io.BytesIO(base64.standard_b64decode(attachment["datas"]))
-        response.data = slide.datas and slide.datas.decode('base64') or ''
+        response.data = slide.datas and base64.b64decode(slide.datas) or b''
-                result['values'] = content.encode('base64')
+                result['values'] = base64.b64encode(content)
-                image = Image.open(io.BytesIO(vals['image'].decode('base64')))
+                image = Image.open(io.BytesIO(base64.b64decode(vals['image'])))
-
+import base64
-                r = open(full_path,'rb').read().encode('base64')
+                r = base64.b64encode(open(full_path,'rb').read())
-        bin_value = value.decode('base64')
+        bin_value = base64.b64decode(value)
-            bin_data = value and value.decode('base64') or ''
+            bin_data = value and base64.b64decode(value) or ''
-            mimetype = guess_mimetype(values['datas'].decode('base64'))
+            mimetype = guess_mimetype(base64.b64decode(values['datas']))
-            response.data = datas.decode('base64')
+            response.data = base64.b64decode(datas)
-            'datas': content.encode('utf8').encode('base64'),
+            'datas': base64.b64encode(content.encode('utf8')),
-                        asset._content = attachment.datas and attachment.datas.decode('base64').decode('utf8') or ''
+                        asset._content = attachment.datas and base64.b64decode(attachment.datas).decode('utf8') or ''
-                                    datas=asset.content.encode('utf8').encode('base64'),
+                                    datas=base64.b64encode(asset.content.encode('utf8')),
-                return self._ir_attach['datas'].decode('base64').decode('utf-8')
+                return base64.b64decode(self._ir_attach['datas']).decode('utf-8')
-            image = Image.open(BytesIO(value.decode('base64')))
+        try: # FIXME: maaaaaybe it could also take raw bytes?
-        return unicodifier('<img src="data:%s;base64,%s">' % (Image.MIME[image.format], value))
+        return unicodifier(b'<img src="data:%s;base64,%s">' % (Image.MIME[image.format].encode('ascii'), value))
-        return unicodifier('<img src="data:%s;base64,%s">' % ('png', barcode.encode('base64')))
+            **{key: value for key, value in pycompat.items(options) if key in ['width', 'height', 'humanreadable']})
-                    module.icon_image = image_file.read().encode('base64')
+                    module.icon_image = base64.b64encode(image_file.read())
-
+import base64
-        return open(os.path.join(tools.config['root_path'], 'addons', 'base', 'res', 'res_company_logo.png'), 'rb') .read().encode('base64')
+        return base64.b64encode(open(os.path.join(tools.config['root_path'], 'addons', 'base', 'res', 'res_company_logo.png'), 'rb') .read())
-
+import base64
-        self.blob1_b64 = self.blob1.encode('base64')
+        self.blob1 = b'blob1'
-        self.blob2_b64 = self.blob2.encode('base64')
+        self.blob2 = b'blob2'
-invalid_form = etree.parse(io.BytesIO('''\
+invalid_form = etree.parse(io.BytesIO(b'''\
-valid_form = etree.parse(io.BytesIO('''\
+valid_form = etree.parse(io.BytesIO(b'''\
-invalid_graph = etree.parse(io.BytesIO('''\
+invalid_graph = etree.parse(io.BytesIO(b'''\
-valid_graph = etree.parse(io.BytesIO('''\
+valid_graph = etree.parse(io.BytesIO(b'''\
-invalid_tree = etree.parse(io.BytesIO('''\
+invalid_tree = etree.parse(io.BytesIO(b'''\
-valid_tree = etree.parse(io.BytesIO('''\
+valid_tree = etree.parse(io.BytesIO(b'''\
-
+import base64
-        encoded_content = content.encode('base64')
+        encoded_content = base64.b64encode(content)
-            value, '<img src="data:image/jpeg;base64,%s">' % (
+            value, b'<img src="data:image/jpeg;base64,%s">' % (
-            converter.value_to_html(content.encode('base64'), {})
+            converter.value_to_html(base64.b64encode(content), {})
-            converter.value_to_html(content.encode('base64'), {})
+            converter.value_to_html(base64.b64encode(content), {})
-        return psycopg2.Binary(str(value)) if value else None
+        if not value:
-
+import base64
-        return t.read().encode('base64')
+        return base64.b64encode(t.read())
-        data_file.write(data.decode('base64'))
+        data_file.write(base64.b64decode(data))
-
+import base64
-            return data.encode('base64')
+            return base64.b64encode(data)
-    import StringIO
+import base64
-    image_stream = StringIO.StringIO(base64_source.decode(encoding))
+    image_stream = io.BytesIO(codecs.decode(base64_source, encoding))
-    background_stream = StringIO.StringIO()
+    background_stream = io.BytesIO()
-    return background_stream.getvalue().encode(encoding)
+    return codecs.encode(background_stream.getvalue(), encoding)
-        img = StringIO.StringIO()
+        img = io.BytesIO()
-    output_stream = StringIO.StringIO()
+    image_stream = Image.open(io.BytesIO(base64.b64decode(data)))
-        thumb_image = Image.open(StringIO.StringIO(output_stream.getvalue()))
+        thumb_image = Image.open(io.BytesIO(output_stream.getvalue()))
-    return output_stream.getvalue().encode('base64')
+    return base64.b64encode(output_stream.getvalue())
-    original = Image.open(StringIO.StringIO(original))
+    original = Image.open(io.BytesIO(original))
-    buffer = StringIO.StringIO()
+    buffer = io.BytesIO()
-    img = open(sys.argv[1],'rb').read().encode('base64')
+    img = base64.b64encode(open(sys.argv[1],'rb').read())
-    open(sys.argv[2], 'wb').write(new.decode('base64'))
+    open(sys.argv[2], 'wb').write(base64.b64decode(new))
-    # pylint: disable=long-builtin,dict-iter-method
+    # pylint: disable=long-builtin,unichr-builtin,unicode-builtin
-        sys.meta_path.append(OdooHook())
+        sys.meta_path.insert(0, OdooHook())
-            end_time = day.date() == end_dt.date() and end_dt.time() or datetime.time.max
+            start_time = datetime.time.min
-            end_time = day.date() == end_dt.date() and end_dt.time() or datetime.time.max
+            start_time = datetime.time.min
-        etag = hasattr(request, 'httprequest') and request.httprequest.headers.get('If-None-Match')
+        etag = bool(request) and request.httprequest.headers.get('If-None-Match')
-        users = [[] for i in range(len(user_obj) / 3 + 1)]
+        users = [[] for i in range(len(user_obj) // 3 + 1)]
-            users[index / 3].append(user)
+            users[index // 3].append(user)
-            while not self._check_place(pos % PPR, pos / PPR, x, y):
+            while not self._check_place(pos % PPR, pos // PPR, x, y):
-            if index >= ppg and ((pos + 1.0) / PPR) > maxy:
+            if index >= ppg and ((pos + 1.0) // PPR) > maxy:
-                minpos = pos / PPR
+                minpos = pos // PPR
-            self.table[pos / PPR][pos % PPR] = {
+                    self.table[(pos // PPR) + y2][(pos % PPR) + x2] = False
-                maxy = max(maxy, y + (pos / PPR))
+                maxy = max(maxy, y + (pos // PPR))
-        return {product.id: product.website_price / add_qty for product in products}
+        return {product.id: product.website_price // add_qty for product in products}
-        qs = ps[:len(ps) / 2] + ps[len(ps) / 2:]
+        qs = ps[:len(ps) // 2] + ps[len(ps) // 2:]
-    image.paste(resized_image, ((size[0] - resized_image.size[0]) / 2, (size[1] - resized_image.size[1]) / 2))
+    image.paste(resized_image, ((size[0] - resized_image.size[0]) // 2, (size[1] - resized_image.size[1]) // 2))
-        new_h = (w * h_ratio) / w_ratio
+        new_h = (w * h_ratio) // w_ratio
-            new_w = (h * w_ratio) / h_ratio
+            new_w = (h * w_ratio) // h_ratio
-        cropped_image = image_stream.crop(((w - new_w) / 2, (h - new_h) / 2, (w + new_w) / 2, (h + new_h) / 2))
+        cropped_image = image_stream.crop(((w - new_w) // 2, (h - new_h) // 2, (w + new_w) // 2, (h + new_h) // 2))
-        thumb_image.thumbnail((new_w / thumbnail_ratio, new_h / thumbnail_ratio), Image.ANTIALIAS)
+        thumb_image.thumbnail((new_w // thumbnail_ratio, new_h // thumbnail_ratio), Image.ANTIALIAS)
-            lock_date = max(move.company_id.period_lock_date, move.company_id.fiscalyear_lock_date)
+            lock_date = max(move.company_id.period_lock_date or '0000-00-00', move.company_id.fiscalyear_lock_date or '0000-00-00')
-            if move.date <= lock_date:
+            if move.date <= (lock_date or '0000-00-00'):
-        maxdate = None
+        maxdate = '0000-00-00'
-        if move_date > self.company_id.fiscalyear_lock_date:
+        if (move_date or '0000-00-00' > self.company_id.fiscalyear_lock_date or '0000-00-00'):
-        maxdate = None
+        maxdate = '0000-00-00'
-        partners = sorted(partners, key=lambda x: (x.ref, x.name))
+        partners = sorted(partners, key=lambda x: (x.ref or '', x.name or ''))
-        if vals.get('probability') >= 100 or not vals.get('active', True):
+        if vals.get('probability', 0) >= 100 or not vals.get('active', True):
-        elif 'probability' in vals and vals['probability'] < 100:
+        elif 'probability' in vals:
-            'parent_model': subtype.parent_id and subtype.parent_id.res_model or False,
+            'parent_model': subtype.parent_id.res_model,
-        subtypes_list = sorted(subtypes_list, key=itemgetter('parent_model', 'res_model', 'internal', 'sequence'))
+        subtypes_list = sorted(subtypes_list, key=lambda it: (it['parent_model'] or '', it['res_model'] or '', it['internal'], it['sequence']))
-            if invoice_line.invoice_id.date_invoice > date_from and invoice_line.invoice_id.date_invoice < date_to:
+            date_from = invoice_line.product_id.membership_date_from or '0000-00-00'
-        self.assertEqual(prp_result, answers, msg="Statistics of simple, multiple choice questions are different from expectation")
+        self.assertItemsEqual(prp_result, answers, msg="Statistics of simple, multiple choice questions are different from expectation")
-    padding = None
+    padding = 0
-            padding = None
+            padding = 0
-            if self.published_date <= fields.Datetime.now():
+            if (self.published_date or '') <= fields.Datetime.now():
-                countries.sort(key=lambda d: d['country_id'] and d['country_id'][1])
+                    countries.sort(key=lambda d: (d['country_id'] or (0, ""))[1])
-        for track in event.track_ids.sorted(lambda track: (track.date, bool(track.location_id))):
+        for track in event.track_ids.sorted(lambda track: (track.date or '', bool(track.location_id))):
-        self.assertSequenceEqual(sorted(gb, key=lambda r: r['date']), [{
+        self.assertSequenceEqual(sorted(gb, key=lambda r: r['date'] or ''), [{
-        result = round(amount, self.currency_id.decimal_places) * -1
+        result = self.currency_id.round(amount) * -1
-                amt = round(line.value_amount, prec)
+                amt = currency.round(line.value_amount)
-                amt = round(value * (line.value_amount / 100.0), prec)
+                amt = currency.round(value * (line.value_amount / 100.0))
-                amt = round(amount, prec)
+                amt = currency.round(amount)
-        dist = round(value - amount, prec)
+        dist = currency.round(value - amount)
-                        line.update({'price': round(valuation_price_unit * line['quantity'], account_prec)})
+                        line.update({'price': company_currency.round(valuation_price_unit * line['quantity'])})
-                            'price_unit': round(price_unit - valuation_price_unit, account_prec),
+                            'price_unit': company_currency.round(price_unit - valuation_price_unit),
-                            'price': round(price_before - line.get('price', 0.0), account_prec),
+                            'price': company_currency.round(price_before - line.get('price', 0.0)),
-            days_count += round((leave_time.total_seconds()/3600 / theoric_hours) * 4) / 4
+            days_count += round((leave_time.total_seconds() / 3600 / theoric_hours) * 4) / 4
-        return round(price, self.invoice_id.currency_id.decimal_places)
+        return self.invoice_id.currency_id.round(price)
-from odoo import api, fields, models
+from odoo import api, fields, models, _
-    user_id = fields.Many2one('res.users', string="Assigned to", required=True)
+    user_id = fields.Many2one('res.users', string="Assigned to")
-    pricelist_id = fields.Many2one('product.pricelist', string='Pricelist', required=True, default=_default_pricelist)
+    pricelist_id = fields.Many2one('product.pricelist', string='Default Pricelist', required=True, default=_default_pricelist,
-            'fiscal_position_id': ui_order['fiscal_position_id']
+            'fiscal_position_id': ui_order['fiscal_position_id'],
-        env['product.pricelist'].search([]).write(dict(currency_id=main_company.currency_id.id))
+        all_pricelists = env['product.pricelist'].search([('id', '!=', excluded_pricelist.id)])
-                                                       'journal_user': True})]})
+                                                       'journal_user': True})],
-            model._pop_field(cr, uid, field.name, context=context)
+            if field.state == 'manual':
-            return http.send_file(data, filename=attachment['name'], as_attachment=True)
+            return http.send_file(data, filename=attachment['name'].encode('utf-8'), as_attachment=True)
-                message = (_('Unknown error during import:') + ' %s: %s' % (type(e), unicode(e)))
+                message = (_('Unknown error during import:') + ' %s: %s' % (type(e), unicode(e.message or e.name)))
-            jobs = (j for j in jobs if j.department_id and j.department_id.id == department.id)
+            jobs = [j for j in jobs if j.department_id and j.department_id.id == department.id]
-            jobs = (j for j in jobs if j.address_id and j.address_id.id == office_id)
+            jobs = [j for j in jobs if j.address_id and j.address_id.id == office_id]
-
+                vals = {}
-                                    picking.unlink()
+                                move.action_cancel()
-            "tzOffset": self._context.get('tz') and datetime.datetime.now(pytz.timezone(self._context['tz'])).utcoffset().total_seconds() / 60 or False,
+                show_reserved_quantity=self.state != 'done'
-            }
+            return self.action_generate_backorder_wizard()
-        wizard.process()
+        res_dict_for_back_order = wizard.process()
-        wizard.process()
+        res_dict_for_back_order = wizard.process()
-        wizard.process()
+        res_dict_for_back_order = wizard.process()
-        wizard.process()
+        res_dict_for_back_order = wizard.process()
-from odoo.exceptions import UserError
+from odoo.exceptions import UserError, ValidationError
-    product_id = fields.Many2one('product.product', 'Product', ondelete="cascade") #might be a related with the move also --> no, because you can put them next to each other
+        'stock.move', 'Stock Move',
-
+    @api.constrains('product_uom_qty')
-        self.assertEqual(move_line.product_qty, 5)  # don't change reservation
+        self.assertEqual(move_line.product_qty, 0)  # change reservation to 0 for done move
-        self.assertEqual(move_line.product_qty, 5)  # don't change reservation
+        self.assertEqual(move_line.product_qty, 0)  # change reservation to 0 for done move
-        self.assertEqual(tracked_move_line.product_qty, 2)  # don't change reservation
+        self.assertEqual(untracked_move_line.product_qty, 0)  # change reservation to 0 for done move
-        self.assertEqual(move1.reserved_availability, 1.0)
+        # reserved_availability should always been 0 for done move.
-        self.assertEqual(move1.move_line_ids.product_qty, 1.0)  # should keep the reservation
+        self.assertEqual(move1.reserved_availability, 0.0)
-        self.assertEqual(move1.move_line_ids.product_qty, 1.0)  # should keep the reservation
+        self.assertEqual(move1.reserved_availability, 0.0)
-        self.assertEqual(move1.move_line_ids.product_qty, 1.0)  # should keep the reservation
+        self.assertEqual(move1.reserved_availability, 0.0)
-            goals = Goals.search(domain, order="completeness desc, current desc")
+            if line.condition=='higher':
-            raise exceptions.UserError(_('You cannot cancel a stock move having already consumed material'))
+            raise exceptions.UserError(_('You cannot cancel a manufacturing order if you have already consumed material.\
-        repartition_domain = domain + [('timesheet_invoice_type', '!=', False)]  # force billable type
+        repartition_domain = domain + [('employee_id', '!=', False), ('timesheet_invoice_type', '!=', False)]  # force billable type
-            credit_aml.with_context(allow_amount_currency=True).write({
+            credit_aml.with_context(allow_amount_currency=True, check_move_validity=False).write({
-    content = fields.Html('Content', default=_default_content, translate=html_translate, sanitize_attributes=False)
+    content = fields.Html('Content', default=_default_content, translate=html_translate, sanitize=False)
-        reference = data['metadata']['reference']
+        reference = data.get('metadata', {}).get('reference')
-            _logger.error(error_msg, data['metadata'])
+            error_msg = _(
-        'Related Document Model Name', index=True, readonly=True, related='res_model_id.model', store=True)
+        'Related Document Model Name', index=True, readonly=True, related='res_model_id.model', compute_sudo=True, store=True)
-    'VND', 'XOF'
+    u'BIF', u'XAF', u'XPF', u'CLP', u'KMF', u'DJF', u'GNF', u'JPY', u'MGA', u'PYGÃ­', u'RWF', u'KRW',
-        
+
-    ], 'Payment', default=0, help="Require immediate payment by the customer when validating the order from the website quote")
+        (0, 'Online Signature'),
-            return 'form'
+        return 'form_save' if self.require_payment else 'form'
-    ], 'Payment', default=0, help="Require immediate payment by the customer when validating the order from the website quote")
+        (0, 'Online Signature'),
-        if not other_ids:
+        if not (other_ids and self.browse(other_ids).exists()):
-    parent = fields.Many2one('test_new_api.recursive')
+    parent = fields.Many2one('test_new_api.recursive', ondelete='cascade')
-                vals = rec._convert_to_write({n: rec[n] for n in ns})
+            for rec in recs:
-                    recs.browse(ids)._write(dict(vals))
+                    target = recs.browse(ids)
-            return cls._handle_exception(e, code=404)
+            return cls._handle_exception(e)
-    def _handle_exception(cls, exception, code=500):
+    def _handle_exception(cls, exception):
-from odoo.addons.portal.controllers.portal import get_records_pager, CustomerPortal
+from odoo.addons.portal.controllers.portal import get_records_pager, CustomerPortal, pager as portal_pager
-        pager = request.website.pager(
+        pager = portal_pager(
-        vals = {'project': project, }
+    @http.route(['/my/project/<int:project_id>'], type='http', auth="user", website=True)
-        pager = request.website.pager(
+        pager = portal_pager(
-        vals = {'task': task, 'user': request.env.user}
+    @http.route(['/my/task/<int:task_id>'], type='http', auth="user", website=True)
-    _inherit = ['mail.alias.mixin', 'mail.thread']
+    _inherit = ['mail.alias.mixin', 'mail.thread', 'portal.mixin']
-    _inherit = ['mail.thread', 'mail.activity.mixin']
+    _inherit = ['mail.thread', 'mail.activity.mixin', 'portal.mixin']
-    def _compute_website_url(self):
+    def _compute_portal_url(self):
-            task.website_url = '/my/task/%s' % task.id
+            task.portal_url = '/my/task/%s' % task.id
-        projects = request.env['project.project'].sudo().search([('rating_status', '!=', 'no'), ('website_published', '=', True)])
+        projects = request.env['project.project'].sudo().search([('rating_status', '!=', 'no'), ('portal_show_rating', '=', True)])
-        if not ((project.rating_status!='no') and project.website_published) and not user.sudo(user).has_group('project.group_project_manager'):
+        if not ((project.rating_status!='no') and project.portal_show_rating) and not user.sudo(user).has_group('project.group_project_manager'):
-from odoo import api, models
+from odoo import api, fields, models
-    _inherit = ['project.project', 'website.published.mixin']
+    _inherit = ['project.project']
-            project.website_url = "/project/rating/%s" % project.id
+        if self.portal_show_rating:
-from . import test_access_rights
+from . import controllers
-class WebsiteAccount(CustomerPortal):
+class CustomerPortal(CustomerPortal):
-        values = super(WebsiteAccount, self)._prepare_portal_layout_values()
+        values = super(CustomerPortal, self)._prepare_portal_layout_values()
-    def my_projects(self, page=1, date_begin=None, date_end=None, sortby=None, **kw):
+    def portal_my_projects(self, page=1, date_begin=None, date_end=None, sortby=None, **kw):
-        return request.render("website_project.my_projects", values)
+        return request.render("project.portal_my_projects", values)
-    def my_project(self, project=None, **kw):
+    def portal_my_project(self, project=None, **kw):
-        return request.render("website_project.my_project", vals)
+        return request.render("project.portal_my_project", vals)
-    def my_tasks(self, page=1, date_begin=None, date_end=None, sortby=None, filterby=None, search=None, search_in='content', **kw):
+    def portal_my_tasks(self, page=1, date_begin=None, date_end=None, sortby=None, filterby=None, search=None, search_in='content', **kw):
-        return request.render("website_project.my_tasks", values)
+        return request.render("project.portal_my_tasks", values)
-    def my_task(self, task=None, **kw):
+    def portal_my_task(self, task=None, **kw):
-        return request.render("website_project.my_task", vals)
+        return request.render("project.portal_my_task", vals)
-from odoo.exceptions import UserError, ValidationError
+from odoo.exceptions import UserError, AccessError
-    attachment_ids = fields.One2many('ir.attachment', 'res_id', domain=lambda self: [('res_model', '=', self._name)], auto_join=True, string='Attachments')
+    attachment_ids = fields.One2many('ir.attachment', compute='_compute_attachment_ids', string="Main Attachments",
-        return [new_group] + groups
+        groups = [new_group] + groups
-from . import test_project_base, test_project_flow, test_access_rights, test_project_ui
+from . import test_project_base, test_project_flow, test_access_rights, test_project_ui, test_portal
-        'rating_project'
+        'website',
-from . import portal_mixin
+from . import mail_thread
-    'description': """Glue module holding mail improvements for website.""",
+    'description': """
-from odoo import api, fields, models, SUPERUSER_ID, _
+from odoo import api, fields, models, _
-        return message_values
+    def _portal_message_format(self, fields_list):
-from odoo.addons.website_mail.controllers.main import _message_post_helper
+from odoo.addons.portal.controllers.mail import _message_post_helper
-from odoo.addons.website_mail.controllers.main import WebsiteMail
+from odoo.addons.portal.controllers.mail import PortalChatter
-class WebsiteRating(WebsiteMail):
+class WebsiteRating(PortalChatter):
-        result = super(WebsiteRating, self).website_chatter_init(res_model, res_id, domain=domain, limit=limit, **kwargs)
+    def portal_chatter_init(self, res_model, res_id, domain=False, limit=False, **kwargs):
-        # add 'rating_include' in context, to fetch them in website_message_format
+    def portal_message_fetch(self, res_model, res_id, domain=False, limit=False, offset=False, **kw):
-        return super(WebsiteRating, self).website_message_fetch(res_model, res_id, domain=domain, limit=limit, offset=offset, **kw)
+        return super(WebsiteRating, self).portal_message_fetch(res_model, res_id, domain=domain, limit=limit, offset=offset, **kw)
-        result = super(MailMessage, self).website_message_format()
+    def _portal_message_format(self, field_list):
-        return result
+            field_list += ['rating_value']
-                values[index][y_field] = int(data_item.get('y_value'))
+                values[index][y_field] = data_item.get('y_value')
-        # the record has an URL redirection: use it directly
+        # the record has a public URL redirection: use it directly
-            return werkzeug.utils.redirect(record_action['url'])
+            if record_target_type == 'public' and not uid:
-        self.phantom_js("/", "console.log('ok')", "'website.snippets.editor' in odoo.__DEBUG__.services", login='admin')
+        self.phantom_js("/", "console.log('ok')", "'website.content.snippets.animation' in odoo.__DEBUG__.services")
-    def test_03_admin_tour_banner(self):
+    def test_02_admin_tour_banner(self):
-    @http.route('/event/add_event', type='http', auth="user", methods=['POST'], website=True)
+    @http.route('/event/add_event', type='json', auth="user", methods=['POST'], website=True)
-        return request.redirect("/event/%s/register?enable_editor=1" % slug(event))
+        return "/event/%s/register?enable_editor=1" % slug(event)
-    @http.route('/event/get_country_event_list', type='http', auth='public', website=True)
+    @http.route('/event/get_country_event_list', type='json', auth='public', website=True)
-        return request.render("website_event.country_events_list", result)
+        return request.env['ir.ui.view'].render_template("website_event.country_events_list", result)
-    @http.route('/forum/new', type='http', auth="user", methods=['POST'], website=True)
+    @http.route('/forum/new', type='json', auth="user", methods=['POST'], website=True)
-        return request.redirect("/forum/%s" % slug(forum_id))
+        return "/forum/%s" % slug(forum_id)
-    @http.route(['/shop/add_product'], type='http', auth="user", methods=['POST'], website=True)
+    @http.route(['/shop/add_product'], type='json', auth="user", methods=['POST'], website=True)
-        return request.redirect("/shop/product/%s?enable_editor=1" % slug(product.product_tmpl_id))
+        return "/shop/product/%s?enable_editor=1" % slug(product.product_tmpl_id)
-                     'perc':0.00
+                     'perc':0.00,
-                line_ids = c_b_lines_obj.search(self.cr, self.uid, [('id', 'in', b_line_ids), ('crossovered_budget_id','=',budget_ids[i][0])])
+                domain_lines = [('id', 'in', b_line_ids),
-                line_ids = c_b_lines_obj.search(self.cr, self.uid, [('id', 'in', budget_ids), ('analytic_account_id','=',an_ids[i][0])])
+                domain_lines = [('id', 'in', budget_ids),
-    @api.depends('cash_control', 'cash_journal_id', 'config_id.cash_control')
+    @api.depends('cash_control', 'cash_journal_id', 'config_id', 'statement_ids')
-            return None
+            return self.env['sale.order']
-            res[m.id] = uom_obj._compute_qty_obj(cr, uid, m.product_uom, m.product_uom_qty, m.product_id.uom_id, context=context)
+            res[m.id] = uom_obj._compute_qty_obj(cr, uid, m.product_uom, m.product_uom_qty, m.product_id.uom_id, rounding_method=rounding_method, context=context)
-        new_move = self.copy(cr, uid, move.id, defaults, context=context)
+        ctx['rounding_method'] = 'HALF-UP'
-        import_result = self.env[self.res_model].with_context(import_file=True).load(import_fields, data)
+
-            existing_variants = [set(variant.attribute_value_ids.ids) for variant in tmpl_id.product_variant_ids]
+            existing_variants = [set(variant.attribute_value_ids.filtered(lambda r: r.attribute_id.create_variant).ids) for variant in tmpl_id.product_variant_ids]
-                if not product_id.active and product_id.attribute_value_ids in variant_matrix:
+                if not product_id.active and product_id.attribute_value_ids.filtered(lambda r: r.attribute_id.create_variant) in variant_matrix:
-                elif product_id.attribute_value_ids not in variant_matrix:
+                elif product_id.attribute_value_ids.filtered(lambda r: r.attribute_id.create_variant) not in variant_matrix:
-            values['price_unit'] = product.lst_price
+            values['price_unit'] = price_unit or product.lst_price
-                    values['price_unit'] = product.standard_price
+                    values['price_unit'] = price_unit or product.standard_price
-# drivers modules must add to drivers an object with a get_status() method 
+# drivers modules must add to drivers an object with a get_status() method
-        
+
-            'Cache-Control': 'no-cache', 
+            'Cache-Control': 'no-cache',
-        The PoS will activate the method payment 
+        The PoS will activate the method payment
-        return { 'status':'waiting' } 
+        return { 'status':'waiting' }
-        print 'is_scanner_connected?' 
+        print 'is_scanner_connected?'
-        print 'scanner' 
+        print 'scanner'
-        if question.type in ['free_text', 'textbox', 'datetime']:
+        # Calculate and return statistics for free_text, textbox, date
-            ('datetime', 'Date and Time'),
+            ('date', 'Date'),
-    validation_max_date = fields.Datetime('Maximum Date')
+    validation_min_date = fields.Date('Minimum Date')
-    def validate_datetime(self, post, answer_tag):
+    def validate_date(self, post, answer_tag):
-        # Checks if user input is a datetime
+        # Checks if user input is a date
-                dateanswer = fields.Datetime.from_string(answer)
+                dateanswer = fields.Date.from_string(answer)
-                errors.update({answer_tag: _('This is not a date/time')})
+                errors.update({answer_tag: _('This is not a date')})
-                max_date = datetime_from_string(self.validation_max_date)
+                date_from_string = fields.Date.from_string
-            except ValueError:  # check that it is a datetime has been done hereunder
+            except ValueError:  # check that it is a date has been done hereunder
-    value_date = fields.Datetime('Date answer')
+    value_date = fields.Date('Date answer')
-    def save_line_datetime(self, user_input_id, question, post, answer_tag):
+    def save_line_date(self, user_input_id, question, post, answer_tag):
-    def test_05_question_datetime(self):
+    def test_05_question_date(self):
-            'validation_min_date': '2015-03-20 00:00:00', 'validation_max_date': '2015-03-25 00:00:00', 'validation_error_msg': "Error"})
+            'page_id': self.page1.id, 'question': 'Q0', 'type': 'date', 'validation_required': True,
-        results = [('2015-55-10', _('This is not a date/time')), ('2015-03-19 00:00:00', 'Error'), ('2015-03-26 00:00:00', 'Error')]
+        results = [('2015-55-10', _('This is not a date')), ('2015-03-19', 'Error'), ('2015-03-26', 'Error')]
-                Validation function for type datetime is unable to notify if answer is violating the validation rules")
+                Validation function for type date is unable to notify if answer is violating the validation rules")
-        tx = self.env['payment.transaction'].create({
+        tx = self.env['payment.transaction'].sudo().create({
-        return {}
+    def get_linked_records(self):
-        return acquirer.s2s_process(kwargs)
+        return acquirer.s2s_process(kwargs).id
-        return PaymentMethod.id
+        return PaymentMethod
-        if self.state == 'done':
+        if self.state in ['done', 'refunded']:
-        if self.state == 'done':
+        if self.state in ['done', 'refunded']:
-                })
+                if self.type == 'validation' and self.state == 'refunding':
-                'state': 'pending',
+                'state': new_state,
-            self.payment_token_id.verified = True
+            if self.payment_token_id:
-            if self.type == 'verification':
+            if self.type == 'validation':
-            self.payment_token_id.verified = True
+            if self.payment_token_id:
-            new_state = 'refunding' if self.type == 'validation' else 'pending'
+            new_state = 'refunding' if self.state == 'refunding' else 'pending'
-        return acquirer.s2s_process(kwargs)
+        return acquirer.s2s_process(kwargs).id
-        return payment_token.id
+        return payment_token
-        if self.state not in ('draft', 'pending'):
+        if self.state not in ('draft', 'pending', 'refunding'):
-                'state': 'done',
+                'state': new_state,
-            acquirer.form = acquirer.sudo()._registration_render(request.env.user.partner_id.id, {'error': {}, 'error_message': [], 'return_url': return_url, 'json': False, 'bootstrap_formatting': True, 'verify_validity': True})
+            acquirer.form = acquirer.sudo()._registration_render(request.env.user.partner_id.id, {'error': {}, 'error_message': [], 'return_url': return_url, 'json': False, 'bootstrap_formatting': True})
-            (:class:`Field` instance).
+    def _in_cache_without(self, field, limit=PREFETCH_MAX):
-        return self.browse(ids)
+        recs = self.browse(ids)
-            IrValues.set_default(model, field, self[name])
+            if isinstance(self[name], models.BaseModel):
-        help="Intermediary account used when moving money from a liquidity account to another")
+    def _no_existing_validated_invoice(self):
-            domain += [('journal_id', '=', invoice.journal_id.id), ('state', 'not in', ['draft', 'cancel'])]
+                journal_sequence = invoice.journal_id.sequence_id
-            if (invoice.state == 'draft') and not self.search(domain, limit=1):
+            if (invoice.state == 'draft') and self._no_existing_validated_invoice():
-                invoice.sequence_number_next = 'no'
+                invoice.sequence_number_next = ''
-                sequence.number_next = int(result.group(2))
+        self.ensure_one()
-        res_users_account_user = self.env.ref('account.group_account_user')
+        res_users_account_user = self.env.ref('account.group_account_invoice')
-    'depends': ['account_accountant'],
+    'depends': ['account'],
-    'depends': ['account_accountant'],
+    'depends': ['account'],
-    'depends': ['hr_contract', 'account_accountant', 'web_tour'],
+    'depends': ['hr_contract', 'account', 'web_tour'],
-    accounting_date = fields.Date(string="Accounting Date")
+    accounting_date = fields.Date(string="Date")
-    'depends': ['report_intrastat', 'sale_stock', 'account_accountant', 'l10n_be'],
+    'depends': ['report_intrastat', 'sale_stock', 'account', 'l10n_be'],
-    'depends': ['account_accountant'],
+    'depends': ['account'],
-    'depends': ['l10n_fr', 'account_accountant'],
+    'depends': ['l10n_fr', 'account'],
-    'depends': ['web_tour', 'crm', 'sale_timesheet', 'purchase', 'mrp', 'account_accountant'],
+    'depends': ['web_tour', 'crm', 'sale_timesheet', 'purchase', 'mrp', 'account'],
-            for address_node in doc.xpath("//div[@class='o_address_format']"):
+            for address_node in doc.xpath("//div[hasclass('o_address_format')]"):
-    _description = "Public Category"
+    _description = "PoS Category"
-    pos_categ_id = fields.Many2one('pos.category', string='Public Category', readonly=True)
+    pos_categ_id = fields.Many2one('pos.category', string='PoS Category', readonly=True)
-            'date_planned': datetime.strptime(self.order_id.confirmation_date, DEFAULT_SERVER_DATETIME_FORMAT) + timedelta(days=self.customer_lead),
+            'date_planned': datetime.strptime(self.order_id.date_order, DEFAULT_SERVER_DATETIME_FORMAT) + timedelta(days=self.customer_lead),
-        date_planned = datetime.strptime(self.order_id.confirmation_date, DEFAULT_SERVER_DATETIME_FORMAT)\
+        date_planned = datetime.strptime(self.order_id.date_order, DEFAULT_SERVER_DATETIME_FORMAT)\
-        so_line = self.env['sale.order.line'].browse(so_line_id) if so_line_id else self.env['sale.order.line'].browse()
+        so_line = self.env['sale.order.line'].browse(so_line_id).sudo() if so_line_id else self.env['sale.order.line'].browse().sudo()
-        quants_groupby = self.env['stock.quant'].read_group(domain_quant, ['product_id', 'qty'], ['product_id'])
+        quants_groupby = self.env['stock.quant'].read_group(domain_quant, ['product_id', 'quantity'], ['product_id'])
-            if OPERATORS[operator](quant['qty'], value):
+            if OPERATORS[operator](quant['quantity'], value):
-            'date_planned': datetime.strptime(self.order_id.date_order, DEFAULT_SERVER_DATETIME_FORMAT) + timedelta(days=self.customer_lead),
+            'date_planned': datetime.strptime(self.order_id.confirmation_date, DEFAULT_SERVER_DATETIME_FORMAT) + timedelta(days=self.customer_lead),
-        date_planned = datetime.strptime(self.order_id.date_order, DEFAULT_SERVER_DATETIME_FORMAT)\
+        date_planned = datetime.strptime(self.order_id.confirmation_date, DEFAULT_SERVER_DATETIME_FORMAT)\
-            partner_id = Partner.sudo().create(checkout)
+            partner_id = Partner.sudo().create(checkout).id
-        request.env[res_model].browse(res_ids).check_access_rule("write")
+        request.env[res_model].browse(res_ids).check_access_rule("read")
-    ), override=True) # docutils.nodes.address exists and is a bibliographic element
+    ), **kw) # docutils.nodes.address exists and is a bibliographic element
-            record = record[name][:1]
+            record = record[name][:1].with_prefetch(record._prefetch)
-            (:class:`Field` instance).
+    def _in_cache_without(self, field, limit=PREFETCH_MAX):
-        return self.browse(ids)
+        recs = self.browse(ids)
-            return request.render("website_sale.cart_popover", values)
+            # force no-cache so IE11 doesn't cache this XHR
-            for account in [x.account_id for x in aml]:
+            #reconcile together the reconciliable (or the liquidity aml) and their newly created counterpart
-                to_rec.reconcile()
+                #reconciliation will be full, so speed up the computation by using skip_full_reconcile_check in the context
-            #we can only check the amount in company currency
+            #computing the `reconciled` field.
-    def compute_full_after_batch_reconcile(self):
+    def force_full_reconcile(self):
-            potentially an exchange rate entry that will balance the remaining amount_residual_currency (possibly several aml).
+            potentially exchange rate entries that will balance the remaining amount_residual_currency (possibly several aml in
-        aml_to_balance_currency = self.env['account.move.line']
+        aml_to_balance_currency = {}
-        partial_rec_id = False
+
-                total_amount_currency += aml.amount_currency
+            if aml.amount_residual_currency:
-            aml = aml_to_balance_currency[0]
+        #create an empty move that will hold all the exchange rate adjustments
-            total_amount_currency += aml_id.amount_currency
+            aml_recs, partial_recs = self.env['account.partial.reconcile'].create_exchange_rate_entry(aml_to_balance, 0.0, total_amount_currency, currency, exchange_move)
-                'exchange_partial_rec_id': partial_rec_id.id if partial_rec_id else False})
+        self.env['account.full.reconcile'].create({
-    @api.multi
+    @api.model
-    def create_exchange_rate_entry(self, aml_to_fix, amount_diff, diff_in_currency, currency, move_date):
+    @api.model
-        `currency_exchange_journal_id` and one of its journal items is
+        Automatically create a journal items to book the exchange rate
-        :param diff_in_currency: float
+
-        :return: account.move.line to reconcile and account.partial.reconcile
+        :param move: account.move
-                    rec._prepare_exchange_diff_partial_reconcile(
+        partial_rec = self.env['account.partial.reconcile']
-                        line_to_reconcile=line_to_reconcile,
+                        line_to_reconcile=line_to_rec,
-        return line_to_reconcile, partial_rec
+            )
-        aml_to_balance = None
+        aml_to_balance = self.env['account.move.line']
-                        aml_to_balance = aml
+                        aml_to_balance |= aml
-            exchange_partial_rec_id = False
+                exchange_move = self.env['account.move'].create(
-                exchange_partial_rec_id = rate_diff_partial_rec.id
+                rate_diff_amls, rate_diff_partial_rec = self.create_exchange_rate_entry(aml_to_balance, total_debit - total_credit, total_amount_currency, currency, exchange_move)
-                'reconciled_line_ids': [(4, a_id) for a_id in aml_ids],
+            self.env['account.full.reconcile'].create({
-    exchange_partial_rec_id = fields.Many2one('account.partial.reconcile')
+
-        self.invoice_ids.register_payment(counterpart_aml)
+        #validate the payment
-        move_lines_filtered.with_context(skip_full_reconcile_check='amount_currency_excluded', manual_full_reconcile_currency=currency).reconcile()
+        move_lines_filtered.with_context(skip_full_reconcile_check='amount_currency_excluded').reconcile()
-        move_lines.compute_full_after_batch_reconcile()
+        #then in second pass, consider the amounts in secondary currency (only if some lines are still not fully reconciled)
-            move_lines_filtered.with_context(skip_full_reconcile_check='amount_currency_only', manual_full_reconcile_currency=currency).reconcile()
+        #then in second pass, consider the amounts in secondary currency (only if some lines are still not fully reconciled)
-        move_lines.compute_full_after_batch_reconcile()
+        move_lines.force_full_reconcile()
-        if 'employee_id' in field_list and result.get('user_id') and result.get('project_id'):
+        if 'employee_id' in field_list and result.get('user_id'):
-        return self.env['ir.actions.report'].sudo().render_template('account.report_invoice', {'docs': self.env['account.invoice'].sudo().browse(ids_to_print)})
+        return {'docs': self.env['account.invoice'].sudo().browse(ids_to_print)}
-    _name = 'report.mrp_bom_cost'
+    _name = 'report.mrp.mrp_bom_cost_report'
-        return self.env['ir.actions.report'].render_template('mrp.mrp_bom_cost_report', {'lines': res})
+        return {'lines': res}
-    _name = 'report.mrp.report_mrpbomstructure'
+    _name = 'report.mrp.mrp_bom_structure_report'
-                total += inv.residual_company_signed
+                total += inv.residual_signed
-                amount_to_show = payment.company_id.currency_id.with_context(date=payment.date).compute(amount,
+                amount_to_show = payment.company_id.currency_id.with_context(date=self.date).compute(amount,
-            return request.redirect("/event/%s" % slug(event))
+            return False
-    @api.depends('name', 'location_id')
+    @api.depends('name', 'location_id.name')
-            if hasattr(field, 'pad_content_field') and vals.get(field.pad_content_field):
+            if hasattr(field, 'pad_content_field') and vals.get(field.pad_content_field) and self[k]:
-from odoo.addons.portal.controllers.portal import CustomerPortal
+from odoo.addons.portal.controllers.portal import CustomerPortal, pager as portal_pager
-        pager = request.pager(
+        pager = portal_pager(
-from odoo.addons.portal.controllers.portal import CustomerPortal, get_records_pager
+from odoo.addons.portal.controllers.portal import CustomerPortal, pager as portal_pager, get_records_pager
-        pager = request.pager(
+        pager = portal_pager(
-        pager = request.pager(
+        pager = portal_pager(
-    _inherit = ['mail.thread', 'mail.activity.mixin']
+    _inherit = ['mail.thread', 'mail.activity.mixin', 'portal.mixin']
-            so.website_url = '/my/orders/%s' % (so.id)
+    def _compute_portal_url(self):
-        return '/mail/view?' + url_encode(params)
+        return self.get_share_url()
-    if current.id in ids:
+    if current.id in ids and (hasattr(current, 'website_url') or hasattr(current, 'portal_url')):
-            'next_record': idx < len(ids) - 1 and current.browse(ids[idx + 1]).website_url
+            'prev_record': idx != 0 and getattr(current.browse(ids[idx - 1]), attr_name),
-           "  * Number of Depreciations: Fix the number of depreciation lines and the time between 2 depreciations.\n"
+    method_time = fields.Selection([('number', 'Number of Entries'), ('end', 'Ending Date')], string='Time Method', required=True, default='number',
-             "  * Number of Depreciations: Fix the number of depreciation lines and the time between 2 depreciations.\n"
+    method_time = fields.Selection([('number', 'Number of Entries'), ('end', 'Ending Date')], string='Time Method', required=True, readonly=True, default='number', states={'draft': [('readonly', False)]},
-        for move in self:
+        moves = self
-                        move.write({'move_line_ids': [(4, move_line_id.id, 0)]})
+                        self.env['stock.move.line'].create(move._prepare_move_line_vals(quantity=1))
-                move.write({'state': 'assigned'})
+                    self.env['stock.move.line'].create(move._prepare_move_line_vals(quantity=move.product_qty))
-                        move.state = 'assigned'
+                        assigned_moves |= move
-                        move.state = 'partially_available'
+                        partially_available_moves |= move
-                        .mapped('move_line_ids')
+                    # As we defer the write on the stock.move's state at the end of the loop, there
-                            move.state = 'assigned'
+                            assigned_moves |= move
-            self.mapped('picking_id')._check_entire_pack()
+                        partially_available_moves |= move
-        self._check_entire_pack()
+    provider = fields.Selection(string='Provider', related='acquirer_id.provider')
-        help="When this field is filled in, the vendor data will only apply to the variant.")
+        help="If not set, the vendor price will apply to all variants of this products.")
-        help="Cost of the product, in the default unit of measure of the product.")
+        help="The cost price is used to valuate your inventory.")
-            if hasattr(field, 'pad_content_field') and vals.get(field.pad_content_field):
+            if hasattr(field, 'pad_content_field') and vals.get(field.pad_content_field) and self[k]:
-
+    def _inverse_is_favorite(self):
-    is_favorite = fields.Boolean(compute='_compute_is_favorite', string='Show Project on dashboard',
+    is_favorite = fields.Boolean(compute='_compute_is_favorite', inverse='_inverse_is_favorite', string='Show Project on dashboard',
-        compute='_compute_is_favorite', inverse='_set_is_favorite',
+        compute='_compute_is_favorite', inverse='_inverse_is_favorite',
-            context['default_crm_lead_type'] = vals.get('type')
+        if vals.get('type') and not self._context.get('default_type'):
-        context.setdefault('default_crm_lead_type', self.type)
+        context.setdefault('default_type', self.type)
-            'context': {'default_crm_lead_type': 'opportunity'}
+            'context': {'default_type': 'opportunity'}
-            if default_team_id and (self.env.context.get('default_crm_lead_type') != 'lead' or default_team_id.use_leads):
+            if default_team_id and (self.env.context.get('default_type') != 'lead' or default_team_id.use_leads):
-            return
+            return self.tracer
-            return
+            return self.tracer
-            return
+            return self.tracer
-                    'lines': {},
+                    'calls': [],
-        lineProfile['infos'][codeProfile['nb']] = {
+        codeProfile['calls'].append({
-        self.lines.append(lineProfile)
+            'time': time.time(),
-                        'line': line,
+            v['report'] = {}
-                            line['line'].pop('delay')
+                v['report'][call['lineno']]['nb'] += 1
-                delay += line.get('delay', 0)
+            for call in v['report'].values():
-                    data = v['lines'][lineno + v['firstline']]
+                if (lineno + v['firstline']) in v['report']:
-            log.append("%-10s%-10d%-10s\n\n" % (
+            log.append("\nTotal:\n%-10s%-10d%-10s\n\n" % (
-            address_id = contact_name = False
+            contact_name = False
-                                               'work_phone': applicant.department_id and applicant.department_id.company_id and applicant.department_id.company_id.phone or False})
+                employee = self.env['hr.employee'].create({
-        return res
+        reverse_sort = True
-        return lines
+        return final_vals
-            if alias.alias_parent_model_id and alias.alias_parent_thread_id:
+            obj = None
-            else:
+            elif model:
-            config_id = self.env['pos.order'].browse(values['order_id']).session_id.config_id.id
+            config_id = self.order_id.browse(values['order_id']).session_id.config_id.id
-                show_lots_text=self.has_tracking != 'none' and self.picking_type_id.use_create_lots and not self.picking_type_id.use_existing_lots and self.state != 'done',
+                show_lots_m2o=self.has_tracking != 'none' and (self.picking_type_id.use_existing_lots or self.state == 'done' or self.origin_returned_move_id.id),  # able to create lots, whatever the value of ` use_create_lots`.
-        generated_tax_res = self.tax_template_ids._generate_tax(company)
+        generated_tax_res = self.with_context(active_test=False).tax_template_ids._generate_tax(company)
-
+        'views/crm_config_settings_views.xml',
-        'views/sale_config_settings_views.xml',
+        'data/web_planner_data.xml',
-from . import sale_config_settings
+from . import crm_config_settings
-    _inherit = 'sale.config.settings'
+class CrmConfigSettings(models.TransientModel):
-        res = super(SaleConfigSettings, self).get_values()
+        res = super(CrmConfigSettings, self).get_values()
-        super(SaleConfigSettings, self).set_values()
+        super(CrmConfigSettings, self).set_values()
-        'views/sale_config_settings_views.xml',
+        'views/crm_config_settings_views.xml',
-from . import sale_config_settings
+from . import crm_config_settings
-    _inherit = 'sale.config.settings'
+class CrmConfigSettings(models.TransientModel):
-    _inherit = 'sale.config.settings'
+    _name = 'sale.config.settings'
-            default_deposit_product_id=ICPSudo.get_param('sale.default_deposit_product_id'),
+            default_deposit_product_id=int(ICPSudo.get_param('sale.default_deposit_product_id')),
-    'depends': ['sale', 'crm'],
+    'depends': ['sale_management', 'crm'],
-            error = "Database creation error: %s" % str(e) or repr(e)
+            error = "Database creation error: %s" % (str(e) or repr(e))
-            error = "Database duplication error: %s" % str(e) or repr(e)
+            error = "Database duplication error: %s" % (str(e) or repr(e))
-            error = "Database deletion error: %s" % str(e) or repr(e)
+            error = "Database deletion error: %s" % (str(e) or repr(e))
-            error = "Database backup error: %s" % str(e) or repr(e)
+            error = "Database backup error: %s" % (str(e) or repr(e))
-            error = "Database restore error: %s" % str(e) or repr(e)
+            error = "Database restore error: %s" % (str(e) or repr(e))
-            error = "Master password update error: %s" % str(e) or repr(e)
+            error = "Master password update error: %s" % (str(e) or repr(e))
-            products = self.env['product.product'].with_context(uom=uom_id).browse(product_ids)
+            products = [item[0].with_context(uom=uom_id) for item in products_qty_partner]
-                pricelist = self.env['product.pricelist'].name_search(pricelist_id_or_name, operator='=', limit=1)
+                pricelist_data = self.env['product.pricelist'].name_search(pricelist_id_or_name, operator='=', limit=1)
-            else:
+                if self.registry:
-    def action_done(self, feedback=False):
+    def action_done(self):
-            elif alias.alias_parent_thread_id:
+            if alias.alias_parent_model_id and alias.alias_parent_thread_id:
-                obj = self.env[model]
+                obj = record_set[0] if thread_id else self.env[model]
-            'name': line['name'][:64],
+            'name': line['name'],
-        'views/payment_assets.xml',
+        'views/payment_portal_templates.xml',
-        return request.render("website_payment.pay_methods", values)
+        return request.render("payment.pay_methods", values)
-        partner_id = user.partner_id.id if user.partner_id.id != request.website.partner_id.id else False
+        partner_id = user.partner_id.id if not user._is_public() else False
-        return request.render('website_payment.pay', values)
+        return request.render('payment.pay', values)
-        partner_id = request.env.user.partner_id.id if request.env.user.partner_id != request.website.partner_id else False
+        partner_id = request.env.user.partner_id.id if not request.env.user._is_public() else False
-            return request.render('website_payment.confirm', {'tx': tx, 'status': status, 'message': message})
+            return request.render('payment.confirm', {'tx': tx, 'status': status, 'message': message})
-from . import main
+# -*- coding: utf-8 -*-
-    'depends': ['website', 'sale', 'sale_payment', 'payment', 'website_payment', 'website_account', 'website_mail', 'website_form', 'website_rating'],
+    'depends': ['website', 'sale', 'sale_payment', 'payment', 'website_payment', 'website_mail', 'website_form', 'website_rating'],
-    'depends' : ['base_setup', 'product', 'analytic', 'web_planner'],
+    'depends' : ['base_setup', 'product', 'analytic', 'web_planner', 'portal'],
-from . import portal_account
+from . import portal
-from odoo.addons.website_portal.controllers.main import website_account
+from odoo.addons.portal.controllers.portal import CustomerPortal
-class PortalAccount(website_account):
+class PortalAccount(CustomerPortal):
-        pager = request.website.pager(
+        pager = request.pager(
-        return request.render("website_account.portal_my_invoices", values)
+        return request.render("account.portal_my_invoices", values)
-            return request.render("website.403")
+            return request.redirect('/my')
-from odoo import api, fields, models, _
+from odoo import api, exceptions, fields, models, _
-from odoo.exceptions import UserError, RedirectWarning, ValidationError, Warning
+from odoo.exceptions import AccessError, UserError, RedirectWarning, ValidationError, Warning
-    'depends': ['website', 'sale_management', 'mail', 'payment', 'website_portal_sale', 'website_mail'],
+    'depends': ['website', 'sale_management', 'mail', 'payment', 'website_mail'],
-    'depends': ['website', 'sale', 'sale_payment', 'payment', 'website_payment', 'website_portal_sale', 'website_account', 'website_mail', 'website_form', 'website_rating'],
+    'depends': ['website', 'sale', 'sale_payment', 'payment', 'website_payment', 'website_account', 'website_mail', 'website_form', 'website_rating'],
-        'website_portal_sale',
+        'website_sale',
-    'depends': ['sales_team', 'account', 'procurement'],
+    'depends': ['sales_team', 'account', 'procurement', 'portal'],
-from . import main
+from . import portal
-from odoo.addons.website_portal.controllers.main import website_account
+from odoo.addons.portal.controllers.portal import CustomerPortal, get_records_pager
-class website_account(website_account):
+class CustomerPortal(CustomerPortal):
-        values = super(website_account, self)._prepare_portal_layout_values()
+        values = super(CustomerPortal, self)._prepare_portal_layout_values()
-        pager = request.website.pager(
+        pager = request.pager(
-        return request.render("website_portal_sale.portal_my_quotations", values)
+        return request.render("sale.portal_my_quotations", values)
-        pager = request.website.pager(
+        pager = request.pager(
-        return request.render("website_portal_sale.portal_my_orders", values)
+        return request.render("sale.portal_my_orders", values)
-                return request.render("website.403")
+                return request.redirect('/my')
-
+        return request.render("sale.orders_followup", values)
-from odoo.exceptions import UserError
+from odoo.exceptions import UserError, AccessError
-from odoo.addons.website_portal_sale.controllers.main import website_account
+from odoo.addons.sale.controllers.portal import CustomerPortal
-class WebsiteSaleDigital(website_account):
+class WebsiteSaleDigital(CustomerPortal):
-    'depends': ['website', 'sale', 'payment', 'website_payment', 'website_portal_sale', 'website_account', 'website_mail', 'website_form', 'website_rating'],
+    'depends': ['website', 'sale', 'sale_payment', 'payment', 'website_payment', 'website_portal_sale', 'website_account', 'website_mail', 'website_form', 'website_rating'],
-}
+from . import test_portal
-from . import test_portal
+from . import wizard
-
+def get_records_pager(ids, current):
-        return request.render("portal.portal_layout", values)
+        return request.render("portal.portal_my_home", values)
-        template = self.env.ref('website_portal.mail_template_data_portal_welcome')
+        template = self.env.ref('portal.mail_template_data_portal_welcome')
-                return http.redirect_with_hash(redirect)
+                return http.redirect_with_hash(self._login_redirect(uid, redirect=redirect))
-                'website_partner', 'website_google_map', 'website_portal'],
+                'website_partner', 'website_google_map', 'portal'],
-class WebsiteAccount(website_account):
+class WebsiteAccount(CustomerPortal):
-        'website_portal',
+        'portal',
-        'website_portal',
+        'website',
-class WebsitePortal(website_account):
+class WebsitePortal(CustomerPortal):
-from odoo.addons.website_portal.controllers.main import website_account, get_records_pager
+from odoo.addons.portal.controllers.portal import get_records_pager
-    'depends': ['project', 'website_portal'],
+    'depends': ['project', 'website', 'portal'],
-from odoo.addons.website_portal.controllers.main import website_account, get_records_pager
+from odoo.addons.portal.controllers.portal import get_records_pager, CustomerPortal
-class WebsiteAccount(website_account):
+class WebsiteAccount(CustomerPortal):
-from odoo.addons.website_portal.controllers.main import get_records_pager
+from . import ir_http
-    @classmethod
+from odoo.addons.portal.controllers.portal import pager
-import math
+from odoo.addons.portal.controllers.portal import pager
-        }
+        return pager(url, total, page=page, step=step, scope=scope, url_args=url_args)
-from odoo.tools import ustr
+from odoo.tools import config, ustr
-        return request.env['res.lang'].search([], limit=1)
+        return request.env['res.lang'].search([], limit=1)
-        redirect.set_cookie('website_lang', lang)
+        redirect.set_cookie('frontend_lang', lang)
-            return any(bot in user_agent.encode('ascii', 'ignore') for bot in cls.bots)
+    def get_page_key(cls):
-        return short_match
+    def _add_dispatch_parameters(cls, func):
-            odoo._geoip_resolver = False
+            request.website = request.env['website'].get_current_website()  # can use `request.env` since auth methods are called
-            request.session['geoip'] = record
+        super(Http, cls)._add_dispatch_parameters(func)
-        return (cls._name, "cache", request.uid, request.lang, request.httprequest.full_path)
+        if request.is_frontend and request.routing_iteration == 1:
-        if request.website:
+        if getattr(request, 'website', False):
-        if request.website:
+        if getattr(request, 'website', False):
-        is_website_request = bool(getattr(request, 'website_enabled', False) and request.website)
+        is_website_request = bool(getattr(request, 'is_frontend', False) and getattr(request, 'website', False))
-from odoo.addons.website.models import website
+from odoo.addons.http_routing.models.ir_http import url_for
-        if request and getattr(request, 'website_enabled', False):
+        if request and getattr(request, 'is_frontend', False):
-        if request and getattr(request, 'website_enabled', False):
+        if request and getattr(request, 'is_frontend', False):
-                url_for=website.url_for,
+                url_for=url_for,
-    _order = "name"
+    _order = "sequence, id"
-        for code, dummy in request.website.get_languages():
+        for code, dummy in cls._get_language_codes():
-            langs = [lg[0] for lg in request.website.get_languages()]
+            langs = [lg[0] for lg in cls._get_language_codes()]
-                                  or request.website.default_lang_code)
+                                  or cls._get_default_lang().code)
-                        or (not url_lang and request.website_multilang and request.lang != request.website.default_lang_code)
+                if ((url_lang and (url_lang != request.lang or url_lang == cls._get_default_lang().code))
-                        and (not is_a_bot or (url_lang and url_lang == request.website.default_lang_code)):
+                        and (not is_a_bot or (url_lang and url_lang == cls._get_default_lang().code)):
-                    if request.lang != request.website.default_lang_code:
+                    if request.lang != cls._get_default_lang().code:
-            if request.lang == request.website.default_lang_code:
+            if request.lang == cls._get_default_lang().code:
-                if request.lang != request.website.default_lang_code:
+                if request.lang != cls._get_default_lang().code:
-            translatable = editable and self._context.get('lang') != request.website.default_lang_code
+            translatable = editable and self._context.get('lang') != request.env['ir.http']._get_default_lang().code
-                languages=request.website.get_languages(),
+                default_lang_code=request.env['ir.http']._get_default_lang().code,
-        langs = [lg[0] for lg in request.website.get_languages()]
+        langs = [lg[0] for lg in request.env['ir.http']._get_language_codes()]
-                elif ps[1] == request.website.default_lang_code:
+                elif ps[1] == request.env['ir.http']._get_default_lang().code:
-            elif lang != request.website.default_lang_code or force_lang:
+            elif lang != request.env['ir.http']._get_default_lang().code or force_lang:
-        langs = [lg[0] for lg in request.website.get_languages()]
+        langs = [lg[0] for lg in request.env['ir.http']._get_language_codes()]
-                context = dict(context, translatable=context.get('lang') != request.website.default_lang_code)
+                context = dict(context, translatable=context.get('lang') != request.env['ir.http']._get_default_lang().code)
-            from odoo.addons.website.models.website import slug
+            from odoo.addons.http_routing.models.ir_http import slug
-
+from odoo.addons.http_routing.models.ir_http import slug
-from odoo.addons.website.models.website import slug
+from odoo.addons.http_routing.models.ir_http import slug
-from odoo.tools import config, pycompat
+from odoo.tools import config
-from odoo.addons.website.models.website import slug, url_for, _UNSLUG_RE
+from odoo.addons.http_routing.models.ir_http import ModelConverter
-        return env[self.model].browse(record_id)
+class ModelConverter(ModelConverter):
-import re
+import re
-from odoo.tools import ustr, pycompat
+from odoo import api, fields, models, tools
-from odoo.addons.website.models.website import slugify, unslug
+from odoo.addons.http_routing.models.ir_http import slugify, unslug
-from odoo.addons.website.models.website import slug
+from odoo.addons.http_routing.models.ir_http import slug
-from odoo.addons.website.models.website import slug, unslug
+from odoo.addons.http_routing.models.ir_http import slug, unslug
-from odoo.addons.website.models.website import slug
+from odoo.addons.http_routing.models.ir_http import slug
-from odoo.addons.website.models.website import unslug
+from odoo.addons.http_routing.models.ir_http import unslug
-from odoo.addons.website.models.website import slug
+from odoo.addons.http_routing.models.ir_http import slug
-from odoo.addons.website.models.website import slug
+from odoo.addons.http_routing.models.ir_http import slug
-from odoo.addons.website.models.website import slug
+from odoo.addons.http_routing.models.ir_http import slug
-from odoo.addons.website.models.website import slug
+from odoo.addons.http_routing.models.ir_http import slug
-from odoo.addons.website.models.website import slug
+from odoo.addons.http_routing.models.ir_http import slug
-from odoo.addons.website.models.website import slug
+from odoo.addons.http_routing.models.ir_http import slug
-from odoo.addons.website.models.website import slug
+from odoo.addons.http_routing.models.ir_http import slug
-from odoo.addons.website.models.website import slug
+from odoo.addons.http_routing.models.ir_http import slug
-from odoo.addons.website.models.website import slug
+from odoo.addons.http_routing.models.ir_http import slug
-from odoo.addons.website.models.website import unslug
+from odoo.addons.http_routing.models.ir_http import unslug
-from odoo.addons.website.models.website import slug
+from odoo.addons.http_routing.models.ir_http import slug
-from odoo.addons.website.models.website import slug
+from odoo.addons.http_routing.models.ir_http import slug
-from odoo.addons.website.models.website import slug
+import unicodedata
-UID_PLACEHOLDER = object()
+
-        env = api.Environment(request.cr, UID_PLACEHOLDER, request.context)
+        _uid = RequestUID(value=value, converter=self)
-        env = api.Environment(request.cr, UID_PLACEHOLDER, request.context)
+        _uid = RequestUID(value=value, converter=self)
-                if not arg.exists():
+        for key, val in list(pycompat.items(arguments)):
-    'depends': ['web', 'web_editor', 'web_planner'],
+    'depends': ['web', 'web_editor', 'web_planner', 'http_routing', 'portal'],
-from . import website
+    def _is_public(self):
-        string='VIES VAT Check')
+        string='Verify VAT Numbers')
-    vat_check_vies = fields.Boolean(string='VIES VAT Check')
+    vat_check_vies = fields.Boolean(string='Verify VAT Numbers')
-        sale_pricelist_setting = self.env['ir.config_parameter'].sudo().get_param('sale.sale_pricelist_setting')
+        ICPSudo = self.env['ir.config_parameter'].sudo()
-            sale_show_tax=self.env['ir.config_parameter'].sudo().get_param('sale.sale_show_tax', default='subtotal'),
+            use_sale_note=ICPSudo.get_param('sale.use_sale_note', default=False),
-        self.env['ir.config_parameter'].sudo().set_param('sale.sale_show_tax', self.sale_show_tax)
+        ICPSudo = self.env['ir.config_parameter'].sudo()
-            if 'vat' in partner and (data['vat'] or False) != (partner.vat or False):
+            if 'vat' in data and (data['vat'] or False) != (partner.vat or False):
-    'summary': 'Holidays, Allocation and Leave Requests',
+    'summary': 'Leave allocations and leave requests',
-    * Integrated with Holiday Management
+    * Integrated with Leaves Management
-    double_holidays = fields.Monetary(compute='_compute_holidays_advantages', string='Double holidays',
+    double_holidays = fields.Monetary(compute='_compute_holidays_advantages', string='Double Holidays',
-    holidays = fields.Float(string="Holidays",
+    holidays = fields.Float(string='Legal Leaves',
-    holidays_editable = fields.Boolean(string="Editable Holidays", default=True)
+    holidays_editable = fields.Boolean(string="Editable Leaves", default=True)
-    * Integrated with Holiday Management
+    * Integrated with Leaves Management
-Bridge module to integrate holidays in timesheet
+Bridge module to integrate leaves in timesheet
-            session = pos_config.session_ids.filtered(lambda s: s.state == 'opened' and not s.rescue)
+            session = pos_config.session_ids.filtered(lambda s: s.state in ['opening_control', 'opened', 'closing_control'] and not s.rescue)
-                    'tax_ids': [(6, 0, done_taxes)] if tax_line.tax_id.include_base_amount else []
+                    'tax_ids': [(6, 0, list(done_taxes))] if tax_line.tax_id.include_base_amount else []
-        return vals
+
-                'product_qty': consume_move.product_uom_qty, 
+                'product_id': consume_move.product_id.id,
-                'location_dest_id': consume_move.location_dest_id.id,})
+                'location_dest_id': consume_move.location_dest_id.id,
-        #TODO: needs to be replaced by checking the different stock.move.lots
+        # TODO: Will fail if user do more than one unbuild with lot on the same MO. Need to check what other unbuild has aready took
-                })
+                original_move = self.mo_id.move_raw_ids.filtered(lambda move: move.product_id == produce_move.product_id)
-        consume_move.quant_ids.sudo().write({'produced_quant_ids': [(6, 0, produced_quant_ids.ids)]})
+        produced_move_line_ids = produce_moves.mapped('move_line_ids').filtered(lambda ml: ml.qty_done > 0)
-from . import test_procurement
+from . import test_procurement
-                            'product_qty': 0.0,
+                            'product_uom_qty': 0.0,
-        for move in moves.filtered(lambda x: x.product_id.tracking == 'none' and x.state not in ('done', 'cancel')):
+        for move in moves.filtered(lambda x: x.product_id.tracking == 'none' and x.quantity_done == 0 and x.state not in ('done', 'cancel')):
-            except Exception, e:
+            except Exception:
-                self.fail("\n" + out + "\n" + err)
+                self.fail("pylint test failed:\n" + (out + "\n" + err).strip())
-from os import devnull
+import os
-            '--load-plugins=pylint.extensions.bad_builtin',
+            '--load-plugins=pylint.extensions.bad_builtin,_odoo_checkers',
-            process = subprocess.Popen(['pylint'] + options + paths, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
+            pylint_bin = tools.which('pylint')
-
+        # pylint: disable=next-method-called
-    siret = fields.Char(string='SIRET', size=14)
+    siret = fields.Char(related='partner_id.siret', string='SIRET', size=14)
-                        ('date', '<', move_line.date),
+                        ('date', '>', move_line.date),
-        final_vals = sorted(final_vals, key=lambda v: v['date'], reverse=True)
+        reverse_sort = True
-    date = fields.Datetime('Date', default=fields.Datetime.now(), required=True)
+    date = fields.Datetime('Date', default=fields.Datetime.now, required=True)
-from odoo.exceptions import UserError
+from odoo.exceptions import ValidationError
-    
+
-    name = fields.Char(string='Point of Sale Name', index=True, required=True, help="An internal identification of the point of sale")
+    name = fields.Char(string='Point of Sale Name', index=True, required=True, help="An internal identification of the point of sale.")
-    iface_big_scrollbars = fields.Boolean('Large Scrollbars', help='For imprecise industrial touchscreens')
+    iface_cashdrawer = fields.Boolean(string='Cashdrawer', help="Automatically open the cashdrawer.")
-    iface_print_skip_screen = fields.Boolean(string='Skip Receipt Screen', default=True,
+        help='The receipt will automatically be printed at the end of each order.')
-        help='The point of sale will display this product category by default. If no category is specified, all available products will be shown')
+        help='The payment input will behave similarily to bank payment input, and will be prefilled with the exact due amount.')
-        help="Check to box to restrict the price control to managers only on point of sale orders.")
+        help="Only users with Manager access rights for PoS app can modify the product prices on orders.")
-    receipt_footer = fields.Text(string='Receipt Footer', help="A short text that will be inserted as a footer in the printed receipt")
+    receipt_header = fields.Text(string='Receipt Header', help="A short text that will be inserted as a header in the printed receipt.")
-        help='The hostname or ip address of the hardware proxy, Will be autodetected if left empty')
+        help='The hostname or ip address of the hardware proxy, Will be autodetected if left empty.')
-        help='A globally unique identifier for this pos configuration, used to prevent conflicts in client-generated data')
+        help='A globally unique identifier for this pos configuration, used to prevent conflicts in client-generated data.')
-        help="Check this if you want to group the Journal Items by Product while closing a Session")
+        help="Check this if you want to group the Journal Items by Product while closing a Session.")
-        help='Defines what kind of barcodes are available and how they are assigned to products, customers and cashiers')
+    barcode_nomenclature_id = fields.Many2one('barcode.nomenclature', string='Barcode Nomenclature',
-        help='This field is there to pass the id of the pos manager group to the point of sale client')
+        help='This field is there to pass the id of the pos manager group to the point of sale client.')
-        help='This field is there to pass the id of the pos user group to the point of sale client')
+        help='This field is there to pass the id of the pos user group to the point of sale client.')
-    fiscal_position_ids = fields.Many2many('account.fiscal.position', string='Fiscal Positions')
+        help="This product is used as reference on customer receipts.")
-            raise UserError(_("The company of the stock location is different than the one of point of sale"))
+            raise ValidationError(_("The company of the stock location is different than the one of point of sale"))
-            raise UserError(_("The company of the sales journal is different than the one of point of sale"))
+            raise ValidationError(_("The company of the sales journal is different than the one of point of sale"))
-    def _check_company_journal(self):
+    def _check_company_invoice_journal(self):
-            raise UserError(_("The invoice journal and the point of sale must belong to the same company"))
+            raise ValidationError(_("The invoice journal and the point of sale must belong to the same company"))
-            raise UserError(_("The default fiscal position must be included in the available fiscal positions of the point of sale"))
+            raise ValidationError(_("The company of a payment method is different than the one of point of sale"))
-        return super(PosConfig, self).create(values)
+        pos_config = super(PosConfig, self).create(values)
-from odoo import fields, models
+from odoo import api, fields, models
-    discount_product_id = fields.Many2one('product.product', string='Discount Product', domain="[('available_in_pos', '=', True)]", help='The product used to model the discount')
+    discount_product_id = fields.Many2one('product.product', string='Discount Product', domain="[('available_in_pos', '=', True)]", help='The product used to model the discount.', default=_get_default_discount_product)
-        'views/pos_config_views.xml',
+        'views/pos_config_views.xml'
-        'views/pos_config_views.xml',
+        'views/pos_config_views.xml',
-from odoo import fields, models
+from odoo import api, fields, models
-    floor_ids = fields.One2many('restaurant.floor', 'pos_config_id', string='Restaurant Floors', help='The restaurant floors served by this point of sale')
+    iface_splitbill = fields.Boolean(string='Bill Splitting', help='Enables Bill Splitting in the Point of Sale.')
-    active = fields.Boolean(default=True)
+    active = fields.Boolean('Active', default=True, track_visibility="onchange")
-    state_id = fields.Many2one('fleet.vehicle.state', 'State', default=_get_default_state, help='Current state of the vehicle', ondelete="set null")
+    state_id = fields.Many2one('fleet.vehicle.state', 'State', default=_get_default_state, 
-            record.contract_count = LogContract.search_count([('vehicle_id', '=', record.id), ('state', '=', 'open')])
+            record.contract_count = LogContract.search_count([('vehicle_id', '=', record.id),('state','!=','closed')])
-                if element.state in ('open', 'toclose') and element.expiration_date:
+                if element.state in ('open', 'expired') and element.expiration_date:
-                            ('state', 'in', ('open', 'toclose'))
+                            ('state', 'in', ('open', 'expired'))
-                          AND contract.state IN ('open', 'toclose')
+                          AND contract.state IN ('open', 'expired')
-                          AND contract.state IN ('open', 'toclose')
+                          AND contract.state IN ('open', 'expired')
-        ('both', 'Both')
+        ('service', 'Service')
-            # if received value for odometer is 0, then remove it from the data as it would result to the creation of a
+            # if received value for odometer is 0, then remove it from the
-            del(data['odometer'])
+            del data['odometer']
-
+    _inherit = ['mail.thread']
-    expiration_date = fields.Date('Contract Expiration Date', default=lambda self: self.compute_next_year_date(fields.Date.context_today(self)),
+    start_date = fields.Date('Contract Start Date', default=fields.Date.context_today, 
-                              copy=False)
+        ('expired', 'Expired'),
-    cost_generated = fields.Float('Recurring Cost Amount',
+    cost_generated = fields.Float('Recurring Cost Amount', 
-             "If the cost frequency is set to unique, the cost will be logged at the start date")
+        "If the cost frequency is set to unique, the cost will be logged at the start date")
-    odometer = fields.Float(string='Odometer at creation', help='Odometer measure of the vehicle at the moment of the contract creation')
+    odometer = fields.Float(string='Odometer at creation', 
-            if (record.expiration_date and (record.state == 'open' or record.state == 'toclose')):
+            if (record.expiration_date and (record.state == 'open' or record.state == 'expired')):
-        contracts = self.search([('state', '=', 'open'), ('expiration_date', '<', limit_date)])
+        date_today = fields.Date.from_string(fields.Date.today())
-        for contract in contracts:
+        for contract in nearly_expired_contracts:
-        return contracts.write({'state': 'toclose'})
+            Vehicle.browse(vehicle).message_post(body=_('%s contract(s) will expire soon and should be renewed and/or closed!') % value)
-                            'name': _('Standard Price changed'),
+                            'name': _('Standard Price changed  - %s') % (product.display_name),
-                            'name': _('Standard Price changed'),
+                            'name': _('Standard Price changed  - %s') % (product.display_name),
-    query = 'SELECT * FROM information_schema.columns WHERE table_name=%s'
+    # Do not select the field `character_octet_length` from `information_schema.columns`
-        'views/project_task.xml'
+        'views/project_views.xml'
-from . import project_task
+from . import project
-    working_days_close = fields.Float(compute='_compute_elapsed', string='Working days to close the task', store=True, group_operator="avg")
+    working_hours_open = fields.Float(compute='_compute_elapsed', string='Working hours to assign', store=True, group_operator="avg")
-    """ Tags of project's tasks (or issues) """
+    """ Tags of project's tasks """
-    _description = "Tags of project's tasks, issues..."
+    _description = "Tags of project's tasks"
-    closing_days = fields.Float(string='# Days to Close',
+    working_days_close = fields.Float(string='# Working Days to Close',
-    opening_days = fields.Float(string='# Days to Assign',
+        help="Number of Working Days to close the task")
-        help="Number of Days to Open the task")
+        help="Number of Working Days to Open the task")
-                    (extract('epoch' from (t.date_start-t.create_date)))/(3600*24)  as opening_days,
+                    t.working_days_close as working_days_close,
-                    will transfer the context of the thread of my_lead to my_project_issue
+        Example :   my_lead.message_change_thread(my_project_task)
-            'task_data': self._calculate_rating(project.id, "project.task"),
+            'task_data': self._calculate_rating(project.id),
-    def _calculate_rating(self, project_id, model_name):
+    def _calculate_rating(self, project_id):
-        domain = [('res_model', '=', model_name), ('res_id', 'in', records.ids), ('consumed', '=', True)]
+        records = request.env["project.task"].sudo().search([('project_id', '=', project_id)])
-        projects._send_rating_mail()
+        projects.mapped('task_ids')._send_task_rating_mail()
-        domain=lambda self: self._get_mail_template_id_domain(),
+        domain=[('model', '=', 'project.task')],
-        domain=lambda self: self._default_domain_rating_template_id(),
+        domain=[('model', '=', 'project.task')],
-        """ Override to updates the document according to the email. """
+        """ Overrides mail_thread message_new that is called by the mailgateway
-        task = super(Task, self).message_new(msg, custom_values=defaults)
+        task = super(Task, self.with_context(create_context)).message_new(msg, custom_values=defaults)
-            'name': msg.get('subject'),
+            'name': msg.get('subject') or _("No Subject"),
-    def should_impact_quants(self):
+    def should_bypass_reservation(self):
-        return False if self.usage in ('supplier', 'inventory', 'production', 'customer') else True
+        return self.usage in ('supplier', 'customer', 'inventory', 'production') or self.scrap_location
-            if ml.location_id.should_impact_quants() and ml.product_id.type == 'product':
+            if ml.product_id.type == 'product':
-            if ml.location_dest_id.should_impact_quants() and ml.product_id.type == 'product':
+        precision = self.env['decimal.precision'].precision_get('Product Unit of Measure')
-                if ml.location_id.should_impact_quants() and ml.product_id.type == 'product':
+            for ml in self.filtered(lambda m: m.state in ('partially_available', 'assigned') and m.product_id.type == 'product'):
-                if ml.location_id.should_impact_quants() and ml.product_id.type == 'product':
+            for ml in self.filtered(lambda ml: ml.state in ['partially_available', 'assigned'] and ml.product_id.type == 'product'):
-                if updates.get('location_id', ml.location_id).should_impact_quants() and ml.product_id.type == 'product':
+                if not updates.get('location_id', ml.location_id).should_bypass_reservation():
-            for ml in self.filtered(lambda ml: ml.move_id.state == 'done'):
+            for ml in self.filtered(lambda ml: ml.move_id.state == 'done' and ml.product_id.type == 'product'):
-                    in_date = Quant._update_available_quantity(ml.product_id, ml.location_dest_id, -ml.qty_done, lot_id=ml.lot_id,
+                in_date = Quant._update_available_quantity(ml.product_id, ml.location_dest_id, -ml.qty_done, lot_id=ml.lot_id,
-                    Quant._update_available_quantity(ml.product_id, ml.location_id, ml.qty_done, lot_id=ml.lot_id,
+                Quant._update_available_quantity(ml.product_id, ml.location_id, ml.qty_done, lot_id=ml.lot_id,
-                if location_id.should_impact_quants() and ml.product_id.type == 'product':
+                if not location_id.should_bypass_reservation():
-                if location_dest_id.should_impact_quants() and ml.product_id.type == 'product' and qty_done:
+                            if not location_id.should_bypass_reservation():
-            if ml.location_id.should_impact_quants() and ml.product_id.type == 'product' and not float_is_zero(ml.product_qty, precision_digits=precision):
+            # Unlinking a move line should unreserve.
-            if ml.product_id.type != 'consu':
+            if ml.product_id.type == 'product':
-                if ml.location_id.should_impact_quants() and float_compare(ml.qty_done, ml.product_qty, precision_rounding=rounding) > 0:
+                if not ml.location_id.should_bypass_reservation() and float_compare(ml.qty_done, ml.product_qty, precision_rounding=rounding) > 0:
-                if ml.location_id.should_impact_quants() and ml.product_id.type == 'product' and ml.product_qty:
+                if not ml.location_id.should_bypass_reservation() and ml.product_id.type == 'product' and ml.product_qty:
-                    Quant._update_available_quantity(ml.product_id, ml.location_dest_id, quantity, lot_id=ml.lot_id, package_id=ml.result_package_id, owner_id=ml.owner_id, in_date=in_date)
+                available_qty, in_date = Quant._update_available_quantity(ml.product_id, ml.location_id, -quantity, lot_id=ml.lot_id, package_id=ml.package_id, owner_id=ml.owner_id)
-        self.product_qty = sum(self.quant_ids.mapped('quantity'))
+        # We only care for the quants in internal or transit locations.
-        self.assertEqual(self.env['stock.quant']._get_available_quantity(self.product1, self.supplier_location), 0.0)
+        self.assertEqual(self.env['stock.quant']._get_available_quantity(self.product1, self.supplier_location), -100.0)
-        self.assertEqual(len(self.env['stock.quant']._gather(self.product1, self.supplier_location)), 0.0)
+        self.assertEqual(len(self.env['stock.quant']._gather(self.product1, self.supplier_location)), 1.0)
-        self.assertEqual(self.env['stock.quant']._get_available_quantity(self.product3, self.supplier_location), 0.0)
+        self.assertEqual(self.env['stock.quant']._get_available_quantity(self.product3, self.supplier_location), -5.0)
-        self.assertEqual(len(self.env['stock.quant']._gather(self.product3, self.supplier_location)), 0.0)
+        self.assertEqual(len(self.env['stock.quant']._gather(self.product3, self.supplier_location)), 1.0)
-        self.assertEqual(self.env['stock.quant']._get_available_quantity(self.product2, self.supplier_location), 0.0)
+        # Quant balance should result with 5 quant in supplier and stock
-        self.assertEqual(len(self.env['stock.quant']._gather(self.product2, self.supplier_location)), 0.0)
+        self.assertEqual(len(self.env['stock.quant']._gather(self.product2, self.supplier_location)), 5.0)
-        self.assertEqual(len(self.env['stock.quant']._gather(self.product1, self.customer_location)), 0.0)
+        # Check there is one quant in customer location
-        # # no quants are created in the customer location
+        # no quants are created in the customer location since it's a consumable
-        self.assertEqual(len(quant), 0, 'There should be no package for customer location')
+        # Check that we have one quant in customer location.
-        # Check there are no negative quants
+        # Should be only 1 negative quant in supplier location
-        self.assertEqual(len(neg_quants), 0, 'There are negative quants!')
+        self.assertEqual(len(neg_quants), 1, 'There should be 1 negative quants for supplier!')
-        # Check there are no negative quants
+        # Should be only 1 negative quant in supplier location
-        self.assertEqual(len(neg_quants), 0, 'There are negative quants!')
+        self.assertEqual(len(neg_quants), 1, 'There should be 1 negative quants for supplier!')
-        self.assertEqual(len(quants), 0)  # No quant created for inventory loss
+        self.assertEqual(len(quants), 1)  # One quant created for inventory loss
-        # Check associated quants: 1 quant for the product and the quantity
+        # Check associated quants: 2 quants for the product and the quantity (1 in stock, 1 in inventory adjustment)
-        self.assertEqual(len(quant), 1)
+        self.assertEqual(len(quant), 2)
-        # There should be no quant in the inventory loss location
+        # There should be one quant in the inventory loss location
-        self.assertEqual(len(quant), 0)
+        self.assertEqual(len(quant), 1)
-        if vals['name'] == _('New'):
+        if not vals.get('name'):
-        if vals.get('user_id'):
+        if vals.get('user_id') and 'date_assign' not in vals:
-            task._message_add_suggested_recipient(recipients, partner=task.partner_id, reason=reason)
+            if task.partner_id:
-
+    # Computed field about working time elapsed between record creation and assignation/closing.
-        ], default='0', index=True, string="Starred")
+        ('0', 'Low'),
-        ], size=1, readonly=True, string="Starred")
+        ('0', 'Low'),
-    'name': 'Issues Form',
+    'name': 'Website Form - Project',
-    'summary': 'Create Issues From Contact Form',
+    'summary': 'Create Tasks From Contact Form',
-====================
+=================
-    'depends': ['website_form', 'project_issue'],
+    'depends': ['website_form', 'project'],
-        'data/website_issue_data.xml',
+        'data/website_form_project_data.xml',
-    'name': 'Website Rating Project Issue',
+    'name': 'Website Rating Project',
-==================================================================================================
+==================================================================
-        'rating_project_issue'
+        'website_project',
-        return request.render('website_rating_project_issue.index', values)
+        return request.render('website_rating_project.index', values)
-        return request.render('website_rating_project_issue.project_rating_page', values)
+        return request.render('website_rating_project.project_rating_page', values)
-        # Calculate rating for Tasks and Issues
+        # Calculate rating for Tasks
-    'summary': 'Create Issues from Leads',
+    'name': 'Lead to Tasks',
-==============
+Lead to Tasks
-Link module to map leads to issues
+Link module to map leads to tasks
-        'wizard/crm_lead2projectissue_wizard_view.xml',
+        'wizard/crm_lead_convert2task_views.xml',
-    'depends': ['crm', 'project_issue'],
+    'depends': ['crm', 'project'],
-from . import crm_lead2projectissue_wizard
+from . import crm_lead_convert2task
-    """ wizard to convert a Lead into a Project Issue and move the Mail Thread """
+class CrmLeadConvert2Task(models.TransientModel):
-    _name = "crm.lead2projectissue.wizard"
+    _name = "crm.lead.convert2task"
-        result = super(CrmLeadToProjectIssueWizard, self).default_get(fields)
+        result = super(CrmLeadConvert2Task, self).default_get(fields)
-    project_id = fields.Many2one('project.project', string='Project', domain=[('use_issues', '=', True)])
+    project_id = fields.Many2one('project.project', string='Project', domain=[('use_tasks', '=', True)])
-    def action_lead_to_project_issue(self):
+    def action_lead_to_project_task(self):
-        # create new project.issue
+        # create new project.task
-        issue = self.env['project.issue'].create(vals)
+        task = self.env['project.task'].create(vals)
-        lead.message_change_thread(issue)
+        lead.message_change_thread(task)
-        attachments.write({'res_model': 'project.issue', 'res_id': issue.id})
+        attachments.write({'res_model': 'project.task', 'res_id': task.id})
-        view = self.env.ref('project_issue.project_issue_form_view')
+        # return the action to go to the form view of the new Task
-            'name': 'Issue created',
+            'name': 'Task created',
-            'res_model': 'project.issue',
+            'res_model': 'project.task',
-            'res_id': issue.id,
+            'res_id': task.id,
-}
+                moves_to_backorder.mapped('move_line_ids').write({'picking_id': backorder_picking.id})
-                if float_compare(ml.qty_done, ml.product_qty, precision_rounding=rounding) > 0:
+                if ml.location_id.should_impact_quants() and float_compare(ml.qty_done, ml.product_qty, precision_rounding=rounding) > 0:
-
+            'registrable': event._is_event_registrable()
-        return request.render("website_event.event_description_full", values)
+        return super(WebsiteEventSaleController, self).event_register(event, **post)
-                    'consume_repair_id': repair.id,
+                    'repair_id': repair.id,
-                    ('location_id.usage', '=', 'supplier'),
+                    ('location_id.usage', '!=', 'internal'),
-                    ('location_dest_id.usage', '=', 'customer'),
+                    ('location_dest_id.usage', '!=', 'internal'),
-            ref = move_line.move_id.inventory_id.name
+            ref = 'Inv. Adj.: ' + move_line.move_id.inventory_id.name
-    def make_dict_move(self, level, parent_id, move_line, stream=False):
+    def make_dict_move(self, level, parent_id, move_line, stream=False, unfoldable=False):
-            'unfoldable': False,
+            'unfoldable': unfoldable,
-                'product_id': move_line.product_id.display_name+' ('+move_line.lot_id.name+')',
+                'product_id': product_id_name,
-                'location_destination': move_line.location_dest_id.name,
+                'location_source': move_line.location_dest_id.name,
-                'product_id': move_line.product_id.display_name + ' (' + move_line.lot_id.name + ')',
+                'product_id': product_id_name,
-        model_obj = self.env[model].browse(model_id)
+    def upstream_traceability(self, level, stream=False, line_id=False, model=False, model_obj=False, parent_quant=False):
-                final_vals += self.make_dict_move(level, stream=stream, parent_id=line_id, move_line=move)
+        for move in moves:
-        model_obj = self.env[model].browse(model_id)
+    def downstream_traceability(self, level, stream=False, line_id=False, model=False, model_obj=False, parent_quant=False):
-                final_vals += self.make_dict_move(level, stream=stream, parent_id=line_id, move_line=move)
+        for move in moves:
-    def _lines(self, line_id=None, model_id=False, model=False, level=0, parent_quant=False, stream=False, obj_ids=[], **kw):
+    def final_vals_to_lines(self, final_vals, level):
-                final_vals += self.make_dict_head(level, stream=stream, parent_id=line_id, model=model or 'stock.move.line', move_line=move_line)
+    @api.model
-    _sql_constraints = [('name_uniq', 'unique (name)', "Title name already exists !")]
+    def _get_default_template(self):
-        states={'draft': [('readonly', False)], 'sent': [('readonly', False)]})
+        states={'draft': [('readonly', False)], 'sent': [('readonly', False)]},
-
+    active = fields.Boolean(default=True, help="If unchecked, it will allow you to hide the quotation template without removing it.")
-    'depends': ['sale_management', 'stock_account'],
+    'depends': ['sale', 'stock_account'],
-    module_website_sale_wishlist = fields.Boolean("Wishlists ", help='Installs *e-Commerce Wishlist*')
+    module_website_sale_wishlist = fields.Boolean("Wishlists", help='Installs *e-Commerce Wishlist*')
-from . import models
+
-        'views/website_sale_stock_templates.xml',
+        'views/product_template_views.xml',
-from . import website
+# -*- coding: utf-8 -*-
-        self.assertTrue(len(countries) == 3, "Must match only countries with names starting with Z (currently 3)")
+        self.assertTrue(len(countries) == 2, "Must match only countries with names starting with Z (currently 2)")
-        self.write(cr, uid, ids, {'state': 'installed'})
+        self.write(cr, uid, ids, {'state': 'installed'}, context=context)
-        self.write(cr, uid, ids, {'state': 'installed'})
+        self.write(cr, uid, ids, {'state': 'installed'}, context=context)
-        res = super(AccountPartialReconcile, self).create(vals)
+    # Do not forwardport in master as of 2017-07-20
-            return res
+            return self
-        aml_set = self.env['account.move.line']
+        partial_rec_set = OrderedDict.fromkeys([x for x in self])
-        aml_to_balance = None
+
-                        aml_to_balance = aml
+                        aml_to_balance |= aml
-                exchange_partial_rec_id = rate_diff_partial_rec.id
+                rate_diff_amls, rate_diff_partial_recs = partial_rec._fix_multiple_exchange_rates_diff(aml_to_balance, total_debit - total_credit, total_amount_currency, currency, exchange_move)
-            self.assertEquals(aml.currency_id.id, line['currency_id'])
+            self.assertEquals(aml.currency_id.id, line['currency_id'])
-    'website': 'https://www.odoo.com/page/gamification',
+    'website' : 'https://www.odoo.com/page/gamification',
-        ], default='ranking',
+        ], default='personal',
-
+    def _get_report_template(self):
-
+            
-                    # users that used to match the challenge
+                    # users that used to match the challenge 
-            'state': <gamification.goal state {draft,inprogress,reached,failed,canceled}>,
+            'state': <gamification.goal state {draft,inprogress,reached,failed,canceled}>,                                
-                'full_suffix': line.definition_id.full_suffix,
+
-                    'user_id': goal.user_id,
+                    'user_id': goal.user_id.id,
-            )
+            body_html = MailTemplates.with_context(challenge_lines=lines_boards).render_template(challenge.report_template_id.body_html, 'gamification.challenge', challenge.id)
-                ctx.update(challenge_lines=lines)
+                body_html = MailTemplates.sudo(user).with_context(challenge_lines=lines).render_template(
-
+                self.env['gamification.challenge'].message_post(
-                        subtype='mail.mt_comment')
+                         body=body_html,
-                if goal.definition_condition == 'higher' and goal.target_goal > 0:
+                if goal.definition_condition == 'higher':
-    'website' : 'https://www.odoo.com/page/gamification',
+    'website': 'https://www.odoo.com/page/gamification',
-        ], default='personal',
+        ], default='ranking',
-    report_template_id = fields.Many2one('mail.template', default=lambda self: self._get_report_template(), string="Report Template", required=True)
+
-            
+
-                    # users that used to match the challenge 
+                    # users that used to match the challenge
-            'state': <gamification.goal state {draft,inprogress,reached,failed,canceled}>,                                
+            'state': <gamification.goal state {draft,inprogress,reached,failed,canceled}>,
-
+                line_data['user_id'] = goal.user_id
-                    'name': goal.user_id.name,
+                    'user_id': goal.user_id,
-            body_html = MailTemplates.with_context(challenge_lines=lines_boards).render_template(challenge.report_template_id.body_html, 'gamification.challenge', challenge.id)
+            challenge.with_context(ctx).message_post_with_template(
-                subtype='mail.mt_comment')
+            template_id = self.env.ref('gamification.simple_report_template_personal', raise_if_not_found=False)
-                    challenge.id)
+                ctx.update(challenge_lines=lines)
-                )
+                template_id.with_context(ctx).send_mail(challenge.id, email_values={'recipient_ids': [(4, user.partner_id.id)]})
-                         subtype='mail.mt_comment')
+                        body=body_html,
-                if goal.definition_condition == 'higher':
+                if goal.definition_condition == 'higher' and goal.target_goal > 0:
-    else:
+    elif odoo.tools.config['db_name']:
-            weight += quant.qty * quant.product_id.weight
+        smls = self.env['stock.move.line'].search([('product_id', '!=', False), ('result_package_id', '=', self.id)])
-                weight += move_line.product_uom_id._compute_quantity(move_line.product_qty, move_line.product_id.uom_id) * move_line.product_id.weight
+                weight += move_line.product_uom_id._compute_quantity(move_line.qty_done, move_line.product_id.uom_id) * move_line.product_id.weight
-        self.invoice = self.pos_order_pos1.action_pos_order_invoice()
+        res = self.pos_order_pos1.action_pos_order_invoice()
-        self.amount_total = self.pos_order_pos1.amount_total
+        invoice = self.env['account.invoice'].browse(res['res_id'])
-            float_compare(self.amount_total, 1752.75, precision_digits=2), 0, "Invoice not correct")
+            float_compare(invoice.amount_total, 1752.75, precision_digits=2), 0, "Invoice not correct")
-            if move_line.result_package_id and move_line.result_package_id.packaging_id:
+            if move_line.result_package_id:
-            if hasattr(field, 'pad_content_field') and vals.get(field.pad_content_field):
+            if hasattr(field, 'pad_content_field') and vals.get(field.pad_content_field) and self[k]:
-    dbs = [i for i in dbs if re.match(r, i)]
+    if odoo.tools.config['dbfilter']:
-        group.add_option("--db-filter", dest="dbfilter", my_default='.*',
+        group.add_option("--db-filter", dest="dbfilter", my_default='',
-            'amount': int(self.amount*100),  # Stripe takes amount in cents (https://support.stripe.com/questions/which-zero-decimal-currencies-does-stripe-support)
+            'amount': int(self.amount if self.currency_id.name in INT_CURRENCIES else self.amount*100),
-                    time.sleep(0.05)
+                    thread.join_retry_count -= 1
-                               'dbname': getattr(th, 'dbname', 'n/a')}
+                               'dbname': getattr(th, 'dbname', 'n/a'),
-        code.append("\n# Thread: %s (id:%s) (db:%s) (uid:%s)" %
+        code.append("\n# Thread: %s (id:%s) (db:%s) (uid:%s) (url:%s)" %
-                     thread_info.get('uid', 'n/a')))
+                     thread_info.get('uid', 'n/a'),
-        if st_lines_left and stl_to_assign_partner and refs:
+        if st_lines_left and stl_to_assign_partner and refs\
-                                    )"""
+        account_clause = ''
-                if inv.currency_id.id != company_currency:
+                if inv.currency_id != company_currency:
-            context['default_type'] = vals.get('type')
+        if vals.get('type') and not self._context.get('default_crm_lead_type'):
-        context.setdefault('default_type', self.type)
+        context.setdefault('default_crm_lead_type', self.type)
-            'context': {'default_type': 'opportunity'}
+            'context': {'default_crm_lead_type': 'opportunity'}
-            if default_team_id and (self.env.context.get('default_type') != 'lead' or default_team_id.use_leads):
+            if default_team_id and (self.env.context.get('default_crm_lead_type') != 'lead' or default_team_id.use_leads):
-        product._set_standard_price(vals.get('standard_price', 0.0))
+        # When a unique variant is created from tmpl then the standard price is set by _set_standard_price
-            template.create_variant_ids()
+            template.with_context(create_from_tmpl=True).create_variant_ids()
-            elif float_compare(line.qty_to_invoice, 0.0, precision_digits=precision) == 1:
+            elif not float_is_zero(line.qty_to_invoice, precision_digits=precision):
-        self.assertEqual(self.so.invoice_status, 'invoiced', 'Sale Stock: so invoice_status should be "to invoice" instead of "%s" after picking return' % self.so.invoice_status)
+        self.assertEqual(self.so.invoice_status, 'to invoice', 'Sale Stock: so invoice_status should be "to invoice" instead of "%s" after picking return' % self.so.invoice_status)
-            replace(MIN(aa.name), '|', '/') AS CompteLib,
+            replace(replace(MIN(aa.name), '|', '/'), '\t', '') AS CompteLib,
-            replace(am.name, '|', '/') AS EcritureNum,
+            replace(replace(aj.code, '|', '/'), '\t', '') AS JournalCode,
-            replace(aa.name, '|', '/') AS CompteLib,
+            replace(replace(aa.name, '|', '/'), '\t', '') AS CompteLib,
-            COALESCE(replace(rp.name, '|', '/'), '') AS CompAuxLib,
+            COALESCE(replace(replace(rp.name, '|', '/'), '\t', ''), '') AS CompAuxLib,
-            ELSE replace(am.ref, '|', '/')
+            ELSE replace(replace(am.ref, '|', '/'), '\t', '')
-            CASE WHEN aml.name IS NULL THEN '/' ELSE replace(aml.name, '|', '/') END AS EcritureLib,
+            CASE WHEN aml.name IS NULL THEN '/' ELSE replace(replace(aml.name, '|', '/'), '\t', '') END AS EcritureLib,
-                                 default=lambda self: self.env.user._get_company())
+                                 default=lambda self: self.env.user.company_id)
-        config = self.next() or {}
+        config = env['ir.module.module'].next() or {}
-    expense_line_ids = fields.One2many('hr.expense', 'sheet_id', string='Expense Lines', states={'done': [('readonly', True)], 'post': [('readonly', True)]}, copy=False)
+    expense_line_ids = fields.One2many('hr.expense', 'sheet_id', string='Expense Lines', states={'approve': [('readonly', True)], 'done': [('readonly', True)], 'post': [('readonly', True)]}, copy=False)
-from . import hr_timesheet_current
+from mock import patch
-                    price_uom = self.env['product.uom']._compute_qty(line_product.uom_id.id, line_product.standard_price, bom_line['product_uom'])
+                    price_uom = self.env['product.uom']._compute_price(line_product.uom_id.id, line_product.standard_price, bom_line['product_uom'])
-        return self.env['report'].render('mrp.mrp_bom_cost', {'lines': res})
+        return self.env['report'].render('mrp.mrp_bom_cost', {'lines': res})
-            'name': line['name'][:64],
+            'name': line['name'],
-        self.assertEqual(self.so.invoice_status, 'to invoice', 'Sale Stock: so invoice_status should be "to invoice" instead of "%s" after picking return' % self.so.invoice_status)
+        self.assertEqual(self.so.invoice_status, 'invoiced', 'Sale Stock: so invoice_status should be "to invoice" instead of "%s" after picking return' % self.so.invoice_status)
-        if values.get('url'):
+        if values.get('url') and not values.get('document_id'):
-        if values.get('url'):
+        if values.get('url') and values['url'] != self.url:
-        if self:
+        if products:
-
+                        # `qty_done` is in `ml.product_uom_id` and, as we will later increase the
-                        grouped_move_lines_out[k] = sum(self.env['stock.move.line'].concat(*list(g)).mapped('qty_done'))
+                        qty_done = 0
-            elif not float_is_zero(line.qty_to_invoice, precision_digits=precision):
+            elif float_compare(line.qty_to_invoice, 0.0, precision_digits=precision) == 1:
-    sale_amount_total = fields.Monetary(compute='_compute_sale_amount_total', string="Sum of Orders", currency_field='company_currency')
+    sale_amount_total = fields.Monetary(compute='_compute_sale_amount_total', string="Sum of Orders", help="Untaxed Total of Confirmed Orders", currency_field='company_currency')
-                if order.state in ('draft', 'sent'):
+                if order.state in ('draft', 'sent', 'sale'):
-        readonly=True, copy=False, stored=True,
+        readonly=True, copy=False, store=True,
-            raise UserError(_('You try to move a product using a UoM that is not compatible with the UoM of the product moved. Please use an UoM in the same UoM category.'))
+        moves_error = self.filtered(lambda move: move.product_id.uom_id.category_id.id != move.product_uom.category_id.id)
-        super(UserError, self).__init__(msg)
+        super(UserError, self).__init__(msg, value='')
-                     _("%s does not ship to your address, please choose another one.") % order.carrier_id.name))
+                     _("%s does not ship to your address, please choose another one.\n(Error: %s)" % (order.carrier_id.name, order.delivery_message))))
-        price_unit = self._get_price_available(order)
+        try:
-            raise UserError(_("Selected product in the delivery method doesn't fulfill any of the delivery carrier(s) criteria."))
+            raise UserError(_("No price rule matching this order; delivery cost cannot be computed."))
-    free_over = fields.Boolean('Free if Order total is more than', help="If the order is more expensive than a certain amount, the customer can benefit from a free shipping", default=False, oldname='free_if_more_than')
+    free_over = fields.Boolean('Free if order amount is above', help="If the order total amount (shipping excluded) is above or equal to this value, the customer benefits from a free shipping", default=False, oldname='free_if_more_than')
-                res['warning_message'] = _('Warning:\nTotal amount of this order is over %.2f, free shipping!\n(actual cost: %.2f)') % (self.amount, res['price'])
+                res['warning_message'] = _('Info:\nTotal amount of this order is above %.2f, free shipping!\n(actual cost: %.2f)') % (self.amount, res['price'])
-                name = '%s fixed price %s and %s times %s Extra' % (name, rule.list_base_price, rule.list_price, rule.variable_factor)
+                name = '%s fixed price %s plus %s times %s' % (name, rule.list_base_price, rule.list_price, rule.variable_factor)
-        self.env['stock.warehouse'].sudo().create({'name': company.name, 'code': company.name[:5], 'company_id': company.id})
+        self.env['stock.warehouse'].sudo().create({'name': company.name, 'code': company.name[:5], 'company_id': company.id, 'partner_id': company.partner_id.id})
-            elif move.location_dest_id.usage == "internal" and move.to_refund_so:
+            elif move.location_dest_id.usage != "customer" and move.to_refund_so:
-    identification_id = fields.Char(string='Identification No')
+    birthday = fields.Date('Date of Birth', groups='hr.group_hr_user')
-    ])
+    ], groups='hr.group_hr_user')
-    ], string='Marital Status')
+    ], string='Marital Status', groups='hr.group_hr_user')
-        domain="[('partner_id', '=', address_home_id)]", help='Employee bank salary account')
+        domain="[('partner_id', '=', address_home_id)]", help='Employee bank salary account', groups='hr.group_hr_user')
-    passport_id = fields.Char('Passport No')
+    passport_id = fields.Char('Passport No', groups='hr.group_hr_user')
-    vehicle_distance = fields.Integer(string='Home-Work Dist.', help="In kilometers")
+    medic_exam = fields.Date(string='Medical Examination Date', groups='hr.group_hr_user')
-                for move in moves:
+                for move in sorted(moves, key=lambda move: move.date_expected):
-            res.update({(slide.id, LinkTracker.sudo().create({'url': '%s/slides/slide/%s' % (base_url, slug(slide))}).short_url) for slide in self})
+            res.update({
-                raise UserError(_('You need to provide a Lot/Serial Number for product %s') % move.product_id.name)
+                raise UserError(_('You need to provide a Lot/Serial Number for product %s') % ("%s (%s)" % (move.product_id.name, move.picking_id.name)))
-        width = int(width)
+        height = int(height or 0)
-                        raise osv.except_osv(_('Error!'), _("""Cannot create move with currency different from ..""") % (line.account_id.code, line.account_id.name))
+                        raise osv.except_osv(_('Error'), _("""Couldn't create move with currency different from the secondary currency of the account "%s - %s". Clear the secondary currency field of the account definition if you want to accept all currencies.""") % (line.account_id.code, line.account_id.name))
-              "qu'il fait une escale technique Ã  St Claude, on dit:")
+        ('A', u"Qu'il n'est pas arrivÃ© Ã  Toronto"),
-        etree.SubElement(billTo, "address").text = (partner.street + (partner.street2 if partner.street2 else '')) or None
+        etree.SubElement(billTo, "address").text = (partner.street or '' + (partner.street2 if partner.street2 else '')) or None
-                available_qty = Quant._update_available_quantity(ml.product_id, ml.location_id, -quantity, lot_id=ml.lot_id, package_id=ml.package_id, owner_id=ml.owner_id)
+                available_qty, in_date = Quant._update_available_quantity(ml.product_id, ml.location_id, -quantity, lot_id=ml.lot_id, package_id=ml.package_id, owner_id=ml.owner_id)
-                Quant._update_available_quantity(ml.product_id, ml.location_dest_id, quantity, lot_id=ml.lot_id, package_id=ml.result_package_id, owner_id=ml.owner_id)
+                Quant._update_available_quantity(ml.product_id, ml.location_dest_id, quantity, lot_id=ml.lot_id, package_id=ml.result_package_id, owner_id=ml.owner_id, in_date=in_date)
-                                                      package_id=ml.package_id, owner_id=ml.owner_id)
+                    in_date = Quant._update_available_quantity(ml.product_id, ml.location_dest_id, -ml.qty_done, lot_id=ml.lot_id,
-                                                      package_id=ml.package_id, owner_id=ml.owner_id)
+                                                      package_id=ml.package_id, owner_id=ml.owner_id, in_date=in_date)
-                    available_qty = Quant._update_available_quantity(product_id, location_id, -quantity, lot_id=lot_id, package_id=package_id, owner_id=owner_id)
+                    available_qty, in_date = Quant._update_available_quantity(product_id, location_id, -quantity, lot_id=lot_id, package_id=package_id, owner_id=owner_id)
-                    Quant._update_available_quantity(product_id, location_dest_id, quantity, lot_id=lot_id, package_id=result_package_id, owner_id=owner_id)
+                    Quant._update_available_quantity(product_id, location_dest_id, quantity, lot_id=lot_id, package_id=result_package_id, owner_id=owner_id, in_date=in_date)
-                    available_qty = Quant._update_available_quantity(ml.product_id, ml.location_id, -quantity, lot_id=ml.lot_id, package_id=ml.package_id, owner_id=ml.owner_id)
+                    available_qty, in_date = Quant._update_available_quantity(ml.product_id, ml.location_id, -quantity, lot_id=ml.lot_id, package_id=ml.package_id, owner_id=ml.owner_id)
-                    Quant._update_available_quantity(ml.product_id, ml.location_dest_id, quantity, lot_id=ml.lot_id, package_id=ml.result_package_id, owner_id=ml.owner_id)
+                    Quant._update_available_quantity(ml.product_id, ml.location_dest_id, quantity, lot_id=ml.lot_id, package_id=ml.result_package_id, owner_id=ml.owner_id, in_date=in_date)
-    def _update_available_quantity(self, product_id, location_id, quantity, lot_id=None, package_id=None, owner_id=None):
+    def _update_available_quantity(self, product_id, location_id, quantity, lot_id=None, package_id=None, owner_id=None, in_date=None):
-                    quant.quantity += quantity
+                    quant.write({
-        return self._get_available_quantity(product_id, location_id, lot_id=lot_id, package_id=package_id, owner_id=owner_id, strict=False)
+        return self._get_available_quantity(product_id, location_id, lot_id=lot_id, package_id=package_id, owner_id=owner_id, strict=False), fields.Datetime.from_string(in_date)
-        self.assertEqual(len(self.env['stock.quant']._gather(self.product3, self.stock_location)), 1.0)
+        quants = self.env['stock.quant']._gather(self.product3, self.stock_location)
-        self.assertEqual(len(self.env['stock.quant']._gather(self.product2, self.stock_location)), 5.0)
+        quants = self.env['stock.quant']._gather(self.product2, self.stock_location)
-        help="When a procurement has a âproduceâ route with a picking type set, it will try to create "
+        help=u"When a procurement has a âproduceâ route with a picking type set, it will try to create "
-            return all(move.state == 'done' for move in self.move_ids)
+            return all(move.state in ('done', 'cancel') for move in self.move_ids) and any(move.state == 'done' for move in self.move_ids)
-            "",
+            "odoo.__DEBUG__.services['web_tour.tour'].tours.portal_load_homepage.ready",
-            ('name', 'ilike', 'website'),
+            '|', ('name', 'ilike', 'website'), ('name', '=', 'web_editor'),
-        # instead we close the socket
+        werkzeug.serving.BaseWSGIServer.__init__(self, "127.0.0.1", 0, app)
-        with self.assertRaises(IntegrityError):
+        with self.assertRaises(IntegrityError), mute_logger('odoo.sql_db'):
-        with self.assertRaises(IntegrityError):
+        with self.assertRaises(IntegrityError), mute_logger('odoo.sql_db'):
-        with self.assertRaises(IntegrityError):
+        with self.assertRaises(IntegrityError), mute_logger('odoo.sql_db'):
-    'debug': ['odoo:DEBUG'],
+    'debug_rpc_answer': ['odoo:DEBUG', 'odoo.sql_db:INFO', 'odoo.http.rpc:DEBUG'],
-                _logger.info("bad query: %s \nERROR: %s", self._obj.query or query, e)
+                _logger.error("bad query: %s\nERROR: %s", self._obj.query or query, e)
-            available_quantity -= max_quantity_on_quant
+                max_quantity_on_quant = min(quant.reserved_quantity, abs(quantity))
-                to_update[0].with_context(bypass_reservation_update=True).product_uom_qty += self.product_id.uom_id._compute_quantity(taken_quantity, self.product_uom, rounding_method='HALF-UP')
+                to_update[0].with_context(bypass_reservation_update=True).product_uom_qty += self.product_id.uom_id._compute_quantity(quantity, self.product_uom, rounding_method='HALF-UP')
-                        Quant._update_reserved_quantity(ml.product_id, ml.location_id, -qty_to_decrease, lot_id=ml.lot_id, package_id=ml.package_id, owner_id=ml.owner_id)
+                        Quant._update_reserved_quantity(ml.product_id, ml.location_id, -qty_to_decrease, lot_id=ml.lot_id, package_id=ml.package_id, owner_id=ml.owner_id, strict=True)
-                            Quant._update_reserved_quantity(ml.product_id, ml.location_id, -qty_to_decrease, lot_id=False, package_id=ml.package_id, owner_id=ml.owner_id)
+                            Quant._update_reserved_quantity(ml.product_id, ml.location_id, -qty_to_decrease, lot_id=False, package_id=ml.package_id, owner_id=ml.owner_id, strict=True)
-                        Quant._update_reserved_quantity(ml.product_id, ml.location_id, -ml.product_qty, lot_id=ml.lot_id, package_id=ml.package_id, owner_id=ml.owner_id)
+                        Quant._update_reserved_quantity(ml.product_id, ml.location_id, -ml.product_qty, lot_id=ml.lot_id, package_id=ml.package_id, owner_id=ml.owner_id, strict=True)
-                            Quant._update_reserved_quantity(ml.product_id, ml.location_id, -ml.product_qty, lot_id=False, package_id=ml.package_id, owner_id=ml.owner_id)
+                            Quant._update_reserved_quantity(ml.product_id, ml.location_id, -ml.product_qty, lot_id=False, package_id=ml.package_id, owner_id=ml.owner_id, strict=True)
-                                                                   package_id=ml.package_id, owner_id=ml.owner_id)
+                                                                   package_id=ml.package_id, owner_id=ml.owner_id, strict=True)
-                        Quant._update_reserved_quantity(ml.product_id, ml.location_id, -ml.product_qty, lot_id=ml.lot_id, package_id=ml.package_id, owner_id=ml.owner_id)
+                        Quant._update_reserved_quantity(ml.product_id, ml.location_id, -ml.product_qty, lot_id=ml.lot_id, package_id=ml.package_id, owner_id=ml.owner_id, strict=True)
-                        Quant._update_reserved_quantity(ml.product_id, ml.location_id, -ml.product_qty, lot_id=False, package_id=ml.package_id, owner_id=ml.owner_id)
+                        Quant._update_reserved_quantity(ml.product_id, ml.location_id, -ml.product_qty, lot_id=False, package_id=ml.package_id, owner_id=ml.owner_id, strict=True)
-        self.env['stock.quant']._update_reserved_quantity(product1, stock_location, -10.0)
+        self.env['stock.quant']._update_reserved_quantity(product1, stock_location, -10.0, strict=True)
-            self.env['stock.quant']._update_reserved_quantity(product1, stock_location, -1.0)
+            self.env['stock.quant']._update_reserved_quantity(product1, stock_location, -1.0, strict=True)
-        self.env['stock.quant']._update_reserved_quantity(product1, stock_location, -2.0)
+        self.env['stock.quant']._update_reserved_quantity(product1, stock_location, -2.0, strict=True)
-            self.env['stock.quant']._update_reserved_quantity(product1, stock_location, -1.0)
+            self.env['stock.quant']._update_reserved_quantity(product1, stock_location, -1.0, strict=True)
-            default_sale_tax_id=params.get_param('account.default_sale_tax_id', default=False)
+            default_purchase_tax_id=int(params.get_param('account.default_purchase_tax_id', default=False)) or False,
-                values['warehouse_id'] = warehouses.id
+            warehouse_id = (
-                packop.action_done()
+            move.move_line_ids.action_done()
-        destination location.
+        """ This method is called during a move's `action_done`. It'll actually move a quant from
-            if pack.picking_id and not pack.picking_id.picking_type_id.use_create_lots:
+        active_picking_id = self.env.context.get('active_picking_id', False)
-
+            'picking_type_id': self.picking_type_in,
-    _order = 'default_code, id'
+    _order = 'default_code, name, id'
-                    ('check_in', '<=', attendance.check_out),
+                    ('check_in', '<', attendance.check_out),
-from odoo import api, fields, models, _
+from odoo import api, fields, models, registry, SUPERUSER_ID, _
-        
+
-            if res['success'] and self.free_over and order._compute_amount_total_without_delivery >= self.amount:
+            if res['success'] and self.free_over and order._compute_amount_total_without_delivery() >= self.amount:
-                    available_move_lines = dict((k, v) for k, v in available_move_lines.iteritems() if v)
+                    available_move_lines = {k: v for k, v in pycompat.items(available_move_lines) if v}
-            except OperationalError, e:
+            except OperationalError as e:
-from odoo import api, models
+from odoo import api, models, _
-        tools.drop_view_if_exists(self._cr, 'report_pos_order')
+        tools.drop_view_if_exists(self._cr, self._table)
-                    SUM(l.qty * u.factor) != 0
+            CREATE OR REPLACE VIEW %s AS (
-        """)
+        """ % (self._table, self._select(), self._from(), self._group_by(),self._having())
-        "static/src/xml/*.xml",
+        "static/src/xml/base.xml",
-            if res['success'] and self.free_over and order._compute_amount_total_without_delivery >= self.amount:
+            if res['success'] and self.free_over and order._compute_amount_total_without_delivery() >= self.amount:
-version_info = (10, 'saas~17', 0, FINAL, 0, '')
+version_info = (11, 0, 0, ALPHA, 1, '')
-        category = self.env['product.category'].search([('type', '=', 'normal')], limit=1)
+        if not category:
-            err_msg = _('You must define at least one product category (that is not a view) in order to be able to create products.')
+            err_msg = _('You must define at least one product category in order to be able to create products.')
-        change_default=True, default=_get_default_category_id, domain="[('type','=','normal')]",
+        change_default=True, default=_get_default_category_id,
-                if self.find_move_ancestors(cr, uid, move, context=context):
+                if move.procure_method == 'make_to_order' or self.find_move_ancestors(cr, uid, move, context=context):
-                if self.find_move_ancestors(cr, uid, move, context=context):
+                if move.procure_method == 'make_to_order' or self.find_move_ancestors(cr, uid, move, context=context):
-    price_reduce = fields.Monetary(compute='_get_price_reduce', string='Price Reduce', readonly=True, store=True)
+    price_reduce = fields.Float(compute='_get_price_reduce', string='Price Reduce', digits=dp.get_precision('Product Price'), readonly=True, store=True)
-                taxes = tax.compute_all(line.price_reduce + base_tax, quantity=line.product_uom_qty,
+                # FORWARD-PORT UP TO SAAS-17
-                    base_tax += tax.compute_all(line.price_reduce + base_tax, quantity=1, product=line.product_id,
+                    base_tax += tax.compute_all(price_reduce + base_tax, quantity=1, product=line.product_id,
-                        acquirer_name = tx.sale_order_id.payment_acquirer_id.provider or 'unknown'
+                        acquirer_name = tx.acquirer_id.provider or 'unknown'
-            raise UserError(_("Some data are missing, this report cannot be printed."))
+            raise UserError(_("Form content is missing, this report cannot be printed."))
-from odoo import api, models
+from odoo import api, models, _
-            raise UserError(_("Some data are missing, this report cannot be printed."))
+            raise UserError(_("Form content is missing, this report cannot be printed."))
-from odoo import api, models
+from odoo import api, models, _
-            raise UserError(_("Some data are missing, this report cannot be printed."))
+            raise UserError(_("Form content is missing, this report cannot be printed."))
-from odoo import api, models
+from odoo import api, models, _
-            raise UserError(_("Some data are missing, this report cannot be printed."))
+            raise UserError(_("Form content is missing, this report cannot be printed."))
-from odoo import api, models
+from odoo import api, models, _
-            raise UserError(_("Some data are missing, this report cannot be printed."))
+            raise UserError(_("Form content is missing, this report cannot be printed."))
-from odoo import api, models
+from odoo import api, models, _
-            raise UserError(_("Some data are missing, this report cannot be printed."))
+            raise UserError(_("Form content is missing, this report cannot be printed."))
-from odoo import api, fields, models
+from odoo import api, fields, models, _
-            raise UserError(_("Some data are missing, this report cannot be printed."))
+            raise UserError(_("Form content is missing, this report cannot be printed."))
-from odoo import api, fields, models
+from odoo import api, fields, models, _
-            raise UserError(_("Some data are missing, this report cannot be printed."))
+            raise UserError(_("Form content is missing, this report cannot be printed."))
-from odoo import api, models
+from odoo import api, models, _
-            raise UserError(_("Some data are missing, this report cannot be printed."))
+            raise UserError(_("Form content is missing, this report cannot be printed."))
-from odoo import api, models
+from odoo import api, models, _
-            raise UserError(_("Some data are missing, this report cannot be printed."))
+            raise UserError(_("Form content is missing, this report cannot be printed."))
-    _inherits = {'product.product': 'product_id'}
+    name = fields.Char(required=True)
-    product_id = fields.Many2one('product.product', string='Delivery Product', required=True, ondelete="cascade")
+    product_id = fields.Many2one('product.product', string='Delivery Product', required=True, ondelete='restrict')
-    free_over = fields.Boolean('Free if Order total is more than', help="If the order is more expensive than a certain amount, the customer can benefit from a free shipping", default=False, oldname='free_if_more_than')
+    free_over = fields.Boolean('Free if order total is more than', help="If the order is more expensive than a certain amount, the customer can benefit from a free shipping", default=False, oldname='free_if_more_than')
-
+        'security/delivery_carrier_security.xml',
-from collections import namedtuple
+from lxml import etree
-from PyPDF2 import PdfFileWriter, PdfFileReader
+from cStringIO import StringIO
-
+
-    def retrieve_attachment(self, record_id, attachment_name=None):
+    def retrieve_attachment(self, record):
-        :return: A recordset of length <= 1
+        :param record: The record owning of the attachment.
-            attachment_name = safe_eval(self.attachment, {'object': record_id, 'time': time})
+            return None
-                ('res_id', '=', record_id.id)
+                ('res_id', '=', record.id)
-    def postprocess_pdf_report(self, res_id, pdfreport_path, attachment_name):
+    @api.multi
-        :param attachment_name: The name of the attachment.
+        :param record_id: The record that will own the attachment.
-        attachment = {
+        attachment_name = safe_eval(self.attachment, {'object': record, 'time': time})
-            'datas': base64.encodestring(attachment_content),
+            'datas': base64.encodestring(buffer.getvalue()),
-            'res_id': res_id,
+            'res_id': record.id,
-            self.env['ir.attachment'].create(attachment)
+            attachment = self.env['ir.attachment'].create(attachment_vals)
-            _logger.info("Cannot save PDF report %r as attachment", attachment['name'])
+            _logger.info("Cannot save PDF report %r as attachment", attachment_vals['name'])
-            _logger.info('The PDF document %s is now saved in the database', attachment['name'])
+            _logger.info('The PDF document %s is now saved in the database', attachment_vals['name'])
-            paperformat,
+            paperformat_id,
-        :param paperformat: A report.paperformat record.
+        :param paperformat_id: A report.paperformat record.
-        :return: A list of string representing the wkhtmltopdf arguments.
+        :return: A list of string representing the wkhtmltopdf process command args.
-                command_args.extend(['--page-size', paperformat.format])
+        if paperformat_id:
-                command_args.extend(['--page-height', str(paperformat.page_height) + 'mm'])
+            if paperformat_id.page_height and paperformat_id.page_width and paperformat_id.format == 'custom':
-                command_args.extend(['--margin-top', str(paperformat.margin_top)])
+                command_args.extend(['--margin-top', str(paperformat_id.margin_top)])
-                if os.name == 'nt' and int(paperformat.dpi) <= 95:
+            elif paperformat_id.dpi:
-                    command_args.extend(['--dpi', str(paperformat.dpi)])
+                    command_args.extend(['--dpi', str(paperformat_id.dpi)])
-            if paperformat.header_line:
+            elif paperformat_id.header_spacing:
-        :return: data found in the html as a dictionary.
+    @api.multi
-        ids = []
+        header_node = etree.Element('div', id='minimal_layout_report_headers')
-            headers.append(header)
+            header_node.append(node)
-            footers.append(footer)
+            footer_node.append(node)
-        # Retrieve content & ids
+        # Retrieve bodies
-                report_id = res_ids[0]
+            body = layout.render(dict(subst=False, body=lxml.html.tostring(node), base_url=base_url))
-            wkhtmltopdf_objs.append(wkhtmltopdf_obj)
+                res_id = False
-        }
+        header = layout.render(dict(subst=True, body=lxml.html.tostring(header_node), base_url=base_url))
-            paperformat,
+            bodies,
-        :param wkhtmltopdf_objs: A list of WkhtmltopdfObj generated by the method create_wkhtmltopdf_obj in ir.actions.report
+        :param bodies: The html bodies of the report, one per page.
-                                    the generation of report attachments.
+        paperformat_id = self.paperformat_id or self.env.user.company_id.paperformat_id
-            paperformat,
+            paperformat_id,
-        pdfdocuments = []
+        files_command_args = []
-            temporary_files.append(entire_report_path)
+        try:
-            content_read = pdfdocument.read()
+        with open(pdf_report_path, 'rb') as pdf_document:
-        return content_read
+        return pdf_content
-    @api.model
+    @api.multi
-    def render_qweb_pdf(self, res_ids, html=None, data=None):
+    @api.multi
-            paperformat = user.company_id.paperformat_id
+            return self.with_context(context).render_qweb_html(res_ids, data=data)[0]
-        ), 'pdf'
+            wk_record_ids = record_ids
-            raise UserError('You cannot decrease the ordered quantity below your delivered quantity.\n'
+            raise UserError('You cannot decrease the ordered quantity below the delivered quantity.\n'
-                                  (line.product_id.name, line.product_uom_qty, values['product_uom_qty'], self.order_id.name))
+            for picking in pickings:
-            values['deliveries'] = delivery_carriers.sudo().with_context(order_id=order.id)
+            values['deliveries'] = delivery_carriers.sudo()
-from odoo.exceptions import ValidationError
+from odoo import api, fields, models
-                self.set_delivery_line()
+                if self.delivery_rating_success:
-
+
-""",
+    'description': "",
-""",
+    'description': "",
-    """,
+    'description': "",
-    """,
+    'description': "",
-""",
+    'description': "",
-    """,
+    'description': "",
-    """,
+    'description': "",
-    """,
+    'description': "",
-""",
+    'description': "",
-    """,
+    'description': "",
-    """,
+    'description': "",
-    """,
+    'description': "",
-        """,
+    'description': "",
-        """,
+    'description': "",
-        """,
+    'description': "",
-        """,
+    'description': "",
-        """,
+    'description': "",
-        """,
+    'description': "",
-        """,
+    'description': "",
-        """,
+    'description': "",
-                )
+                quantity_in_stock = sum(self.env['stock.quant'].search([
-            ('location_id', 'child_of', location_id.id),
+            domain = expression.AND([[('location_id', 'child_of', location_id.id)], domain])
-    def _update_available_quantity(self, product_id, location_id, quantity, lot_id=None, package_id=None, owner_id=None, strict=True):
+    def _update_available_quantity(self, product_id, location_id, quantity, lot_id=None, package_id=None, owner_id=None):
-        quants = self._gather(product_id, location_id, lot_id=lot_id, package_id=package_id, owner_id=owner_id, strict=strict)
+        quants = self._gather(product_id, location_id, lot_id=lot_id, package_id=package_id, owner_id=owner_id, strict=True)
-        return self._get_available_quantity(product_id, location_id, lot_id=lot_id, package_id=package_id, owner_id=owner_id, strict=strict)
+        return self._get_available_quantity(product_id, location_id, lot_id=lot_id, package_id=package_id, owner_id=owner_id, strict=False)
-            'context': {'default_picking_id': self.id, 'product_ids': scrapeable_products.ids},
+            'context': {'default_picking_id': self.id, 'product_ids': self.move_line_ids.mapped('product_id').ids},
-                raise UserError(_('You cannot scrap a move without having available stock for %s. You can correct it with an inventory adjustment.') % move.product_id.name)
+            if self.product_id.type == 'product':
-from odoo.tests.common import TransactionCase
+from odoo.tests.common import TransactionCase
-                        raise UserError('You cannot decrease the ordered quantity below your receipt.\n'
+                        raise UserError('You cannot decrease the ordered quantity below the received quantity.\n'
-        default=1.0, required=True, states={'done': [('readonly', True)]},
+        default=0.0, required=True, states={'done': [('readonly', True)]},
-            self.product_uom_qty = 1.0
+
-                                           'location_dest_id': location_dest_id,})]
+            'move_line_ids': [(0, 0, {
-                    not (move.restrict_lot_id or (move_line and (move_line.product_id and move_line.pack_lot_ids)) or (move_line and not move_line.product_id)):
+                    not (move_line and (move_line.product_id and move_line.pack_lot_ids)) or (move_line and not move_line.product_id):
-    def split(self, qty, restrict_lot_id=False, restrict_partner_id=False):
+    def split(self, qty, restrict_partner_id=False):
-#             'restrict_lot_id': self.lot_id.id,  # FIXME: JCO i asked you x times, should we drop this or not????
+            consignment_enabled = self.user_has_groups('stock.group_tracking_owner')
-                    and (multi_locations_enabled or move.has_tracking != 'none' or len(move.move_line_ids) > 1 or has_package):
+                    and (multi_locations_enabled or move.has_tracking != 'none' or len(move.move_line_ids) > 1 or has_package or consignment_enabled):
-    type = fields.Selection([('radio', 'Radio'), ('select', 'Select'), ('color', 'Color'), ('hidden', 'Hidden')], default='radio')
+    type = fields.Selection([('radio', 'Radio'), ('select', 'Select'), ('color', 'Color')], default='radio')
-                date_order=self.order_id.date_order,
+                date=self.order_id.date_order,
-                    field_data['relation_field'] in self._existing_field_data(field_data['relation'])
+                    field_data['relation_field'] in self._get_manual_field_data(field_data['relation'])
-        fields_data = self._existing_field_data(model._name)
+        fields_data = self._get_manual_field_data(model._name)
-                return self._ir_attach['datas'].decode('base64')
+                return self._ir_attach['datas'].decode('base64').decode('utf-8')
-    def get_tracking_link(self, pickings):
+    def get_tracking_link(self, picking):
-        :return list: A list of string URLs, containing the tracking links for every picking
+        :param picking: record of stock.picking
-            return getattr(self, '%s_get_tracking_link' % self.delivery_type)(pickings)
+            return getattr(self, '%s_get_tracking_link' % self.delivery_type)(picking)
-        raise NotImplementedError()
+    def fixed_get_tracking_link(self, picking):
-            res = res + [{'exact_price': p.carrier_id._get_price_available(p.sale_id),  # TODO cleanme
+            res = res + [{'exact_price': p.carrier_id._get_price_available(p.sale_id) if p.sale_id else 0.0,  # TODO cleanme
-        raise NotImplementedError()
+    def base_on_rule_get_tracking_link(self, picking):
-    def base_on_rule__cancel_shipment(self, pickings):
+    def base_on_rule_cancel_shipment(self, pickings):
-        else:
+        if not self.carrier_tracking_url:
-                         'url': url,
+                         'url': self.carrier_tracking_url,
-            ]
+            domain = [('so_line', 'in', self.ids), ('amount', '<=', 0.0)]
-            ]
+            domain = [('so_line', 'in', self.ids), '|', ('amount', '<=', 0.0), ('project_id', '!=', False)]
-        if not domain:
+        if not domain and self.ids:
-    account_id = fields.Many2one('account.account', string='Account', states={'post': [('readonly', True)], 'done': [('readonly', True)]}, default=lambda self: self.env['ir.property'].get('property_account_expense_categ_id', 'product.category'))
+    account_id = fields.Many2one('account.account', string='Account', states={'post': [('readonly', True)], 'done': [('readonly', True)]}, default=lambda self: self.env['ir.property'].get('property_account_expense_categ_id', 'product.category'),
-            date = date.replace(month=last_month, day=last_day, year=date.year + 1)
+            if last_month == 2 and last_day == 29 and (date.year + 1) % 4 != 0:
-        date_from = date_from.replace(year=date_from.year - 1)
+        if date_from.month == 2 and date_from.day == 29:
-                'price': self.fixed_price,
+                'price': price_unit,
-            payment = False
+            payment = self.env['account.payment']
-                if not [s for s in links_blacklist if s in href]:
+                parsed = urlparse(url, scheme='http')
-    def _increase_reserved_quantity(self, need, available_quantity, location_id, lot_id=None, package_id=None, owner_id=None, strict=True):
+    def _update_reserved_quantity(self, need, available_quantity, location_id, lot_id=None, package_id=None, owner_id=None, strict=True):
-        quants = self.env['stock.quant']._increase_reserved_quantity(
+        quants = self.env['stock.quant']._update_reserved_quantity(
-                    taken_quantity = move._increase_reserved_quantity(need, available_quantity, move.location_id, strict=False)
+                    taken_quantity = move._update_reserved_quantity(need, available_quantity, move.location_id, strict=False)
-                        taken_quantity = move._increase_reserved_quantity(need, quantity, location_id, lot_id, package_id, owner_id)
+                        taken_quantity = move._update_reserved_quantity(need, quantity, location_id, lot_id, package_id, owner_id)
-                available_qty = Quant._decrease_available_quantity(ml.product_id, ml.location_id, quantity, lot_id=ml.lot_id, package_id=ml.package_id, owner_id=ml.owner_id)
+                available_qty = Quant._update_available_quantity(ml.product_id, ml.location_id, -quantity, lot_id=ml.lot_id, package_id=ml.package_id, owner_id=ml.owner_id)
-                        Quant._increase_available_quantity(ml.product_id, ml.location_id, taken_from_untracked_qty, lot_id=ml.lot_id, package_id=ml.package_id, owner_id=ml.owner_id)
+                        Quant._update_available_quantity(ml.product_id, ml.location_id, -taken_from_untracked_qty, lot_id=False, package_id=ml.package_id, owner_id=ml.owner_id)
-                Quant._increase_available_quantity(ml.product_id, ml.location_dest_id, quantity, lot_id=ml.lot_id, package_id=ml.result_package_id, owner_id=ml.owner_id)
+                Quant._update_available_quantity(ml.product_id, ml.location_dest_id, quantity, lot_id=ml.lot_id, package_id=ml.result_package_id, owner_id=ml.owner_id)
-                        Quant._decrease_reserved_quantity(ml.product_id, ml.location_id, qty_to_decrease, lot_id=ml.lot_id, package_id=ml.package_id, owner_id=ml.owner_id)
+                        Quant._update_reserved_quantity(ml.product_id, ml.location_id, -qty_to_decrease, lot_id=ml.lot_id, package_id=ml.package_id, owner_id=ml.owner_id)
-                            Quant._decrease_reserved_quantity(ml.product_id, ml.location_id, qty_to_decrease, lot_id=False, package_id=ml.package_id, owner_id=ml.owner_id)
+                            Quant._update_reserved_quantity(ml.product_id, ml.location_id, -qty_to_decrease, lot_id=False, package_id=ml.package_id, owner_id=ml.owner_id)
-                        Quant._decrease_reserved_quantity(ml.product_id, ml.location_id, ml.product_qty, lot_id=ml.lot_id, package_id=ml.package_id, owner_id=ml.owner_id)
+                        Quant._update_reserved_quantity(ml.product_id, ml.location_id, -ml.product_qty, lot_id=ml.lot_id, package_id=ml.package_id, owner_id=ml.owner_id)
-                            Quant._decrease_reserved_quantity(ml.product_id, ml.location_id, ml.product_qty, lot_id=False, package_id=ml.package_id, owner_id=ml.owner_id)
+                            Quant._update_reserved_quantity(ml.product_id, ml.location_id, -ml.product_qty, lot_id=False, package_id=ml.package_id, owner_id=ml.owner_id)
-                        q = Quant._increase_reserved_quantity(ml.product_id, updates.get('location_id', ml.location_id), ml.product_qty, lot_id=updates.get('lot_id', ml.lot_id),
+                        q = Quant._update_reserved_quantity(ml.product_id, updates.get('location_id', ml.location_id), ml.product_qty, lot_id=updates.get('lot_id', ml.lot_id),
-                                q = Quant._increase_reserved_quantity(ml.product_id, updates.get('location_id', ml.location_id), ml.product_qty, lot_id=False,
+                                q = Quant._update_reserved_quantity(ml.product_id, updates.get('location_id', ml.location_id), ml.product_qty, lot_id=False,
-                    Quant._decrease_available_quantity(ml.product_id, ml.location_dest_id, ml.qty_done, lot_id=ml.lot_id,
+                    Quant._update_available_quantity(ml.product_id, ml.location_dest_id, -ml.qty_done, lot_id=ml.lot_id,
-                    Quant._increase_available_quantity(ml.product_id, ml.location_id, ml.qty_done, lot_id=ml.lot_id,
+                    Quant._update_available_quantity(ml.product_id, ml.location_id, ml.qty_done, lot_id=ml.lot_id,
-                    available_qty = Quant._decrease_available_quantity(product_id, location_id, quantity, lot_id=lot_id, package_id=package_id, owner_id=owner_id)
+                    available_qty = Quant._update_available_quantity(product_id, location_id, -quantity, lot_id=lot_id, package_id=package_id, owner_id=owner_id)
-                            Quant._increase_available_quantity(product_id, location_id, taken_from_untracked_qty, lot_id=lot_id, package_id=package_id, owner_id=owner_id)
+                            Quant._update_available_quantity(product_id, location_id, -taken_from_untracked_qty, lot_id=False, package_id=package_id, owner_id=owner_id)
-                    Quant._increase_available_quantity(product_id, location_dest_id, quantity, lot_id=lot_id, package_id=result_package_id, owner_id=owner_id)
+                    Quant._update_available_quantity(product_id, location_dest_id, quantity, lot_id=lot_id, package_id=result_package_id, owner_id=owner_id)
-                self.env['stock.quant']._decrease_reserved_quantity(ml.product_id, ml.location_id, ml.product_qty, lot_id=ml.lot_id,
+                self.env['stock.quant']._update_reserved_quantity(ml.product_id, ml.location_id, -ml.product_qty, lot_id=ml.lot_id,
-                        Quant._decrease_reserved_quantity(ml.product_id, ml.location_id, ml.product_qty, lot_id=ml.lot_id, package_id=ml.package_id, owner_id=ml.owner_id)
+                        Quant._update_reserved_quantity(ml.product_id, ml.location_id, -ml.product_qty, lot_id=ml.lot_id, package_id=ml.package_id, owner_id=ml.owner_id)
-                        Quant._decrease_reserved_quantity(ml.product_id, ml.location_id, ml.product_qty, lot_id=False, package_id=ml.package_id, owner_id=ml.owner_id)
+                        Quant._update_reserved_quantity(ml.product_id, ml.location_id, -ml.product_qty, lot_id=False, package_id=ml.package_id, owner_id=ml.owner_id)
-                    available_qty = Quant._decrease_available_quantity(ml.product_id, ml.location_id, quantity, lot_id=ml.lot_id, package_id=ml.package_id, owner_id=ml.owner_id)
+                    available_qty = Quant._update_available_quantity(ml.product_id, ml.location_id, -quantity, lot_id=ml.lot_id, package_id=ml.package_id, owner_id=ml.owner_id)
-                            Quant._increase_available_quantity(ml.product_id, ml.location_id, taken_from_untracked_qty, lot_id=ml.lot_id, package_id=ml.package_id, owner_id=ml.owner_id)
+                            Quant._update_available_quantity(ml.product_id, ml.location_id, -taken_from_untracked_qty, lot_id=False, package_id=ml.package_id, owner_id=ml.owner_id)
-                    Quant._increase_available_quantity(ml.product_id, ml.location_dest_id, quantity, lot_id=ml.lot_id, package_id=ml.result_package_id, owner_id=ml.owner_id)
+                    Quant._update_available_quantity(ml.product_id, ml.location_dest_id, quantity, lot_id=ml.lot_id, package_id=ml.result_package_id, owner_id=ml.owner_id)
-    def _increase_available_quantity(self, product_id, location_id, quantity, lot_id=None, package_id=None, owner_id=None, strict=True):
+    def _update_available_quantity(self, product_id, location_id, quantity, lot_id=None, package_id=None, owner_id=None, strict=True):
-    def _increase_reserved_quantity(self, product_id, location_id, quantity, lot_id=None, package_id=None, owner_id=None, strict=False):
+    def _update_reserved_quantity(self, product_id, location_id, quantity, lot_id=None, package_id=None, owner_id=None, strict=False):
-        self.env['stock.quant']._increase_available_quantity(self.product1, self.stock_location, 100)
+        self.env['stock.quant']._update_available_quantity(self.product1, self.stock_location, 100)
-        self.env['stock.quant']._increase_available_quantity(self.product1, self.stock_location, 100)
+        self.env['stock.quant']._update_available_quantity(self.product1, self.stock_location, 100)
-        self.env['stock.quant']._increase_available_quantity(self.product3, self.stock_location, 3, lot_id=lot1)
+        self.env['stock.quant']._update_available_quantity(self.product3, self.stock_location, 2)
-        self.env['stock.quant']._increase_available_quantity(self.product2, self.stock_location, 1, lot_id=lot2)
+        self.env['stock.quant']._update_available_quantity(self.product2, self.stock_location, 2)
-        self.env['stock.quant']._increase_available_quantity(self.product2, self.stock_location, 1, lot_id=lot2)
+        self.env['stock.quant']._update_available_quantity(self.product2, self.stock_location, 1, lot_id=lot1)
-        self.env['stock.quant']._increase_available_quantity(self.product2, self.stock_location, 2)
+        self.env['stock.quant']._update_available_quantity(self.product2, self.stock_location, 2)
-        self.env['stock.quant']._increase_available_quantity(self.product2, self.stock_location, 1, lot_id=lot2)
+        self.env['stock.quant']._update_available_quantity(self.product2, self.stock_location, 1, lot_id=lot1)
-        self.env['stock.quant']._increase_available_quantity(self.product2, self.stock_location, 1)
+        self.env['stock.quant']._update_available_quantity(self.product2, self.stock_location, 1)
-        self.env['stock.quant']._increase_available_quantity(self.product2, self.stock_location, 1.0)
+        self.env['stock.quant']._update_available_quantity(self.product2, self.stock_location, 1.0)
-        self.env['stock.quant']._increase_available_quantity(self.product2, self.stock_location, 1.0)
+        self.env['stock.quant']._update_available_quantity(self.product2, self.stock_location, 1.0)
-        self.env['stock.quant']._increase_available_quantity(self.product1, self.stock_location, 150.0)
+        self.env['stock.quant']._update_available_quantity(self.product1, self.stock_location, 150.0)
-        self.env['stock.quant']._increase_available_quantity(self.product1, self.stock_location, 50.0)
+        self.env['stock.quant']._update_available_quantity(self.product1, self.stock_location, 50.0)
-        self.env['stock.quant']._increase_available_quantity(self.product1, self.stock_location, 150.0)
+        self.env['stock.quant']._update_available_quantity(self.product1, self.stock_location, 150.0)
-        self.env['stock.quant']._increase_available_quantity(self.product1, self.stock_location, 150.0, package_id=package1)
+        self.env['stock.quant']._update_available_quantity(self.product1, self.stock_location, 150.0, package_id=package1)
-        self.env['stock.quant']._increase_available_quantity(self.product1, self.stock_location, 2)
+        self.env['stock.quant']._update_available_quantity(self.product1, self.stock_location, 2)
-        self.env['stock.quant']._increase_available_quantity(self.product1, self.stock_location, 2)
+        self.env['stock.quant']._update_available_quantity(self.product1, self.stock_location, 2)
-        self.env['stock.quant']._increase_available_quantity(self.product1, self.stock_location, 1.0)
+        self.env['stock.quant']._update_available_quantity(self.product1, self.stock_location, 1.0)
-        self.env['stock.quant']._increase_available_quantity(self.product1, self.stock_location, 1.0, lot_id=lot1)
+        self.env['stock.quant']._update_available_quantity(self.product1, self.stock_location, 1.0, lot_id=lot1)
-        self.env['stock.quant']._increase_available_quantity(self.product1, self.stock_location, 2.0)
+        self.env['stock.quant']._update_available_quantity(self.product1, self.stock_location, 2.0)
-        self.env['stock.quant']._increase_available_quantity(self.product1, self.stock_location, 2.0, lot_id=lot1)
+        self.env['stock.quant']._update_available_quantity(self.product1, self.stock_location, 2.0, lot_id=lot1)
-        self.env['stock.quant']._increase_available_quantity(self.product1, self.stock_location, 2.0)
+        self.env['stock.quant']._update_available_quantity(self.product1, self.stock_location, 2.0)
-        self.env['stock.quant']._increase_available_quantity(self.product1, self.stock_location, 1.0)
+        self.env['stock.quant']._update_available_quantity(self.product1, self.stock_location, 1.0)
-        self.env['stock.quant']._increase_available_quantity(self.product1, self.stock_location, 1.0, lot_id=lot1)
+        self.env['stock.quant']._update_available_quantity(self.product1, self.stock_location, 1.0, lot_id=lot1)
-        self.env['stock.quant']._increase_available_quantity(self.product1, shelf2_location, 1.0)
+        self.env['stock.quant']._update_available_quantity(self.product1, shelf1_location, 1.0)
-        self.env['stock.quant']._increase_available_quantity(self.product1, self.stock_location, 1.0, lot_id=lot2)
+        self.env['stock.quant']._update_available_quantity(self.product1, self.stock_location, 1.0, lot_id=lot1)
-        self.env['stock.quant']._increase_available_quantity(self.product1, self.stock_location, 1.0, package_id=package2)
+        self.env['stock.quant']._update_available_quantity(self.product1, self.stock_location, 1.0, package_id=package1)
-        self.env['stock.quant']._increase_available_quantity(self.product1, self.stock_location, 1.0, owner_id=owner2)
+        self.env['stock.quant']._update_available_quantity(self.product1, self.stock_location, 1.0, owner_id=owner1)
-        self.env['stock.quant']._increase_available_quantity(self.product1, self.stock_location, 1.0, lot_id=lot2)
+        self.env['stock.quant']._update_available_quantity(self.product1, self.stock_location, 1.0, lot_id=lot1, package_id=package1)
-        self.env['stock.quant']._increase_available_quantity(self.product1, shelf1_location, 1.0)
+        self.env['stock.quant']._update_available_quantity(self.product1, shelf1_location, 1.0)
-        self.env['stock.quant']._increase_available_quantity(self.product3, self.stock_location, 5)
+        self.env['stock.quant']._update_available_quantity(self.product3, self.stock_location, 5)
-        self.env['stock.quant']._increase_available_quantity(self.product3, self.stock_location, 2, lot_id=lot1)
+        self.env['stock.quant']._update_available_quantity(self.product3, self.stock_location, 3)
-        self.env['stock.quant']._increase_available_quantity(self.product1, shelf2_location, 1.0)
+        self.env['stock.quant']._update_available_quantity(self.product1, shelf1_location, 1.0)
-        self.env['stock.quant']._increase_available_quantity(self.product1, self.stock_location, 1.0, lot_id=lot2)
+        self.env['stock.quant']._update_available_quantity(self.product1, self.stock_location, 1.0, lot_id=lot1)
-        self.env['stock.quant']._increase_available_quantity(self.product1, self.stock_location, 1.0, package_id=package2)
+        self.env['stock.quant']._update_available_quantity(self.product1, self.stock_location, 1.0, package_id=package1)
-        self.env['stock.quant']._increase_available_quantity(self.product1, self.stock_location, 1.0, owner_id=owner2)
+        self.env['stock.quant']._update_available_quantity(self.product1, self.stock_location, 1.0, owner_id=owner1)
-        self.env['stock.quant']._increase_available_quantity(self.product1, self.stock_location, 1.0, lot_id=lot2)
+        self.env['stock.quant']._update_available_quantity(self.product1, self.stock_location, 1.0, lot_id=lot1, package_id=package1)
-        self.env['stock.quant']._increase_available_quantity(self.product1, shelf1_location, 1.0)
+        self.env['stock.quant']._update_available_quantity(self.product1, shelf1_location, 1.0)
-        self.env['stock.quant']._increase_available_quantity(self.product1, shelf2_location, 1.0)
+        self.env['stock.quant']._update_available_quantity(self.product1, shelf1_location, 1.0)
-        self.env['stock.quant']._increase_available_quantity(self.product1, shelf1_location, 1.0)
+        self.env['stock.quant']._update_available_quantity(self.product1, shelf1_location, 1.0)
-        self.env['stock.quant']._increase_available_quantity(self.product1, shelf1_location, 1.0)
+        self.env['stock.quant']._update_available_quantity(self.product1, shelf1_location, 1.0)
-        self.env['stock.quant']._increase_available_quantity(self.product1, self.stock_location, 5.0)
+        self.env['stock.quant']._update_available_quantity(self.product1, self.stock_location, 5.0)
-        self.env['stock.quant']._increase_available_quantity(self.product3, self.stock_location, 5.0, lot_id=lot1)
+        self.env['stock.quant']._update_available_quantity(self.product3, self.stock_location, 5.0, lot_id=lot1)
-        self.env['stock.quant']._increase_available_quantity(self.productA, location, 10.0)
+        self.env['stock.quant']._update_available_quantity(self.productA, location, 10.0)
-        self.env['stock.quant']._increase_available_quantity(self.productA, stock_location, 10.0)
+        self.env['stock.quant']._update_available_quantity(self.productA, stock_location, 10.0)
-        self.env['stock.quant']._increase_available_quantity(self.productA, pack_location, 5.0)
+        self.env['stock.quant']._update_available_quantity(self.productA, pack_location, 5.0)
-        self.env['stock.quant']._increase_available_quantity(self.productA, stock_location, 10.0)
+        self.env['stock.quant']._update_available_quantity(self.productA, stock_location, 10.0)
-        self.env['stock.quant']._increase_available_quantity(self.productA, location, 10.0)
+        self.env['stock.quant']._update_available_quantity(self.productA, location, 10.0)
-        self.env['stock.quant']._increase_available_quantity(self.productA, location, 10.0)
+        self.env['stock.quant']._update_available_quantity(self.productA, location, 10.0)
-        self.env['stock.quant']._increase_available_quantity(self.productA, location, 10.0)
+        self.env['stock.quant']._update_available_quantity(self.productA, location, 10.0)
-        self.env['stock.quant']._increase_available_quantity(self.productA, pack_location, 2)
+        self.env['stock.quant']._update_available_quantity(self.productA, pack_location, 2)
-        self.env['stock.quant']._increase_available_quantity(self.productA, pack_location, 1)
+        self.env['stock.quant']._update_available_quantity(self.productA, pack_location, 1)
-        self.env['stock.quant']._increase_available_quantity(self.productA, pack_location, 1)
+        self.env['stock.quant']._update_available_quantity(self.productA, pack_location, 1)
-        self.env['stock.quant']._increase_available_quantity(self.productA, pack_location, 1)
+        self.env['stock.quant']._update_available_quantity(self.productA, pack_location, 1)
-        self.env['stock.quant']._increase_available_quantity(self.productA, self.env['stock.location'].browse(self.stock_location), 1.0)
+        self.env['stock.quant']._update_available_quantity(self.productA, self.env['stock.location'].browse(self.stock_location), 1.0)
-        self.env['stock.quant']._increase_available_quantity(self.productA, stock_location, 1.0, lot_id=lot1)
+        self.env['stock.quant']._update_available_quantity(self.productA, stock_location, 1.0, lot_id=lot1)
-        self.env['stock.quant']._increase_available_quantity(self.productA, stock_location, 1.0, lot_id=lot1)
+        self.env['stock.quant']._update_available_quantity(self.productA, stock_location, 1.0, lot_id=lot1)
-        self.env['stock.quant']._increase_available_quantity(self.productA, stock_location, 1.0, lot_id=serial1)
+        self.env['stock.quant']._update_available_quantity(self.productA, stock_location, 1.0, lot_id=serial1)
-            self.env['stock.quant']._increase_available_quantity(product1, stock_location, 1.0)
+            self.env['stock.quant']._update_available_quantity(product1, stock_location, 1.0)
-        self.env['stock.quant']._increase_available_quantity(product1, stock_location, 1.0)
+        self.env['stock.quant']._update_available_quantity(product1, stock_location, 1.0)
-        self.env['stock.quant']._increase_available_quantity(product1, stock_location, 1.0)
+        self.env['stock.quant']._update_available_quantity(product1, stock_location, 1.0)
-        self.env['stock.quant']._increase_available_quantity(product, stock_location, 1.0)
+        self.env['stock.quant']._update_available_quantity(product, stock_location, 1.0)
-        self.env['stock.quant']._increase_available_quantity(product1, stock_location, 1.0)
+        self.env['stock.quant']._update_available_quantity(product1, stock_location, 1.0)
-        self.env['stock.quant']._decrease_available_quantity(product1, stock_location, 1.0)
+        self.env['stock.quant']._update_available_quantity(product1, stock_location, -1.0)
-        self.env['stock.quant']._decrease_available_quantity(product1, stock_location, 1.0)
+        self.env['stock.quant']._update_available_quantity(product1, stock_location, -1.0)
-        self.env['stock.quant']._decrease_available_quantity(product, stock_location, 1.0)
+        self.env['stock.quant']._update_available_quantity(product, stock_location, -1.0)
-        self.env['stock.quant']._decrease_available_quantity(product1, stock_location, 1.0)
+        self.env['stock.quant']._update_available_quantity(product1, stock_location, -1.0)
-        self.env['stock.quant']._increase_reserved_quantity(product1, stock_location, 10.0)
+        self.env['stock.quant']._update_reserved_quantity(product1, stock_location, 10.0)
-        self.env['stock.quant']._increase_reserved_quantity(product1, stock_location, 10.0)
+        self.env['stock.quant']._update_reserved_quantity(product1, stock_location, 10.0)
-        self.env['stock.quant']._increase_reserved_quantity(product1, stock_location, 10.0)
+        self.env['stock.quant']._update_reserved_quantity(product1, stock_location, 10.0)
-            self.env['stock.quant']._increase_reserved_quantity(product1, stock_location, 10.0)
+            self.env['stock.quant']._update_reserved_quantity(product1, stock_location, 10.0)
-            self.env['stock.quant']._increase_reserved_quantity(product1, stock_location, 1.0)
+            self.env['stock.quant']._update_reserved_quantity(product1, stock_location, 1.0)
-        self.env['stock.quant']._decrease_reserved_quantity(product1, stock_location, 10.0)
+        self.env['stock.quant']._update_reserved_quantity(product1, stock_location, -10.0)
-            self.env['stock.quant']._increase_reserved_quantity(product1, stock_location, 1.0)
+            self.env['stock.quant']._update_reserved_quantity(product1, stock_location, 1.0)
-            self.env['stock.quant']._decrease_reserved_quantity(product1, stock_location, 1.0)
+            self.env['stock.quant']._update_reserved_quantity(product1, stock_location, -1.0)
-        self.env['stock.quant']._increase_available_quantity(product1, stock_location, 2.0)
+        self.env['stock.quant']._update_available_quantity(product1, stock_location, 2.0)
-        self.env['stock.quant']._increase_reserved_quantity(product1, stock_location, 2.0)
+        self.env['stock.quant']._update_reserved_quantity(product1, stock_location, 2.0)
-        self.env['stock.quant']._decrease_reserved_quantity(product1, stock_location, 2.0)
+        self.env['stock.quant']._update_reserved_quantity(product1, stock_location, -2.0)
-        self.env['stock.quant']._decrease_available_quantity(product1, stock_location, 2.0)
+        self.env['stock.quant']._update_available_quantity(product1, stock_location, -2.0)
-        self.env['stock.quant']._increase_available_quantity(product1, pack_location, 2.0)
+        self.env['stock.quant']._update_available_quantity(product1, pack_location, 2.0)
-        self.env['stock.quant']._increase_available_quantity(product1, stock_location, 1.0, lot_id=lot1)
+        self.env['stock.quant']._update_available_quantity(product1, stock_location, 1.0)
-        self.env['stock.quant']._increase_reserved_quantity(product1, stock_location, 1.0, lot_id=lot1, strict=True)
+        self.env['stock.quant']._update_reserved_quantity(product1, stock_location, 1.0, lot_id=lot1, strict=True)
-        self.env['stock.quant']._decrease_reserved_quantity(product1, stock_location, 1.0, lot_id=lot1, strict=True)
+        self.env['stock.quant']._update_reserved_quantity(product1, stock_location, -1.0, lot_id=lot1, strict=True)
-            self.env['stock.quant']._decrease_reserved_quantity(product1, stock_location, 1.0)
+            self.env['stock.quant']._update_reserved_quantity(product1, stock_location, -1.0)
-    def base_on_rule__get_tracking_link(self, pickings):
+    def base_on_rule_get_tracking_link(self, pickings):
-    def base_on_rule__cancel_shipment(self, pickings):
+    def base_on_rule_cancel_shipment(self, pickings):
-        readonly=True, required=True)
+    company_id = fields.Many2one(related='location_id.company_id',
-            raise ValidationError(_('Quants cannot be created for consumables.'))
+        if any(elem.product_id.type != 'product' for elem in self):
-    def _get_field_data(self, model_name):
+    @tools.ormcache('model_name')
-        return self._all_field_data()[model_name]
+        cr = self._cr
-        fields_data = self._get_field_data(field.model_name)
+        fields_data = self._existing_field_data(field.model_name)
-            fields_data = self._get_field_data(model._name)
+            fields_data = self._existing_field_data(model._name)
-                    field_data['relation_field'] in self._get_field_data(field_data['relation'])
+                    field_data['relation_field'] in self._existing_field_data(field_data['relation'])
-        fields_data = self._get_field_data(model._name)
+        fields_data = self._existing_field_data(model._name)
-        employee = self.employee_id
+    def _get_users_to_subscribe(self, employee=False):
-            user_ids.append(employee.user_id.id)
+            users |= employee.user_id
-            user_ids.append(employee.parent_id.user_id.id)
+            users |= employee.parent_id.user_id
-        self.message_subscribe_users(user_ids=user_ids)
+            users |= employee.department_id.manager_id.user_id
-        sys.meta_path.append(OdooHook())
+        sys.meta_path.insert(0, OdooHook())
-            end_time = day.date() == end_dt.date() and end_dt.time() or datetime.time.max
+            start_time = datetime.time.min
-            end_time = day.date() == end_dt.date() and end_dt.time() or datetime.time.max
+            start_time = datetime.time.min
-        etag = hasattr(request, 'httprequest') and request.httprequest.headers.get('If-None-Match')
+        etag = bool(request) and request.httprequest.headers.get('If-None-Match')
-        users = [[] for i in range(len(user_obj) / 3 + 1)]
+        users = [[] for i in range(len(user_obj) // 3 + 1)]
-            users[index / 3].append(user)
+            users[index // 3].append(user)
-            while not self._check_place(pos % PPR, pos / PPR, x, y):
+            while not self._check_place(pos % PPR, pos // PPR, x, y):
-            if index >= ppg and ((pos + 1.0) / PPR) > maxy:
+            if index >= ppg and ((pos + 1.0) // PPR) > maxy:
-                minpos = pos / PPR
+                minpos = pos // PPR
-            self.table[pos / PPR][pos % PPR] = {
+                    self.table[(pos // PPR) + y2][(pos % PPR) + x2] = False
-                maxy = max(maxy, y + (pos / PPR))
+                maxy = max(maxy, y + (pos // PPR))
-        return {product.id: product.website_price / add_qty for product in products}
+        return {product.id: product.website_price // add_qty for product in products}
-        qs = ps[:len(ps) / 2] + ps[len(ps) / 2:]
+        qs = ps[:len(ps) // 2] + ps[len(ps) // 2:]
-    image.paste(resized_image, ((size[0] - resized_image.size[0]) / 2, (size[1] - resized_image.size[1]) / 2))
+    image.paste(resized_image, ((size[0] - resized_image.size[0]) // 2, (size[1] - resized_image.size[1]) // 2))
-        new_h = (w * h_ratio) / w_ratio
+        new_h = (w * h_ratio) // w_ratio
-            new_w = (h * w_ratio) / h_ratio
+            new_w = (h * w_ratio) // h_ratio
-        cropped_image = image_stream.crop(((w - new_w) / 2, (h - new_h) / 2, (w + new_w) / 2, (h + new_h) / 2))
+        cropped_image = image_stream.crop(((w - new_w) // 2, (h - new_h) // 2, (w + new_w) // 2, (h + new_h) // 2))
-        thumb_image.thumbnail((new_w / thumbnail_ratio, new_h / thumbnail_ratio), Image.ANTIALIAS)
+        thumb_image.thumbnail((new_w // thumbnail_ratio, new_h // thumbnail_ratio), Image.ANTIALIAS)
-            lock_date = max(move.company_id.period_lock_date, move.company_id.fiscalyear_lock_date)
+            lock_date = max(move.company_id.period_lock_date or '0000-00-00', move.company_id.fiscalyear_lock_date or '0000-00-00')
-            if move.date <= lock_date:
+            if move.date <= (lock_date or '0000-00-00'):
-        maxdate = None
+        maxdate = '0000-00-00'
-        if move_date > self.company_id.fiscalyear_lock_date:
+        if (move_date or '0000-00-00' > self.company_id.fiscalyear_lock_date or '0000-00-00'):
-        maxdate = None
+        maxdate = '0000-00-00'
-        partners = sorted(partners, key=lambda x: (x.ref, x.name))
+        partners = sorted(partners, key=lambda x: (x.ref or '', x.name or ''))
-        if vals.get('probability') >= 100 or not vals.get('active', True):
+        if vals.get('probability', 0) >= 100 or not vals.get('active', True):
-        elif 'probability' in vals and vals['probability'] < 100:
+        elif 'probability' in vals:
-            'parent_model': subtype.parent_id and subtype.parent_id.res_model or False,
+            'parent_model': subtype.parent_id.res_model,
-        subtypes_list = sorted(subtypes_list, key=itemgetter('parent_model', 'res_model', 'internal', 'sequence'))
+        subtypes_list = sorted(subtypes_list, key=lambda it: (it['parent_model'] or '', it['res_model'] or '', it['internal'], it['sequence']))
-            if invoice_line.invoice_id.date_invoice > date_from and invoice_line.invoice_id.date_invoice < date_to:
+            date_from = invoice_line.product_id.membership_date_from or '0000-00-00'
-        self.assertEqual(prp_result, answers, msg="Statistics of simple, multiple choice questions are different from expectation")
+        self.assertItemsEqual(prp_result, answers, msg="Statistics of simple, multiple choice questions are different from expectation")
-    padding = None
+    padding = 0
-            padding = None
+            padding = 0
-            if self.published_date <= fields.Datetime.now():
+            if (self.published_date or '') <= fields.Datetime.now():
-                countries.sort(key=lambda d: d['country_id'] and d['country_id'][1])
+                    countries.sort(key=lambda d: (d['country_id'] or (0, ""))[1])
-        for track in event.track_ids.sorted(lambda track: (track.date, bool(track.location_id))):
+        for track in event.track_ids.sorted(lambda track: (track.date or '', bool(track.location_id))):
-        self.assertSequenceEqual(sorted(gb, key=lambda r: r['date']), [{
+        self.assertSequenceEqual(sorted(gb, key=lambda r: r['date'] or ''), [{
-        result = round(amount, self.currency_id.decimal_places) * -1
+        result = self.currency_id.round(amount) * -1
-                amt = round(line.value_amount, prec)
+                amt = currency.round(line.value_amount)
-                amt = round(value * (line.value_amount / 100.0), prec)
+                amt = currency.round(value * (line.value_amount / 100.0))
-                amt = round(amount, prec)
+                amt = currency.round(amount)
-        dist = round(value - amount, prec)
+        dist = currency.round(value - amount)
-                        line.update({'price': round(valuation_price_unit * line['quantity'], account_prec)})
+                        line.update({'price': company_currency.round(valuation_price_unit * line['quantity'])})
-                            'price_unit': round(price_unit - valuation_price_unit, account_prec),
+                            'price_unit': company_currency.round(price_unit - valuation_price_unit),
-                            'price': round(price_before - line.get('price', 0.0), account_prec),
+                            'price': company_currency.round(price_before - line.get('price', 0.0)),
-
+from odoo.tools import pycompat
-            days_count += round((work_time.total_seconds() / 3600 / theoric_hours) * 4) / 4
+            days_count += pycompat.round((work_time.total_seconds() / 3600 / theoric_hours) * 4) / 4
-            days_count += round((leave_time.total_seconds()/3600 / theoric_hours) * 4) / 4
+            days_count += pycompat.round((leave_time.total_seconds() / 3600 / theoric_hours) * 4) / 4
-        return round(price, self.invoice_id.currency_id.decimal_places)
+        return self.invoice_id.currency_id.round(price)
-        rounded_value = round(normalized_value) # round to integer
+        rounded_value = pycompat.round(normalized_value) # round to integer
-            res = res + [{'exact_price': p.carrier_id._get_price_available(p.sale_id),  # TODO cleanme
+            res = res + [{'exact_price': p.carrier_id._get_price_available(p.sale_id) if p.sale_id else 0.0,  # TODO cleanme
-            for line in order.lines.filtered(lambda l: l.product_id.type in ['product', 'consu']):
+            for line in order.lines.filtered(lambda l: l.product_id.type in ['product', 'consu'] and not float_is_zero(l.qty, precision_digits=l.product_id.uom_id.rounding)):
-                qcontext.update(values)
+            editable = request.website.is_publisher()
-                if qcontext.get('editable'):
+            if not translatable and not self.env.context.get('rendering_bundle'):
-        return qcontext
+        qcontext = super(View, self)._prepare_qcontext()
-            request=request, # might be unbound if we're not in an httprequest context
+            request=request,  # might be unbound if we're not in an httprequest context
-        return self.env[engine].render(self.id, qcontext)
+        return qcontext
-            request.uid = request.session.uid
+        if not request.uid:
-from odoo import fields, models, tools
+from odoo import fields, models, tools, api
-        tools.drop_view_if_exists(self._cr, 'crm_activity_report')
+        tools.drop_view_if_exists(self._cr, self._table)
-            )""")
+            CREATE OR REPLACE VIEW %s AS (
-        r = requests.get(url, data=params, timeout=self.TIMEOUT)
+        r = requests.post(url, data=params, timeout=self.TIMEOUT)
-        return self.env['product.product'].browse(product_id)
+        return self.env['product.product'].browse(int(product_id))
-        help='This value is given by the sum of all holidays requests with a positive value.')
+        help='This value is given by the sum of all leaves requests with a positive value.')
-        help='This value is given by the sum of all holidays requests with a negative value.')
+        help='This value is given by the sum of all leaves requests with a negative value.')
-            "\nThe status is 'Approved', when holiday request is approved by manager.")
+            help="The status is set to 'To Submit', when a leave request is created." +
-            sale_show_tax=self.group_show_price_total and 'total' or 'subtotal',
+            sale_show_tax=self.env['ir.config_parameter'].sudo().get_param('sale.sale_show_tax', default='subtotal'),
-            self.stage_id = self.stage_find(self.project_id.id, [('fold', '=', False)])
+            if self.project_id not in self.stage_id.project_ids:
-            self.stage_id = self.stage_find(self.project_id.id, [('fold', '=', False)])
+            if self.project_id not in self.stage_id.project_ids:
-            raise UserError(_("Some data are missing, this report cannot be printed."))
+            raise UserError(_("Form content is missing, this report cannot be printed."))
-            raise UserError(_("Some data are missing, this report cannot be printed."))
+            raise UserError(_("Form content is missing, this report cannot be printed."))
-            raise UserError(_("Some data are missing, this report cannot be printed."))
+            raise UserError(_("Form content is missing, this report cannot be printed."))
-            raise UserError(_("Some data are missing, this report cannot be printed."))
+            raise UserError(_("Form content is missing, this report cannot be printed."))
-            raise UserError(_("Some data are missing, this report cannot be printed."))
+            raise UserError(_("Form content is missing, this report cannot be printed."))
-            raise UserError(_("Some data are missing, this report cannot be printed."))
+            raise UserError(_("Form content is missing, this report cannot be printed."))
-            raise UserError(_("Some data are missing, this report cannot be printed."))
+            raise UserError(_("Form content is missing, this report cannot be printed."))
-            raise UserError(_("Some data are missing, this report cannot be printed."))
+            raise UserError(_("Form content is missing, this report cannot be printed."))
-            raise UserError(_("Some data are missing, this report cannot be printed."))
+            raise UserError(_("Form content is missing, this report cannot be printed."))
-            raise UserError(_("Some data are missing, this report cannot be printed."))
+            raise UserError(_("Form content is missing, this report cannot be printed."))
-                currency = self.currency_id.with_context(date=self.date_invoice or fields.Date.context_today(self))
+                currency = self.currency_id.with_context(date=self.date or self.date_invoice or fields.Date.context_today(self))
-                totlines = inv.with_context(ctx).payment_term_id.with_context(currency_id=company_currency.id).compute(total, date_invoice)[0]
+                totlines = inv.with_context(ctx).payment_term_id.with_context(currency_id=company_currency.id).compute(total, inv.date_invoice)[0]
-                ctx['date'] = date_invoice
+                ctx['date'] = inv.date or inv.date_invoice
-            date = inv.date or date_invoice
+            date = inv.date or inv.date_invoice
-            self.env['account.journal'].create({
+            bank_journals += self.env['account.journal'].create({
-version_info = (11, 0, 0, ALPHA, 1, '')
+version_info = (10, 'saas~17', 0, FINAL, 0, '')
-    _inherit = 'stock.pack.operation'
+class StockMoveLine(models.Model):
-    @api.depends('pack_operation_ids')
+    @api.depends('move_line_ids')
-                packs.add(packop.result_package_id.id)
+        for move_line in self.move_line_ids:
-    @api.depends('pack_operation_ids')
+    @api.depends('move_line_ids')
-                weight += packop.product_uom_id._compute_quantity(packop.product_qty, packop.product_id.uom_id) * packop.product_id.weight
+        for move_line in self.move_line_ids:
-            total_weight = sum([po.qty_done * po.product_id.weight for po in pack_operation_ids])
+            move_line_ids = [po for po in picking_id.move_line_ids if po.qty_done > 0 and not po.result_package_id]
-            moves_raw.mapped('pack_operation_ids').write({'workorder_id': workorder.id})
+            moves_raw.mapped('move_line_ids').write({'workorder_id': workorder.id})
-            self.env['stock.pack.operation'].create({
+            self.env['stock.move.line'].create({
-                self.env['stock.pack.operation'].create({
+                self.env['stock.move.line'].create({
-        'stock.pack.operation', 'workorder_id', 'Moves to Track',
+        'stock.move.line', 'workorder_id', 'Moves to Track',
-        'stock.pack.operation', 'workorder_id',
+        'stock.move.line', 'workorder_id',
-                        self.active_move_line_ids += self.env['stock.pack.operation'].new({
+                        self.active_move_line_ids += self.env['stock.move.line'].new({
-        MoveLine = self.env['stock.pack.operation']
+        MoveLine = self.env['stock.move.line']
-                move_line = production_move.pack_operation_ids.filtered(lambda x: x.lot_id.id == self.final_lot_id.id)
+                move_line = production_move.move_line_ids.filtered(lambda x: x.lot_id.id == self.final_lot_id.id)
-    _inherit = 'stock.pack.operation'
+class StockMoveLine(models.Model):
-                movelot.move_id.production_id.move_raw_ids.mapped('pack_operation_ids')\
+                movelot.move_id.production_id.move_raw_ids.mapped('move_line_ids')\
-        return super(StockPackOperation, self).write(vals)
+        return super(StockMoveLine, self).write(vals)
-    active_move_line_ids = fields.One2many('stock.pack.operation', 'move_id', domain=[('done_wo', '=', True)], string='Lots')
+    active_move_line_ids = fields.One2many('stock.move.line', 'move_id', domain=[('done_wo', '=', True)], string='Lots')
-                move.pack_operation_ids.write({'production_id': move.raw_material_production_id.id, 
+            if move.move_line_ids:
-        show_reserved = any([x for x in self.pack_operation_ids if x.product_qty > 0.0])
+        show_reserved = any([x for x in self.move_line_ids if x.product_qty > 0.0])
-                moves_raw.mapped('pack_operation_ids').write({'workorder_id': wo.id})
+                moves_raw.mapped('move_line_ids').write({'workorder_id': wo.id})
-                if not move.pack_operation_ids.filtered(lambda x: not x.lot_produced_id):
+                if not move.move_line_ids.filtered(lambda x: not x.lot_produced_id):
-                    existing_lines += move.pack_operation_ids.filtered(lambda x: not x.lot_produced_id).ids
+                    existing_lines += move.move_line_ids.filtered(lambda x: not x.lot_produced_id).ids
-    consume_line_ids = fields.Many2many('stock.pack.operation', 'mrp_produce_stock_pack_operation', string='Product to Track')
+    consume_line_ids = fields.Many2many('stock.move.line', 'mrp_produce_stock_move_line', string='Product to Track')
-        packs = self.env['stock.pack.operation']
+        packs = self.env['stock.move.line']
-            existing_move_line = produce_move.pack_operation_ids.filtered(lambda x: x.lot_id == self.lot_id)
+            existing_move_line = produce_move.move_line_ids.filtered(lambda x: x.lot_id == self.lot_id)
-                for moveline in move.pack_operation_ids.filtered(lambda x: not x.lot_produced_id):
+                for moveline in move.move_line_ids.filtered(lambda x: not x.lot_produced_id):
-                                           'lot_id': operation.lot_id.id,
+                    'move_line_ids': [(0, 0, {'product_id': operation.product_id.id,
-                                           'lot_id': repair.lot_id.id,
+                'move_line_ids': [(0, 0, {'product_id': repair.product_id.id,
-                    self.env['stock.pack.operation'].create({
+                    self.env['stock.move.line'].create({
-        for ml in self.picking.pack_operation_ids:
+        for ml in self.picking.move_line_ids:
-        self.picking.pack_operation_ids.write({'qty_done': 5.0})
+        self.picking.move_line_ids.write({'qty_done': 5.0})
-        self.picking.pack_operation_ids.write({'qty_done': 5.0})
+        self.picking.move_line_ids.write({'qty_done': 5.0})
-        return_pick.pack_operation_ids.write({'qty_done': 2})
+        return_pick.move_line_ids.write({'qty_done': 2})
-from . import stock_pack_operation
+from . import stock_move_line
-            'pack_operation_ids': [(0, 0, {'product_id': self.product_id.id,
+            'move_line_ids': [(0, 0, {'product_id': self.product_id.id,
-    pack_operation_nosuggest_ids = fields.One2many('stock.pack.operation', 'move_id', domain=[('product_qty', '=', 0.0)])
+    move_line_ids = fields.One2many('stock.move.line', 'move_id')
-    @api.depends('has_tracking', 'pack_operation_ids', 'location_id', 'location_dest_id', 'is_editable')
+    @api.depends('has_tracking', 'move_line_ids', 'location_id', 'location_dest_id', 'is_editable')
-            has_package = move.pack_operation_ids.mapped('package_id') | move.pack_operation_ids.mapped('result_package_id')
+            has_package = move.move_line_ids.mapped('package_id') | move.move_line_ids.mapped('result_package_id')
-                    and (multi_locations_enabled or move.has_tracking != 'none' or len(move.pack_operation_ids) > 1 or has_package):
+                    and (multi_locations_enabled or move.has_tracking != 'none' or len(move.move_line_ids) > 1 or has_package):
-        return self.pack_operation_ids
+        return self.move_line_ids
-    @api.depends('pack_operation_ids.qty_done', 'pack_operation_ids.product_uom_id')
+    @api.depends('move_line_ids.qty_done', 'move_line_ids.product_uom_id')
-                    move.write({'pack_operation_ids': [(4, move_line.id)]})
+                    move_line = self.env['stock.move.line'].create(dict(move._prepare_move_line_vals(), qty_done=quantity_done))
-    @api.depends('pack_operation_ids.product_qty')
+    @api.depends('move_line_ids.product_qty')
-        self.reserved_availability = self.product_id.uom_id._compute_quantity(sum(self.pack_operation_ids.mapped('product_qty')), self.product_uom, rounding_method='HALF-UP')
+        self.reserved_availability = self.product_id.uom_id._compute_quantity(sum(self.move_line_ids.mapped('product_qty')), self.product_uom, rounding_method='HALF-UP')
-        # reserved move lines. We do this by displaying `pack_operation_nosuggest_ids`. We use
+        # reserved move lines. We do this by displaying `move_line_nosuggest_ids`. We use
-    def check_tracking(self, pack_operation):
+    def check_tracking(self, move_line):
-                    not (move.restrict_lot_id or (pack_operation and (pack_operation.product_id and pack_operation.pack_lot_ids)) or (pack_operation and not pack_operation.product_id)):
+                    not (move.restrict_lot_id or (move_line and (move_line.product_id and move_line.pack_lot_ids)) or (move_line and not move_line.product_id)):
-            to_update = self.pack_operation_ids.filtered(lambda m: m.location_id.id == reserved_quant.location_id.id and m.lot_id.id == reserved_quant.lot_id.id and m.package_id.id == reserved_quant.package_id.id and m.owner_id.id == reserved_quant.owner_id.id)
+            to_update = self.move_line_ids.filtered(lambda m: m.location_id.id == reserved_quant.location_id.id and m.lot_id.id == reserved_quant.lot_id.id and m.package_id.id == reserved_quant.package_id.id and m.owner_id.id == reserved_quant.owner_id.id)
-                        self.env['stock.pack.operation'].create(self._prepare_move_line_vals(quantity=1, reserved_quant=reserved_quant))
+                        self.env['stock.move.line'].create(self._prepare_move_line_vals(quantity=1, reserved_quant=reserved_quant))
-                    self.env['stock.pack.operation'].create(self._prepare_move_line_vals(quantity=quantity, reserved_quant=reserved_quant))
+                    self.env['stock.move.line'].create(self._prepare_move_line_vals(quantity=quantity, reserved_quant=reserved_quant))
-                        move.write({'pack_operation_ids': [(4, move_line_id.id, 0)]})
+                        move_line_id = self.env['stock.move.line'].create(move._prepare_move_line_vals(quantity=1))
-                    move.write({'pack_operation_ids': [(4, move_line_id.id, 0)]})
+                    move_line_id = self.env['stock.move.line'].create(move._prepare_move_line_vals(quantity=move.product_qty))
-                    move_lines_in = move.move_orig_ids.filtered(lambda m: m.state == 'done').mapped('pack_operation_ids')
+                    move_lines_in = move.move_orig_ids.filtered(lambda m: m.state == 'done').mapped('move_line_ids')
-                        grouped_move_lines_in[k] = sum(self.env['stock.pack.operation'].concat(*list(g)).mapped('qty_done'))
+                        grouped_move_lines_in[k] = sum(self.env['stock.move.line'].concat(*list(g)).mapped('qty_done'))
-                        .mapped('pack_operation_ids')
+                        .mapped('move_line_ids')
-                        .mapped('pack_operation_ids')
+                        .mapped('move_line_ids')
-                        grouped_move_lines_out[k] = sum(self.env['stock.pack.operation'].concat(*list(g)).mapped('qty_done'))
+                        grouped_move_lines_out[k] = sum(self.env['stock.move.line'].concat(*list(g)).mapped('qty_done'))
-                        grouped_move_lines_out[k] = sum(self.env['stock.pack.operation'].concat(*list(g)).mapped('product_qty'))
+                        grouped_move_lines_out[k] = sum(self.env['stock.move.line'].concat(*list(g)).mapped('product_qty'))
-                        need = move.product_qty - sum(move.pack_operation_ids.mapped('product_qty'))
+                        need = move.product_qty - sum(move.move_line_ids.mapped('product_qty'))
-            for move_line in self.pack_operation_ids.filtered(lambda ml: ml.qty_done):
+            for move_line in self.move_line_ids.filtered(lambda ml: ml.qty_done):
-                for move_line in move.pack_operation_ids:
+                for move_line in move.move_line_ids:
-                move.pack_operation_ids.filtered(lambda x: x.qty_done == 0.0).write({'move_id': new_move})
+                move.move_line_ids.filtered(lambda x: x.qty_done == 0.0).write({'move_id': new_move})
-            for packop in move.pack_operation_ids:
+            for packop in move.move_line_ids:
-                        'pack_operation_ids': [],
+                        'move_line_ids': [],
-    _name = "stock.pack.operation" #TODO: change to stock.move.operation
+class StockMoveLine(models.Model):
-        ml = super(PackOperation, self).create(vals)
+        ml = super(StockMoveLine, self).create(vals)
-            return super(PackOperation, self).write(vals)
+            return super(StockMoveLine, self).write(vals)
-        res = super(PackOperation, self).write(vals)
+        res = super(StockMoveLine, self).write(vals)
-        return super(PackOperation, self).unlink()
+        return super(StockMoveLine, self).unlink()
-            oudated_candidates = self.env['stock.pack.operation'].search(oudated_move_lines_domain)
+            oudated_candidates = self.env['stock.move.line'].search(oudated_move_lines_domain)
-        'stock.pack.operation', 'picking_id', 'Operations',
+    move_line_ids = fields.One2many(
-        'Has Pack Operations', compute='_compute_pack_operation_exist',
+    move_line_exist = fields.Boolean(
-        self.pack_operation_exist = bool(self.pack_operation_ids)
+    def _compute_move_line_exist(self):
-        for pack_op in self.pack_operation_ids:
+        for pack_op in self.move_line_ids:
-        self.pack_operation_ids.write({'owner_id': self.owner_id.id})
+        self.move_line_ids.write({'owner_id': self.owner_id.id})
-            # for ops in pick.pack_operation_ids.filtered(lambda x: not x.move_id and not x.product_id):
+            # for ops in pick.move_line_ids.filtered(lambda x: not x.move_id and not x.product_id):
-            #         self.pack_operation_ids.create({'product_id': quant.product_id.id,
+            #         self.move_line_ids.create({'product_id': quant.product_id.id,
-            for ops in pick.pack_operation_ids.filtered(lambda x: not x.move_id):
+            for ops in pick.move_line_ids.filtered(lambda x: not x.move_id):
-            origin_packages = picking.pack_operation_ids.mapped("package_id")
+            origin_packages = picking.move_line_ids.mapped("package_id")
-                packops = picking.pack_operation_ids.filtered(lambda x: x.package_id == pack)
+                packops = picking.move_line_ids.filtered(lambda x: x.package_id == pack)
-                    grouped_ops[k] = sum(self.env['stock.pack.operation'].concat(*list(g)).mapped('product_qty'))
+                    grouped_ops[k] = sum(self.env['stock.move.line'].concat(*list(g)).mapped('product_qty'))
-        if not self.move_lines and not self.pack_operation_ids:
+        move_line_delete = self.env['stock.move.line']
-        if self.state == 'draft' or all([x.qty_done == 0.0 for x in self.pack_operation_ids]):
+        if self.state == 'draft' or all([x.qty_done == 0.0 for x in self.move_line_ids]):
-                for pack in self.pack_operation_ids:
+                for pack in self.move_line_ids:
-        for operation in self.pack_operation_ids:
+        for operation in self.move_line_ids:
-            pack_operations_delete.unlink()
+                move_line_delete |= operation
-        for ops in self.pack_operation_ids.filtered(lambda x: x.package_id and not x.product_id and not x.move_id):
+        for ops in self.move_line_ids.filtered(lambda x: x.package_id and not x.product_id and not x.move_id):
-        for pack in self.pack_operation_ids.filtered(lambda x: x.product_id and not x.move_id):
+        for pack in self.move_line_ids.filtered(lambda x: x.product_id and not x.move_id):
-            for product, remaining_qty in pycompat.items(pack_operation._get_remaining_prod_quantities()):
+        for move_line in self.move_line_ids:
-                    vals = self._prepare_values_extra_move(pack_operation, product, remaining_qty)
+                    vals = self._prepare_values_extra_move(move_line, product, remaining_qty)
-                'pack_operation_ids': [],
+                'move_line_ids': [],
-            operation_ids = self.env['stock.pack.operation']
+            operations = pick.move_line_ids.filtered(lambda o: o.qty_done > 0 and not o.result_package_id)
-        scrapeable_products = self.pack_operation_ids.mapped('product_id').filtered(lambda p: p.type == 'product')
+        scrapeable_products = self.move_line_ids.mapped('product_id').filtered(lambda p: p.type == 'product')
-        packages = self.pack_operation_ids.mapped('result_package_id')
+        packages = self.move_line_ids.mapped('result_package_id')
-            pack = self.env['stock.pack.operation'].browse(pack_id)
+            pack = self.env['stock.move.line'].browse(pack_id)
-    current_picking_move_line_ids = fields.One2many('stock.pack.operation', compute="_compute_current_picking_info")
+    move_line_ids = fields.One2many('stock.move.line', 'result_package_id')
-        pickings = self.env['stock.pack.operation'].search([('result_package_id', 'in', self.ids)]).mapped('picking_id')
+        pickings = self.env['stock.move.line'].search([('result_package_id', 'in', self.ids)]).mapped('picking_id')
-            'pack_operation_ids': [(0, 0, {'product_id': self.product_id.id,
+            'move_line_ids': [(0, 0, {'product_id': self.product_id.id,
-        res = self.env['stock.pack.operation']
+        res = self.env['stock.move.line']
-                res |= move_line.move_id.move_orig_ids.mapped('pack_operation_ids').filtered(
+                res |= move_line.move_id.move_orig_ids.mapped('move_line_ids').filtered(
-                    res |= self.env['stock.pack.operation'].search([
+                    res |= self.env['stock.move.line'].search([
-        res = self.env['stock.pack.operation']
+        res = self.env['stock.move.line']
-                res |= move_line.move_id.move_dest_ids.mapped('pack_operation_ids').filtered(
+                res |= move_line.move_id.move_dest_ids.mapped('move_line_ids').filtered(
-                    res |= self.env['stock.pack.operation'].search([
+                    res |= self.env['stock.move.line'].search([
-                move_ids = self.env['stock.pack.operation'].search([
+                move_ids = self.env['stock.move.line'].search([
-                res += self._lines(line_id, model_id=model_id, model='stock.pack.operation', level=level, parent_quant=parent_quant,
+                res += self._lines(line_id, model_id=model_id, model='stock.move.line', level=level, parent_quant=parent_quant,
-                move_ids = self.env['stock.pack.operation'].search([
+                move_ids = self.env['stock.move.line'].search([
-                res += self._lines(line_id, model_id=model_id, model='stock.pack.operation', level=level, parent_quant=parent_quant,
+                res += self._lines(line_id, model_id=model_id, model='stock.move.line', level=level, parent_quant=parent_quant,
-            move_line_ids = self.env['stock.pack.operation'].browse(context.get('active_id'))
+            move_ids = self.env['stock.picking'].browse(context['active_id']).move_lines.mapped('move_line_ids').filtered(lambda m: m.lot_id and m.state == 'done')
-            'model':'stock.pack.operation',
+            'model':'stock.move.line',
-        if model == 'stock.pack.operation':
+        if model == 'stock.move.line':
-                'model': model or 'stock.pack.operation',
+                'model': model or 'stock.move.line',
-        if model == 'stock.pack.operation':
+        if model == 'stock.move.line':
-            moves = self.env['stock.pack.operation'].search([
+            moves = self.env['stock.move.line'].search([
-        if model == 'stock.pack.operation':
+        if model == 'stock.move.line':
-            moves = self.env['stock.pack.operation'].search([
+            moves = self.env['stock.move.line'].search([
-                final_vals += self.make_dict_head(level, stream=stream, parent_id=line_id, model=model or 'stock.pack.operation', move_line=move_line)
+                final_vals += self.make_dict_head(level, stream=stream, parent_id=line_id, model=model or 'stock.move.line', move_line=move_line)
-                if line['model_name'] == 'stock.pack.operation':
+                if line['model_name'] == 'stock.move.line':
-        self.StockPackObj = self.env['stock.pack.operation']
+        self.StockPackObj = self.env['stock.move.line']
-        PackOperation = self.env['stock.pack.operation'].sudo(self.user_stock_manager)
+        PackOperation = self.env['stock.move.line'].sudo(self.user_stock_manager)
-        self.assertEqual(len(move1.pack_operation_ids), 1)
+        self.assertEqual(len(move1.move_line_ids), 1)
-        move_line = move1.pack_operation_ids[0]
+        move_line = move1.move_line_ids[0]
-        move_line = move1.pack_operation_ids[0]
+        self.assertEqual(len(move1.move_line_ids), 1)
-        move_line = move1.pack_operation_ids[0]
+        self.assertEqual(len(move1.move_line_ids), 5)
-        for move_line in move1.pack_operation_ids:
+        for move_line in move1.move_line_ids:
-        self.assertEqual(len(move1.pack_operation_ids), 1)
+        self.assertEqual(len(move1.move_line_ids), 1)
-        move_line = move1.pack_operation_ids[0]
+        move_line = move1.move_line_ids[0]
-        self.assertEqual(len(move1.pack_operation_ids), 1)
+        self.assertEqual(len(move1.move_line_ids), 1)
-        move_line = move1.pack_operation_ids[0]
+        move_line = move1.move_line_ids[0]
-        self.assertEqual(len(move1.pack_operation_ids), 2)
+        self.assertEqual(len(move1.move_line_ids), 2)
-        for ml in move1.pack_operation_ids:
+        self.assertEqual(len(move1.move_line_ids), 4)
-        untracked_move_line = move1.pack_operation_ids.filtered(lambda ml: not ml.lot_id)
+        untracked_move_line = move1.move_line_ids.filtered(lambda ml: not ml.lot_id)
-        for ml in move1.pack_operation_ids:
+        for ml in move1.move_line_ids:
-        move1.pack_operation_ids.write({'qty_done': 1.0})
+        move1.move_line_ids.write({'qty_done': 1.0})
-        move1.pack_operation_ids.write({'qty_done': 1.0})
+        move1.move_line_ids.write({'qty_done': 1.0})
-        self.env['stock.pack.operation'].create({
+        self.env['stock.move.line'].create({
-        self.env['stock.pack.operation'].create({
+        self.env['stock.move.line'].create({
-        move1.pack_operation_ids.write({'qty_done': 1.0})
+        move1.move_line_ids.write({'qty_done': 1.0})
-        move1.with_context(debug=True).pack_operation_ids[1].lot_id = lot3
+        move1.with_context(debug=True).move_line_ids[1].lot_id = lot3
-        self.env['stock.pack.operation'].create({
+        self.env['stock.move.line'].create({
-        self.assertEqual(len(move1.pack_operation_ids), 1)
+        self.assertEqual(len(move1.move_line_ids), 1)
-        move_line = move1.pack_operation_ids
+        move_line = move1.move_line_ids
-        self.assertEqual(len(move1.pack_operation_ids), 1)
+        self.assertEqual(len(move1.move_line_ids), 1)
-        self.assertEqual(move1.pack_operation_ids.location_dest_id.id, shelf1_location.id)
+        self.assertEqual(move1.move_line_ids.location_dest_id.id, shelf1_location.id)
-        self.assertEqual(len(move1.pack_operation_ids), 1)
+        self.assertEqual(len(move1.move_line_ids), 1)
-        self.assertEqual(len(move1.pack_operation_ids), 0)
+        self.assertEqual(len(move1.move_line_ids), 0)
-        self.assertEqual(len(move1.pack_operation_ids), 1)
+        self.assertEqual(len(move1.move_line_ids), 1)
-        self.assertEqual(len(move1.pack_operation_ids), 0)
+        self.assertEqual(len(move1.move_line_ids), 0)
-        self.assertEqual(len(move1.pack_operation_ids), 1)
+        self.assertEqual(len(move1.move_line_ids), 1)
-        self.assertEqual(len(move1.pack_operation_ids), 0.0)
+        self.assertEqual(len(move1.move_line_ids), 0.0)
-        self.assertEqual(len(move1.pack_operation_ids), 1)
+        self.assertEqual(len(move1.move_line_ids), 1)
-        self.assertEqual(len(move1.pack_operation_ids), 0.0)
+        self.assertEqual(len(move1.move_line_ids), 0.0)
-        move_stock_pack.pack_operation_ids[0].qty_done = 1.0
+        move_stock_pack.move_line_ids[0].qty_done = 1.0
-        move_line = move_pack_cust.pack_operation_ids[0]
+        self.assertEqual(len(move_pack_cust.move_line_ids), 1)
-        move_line_stock_pack = move_stock_pack.pack_operation_ids[0]
+        move_line_stock_pack = move_stock_pack.move_line_ids[0]
-        move_line_pack_cust = move_pack_cust.pack_operation_ids[0]
+        move_line_pack_cust = move_pack_cust.move_line_ids[0]
-        move_stock_pack_1.pack_operation_ids[0].qty_done = 1.0
+        self.assertEqual(len(move_stock_pack_1.move_line_ids), 1)
-        self.assertEqual(len(move_pack_cust.pack_operation_ids), 1)
+        self.assertEqual(len(move_pack_cust.move_line_ids), 1)
-        move_stock_pack_2.pack_operation_ids[0].qty_done = 1.0
+        self.assertEqual(len(move_stock_pack_2.move_line_ids), 1)
-        move_line_1 = move_pack_cust.pack_operation_ids[0]
+        self.assertEqual(len(move_pack_cust.move_line_ids), 1)
-        move_stock_pack_1.pack_operation_ids[0].qty_done = 1.0
+        self.assertEqual(len(move_stock_pack_1.move_line_ids), 1)
-        self.assertEqual(len(move_pack_cust.pack_operation_ids), 1)
+        self.assertEqual(len(move_pack_cust.move_line_ids), 1)
-        move_stock_pack_2.pack_operation_ids[0].qty_done = 1.0
+        self.assertEqual(len(move_stock_pack_2.move_line_ids), 1)
-        move_line_1 = move_pack_cust.pack_operation_ids[0]
+        self.assertEqual(len(move_pack_cust.move_line_ids), 1)
-        move_stock_pack.pack_operation_ids[0].qty_done = 2.0
+        self.assertEqual(len(move_stock_pack.move_line_ids), 1)
-        self.assertEqual(len(move_pack_cust_2.pack_operation_ids), 1)
+        self.assertEqual(len(move_pack_cust_1.move_line_ids), 1)
-        move_pack_cust_2.pack_operation_ids[0].qty_done = 1.0
+        move_pack_cust_1.move_line_ids[0].qty_done = 1.0
-        move_supp_stock_1.pack_operation_ids.qty_done = 3.0
+        move_supp_stock_1.move_line_ids.qty_done = 3.0
-        move2.write({'pack_operation_ids': [(0, 0, {
+        move2.write({'move_line_ids': [(0, 0, {
-        move2.write({'pack_operation_ids': [(0, 0, {
+        move2.write({'move_line_ids': [(0, 0, {
-        move1.pack_operation_ids.location_id = shelf2_location.id
+        move1.move_line_ids.location_id = shelf2_location.id
-        move1.pack_operation_ids.lot_id = lot2.id
+        move1.move_line_ids.lot_id = lot2.id
-        move1.pack_operation_ids.package_id = package2.id
+        move1.move_line_ids.package_id = package2.id
-        move1.pack_operation_ids.owner_id = owner2.id
+        move1.move_line_ids.owner_id = owner2.id
-        move_line = move1.pack_operation_ids[0]
+        move_line = move1.move_line_ids[0]
-        move1.pack_operation_ids.location_id = shelf2_location.id
+        move1.move_line_ids.location_id = shelf2_location.id
-        move_line = move1.pack_operation_ids[0]
+        self.assertEqual(len(move1.move_line_ids), 1)
-        self.assertEqual(len(move1.pack_operation_ids), 2)
+        self.assertEqual(len(move1.move_line_ids), 2)
-        for move_line in move1.pack_operation_ids:
+        for move_line in move1.move_line_ids:
-        move1.pack_operation_ids.qty_done = 1
+        move1.move_line_ids.qty_done = 1
-        move1.pack_operation_ids.location_id = shelf2_location.id
+        move1.move_line_ids.location_id = shelf2_location.id
-        move1.pack_operation_ids.qty_done = 1
+        move1.move_line_ids.qty_done = 1
-        move1.pack_operation_ids.lot_id = lot2.id
+        move1.move_line_ids.lot_id = lot2.id
-        move1.pack_operation_ids.qty_done = 1
+        move1.move_line_ids.qty_done = 1
-        move1.pack_operation_ids.package_id = package2.id
+        move1.move_line_ids.package_id = package2.id
-        move1.pack_operation_ids.qty_done = 1
+        move1.move_line_ids.qty_done = 1
-        move1.pack_operation_ids.owner_id = owner2.id
+        move1.move_line_ids.owner_id = owner2.id
-        move1.pack_operation_ids.qty_done = 1
+        move1.move_line_ids.qty_done = 1
-        move_line = move1.pack_operation_ids[0]
+        move_line = move1.move_line_ids[0]
-        move1.pack_operation_ids.qty_done = 1
+        move1.move_line_ids.qty_done = 1
-        move1.pack_operation_ids.location_id = shelf2_location.id
+        move1.move_line_ids.location_id = shelf2_location.id
-        move1.pack_operation_ids.qty_done = 1
+        move1.move_line_ids.qty_done = 1
-        move1.pack_operation_ids.location_id = shelf2_location.id
+        move1.move_line_ids.location_id = shelf2_location.id
-        move1.pack_operation_ids.qty_done = 1
+        move1.move_line_ids.qty_done = 1
-        move1.pack_operation_ids.qty_done = 2
+        move1.move_line_ids.qty_done = 2
-        move1.pack_operation_ids.qty_done = 1
+        move1.move_line_ids.qty_done = 1
-        move1.pack_operation_ids.qty_done = 0
+        move1.move_line_ids.qty_done = 0
-        move1.pack_operation_ids.qty_done = 10
+        move1.move_line_ids.qty_done = 10
-        move1.pack_operation_ids.qty_done = 0
+        move1.move_line_ids.qty_done = 0
-        move1.pack_operation_ids.qty_done = 10
+        move1.move_line_ids.qty_done = 10
-            'qty_done': move1.pack_operation_ids.qty_done,
+        self.env['stock.move.line'].create({
-            'location_dest_id': move1.pack_operation_ids.location_dest_id.id,
+            'location_id': move1.move_line_ids.location_id.id,
-        move1.pack_operation_ids[1].qty_done = 5
+        move1.move_line_ids[1].qty_done = 5
-        self.assertEqual(len(picking.move_lines.pack_operation_ids), 1)
+        self.assertEqual(len(picking.move_lines.move_line_ids), 1)
-        self.assertEqual(picking.move_lines.pack_operation_ids.qty_done, 5.0)
+        self.assertEqual(picking.move_lines.move_line_ids.qty_done, 5.0)
-            the quantity done to the initial demand. It should also create the pack_operation line.
+            the quantity done to the initial demand. It should also create the move line.
-        self.assertEqual(picking.move_lines.pack_operation_ids.product_qty, 0.0)
+        self.assertEqual(len(picking.move_lines.move_line_ids), 1)
-        picking.move_lines.pack_operation_ids[0].qty_done = 5.0
+        picking.move_lines.move_line_ids[0].qty_done = 5.0
-        self.assertEqual(picking.move_lines.pack_operation_ids.qty_done, 5.0)
+        self.assertEqual(len(picking.move_lines.move_line_ids), 1)
-        picking_pick.move_lines[0].pack_operation_ids[0].qty_done = 10.0
+        picking_pick.move_lines[0].move_line_ids[0].qty_done = 10.0
-        picking_client.move_lines[0].pack_operation_ids[0].qty_done = 5
+        picking_client.move_lines[0].move_line_ids[0].qty_done = 5
-        move_pick.pack_operation_ids[0].qty_done = 10.0
+        move_pick.move_line_ids[0].qty_done = 10.0
-        picking_pick.move_lines[0].pack_operation_ids[0].qty_done = 10.0
+        picking_pick.move_lines[0].move_line_ids[0].qty_done = 10.0
-        return_pick.move_lines[0].pack_operation_ids[0].qty_done = 2.0
+        return_pick.move_lines[0].move_line_ids[0].qty_done = 2.0
-        picking_pick.move_lines[0].pack_operation_ids[0].qty_done = 5.0
+        picking_pick.move_lines[0].move_line_ids[0].qty_done = 5.0
-        self.assertEqual(picking_pick_backorder.pack_operation_ids.product_qty, 5.0)
+        self.assertEqual(picking_pick_backorder.move_line_ids.product_qty, 5.0)
-        delivery_order.move_lines[0].pack_operation_ids[0].qty_done = 1
+        delivery_order.move_lines[0].move_line_ids[0].qty_done = 1
-        delivery_order.move_lines[0].pack_operation_ids[0].qty_done = 1
+        delivery_order.move_lines[0].move_line_ids[0].qty_done = 1
-        delivery_order.move_lines[0].pack_operation_ids[0].qty_done = 2
+        delivery_order.move_lines[0].move_line_ids[0].qty_done = 2
-        extra_move_line = extra_move.pack_operation_ids[0]
+        extra_move_line = extra_move.move_line_ids[0]
-        self.assertEqual(move1.pack_operation_ids.qty_done, 1.0)
+        self.assertEqual(move1.move_line_ids.product_qty, 1.0)  # should keep the reservation
-        delivery_order.move_lines[0].pack_operation_ids[0].qty_done = 3
+        delivery_order.move_lines[0].move_line_ids[0].qty_done = 3
-        extra_move_line = extra_move.pack_operation_ids[0]
+        extra_move_line = extra_move.move_line_ids[0]
-        self.assertEqual(move1.pack_operation_ids.qty_done, 1.0)
+        self.assertEqual(move1.move_line_ids.product_qty, 1.0)  # should keep the reservation
-        receipt.move_lines[0].pack_operation_ids[0].qty_done = 2
+        receipt.move_lines[0].move_line_ids[0].qty_done = 2
-        extra_move_line = extra_move.pack_operation_ids[0]
+        extra_move_line = extra_move.move_line_ids[0]
-        self.assertEqual(move1.pack_operation_ids.qty_done, 1.0)
+        self.assertEqual(move1.move_line_ids.product_qty, 1.0)  # should keep the reservation
-        self.assertEqual(move1.pack_operation_ids.product_qty, 1)
+        self.assertEqual(len(move1.move_line_ids), 1)
-        self.assertEqual(move1.pack_operation_ids.product_qty, 2)
+        self.assertEqual(len(move1.move_line_ids), 1)
-        self.assertEqual(move1.pack_operation_ids.product_qty, 1)
+        self.assertEqual(len(move1.move_line_ids), 1)
-        self.assertEqual(move1.pack_operation_ids.product_qty, 2)
+        self.assertEqual(len(move1.move_line_ids), 1)
-        self.assertEqual(move1.pack_operation_ids.product_qty, 1)
+        self.assertEqual(len(move1.move_line_ids), 1)
-        self.assertEqual(move1.pack_operation_ids[1].lot_id.id, lot2.id)
+        self.assertEqual(len(move1.move_line_ids), 2)
-        self.assertEqual(move1.pack_operation_ids.product_qty, 1)
+        self.assertEqual(len(move1.move_line_ids), 1)
-        self.assertEqual(move1.pack_operation_ids[1].lot_id.id, serial2.id)
+        self.assertEqual(len(move1.move_line_ids), 2)
-        move_d.pack_operation_ids.qty_done = 5
+        move_a.move_line_ids.qty_done = 4
-        move_cust_b.pack_operation_ids.qty_done = 3.0
+        move_cust_a.move_line_ids.qty_done = 2.0
-        move_cust_c.pack_operation_ids[0].write({
+        move_cust_c.move_line_ids[0].write({
-        move_cust_d.pack_operation_ids.qty_done = 6.0
+        move_cust_d.move_line_ids.qty_done = 6.0
-        move_in.pack_operation_ids.qty_done = 3.0
+        move_in.move_line_ids.qty_done = 3.0
-        picking_in_package = move_in.pack_operation_ids.result_package_id
+        picking_in_package = move_in.move_line_ids.result_package_id
-        move_pack.pack_operation_ids.qty_done = 3.0
+        move_pack.move_line_ids.qty_done = 3.0
-        picking_pack_package = move_pack.pack_operation_ids.result_package_id
+        picking_pack_package = move_pack.move_line_ids.result_package_id
-        picking_out_package = move_out.pack_operation_ids.result_package_id
+        picking_out.move_line_ids.qty_done = 3.0
-        packop2 = picking_in.pack_operation_ids[0].with_context(bypass_reservation_update=True).copy({'product_uom_qty': 0})
+        picking_in.move_line_ids[0].result_package_id = pack1
-        packout2 = picking_out.pack_operation_ids[0].with_context(bypass_reservation_update=True).copy({'product_uom_qty': 0})
+        packout1 = picking_out.move_line_ids[0]
-        packop2 = picking_in.pack_operation_ids[0].with_context(bypass_reservation_update=True).copy({'product_uom_qty': 0})
+        picking_in.move_line_ids[0].result_package_id = pack1
-        packout1 = picking_out.pack_operation_ids[1]
+        packout0 = picking_out.move_line_ids[0]
-                for move_line in move.pack_operation_ids:
+            if move.move_line_ids:
-                                                  mapped('pack_operation_ids').mapped('product_qty'))
+                                                  mapped('move_line_ids').mapped('product_qty'))
-    _inherit = 'stock.pack.operation'
+class StockMoveLine(models.Model):
-        super(StockPackOperation, self).write(vals)
+        super(StockMoveLine, self).write(vals)
-        move1.pack_operation_ids.qty_done = 68.0
+        move1.move_line_ids.qty_done = 68.0
-        move2.pack_operation_ids.qty_done = 140.0
+        move2.move_line_ids.qty_done = 140.0
-        move3.pack_operation_ids.qty_done = 94.0
+        move3.move_line_ids.qty_done = 94.0
-        move4.pack_operation_ids.qty_done = 40.0
+        move4.move_line_ids.qty_done = 40.0
-        move5.pack_operation_ids.qty_done = 78.0
+        move5.move_line_ids.qty_done = 78.0
-        move6.pack_operation_ids.qty_done = 116.0
+        move6.move_line_ids.qty_done = 116.0
-        move7.pack_operation_ids.qty_done = 62.0
+        move7.move_line_ids.qty_done = 62.0
-        move1.pack_operation_ids.qty_done = 10.0
+        move1.move_line_ids.qty_done = 10.0
-        move2.pack_operation_ids.qty_done = 10.0
+        move2.move_line_ids.qty_done = 10.0
-        move3.pack_operation_ids.qty_done = 15.0
+        move3.move_line_ids.qty_done = 15.0
-        move4.pack_operation_ids.qty_done = 5.0
+        move4.move_line_ids.qty_done = 5.0
-        move5.pack_operation_ids.qty_done = 7.0
+        move5.move_line_ids.qty_done = 7.0
-        move1.pack_operation_ids.qty_done = 60.0
+        move1.move_line_ids.qty_done = 60.0
-        move2.pack_operation_ids.qty_done = 140.0
+        move2.move_line_ids.qty_done = 140.0
-        move3.pack_operation_ids.qty_done = 190.0
+        move3.move_line_ids.qty_done = 190.0
-        move4.pack_operation_ids.qty_done = 70.0
+        move4.move_line_ids.qty_done = 70.0
-        move5.pack_operation_ids.qty_done = 30.0
+        move5.move_line_ids.qty_done = 30.0
-            for pack_operation in (picking or self.picking_id).pack_operation_ids:
+            for move in (picking or self.picking_id).move_lines:
-                pos_pack_lots = PosPackOperationLot.search([('order_id', '=', order.id), ('product_id', '=', pack_operation.product_id.id)])
+                pos_pack_lots = PosPackOperationLot.search([('order_id', '=', order.id), ('product_id', '=', move.product_id.id)])
-                        stock_production_lot = StockProductionLot.search([('name', '=', lot_name), ('product_id', '=', pack_operation.product_id.id)])
+                        stock_production_lot = StockProductionLot.search([('name', '=', lot_name), ('product_id', '=', move.product_id.id)])
-                                qty = pack_operation.product_qty
+                                qty = move.product_uom_qty
-                    qty_done = pack_operation.product_qty
+                elif move.product_id.tracking == 'none' or not lots_necessary:
-                pack_operation.write({'pack_lot_ids': [(0, 0, x) for x in pack_lots], 'qty_done': qty_done})
+                for pack_lot in pack_lots:
-        wiz_act = pick.do_new_transfer()
+        pick.move_lines.write({'quantity_done': 1})
-        pick_2.do_new_transfer()
+        pick_2.move_lines.write({'quantity_done': 4})
-                                           'product_uom_id': operation.product_uom_id.id,
+                                           'lot_id': operation.lot_id.id,
-                                           'location_dest_id': operation.location_dest_id.id,})]
+                                           'location_dest_id': operation.location_dest_id.id,})],
-                                           'product_uom_id': repair.product_uom_id.id or repair.product_id.uom_id.id,
+                                           'lot_id': repair.lot_id.id,
-                                           'location_dest_id': repair.location_dest_id.id,})]
+                                           'location_dest_id': repair.location_dest_id.id,})],
-
+        self.assertEqual(len(self.mrp_repair_rmrp0.move_id.move_line_ids[0].consume_line_ids), 1, "Consume lines should be set")
-        wiz_act = pick.do_new_transfer()
+        pick.move_lines.write({'quantity_done': 1})
-        self.assertIsNone(pick_2.do_new_transfer(), 'Sale Stock: second picking should be final without need for a backorder')
+        pick_2.move_lines.write({'quantity_done': 1})
-        self.assertIsNone(pick.do_new_transfer(), 'Sale Stock: complete delivery should not need a backorder')
+        pick.move_lines.write({'quantity_done': 2})
-        pick.pack_operation_product_ids.write({'qty_done': 5})
+        pick.move_lines.write({'quantity_done': 5})
-        return_pick.pack_operation_product_ids.write({'qty_done': 2})
+        return_pick.move_lines.write({'quantity_done': 2})
-        backorder_wiz.process_cancel_backorder()
+        pick.move_lines.write({'quantity_done': 4})
-        self.so.picking_ids[0].action_done()
+        self.so.picking_ids[0].force_assign()
-                    order.message_post(body=msg)
+            self.filtered(
-        help="Cost of the product template used for standard stock valuation in accounting and used as a base price on purchase orders. "
+        help="Cost used for standard stock valuation in accounting and used as a base price on purchase orders. "
-        """ Returns the unit price to store on the quant """
+    def _get_price_unit(self):
-        return super(StockMove, self).get_price_unit()
+            line = self.purchase_line_id
-        # check the picking crated or not
+        # check the picking created or not
-        'report/stock_history_views.xml',
+from odoo.addons import decimal_precision as dp
-        ('real', 'Real Price')], string='Costing Method',
+        ('fifo', '(financial) FIFO'),
-        ('real', 'Real Price')], string="Costing Method",
+        ('fifo', '(financial) FIFO)'),
-
+class StockPackOperation(models.Model):
-        return res
+    def write(self, vals):
-        return moves.filtered(lambda m: m.product_id.cost_method not in ('real', 'average'))
+    value = fields.Float()
-        return res
+    def _get_price_unit(self):
-                new_std_price = ((amount_unit * product_tot_qty_available) + (move.get_price_unit() * move.product_qty)) / (product_tot_qty_available + move.product_qty)
+    def replay(self):
-            move.write({'price_unit': move.product_id.standard_price})
+    def action_done(self):
-
+    
-                valuation_amount = cost if self.product_id.cost_method == 'real' else self.product_id.standard_price
+            valuation_amount = cost
-        debit_value = self.company_id.currency_id.round(valuation_amount * qty)
+        debit_value = self.company_id.currency_id.round(valuation_amount)
-            )""")
+from . import test_stockvaluation
-            action = self.env['ir.model.data'].xmlid_to_object('stock_account.action_stock_history')
+            action = self.env['ir.model.data'].xmlid_to_object('stock_account.stock_move_valuation_action')
-                    'res_model': 'stock.history',
+                    'view_mode': 'tree',
-            action = self.env.ref('stock.quantsact').read()[0]
+            action = self.env.ref('stock_account.product_valuation_action').read()[0]
-        'test/stock_landed_costs_rounding.yml',
+        # '../account/test/account_minimal_test.xml',
-                line._create_accounting_entries(move, qty_out)
+                cost_to_add = line.additional_landed_cost
-            if move.product_id.valuation != 'real_time' or move.product_id.cost_method != 'real':
+            if move.product_id.valuation != 'real_time' or move.product_id.cost_method not in ('average', 'fifo'):
-                'former_cost': sum(quant.cost * quant.qty for quant in move.quant_ids),
+                'former_cost': move.value,
-from . import test_stock_landed_costs_purchase
+# from . import test_stock_landed_costs_purchase
-            'cost_method': 'real',
+            'cost_method': 'fifo',
-            'cost_method': 'real',
+            'cost_method': 'fifo',
-            line.order_id._create_picking()
+            line._create_or_update_picking(values)
-                    order.message_post(body=msg)
+            self.filtered(lambda l: l.order_id.state == 'purchase')._create_or_update_picking(values)
-            orders._create_picking()
+    def _create_or_update_picking(self, vals):
-        """
+    def _get_move_template(self, picking):
-            'price_unit': price_unit,
+            'price_unit': self._get_stock_move_price_unit(),
-            'route_ids': self.order_id.picking_type_id.warehouse_id and [(6, 0, [x.id for x in self.order_id.picking_type_id.warehouse_id.route_ids])] or [],
+            'route_ids': self.order_id.picking_type_id.warehouse_id and [
-        'Purchase Order Line', ondelete='set null', index=True, readonly=True)
+        'Purchase Order Line', ondelete='set null', index=True, readonly=True, copy=False)
-        return super(StockMove, self).copy(default)
+    def _prepare_extra_move_vals(self, qty):
-        self.picking.do_new_transfer()
+        for ml in self.picking.pack_operation_ids:
-        self.assertEqual(len(moves), 1, 'One move should be created')
+        self.assertEqual(len(moves), 1, 'One moves should have been created')
-        self.picking.do_new_transfer()
+        self.picking.pack_operation_ids.write({'qty_done': 5.0})
-        self.picking.do_new_transfer()
+        self.picking.pack_operation_ids.write({'qty_done': 5.0})
-        return_pick.do_new_transfer()
+        return_pick.pack_operation_ids.write({'qty_done': 2})
-                'picking_id': self.picking_id.id}
+            extra_move_vals = self._prepare_extra_move_vals(extra_move_quantity)
-        }
+        defaults = self._prepare_move_split_vals(uom_qty)
-            if new_qty:
+            if return_line.quantity:
-                })
+                vals = self._prepare_move_default_values(return_line, new_picking)
-    @api.depends('move_raw_ids.state', 'move_raw_ids.partially_available', 'workorder_ids.move_raw_ids', 'bom_id.ready_to_produce')
+    @api.depends('move_raw_ids.state', 'workorder_ids.move_raw_ids', 'bom_id.ready_to_produce')
-                partial_list = [x.partially_available and x.state in ('waiting', 'confirmed', 'assigned') for x in order.move_raw_ids]
+                partial_list = [x.state in ('partially_available', 'assigned') for x in order.move_raw_ids]
-                any(order.move_finished_ids.filtered(lambda x: (x.quantity_done) > 0 and (x.state not in ['done', 'cancel'])))
+            if order.product_tmpl_id._is_cost_method_standard():
-            'move_dest_id': self.procurement_ids and self.procurement_ids[0].move_dest_id.id or False,
+            'move_dest_ids': self.procurement_ids and [(4, p) for p in self.procurement_ids.mapped('move_dest_id').ids] or False,
-            move_to_assign.action_assign()
+            production.move_raw_ids.action_assign()
-            moves_raw.mapped('move_lot_ids').write({'workorder_id': workorder.id})
+            moves_raw.mapped('pack_operation_ids').write({'workorder_id': workorder.id})
-                        lot_quants[lot].sudo().write({'consumed_quant_ids': [(6, 0, [x.id for x in raw_lot_quants[lot] | quants])]})
+            #order.action_assign()
-            order.action_assign()
+                    # Link with everything
-        if vals['name'] == _('New'):
+        if not vals.get('name') or vals['name'] == _('New'):
-            self.env['stock.move.lots'].create({
+            self.env['stock.pack.operation'].create({
-                'quantity': consume_move.product_uom_qty})
+                'qty_done': consume_move.product_uom_qty,
-        consume_move.move_validate()
+        consume_move.action_done()
-                self.env['stock.move.lots'].create({
+                self.env['stock.pack.operation'].create({
-                    'quantity': produce_move.product_uom_qty
+                    'qty_done': produce_move.product_uom_qty,
-        produce_moves.move_validate()
+        produce_moves.action_done()
-        'stock.move.lots', 'workorder_id', 'Moves to Track',
+    move_line_ids = fields.One2many(
-        'stock.move.lots', 'workorder_id',
+    active_move_line_ids = fields.One2many(
-            move_lots = self.active_move_lot_ids.filtered(lambda move_lot: move_lot.move_id == move)
+            move_lots = self.active_move_line_ids.filtered(lambda move_lot: move_lot.move_id == move)
-                move_lots[0].quantity_done = new_qty
+                move_lots[0].product_qty = new_qty
-                        self.active_move_lot_ids += self.env['stock.move.lots'].new({
+                        self.active_move_line_ids += self.env['stock.pack.operation'].new({
-                            'quantity_done': min(1.0, qty_todo),
+                            'product_qty': 0.0,
-                            'done_wo': False
+                            'done_wo': False,
-                            self.active_move_lot_ids -= move_lot  # Difference operator
+                            self.active_move_line_ids -= move_lot  # Difference operator
-                                move_lot.quantity_done = move_lot.quantity_done - qty_todo
+                            #move_lot.product_qty = move_lot.product_qty - qty_todo
-                                move_lot.quantity_done = 0
+                                move_lot.qty_done = 0
-        """ Generate stock move lots """
+        """ Generate stock move lines """
-        MoveLot = self.env['stock.move.lots']
+        MoveLine = self.env['stock.pack.operation']
-                    MoveLot.create({
+                    MoveLine.create({
-                        'quantity_done': min(1, qty),
+                        'product_uom_qty': 0,
-                MoveLot.create({
+                MoveLine.create({
-                    'quantity_done': qty,
+                    'product_uom_qty': 0,
-                move_lot.sudo().unlink()
+        for move_line in self.active_move_line_ids:
-            if not move_lot.lot_id:
+            if not move_line.lot_id:
-            lots = self.move_lot_ids.filtered(lambda x: (x.lot_id.id == move_lot.lot_id.id) and (not x.lot_produced_id) and (not x.done_move))
+            # Search other move_line where it could be added:
-                lots[0].quantity_done += move_lot.quantity_done
+                lots[0].qty_done += move_line.qty_done
-                move_lot.sudo().unlink()
+                move_line.sudo().unlink()
-                move_lot.done_wo = True
+                move_line.lot_produced_id = self.final_lot_id.id
-            lambda move_lot: not move_lot.done_move and not move_lot.lot_produced_id and move_lot.quantity_done > 0
+        self.move_line_ids.filtered(
-                    move_lot.quantity += self.qty_producing
+            if production_move.has_tracking != 'none':
-                                     })
+                    move_line.create({'move_id': production_move.id,
-                production_move.quantity_done += self.qty_producing  # TODO: UoM conversion?
+                production_move.quantity_done += self.qty_producing
-    _description = "Quantities to Process by lots"
+class StockPackOperation(models.Model):
-    @api.constrains('lot_id', 'quantity_done')
+    @api.constrains('lot_id', 'qty_done')
-            for move_lot in self.move_id.active_move_lot_ids.filtered(lambda r: not r.lot_produced_id and r.lot_id):
+            for move_lot in self.move_id.active_move_line_ids.filtered(lambda r: not r.lot_produced_id and r.lot_id):
-                if float_compare(move_lot.quantity_done, 1.0, precision_rounding=move_lot.product_id.uom_id.rounding) == 1:
+                if float_compare(move_lot.qty_done, 1.0, precision_rounding=move_lot.move_id.product_id.uom_id.rounding) == 1:
-                movelot.move_id.production_id.move_raw_ids.mapped('move_lot_ids')\
+                movelot.move_id.production_id.move_raw_ids.mapped('pack_operation_ids')\
-        return super(StockMoveLots, self).write(vals)
+        return super(StockPackOperation, self).write(vals)
-    active_move_lot_ids = fields.One2many('stock.move.lots', 'move_id', domain=[('done_wo', '=', True)], string='Lots')
+    active_move_line_ids = fields.One2many('stock.pack.operation', 'move_id', domain=[('done_wo', '=', True)], string='Lots')
-                move.quantity_done_store = move.quantity_done
+        help='Technical Field to order moves')
-        self.check_move_lots()
+    def action_assign(self):
-        if any(move.quantity_done for move in self):
+        if any(move.quantity_done for move in self): #TODO: either put in stock, or check there is a production order related to it
-    @api.multi
+    # Could use split_move_operation from stock here
-        show_reserved = any([x for x in self.move_lot_ids if x.quantity > 0.0])
+        show_reserved = any([x for x in self.pack_operation_ids if x.product_qty > 0.0])
-                self.procurement_id.write({'state': 'done'})
+#         if not self.split_from and self.procurement_id:
-        return super(StockScrap, self)._get_origin_moves() or self.production_id and self.production_id.move_raw_ids.filtered(lambda x: x.product_id == self.product_id)
+        return super(StockScrap, self)._get_origin_moves() or self.production_id and self.production_id.move_raw_ids.filtered(lambda x: x.product_id == self.product_id)
-        workorders[0].active_move_lot_ids[0].write({'lot_id': lot_sheet.id, 'quantity_done': 1})
+        workorders[0].active_move_line_ids[0].write({'lot_id': lot_sheet.id, 'qty_done': 1})
-        workorders[1].active_move_lot_ids[0].write({'lot_id': lot_leg.id, 'quantity_done': 4})
+        workorders[1].active_move_line_ids[0].write({'lot_id': lot_leg.id, 'qty_done': 4})
-        move_lot.write({'lot_id': lot_bolt.id, 'quantity_done': 4})
+        move_lot = workorders[2].active_move_line_ids[0]
-        self.assertEqual(finished_quant.consumed_quant_ids, consume_quants)
+# TODO: check quantities in stock then
-        product_consume.consume_line_ids.write({'quantity_done': 12})
+        product_consume.consume_line_ids.write({'qty_done': 12})
-        product_consume.consume_line_ids.write({'quantity_done': 8})
+        product_consume.consume_line_ids.write({'qty_done': 8})
-        self.assertEqual(sum(keybord_moves.mapped('qty')), 20)
+#         raw_moves_state = any(move.state != 'done' for move in mo_custom_laptop.move_raw_ids)
-        """ Testing bill of material with diffrent unit of measure."""
+        """ Testing bill of material with different unit of measure."""
-        product_consume.consume_line_ids.filtered(lambda x : x.product_id == product_B).write({'quantity_done': 20})
+        product_consume.consume_line_ids.filtered(lambda x : x.product_id == product_C).write({'qty_done': 3000})
-        self.assertEqual(move_product_c.quant_ids.product_uom_id.id, kg)
+        #TODO: check original quants qtys diminished
-                moves_raw.mapped('move_lot_ids').write({'workorder_id': wo.id})
+                moves_raw.mapped('pack_operation_ids').write({'workorder_id': wo.id})
-                if wo.move_raw_ids.filtered(lambda x: x.product_id.tracking != 'none') and not wo.active_move_lot_ids:
+                if wo.move_raw_ids.filtered(lambda x: x.product_id.tracking != 'none') and not wo.active_move_line_ids:
-                if not move.move_lot_ids.filtered(lambda x: not x.lot_produced_id):
+                if not move.pack_operation_ids.filtered(lambda x: not x.lot_produced_id):
-                                'plus_visible': True,
+                                'product_qty': min(1,qty),
-                            'plus_visible': True,
+                            'product_qty': qty,
-                    existing_lines += move.move_lot_ids.filtered(lambda x: not x.lot_produced_id).ids
+                    existing_lines += move.pack_operation_ids.filtered(lambda x: not x.lot_produced_id).ids
-            res['consume_line_ids'] = [(0,0,x) for x in lines] + [(4, x) for x in existing_lines]
+            res['consume_line_ids'] = (existing_lines and [(6, 0, [x for x in existing_lines])] or []) + [(0, 0, x) for x in lines]
-    consume_line_ids = fields.Many2many('stock.move.lots', 'mrp_produce_stock_move_lots', string='Product to Track')
+    consume_line_ids = fields.Many2many('stock.pack.operation', 'mrp_produce_stock_pack_operation', string='Product to Track')
-                move.quantity_done_store += float_round(quantity * move.unit_factor, precision_rounding=rounding)
+                move.quantity_done += float_round(quantity * move.unit_factor, precision_rounding=rounding)
-                move.quantity_done_store += float_round(quantity, precision_rounding=rounding)
+                move.quantity_done += float_round(quantity, precision_rounding=rounding)
-                move.quantity_done_store += float_round(quantity * move.unit_factor, precision_rounding=rounding)
+                move.quantity_done += float_round(quantity * move.unit_factor, precision_rounding=rounding)
-        lots = self.env['stock.move.lots']
+        packs = self.env['stock.pack.operation']
-                existing_move_lot.quantity_done += self.product_qty
+            existing_move_line = produce_move.pack_operation_ids.filtered(lambda x: x.lot_id == self.lot_id)
-                  'quantity_done': self.product_qty,
+                  'product_uom_qty': self.product_qty,
-                lots.create(vals)
+                packs.create(vals)
-                    if movelots.quantity_done and self.lot_id:
+                for moveline in move.pack_operation_ids.filtered(lambda x: not x.lot_produced_id):
-                        remaining_qty = movelots.quantity - movelots.quantity_done
+                        remaining_qty = moveline.product_uom_qty - moveline.qty_done
-                            movelots.write({'quantity': remaining_qty, 'quantity_done': 0})
+                            default = {'product_uom_qty': moveline.qty_done,
-                            movelots.write({'lot_produced_id': self.lot_id.id})
+                            moveline.write({'lot_produced_id': self.lot_id.id})
-                    'restrict_lot_id': operation.lot_id.id,
+                    'pack_operation_ids': [(0, 0, {'product_id': operation.product_id.id,
-                'restrict_lot_id': repair.lot_id.id,
+                'pack_operation_ids': [(0, 0, {'product_id': repair.product_id.id,
-        for procurement_id, production_id in pycompat.items(res):
+        for procurement_id in res:
-            return self._get_parent_move(move.move_dest_id)
+        if move.move_dest_ids:
-                moves.force_assign()
+                moves.action_assign()
-            'move_dest_id': False,
+            'move_dest_ids': False,
-                    'move_dest_id': procurement.move_dest_id.id,  # move destination is same as procurement destination
+                    'move_dest_ids': procurement.move_dest_id and [(4, procurement.move_dest_id.id)] or [],  # move destination is same as procurement destination
-                            old_move_date = datetime.strptime(move.move_dest_id.date_expected, DEFAULT_SERVER_DATETIME_FORMAT)
+                            old_move_date = datetime.strptime(move.move_dest_ids[0].date_expected, DEFAULT_SERVER_DATETIME_FORMAT)
-                        move.move_dest_id.write(propagated_changes_dict)
+                        move.move_dest_ids.filtered(lambda m: m.state not in ('done', 'cancel')).write(propagated_changes_dict)
-    @http.route('/mrp_workorder/<string:output_format>/<string:report_name>/<int:report_id>', type='http', auth='user')
+    @http.route('/stock/<string:output_format>/<string:report_name>/<int:report_id>', type='http', auth='user')
-        context_ids = []
+        res = []
-            context_ids = self.env['mrp.production'].browse(context['active_id']).move_finished_ids.mapped('quant_ids')
+            if stream == "downstream":
-        res = self.with_context(context)._lines(line_id, model_id=model_id, model=model, level=level, parent_quant=parent_quant)
+            move_ids = self.env['stock.picking'].browse(context['active_id']).move_lines.mapped('pack_operation_ids').filtered(lambda m: m.lot_id and m.state == 'done')
-    def get_links(self, move):
+    def get_links(self, move_line):
-        if move.picking_id:
+        if move_line.picking_id:
-            ref = move.consume_unbuild_id.name or move.unbuild_id.name
+            res_id = move_line.picking_id.id
-        data = {
+    def make_dict_move(self, level, parent_id, move_line, stream=False):
-            'location_destination': move.location_dest_id.name,
+            'date': move_line.move_id.date,
-        return final_vals
+            'res_model': res_model}]
-            final_vals.append({
+    def make_dict_head(self, level, parent_id, model=False, stream=False, move_line=False):
-                'res_id': res_id,
+                'date': move_line.move_id.date,
-            final_vals.append({
+                'reference_id': False}]
-                'location_destination': False,
+                'unfoldable': True,
-        return final_vals
+                'reference_id': False}]
-    def upstream_traceability(self, level, stream=False, line_id=False, model=False, model_id=False, parent_quant=False, final_vals=None):
+    def upstream_traceability(self, level, stream=False, line_id=False, model=False, model_id=False, parent_quant=False):
-                    final_vals = self.make_dict_head(level, line_id=line_id, stream=stream, move=False, quant=quant, final_vals=final_vals)
+        final_vals =[]
-    def downstream_traceability(self, level, stream=False, line_id=False, model=False, model_id=False, parent_quant=False, final_vals=None):
+    def downstream_traceability(self, level, stream=False, line_id=False, model=False, model_id=False, parent_quant=False):
-        return True
+        final_vals = []
-    def _lines(self, line_id=None, model_id=False, model=False, level=0, parent_quant=False, **kw):
+    def _lines(self, line_id=None, model_id=False, model=False, level=0, parent_quant=False, stream=False, obj_ids=[], **kw):
-                self.downstream_traceability(level, stream='downstream', line_id=line_id, model=model, model_id=model_id, parent_quant=parent_quant, final_vals=final_vals)
+        if model and line_id:
-                self.upstream_traceability(level, stream='upstream', line_id=line_id, model=model, model_id=model_id, parent_quant=parent_quant, final_vals=final_vals)
+                final_vals += self.upstream_traceability(level, stream='upstream', line_id=line_id, model=model, model_id=model_id, parent_quant=parent_quant)
-                final_vals = self.make_dict_head(level, stream=context.get('stream', False), line_id=line_id, move=False, quant=quant, final_vals=final_vals)
+            for move_line in obj_ids:
-                    final_vals = self.make_dict_head(line['level'], line_id=line['id'], move=model, quant=False, final_vals=final_vals)
+                    final_vals += self.make_dict_head(line['level'], model=line['model_name'], parent_id=line['id'], move_line=model)
-                    final_vals = self.make_dict_head(line['level'], line_id=line['id'], quant=model, final_vals=final_vals)
+                if line['model_name'] == 'stock.pack.operation':
-            "mrp_workorder.report_stock_inventory_print",
+            "stock.report_stock_inventory_print",
-        result['html'] = self.env.ref('mrp_workorder.report_stock_inventory').render(rcontext)
+        result['html'] = self.env.ref('stock.report_stock_inventory').render(rcontext)
-        return {'type': 'ir.actions.act_window_close'}
+    'qweb': [
-        self.MoveObj.create({
+        move_a = self.MoveObj.create({
-        self.MoveObj.create({
+        move_b = self.MoveObj.create({
-        self.MoveObj.create({
+        move_c = self.MoveObj.create({
-        self.MoveObj.create({
+        move_d = self.MoveObj.create({
-            'product_qty': 5.0})
+        picking_in.action_assign()
-            'product_qty': 2,
+            'qty_done': 2,
-            'pack_lot_ids': [(0, 0, {'lot_id': lot2_productC.id, 'qty': 2.0})],
+            'move_id': move_c.id,
-            'product_qty': 2,
+            'qty_done': 2,
-            'picking_id': picking_in.id})
+            'move_id': move_d.id
-        self.assertEqual(sum(total_qty), 23,  'Wrong quantity in pack operation (%s found instead of 23)' % (sum(total_qty)))
+        total_qty = sum(self.StockPackObj.search([('move_id', 'in', picking_in.move_lines.ids)]).mapped('qty_done'))
-        picking_in.do_transfer()
+        picking_in.action_done()
-        # Check total no of move lines of incoming shipment.
+        # Check total no of move lines of incoming shipment. move line e disappear from original picking to go in backorder.
-        self.MoveObj.create({
+        move_cust_a = self.MoveObj.create({
-        self.MoveObj.create({
+        move_cust_b = self.MoveObj.create({
-        self.MoveObj.create({
+        move_cust_c = self.MoveObj.create({
-        self.MoveObj.create({
+        move_cust_d = self.MoveObj.create({
-        self.assertEqual(picking_out.move_lines[3].state, 'confirmed', 'Wrong state of move line.')
+        self.assertEqual(move_cust_a.state, 'partially_available', 'Wrong state of move line.')
-        self.StockPackObj.search([('product_id', '=', self.productB.id), ('picking_id', '=', picking_out.id)]).write({'product_qty': 3.0})
+        move_cust_a.pack_operation_ids.qty_done = 2.0
-            'product_qty': 2,
+            'qty_done': 2,
-            'product_qty': 2.0, 'pack_lot_ids': [(0, 0, {'lot_id': lot2_productC.id, 'qty': 2.0})],})
+            'move_id': move_cust_b.id})
-            'product_qty': 3,
+            'qty_done': 3.0,
-        self.StockPackObj.search([('product_id', '=', self.productD.id), ('picking_id', '=', picking_out.id)]).write({'product_qty': 6.0})
+            'move_id': move_cust_c.id})
-        picking_out.do_transfer()
+        picking_out.action_done()
-        #------------------
+
-        #-----------------------------------------------------------------------
+        # -----------------------------------------------------------------------
-        #-----------------------------------------------------------------------
+        # -----------------------------------------------------------------------
-        total_qty = [quant.qty for quant in quants]
+        total_qty = [quant.quantity for quant in quants]
-        total_qty = [quant.qty for quant in quants]
+        total_qty = [quant.quantity for quant in quants]
-        self.assertEqual(quant.qty, 1.0, 'Expecting 1.0 Unit , got %.4f Unit on location stock!' % (quant.qty))
+        self.assertEqual(quant.quantity, 1.0, 'Expecting 1.0 Unit , got %.4f Unit on location stock!' % (quant.quantity))
-        #-----------------------------------------------------------------------
+
-        #-----------------------------------------------------------------------
+        # -----------------------------------------------------------------------
-        lot2_productD = LotObj.create({'name': 'Lot 2', 'product_id': self.productD.id})
+        LotObj.create({'name': 'Lot 2', 'product_id': self.productD.id})
-            'pack_lot_ids': [(0, 0, {'lot_id': lot1_productD.id, 'qty': 4.0})],})
+        packD = self.StockPackObj.search([('product_id', '=', self.productD.id), ('picking_id', '=', back_order_in.id)], order='product_qty')
-                      })
+        packCs.write({
-            'product_qty': 1,
+            'qty_done': 1,
-            'pack_lot_ids': [(0, 0, {'lot_id': lot4_productC.id, 'qty': 1.0})]})
+            'lot_id': lot4_productC.id,
-            'product_qty': 2,
+            'qty_done': 2,
-            'pack_lot_ids': [(0, 0, {'lot_id': lot5_productC.id, 'qty': 2.0})]})
+            'lot_id': lot5_productC.id,
-            'product_qty': 2,
+            'qty_done': 2,
-            'pack_lot_ids': [(0, 0, {'lot_id': lot6_productC.id, 'qty': 2.0})]})
+            'lot_id': lot6_productC.id,
-            'product_qty': 10,
+            'qty_done': 10,
-        back_order_in.do_transfer()
+            'picking_id': back_order_in.id
-        self.assertEqual(len(back_order_in.move_lines), 6, 'Wrong number of move lines')
+        self.assertEqual(len(back_order_in.move_lines), 5, 'Wrong number of move lines')
-        self.assertEqual(set(c_done_qty), set([3.0, 1.0, 2.0]), 'Wrong quantity of moves product C.')
+        self.assertEqual(set(c_done_qty), set([3.0, 3.0]), 'Wrong quantity of moves product C.')
-        #-----------------------------------------------------------------------
+        # -----------------------------------------------------------------------
-        #-----------------------------------------------------------------------
+        # -----------------------------------------------------------------------
-        total_qty = [quant.qty for quant in quants]
+        total_qty = [quant.quantity for quant in quants]
-        total_qty = [quant.qty for quant in quants]
+        total_qty = [quant.quantity for quant in quants]
-        total_qty = [quant.qty for quant in quants]
+        total_qty = [quant.quantity for quant in quants]
-        #-----------------------------------------------------------------------
+
-        total_qty = [quant.qty for quant in quants]
+        total_qty = [quant.quantity for quant in quants]
-        picking_in_A.do_prepare_partial()
+
-        #-----------------------------------------------------------------------
+        res_dict = picking_in_A.button_validate()
-        #-----------------------------------------------------------------------
+        # -----------------------------------------------------------------------
-        total_qty = [quant.qty for quant in quants]
+        total_qty = [quant.quantity for quant in quants]
-        total_qty = [quant.qty for quant in quants]
+        total_qty = [quant.quantity for quant in quants]
-        total_qty = [quant.qty for quant in quants]
+        total_qty = [quant.quantity for quant in quants]
-        total_qty = [quant.qty for quant in quants]
+        total_qty = [quant.quantity for quant in quants]
-        total_qty = [quant.qty for quant in quants]
+        total_qty = [quant.quantity for quant in quants]
-        self.MoveObj.create({
+        move_in_a = self.MoveObj.create({
-        self.assertEqual(PackdozA.product_qty, 120, 'Wrong quantity in pack operation (%s found instead of 120)' % (PackdozA.product_qty))
+        self.assertEqual(PackdozA.product_uom_qty, 120, 'Wrong quantity in pack operation (%s found instead of 120)' % (PackdozA.product_uom_qty))
-        self.assertEqual(PackSdozA.product_qty, 1512, 'Wrong quantity in pack operation (%s found instead of 1512)' % (PackSdozA.product_qty))
+        self.assertEqual(PackSdozA.product_uom_qty, 1512, 'Wrong quantity in pack operation (%s found instead of 1512)' % (PackSdozA.product_uom_qty))
-        self.assertEqual(PackSdozAround.product_qty, 1584, 'Wrong quantity in pack operation (%s found instead of 1584)' % (PackSdozAround.product_qty))
+        self.assertEqual(PackSdozAround.product_uom_qty, 1584, 'Wrong quantity in pack operation (%s found instead of 1584)' % (PackSdozAround.product_uom_qty))
-        self.assertEqual(packgB.product_uom_id.id, self.uom_gm.id, 'Wrong uom in pack operation for product gB.')
+        self.assertEqual(packgB.product_uom_qty, 0.525, 'Wrong quantity in pack operation (%s found instead of 0.525)' % (packgB.product_uom_qty))
-        self.assertEqual(packkgB.product_qty, 20.0, 'Wrong quantity in pack operation (%s found instead of 20)' % (packkgB.product_qty))
+        self.assertEqual(packkgB.product_uom_qty, 20.0, 'Wrong quantity in pack operation (%s found instead of 20)' % (packkgB.product_uom_qty))
-            'product_qty': 0.020, 'product_uom_id': self.uom_kg.id})
+            'product_uom_qty': 0.020, 'product_uom_id': self.uom_kg.id})
-            'product_qty': 525.3, 'product_uom_id': self.uom_gm.id})
+            'product_uom_qty': 526, 'product_uom_id': self.uom_gm.id})
-            'product_qty': 4, 'product_uom_id': self.uom_dozen.id})
+            'product_uom_qty': 4, 'product_uom_id': self.uom_dozen.id})
-            'product_qty': 48,
+            'product_uom_qty': 48,
-            'picking_id': picking_in_B.id})
+            'move_id': move_in_a.id
-        #-----------------------------------------------------------------------
+        res_dict = picking_in_B.button_validate()
-        self.assertEqual(moves_gB_g.product_uom.id, self.uom_gm.id, 'Wrong uom in move for product gB.')
+
-        total_qty = [quant.qty for quant in quants]
+        total_qty = [quant.quantity for quant in quants]
-        self.assertEqual(sum(total_qty), 21, 'Expecting 18 SDozen , got %.4f SDozen on location stock!' % (sum(total_qty)))
+        total_qty = [quant.quantity for quant in quants]
-        total_qty = [quant.qty for quant in quants]
+        total_qty = [quant.quantity for quant in quants]
-        self.assertEqual(self.gB.qty_available, 1050.6, 'Wrong quantity available (%s found instead of 1050.6)' % (self.gB.qty_available))
+        total_qty = [quant.quantity for quant in quants]
-        total_qty = [quant.qty for quant in quants]
+        total_qty = [quant.quantity for quant in quants]
-        picking_out.do_transfer()
+        res_dict = picking_out.button_validate()
-            'product_uom_qty': 360,
+            'product_uom_qty': 361,
-        DozA_qty = self.MoveObj.search([('product_id', '=', self.DozA.id), ('picking_id', '=', picking_out.id)], limit=1).reserved_availability
+        DozA_qty = self.MoveObj.search([('product_id', '=', self.DozA.id), ('picking_id', '=', picking_out.id)], limit=1).product_qty
-        SDozA_qty = self.MoveObj.search([('product_id', '=', self.SDozA.id), ('picking_id', '=', picking_out.id)], limit=1).reserved_availability
+        SDozA_qty = self.MoveObj.search([('product_id', '=', self.SDozA.id), ('picking_id', '=', picking_out.id)], limit=1).product_qty
-        SDozARound_qty = self.MoveObj.search([('product_id', '=', self.SDozARound.id), ('picking_id', '=', picking_out.id)], limit=1).reserved_availability
+        SDozARound_qty = self.MoveObj.search([('product_id', '=', self.SDozARound.id), ('picking_id', '=', picking_out.id)], limit=1).product_qty
-        gB_qty = self.MoveObj.search([('product_id', '=', self.gB.id), ('picking_id', '=', picking_out.id)], limit=1).reserved_availability
+        gB_qty = self.MoveObj.search([('product_id', '=', self.gB.id), ('picking_id', '=', picking_out.id)], limit=1).product_qty
-        kgB_qty = self.MoveObj.search([('product_id', '=', self.kgB.id), ('picking_id', '=', picking_out.id)], limit=1).reserved_availability
+        kgB_qty = self.MoveObj.search([('product_id', '=', self.kgB.id), ('picking_id', '=', picking_out.id)], limit=1).product_qty
-        picking_out.do_transfer()
+        res_dict = picking_out.button_validate()
-        total_qty = [quant.qty for quant in quants]
+        total_qty = [quant.quantity for quant in quants]
-        total_qty = [quant.qty for quant in quants]
+        total_qty = [quant.quantity for quant in quants]
-        total_qty = [quant.qty for quant in quants]
+        total_qty = [quant.quantity for quant in quants]
-        self.assertEqual(self.gB.qty_available, 547.6, 'Wrong quantity available (%s found instead of 547.6)' % (self.gB.qty_available))
+        total_qty = [quant.quantity for quant in quants]
-        total_qty = [quant.qty for quant in quants]
+        total_qty = [quant.quantity for quant in quants]
-        bo_in_B.do_transfer()
+        res_dict = bo_in_B.button_validate()
-        total_qty = [quant.qty for quant in quants]
+        total_qty = [quant.quantity for quant in quants]
-        productKG = self.ProductObj.create({'name': 'Product KG', 'uom_id': self.uom_kg.id, 'uom_po_id': self.uom_kg.id})
+        productKG = self.ProductObj.create({'name': 'Product KG', 'uom_id': self.uom_kg.id, 'uom_po_id': self.uom_kg.id, 'type': 'product'})
-        self.assertEqual(packKG.product_uom_id.id, self.uom_kg.id, 'Wrong product uom in pack operation.')
+        self.assertEqual(packKG.product_qty, 1000, 'Wrong product real quantity in pack operation (%s found instead of 1000)' % (packKG.product_qty))
-        picking_in.do_transfer()
+        res_dict = picking_in.button_validate()
-        #-----------------------------------------------------------------------
+        # -----------------------------------------------------------------------
-        #-----------------------------------------------------------------------
+        # -----------------------------------------------------------------------
-        picking_out.do_transfer()
+        pack_opt.write({'product_uom_qty': 0.5})
-        total_qty = [quant.qty for quant in quants]
+        total_qty = [quant.quantity for quant in quants]
-        #---------------------------------
+        # ---------------------------------
-        bo_out_1.do_transfer()
+        pack_opt.write({'product_uom_qty': 0.5})
-        total_qty = [quant.qty for quant in quants]
+        total_qty = [quant.quantity for quant in quants]
-        #---------------------------------
+        # ---------------------------------
-        bo_out_2.do_transfer()
+        pack_opt.write({'product_uom_qty': 0.5})
-        total_qty = [quant.qty for quant in quants]
+        total_qty = [quant.quantity for quant in quants]
-        #---------------------------------
+        # ---------------------------------
-        bo_out_3.do_transfer()
+        pack_opt.write({'product_uom_qty': 0.5})
-        total_qty = [quant.qty for quant in quants]
+        total_qty = [quant.quantity for quant in quants]
-        #---------------------------------
+        # ---------------------------------
-        bo_out_4.do_transfer()
+        pack_opt.write({'product_uom_qty': 0.5})
-        total_qty = [quant.qty for quant in quants]
+        total_qty = [quant.quantity for quant in quants]
-        total_qty = [quant.qty for quant in quants]
+        total_qty = [quant.quantity for quant in quants]
-        total_qty = [quant.qty for quant in quants]
+        total_qty = [quant.quantity for quant in quants]
-        productKG = self.ProductObj.create({'name': 'Product KG', 'uom_id': self.uom_kg.id, 'uom_po_id': self.uom_kg.id})
+        productKG = self.ProductObj.create({'name': 'Product KG', 'uom_id': self.uom_kg.id, 'uom_po_id': self.uom_kg.id, 'type': 'product'})
-        total_qty = [quant.qty for quant in quants]
+        total_qty = [quant.quantity for quant in quants]
-        total_qty = [quant.qty for quant in quants]
+        total_qty = [quant.quantity for quant in quants]
-        #--------------------------------------------------------
+        # --------------------------------------------------------
-        #---------------------------------------------------------
+        # ---------------------------------------------------------
-        lotproduct = self.ProductObj.create({'name': 'Lot Product', 'uom_id': self.uom_unit.id, 'uom_po_id': self.uom_unit.id})
+        packproduct = self.ProductObj.create({'name': 'Pack Product', 'uom_id': self.uom_unit.id, 'uom_po_id': self.uom_unit.id, 'type': 'product'})
-        pack2 = pack_obj.create({'name': 'PACK00TEST2'})
+        pack_obj.create({'name': 'PACK00TEST2'})
-        total_qty = sum([quant.qty for quant in quants])
+        total_qty = sum([quant.quantity for quant in quants])
-        #Create an inventory that will put the lots without lot to 0 and check that taking without pack will not take it from the pack
+        # Create an inventory that will put the lots without lot to 0 and check that taking without pack will not take it from the pack
-                                        'location_id': self.stock_location})
+                                         'filter': 'partial',
-        total_qty = sum([quant.qty for quant in quants])
+        total_qty = sum([quant.quantity for quant in quants])
-        total_qty = sum([quant.qty for quant in quants])
+        total_qty = sum([quant.quantity for quant in quants])
-
+        res_dict = picking_in.button_validate()
-        self.MoveObj.create({
+        move_out = self.MoveObj.create({
-        picking_out.do_new_transfer()
+
-        self.assertEqual(sum([x.qty for x in quants if x.lot_id.id == lot3.id]), 2.0, 'Wrong sum of quants with lot 3')
+        # TODO wait sle fix
-            'location_id': self.stock_location   ,
+            'location_id': self.stock_location,
-            'move_dest_id': move_out.id})
+            'move_dest_ids': [(4, move_out.id, 0)]})
-            'move_dest_id': move_pack.id})
+            'move_dest_ids': [(4, move_pack.id, 0)]})
-        picking_in.pack_operation_product_ids.qty_done = 3.0
+        move_in.pack_operation_ids.qty_done = 3.0
-        picking_in_package = picking_in.pack_operation_ids.result_package_id
+        picking_in_package = move_in.pack_operation_ids.result_package_id
-        picking_in.do_new_transfer()
+        picking_in.action_done()
-        picking_pack.put_in_pack()
+        # Set the quantity done on the pack operation
-        picking_pack_package = picking_pack.pack_operation_ids.result_package_id
+        picking_pack_package = move_pack.pack_operation_ids.result_package_id
-        picking_pack.do_new_transfer()
+        picking_pack.action_done()
-        picking_out.do_new_transfer()
+        picking_out.pack_operation_ids.qty_done = 3.0
-        self.assertEqual(quant.qty, 3.0, 'The quant in customer location for productA has not a quantity of 3.0')
+        self.assertEqual(picking_in_package.id, picking_pack_package.id, 'The package created in the picking in is not in the one created in picking pack')
-        packop2.product_qty = 6
+        picking_in.pack_operation_ids[0].qty_done = 4
-        self.assertEqual(sum(x.qty for x in pack2.quant_ids), 6.0, 'Pack 2 should have 6 pieces')
+        picking_in.action_done()
-        packout1.product_qty = 2
+        packout2 = picking_out.pack_operation_ids[0].with_context(bypass_reservation_update=True).copy({'product_uom_qty': 0})
-        neg_quants = self.env['stock.quant'].search([('product_id', '=', self.productE.id), ('qty', '<', 0.0)])
+        packout2.qty_done = 1
-        self.assertEqual(len(picking_out.move_lines[0].quant_ids), 2, 'We should have exactly 2 quants in the end')
+        quants = self.env['stock.quant']._gather(self.productE, self.env['stock.location'].browse(self.stock_location))
-        packop2.product_qty = 80
+        picking_in.pack_operation_ids[0].qty_done = 120
-        self.assertEqual(sum(x.qty for x in pack2.quant_ids), 80, 'Pack 2 should have 80 pieces')
+        picking_in.action_done()
-        #Convert entire packs into taking out of packs
+        # Convert entire packs into taking out of packs
-            'product_qty': 120.0,
+            'qty_done': 120.0,
-            'product_qty': 80.0,
+            'qty_done': 80.0,
-        neg_quants = self.env['stock.quant'].search([('product_id', '=', self.productE.id), ('qty', '<', 0.0)])
+        picking_out.action_done()
-        self.assertEqual(len(picking_out.move_lines[0].quant_ids), 2, 'We should have exactly 2 quants in the end')
+        quants = self.env['stock.quant']._gather(self.productE, self.env['stock.location'].browse(self.stock_location))
-
+        self.assertEquals(len(picking_out.move_lines), 1.0)
-            'procure_method':'make_to_order'})
+            'procure_method': 'make_to_order'})
-            'move_dest_id': move_with_ancestors.id})
+            'move_dest_ids': [(4, move_with_ancestors.id, 0)]})
-class TestInventory(TestStockCommon):
+class TestWarehouse(TestStockCommon):
-        # TDE NOTE: replaces test/inventory.yml present until saas-10
+        self.product_1.type = 'product'
-        self.assertEqual(inventory.move_ids.quant_ids.history_ids[0].product_qty, 50.0)
+        quants = self.env['stock.quant']._gather(self.product_1, self.env.ref('stock.location_inventory'))
-        self.assertEqual(self.product_1.with_context(location=self.env.ref('stock.stock_location_stock').id).qty_available, 0.0)
+        self.assertEqual(self.env['stock.quant']._gather(self.product_1, self.warehouse_1.lot_stock_id).quantity, 35.0)
-
+        product.type = 'product'
-
+        customer_move.quantity_done = 5
-        self.assertEqual(product.with_context(location=self.env.ref('stock.stock_location_customers').id).qty_available, 5.0)
+        receive_move.quantity_done = 15
-        picking_out.do_transfer()
+        picking_out.move_lines.quantity_done = 1
-        return_wiz = self.env['stock.return.picking']\
+        quant = self.env['stock.quant'].search([('product_id', '=', productA.id), ('location_id', '=', stock_location.id)])
-        return_pick = self.env['stock.picking'].browse(res['res_id'])
+            .create({})
-        return_pick.do_transfer()
+        return_pick.move_lines.quantity_done = 1
-        self.assertEqual(quant.qty, 1)
+        quant = self.env['stock.quant'].search([('product_id', '=', productA.id), ('location_id', '=', stock_location.id)])
-    @api.depends('quant_ids', 'children_ids')
+    @api.depends('quant_ids')
-            total_weight = sum([po.qty_done * po.product_id.weight for po in pack_operation_product_ids]) + sum([po.package_id.weight for po in pack_operation_pack_ids])
+            pack_operation_ids = [po for po in picking_id.pack_operation_ids if po.qty_done > 0 and not po.result_package_id]
-
+            has_package = move.pack_operation_ids.mapped('package_id') | move.pack_operation_ids.mapped('result_package_id')
-                    and (multi_locations_enabled or move.has_tracking != 'none' or len(move.pack_operation_ids) > 1):
+                    and (multi_locations_enabled or move.has_tracking != 'none' or len(move.pack_operation_ids) > 1 or has_package):
-    package_id = fields.Many2one('stock.quant.package', 'Source Package')
+    package_id = fields.Many2one('stock.quant.package', 'Source Package', ondelete='restrict')
-        ondelete='cascade', required=False,
+        ondelete='restrict', required=False,
-from odoo.tools.float_utils import float_compare
+from odoo.tools.float_utils import float_compare, float_round
-                pack_operation_ids |= op
+            operations = pick.pack_operation_ids.filtered(lambda o: o.qty_done > 0 and not o.result_package_id)
-                pack_operation_ids.write({'result_package_id': package.id})
+                package = self.env['stock.quant.package'].create({})
-        help='The package containing this quant', readonly=True)
+        help='The package containing this quant', readonly=True, ondelete='restrict')
-    children_ids = fields.One2many('stock.quant.package', 'parent_id', 'Contained Packages', readonly=True)
+    move_line_ids = fields.One2many('stock.pack.operation', 'result_package_id')
-    @api.depends('quant_ids.package_id', 'quant_ids.location_id', 'quant_ids.company_id', 'quant_ids.owner_id', 'ancestor_ids')
+    @api.depends('quant_ids.package_id', 'quant_ids.location_id', 'quant_ids.company_id', 'quant_ids.owner_id')
-                values = {'location_id': False, 'company_id': self.env.user.company_id.id, 'owner_id': False}
+            values = {'location_id': False, 'company_id': self.env.user.company_id.id, 'owner_id': False}
-                current = current.parent_id
+            name = package.name
-            locations = parent.get_content().filtered(lambda quant: quant.qty > 0.0).mapped('location_id')
+            locations = pack.get_content().filtered(lambda quant: quant.qty > 0.0).mapped('location_id')
-        return self.env['ir.actions.act_window'].for_xml_id('stock', 'action_package_view')
+            move_lines_to_remove = self.move_line_ids.filtered(lambda move_line: move_line.state != 'done')
-    product_id = fields.Many2one('product.product', string="Product", required=True)
+    product_id = fields.Many2one('product.product', string="Product", required=True, domain="[('id', '=', product_id)]")
-                if move.move_dest_id:
+                if move.move_dest_ids:
-                quantity = move.product_id.uom_id._compute_quantity(quantity, move.product_uom)
+                quantity = move.product_qty - sum(move.move_dest_ids.filtered(lambda m: m.state in ['partially_available', 'assigned', 'done']).\
-            unreserve_moves.write({'move_orig_ids': False})
+        # TODO sle: the unreserve of the next moves could be less brutal
-
+            # TODO sle: float_is_zero?
-                return_line.move_id.copy({
+                r = return_line.move_id.copy({
-                    'move_dest_id': move_dest_id,
+                r.write({'move_orig_ids': [(4, return_line.move_id.id, False)]})
-# Part of Odoo. See LICENSE file for full copyright and licensing details.
+# Part of Odoo. See ICENSE file for full copyright and licensing details.
-        new_picking = picking.copy({
+        picking_type_id = self.picking_id.picking_type_id.return_picking_type_id.id or self.picking_id.picking_type_id.id
-            'location_id': picking.location_dest_id.id,
+            'origin': self.picking_id.name,
-            values={'self': new_picking, 'origin': picking},
+            values={'self': new_picking, 'origin': self.picking_id},
-                    'warehouse_id': picking.picking_type_id.warehouse_id.id,
+                    'warehouse_id': self.picking_id.picking_type_id.warehouse_id.id,
-            'context': {'default_picking_id': self.id, 'product_ids': self.pack_operation_product_ids.mapped('product_id').ids},
+            'context': {'default_picking_id': self.id, 'product_ids': scrapeable_products.ids},
-            if any([not x[0] for x in quants]):
+            quantity_in_stock = self.env['stock.quant']._get_quantity(
-            moves.recalculate_move_state()
+            # TODO: unreserve reserved
-            'restrict_partner_id': self.owner_id.id,
+            'pack_operation_ids': [(0, 0, {'product_id': self.product_id.id,
-        'data/stock_demo.xml',
+        'data/stock_demo.xml',
-    def _get_move_values(self, qty, location_id, location_dest_id):
+    def _get_move_values(self, qty, location_id, location_dest_id, out):
-            'restrict_lot_id': self.prod_lot_id.id,
+            #'restrict_lot_id': self.prod_lot_id.id,
-                vals = self._get_move_values(abs(diff), line.product_id.property_stock_inventory.id, line.location_id.id)
+                vals = self._get_move_values(abs(diff), line.product_id.property_stock_inventory.id, line.location_id.id, False)
-                            quant._quant_reconcile_negative(move)
+                vals = self._get_move_values(abs(diff), line.location_id.id, line.product_id.property_stock_inventory.id, True)
-        'Quantity',
+        'Initial Demand',
-        help="Remaining Quantity in default UoM according to operations matched with this move")
+    pack_operation_nosuggest_ids = fields.One2many('stock.pack.operation', 'move_id', domain=[('product_qty', '=', 0.0)])
-    quantity_done = fields.Float('Quantity', compute='_qty_done_compute', digits=dp.get_precision('Product Unit of Measure'))
+    quantity_done = fields.Float('Quantity Done', compute='_quantity_done_compute', digits=dp.get_precision('Product Unit of Measure'), inverse='_quantity_done_set',
-
+    @api.model
-        self.product_uom_qty = 1.0
+        if self.product_uom_qty:
-    _name = "stock.pack.operation"
+    _name = "stock.pack.operation" #TODO: change to stock.move.operation
-    lot_id = fields.Many2one('stock.production.lot', 'Lot')
+    @api.depends('picking_id.picking_type_id', 'product_id.tracking')
-            picking = self.picking_id
+        picking = self.picking_id
-        'stock.pack.operation', 'picking_id', 'Related Packing Operations',
+        'stock.pack.operation', 'picking_id', 'Operations',
-        cancel_moves = self.with_context(cancel_procurement=True).filtered(lambda order: order.rule_id.action == 'move').mapped('move_ids')
+        cancel_moves = self.filtered(lambda order: order.rule_id.action == 'move').mapped('move_ids').filtered(lambda m: m.state not in ('cancel', 'done'))
-            'move_dest_id': self.move_dest_id and self.move_dest_id.id or False,
+            'move_dest_ids': self.move_dest_id and [(4, self.move_dest_id.id)] or False,
-            move.write({'move_dest_id': new_move.id})
+            move.write({'move_dest_ids': [(4, new_move.id)]})
-        copy=False, index=True,
+    move_dest_ids = fields.Many2many(
-        'stock.move', 'move_dest_id', 'Original Move',
+    move_orig_ids = fields.Many2many(
-        ('assigned', 'Available'), ('done', 'Done')], string='Status',
+        ('waiting', 'Waiting Another Move'),
-        help='Operations that impact this move for the computation of the remaining quantities')
+    pack_operation_ids = fields.One2many('stock.pack.operation', 'move_id')
-            self.product_qty = self.product_uom._compute_quantity(self.product_uom_qty, self.product_id.uom_id)
+        self.product_qty = self.product_uom._compute_quantity(self.product_uom_qty, self.product_id.uom_id)
-        self.remaining_qty = float_round(self.product_qty - sum(self.mapped('linked_move_operation_ids').mapped('qty')), precision_rounding=self.product_id.uom_id.rounding)
+        # TODO: sle jco
-    @api.depends('reserved_quant_ids.qty')
+    @api.depends('pack_operation_ids.product_qty')
-        self.reserved_availability = sum(self.mapped('reserved_quant_ids').mapped('qty'))
+        """ Fill the `availability` field on a stock move, which is the actual reserved quantity
-            self.availability = min(self.product_qty, sum(quants.mapped('qty')))
+            total_availability = self.env['stock.quant']._get_available_quantity(self.product_id, self.location_id)
-                if move.move_dest_id and move.propagate:
+                if move.move_dest_ids and move.propagate:
-        pass
+        if any(move.state in ('done', 'cancel') for move in self):
-            if move.move_dest_id:
+            if move.move_dest_ids:
-        return True
+    @api.onchange('product_uom')
-                    inner_move = inner_move.split_from
+                if move.procure_method == 'make_to_order':
-
+                    move_to_confirm |= move
-        (pickings - pickings_partial).write({'recompute_pack_op': True})
+        """ Allow to work on stock move lines even if the reservationis not possible. We just mark
-        return True
+        """ Reserve stock moves by creating their stock move lines. A stock move is 
-                                      dest_package_id=quant_dest_package_id, entire_pack=entire_pack)
+    def _create_extra_move(self):
-        pickings.filtered(lambda picking: picking.state == 'done' and not picking.date_done).write({'date_done': time.strftime(DEFAULT_SERVER_DATETIME_FORMAT)})
+                    # split this move line and assign the new part to our extra move
-        return True
+    @api.multi
-            'move_dest_id': self.move_dest_id.id,
+            'move_dest_ids': [(4, x.id) for x in self.move_dest_ids if x.state not in ('done', 'cancel')],
-            new_move.write({'move_dest_id': new_move_prop})
+        # FIXME: pim fix your crap
-from odoo.tools.float_utils import float_round, float_compare
+from odoo.exceptions import UserError
-    product_qty = fields.Float('To Do', default=0.0, digits=dp.get_precision('Product Unit of Measure'), required=True)
+    move_id = fields.Many2one(
-    is_done = fields.Boolean(compute='_compute_is_done', string='Done', readonly=False, oldname='processed_boolean')
+    qty_done = fields.Float('Done', default=0.0, digits=dp.get_precision('Product Unit of Measure'), copy=False)
-    date = fields.Datetime('Date', default=fields.Date.context_today, required=True)
+    lot_id = fields.Many2one('stock.production.lot', 'Lot')
-    fresh_record = fields.Boolean('Newly created pack operation', default=True)
+    location_id = fields.Many2one('stock.location', 'From', required=True)
-                self.qty_done = 0.0
+    state = fields.Selection(related='move_id.state')
-        elif self.picking_id.picking_type_id and self.product_id.tracking != 'none':  # TDE FIXME: not sure correctly migrated
+        if self.picking_id.picking_type_id and self.product_id.tracking != 'none':  # TDE FIXME: not sure correctly migrated
-        self.qty_done = sum([x.qty for x in self.pack_lot_ids])
+    @api.one
-                self.product_uom_id = self.product_id.uom_id.id
+                if self.move_id.product_uom:
-        return super(PackOperation, self).create(vals)
+        vals['ordered_qty'] = vals.get('product_uom_qty')
-        return super(PackOperation, self).write(values)
+    def write(self, vals):
-            raise UserError(_('You can not delete pack operations of a done picking'))
+        precision = self.env['decimal.precision'].precision_get('Product Unit of Measure')
-             "Used at the stock_move_obj.action_done() time to avoid seeking a matching quant again")
+    def action_done(self):
-    # TDE FIXME: separate those two kind of pack operations
+
-    launch_pack_operations = fields.Boolean("Launch Pack Operations", copy=False)
+    show_operations = fields.Boolean(related='picking_type_id.show_operations')
-    @api.depends('move_type', 'launch_pack_operations', 'move_lines.state', 'move_lines.picking_id', 'move_lines.partially_available')
+    @api.depends('move_type', 'move_lines.state', 'move_lines.picking_id')
-        elif not self.move_lines:
+        # FIXME: goes in 3 times at each write?
-            # "waiting" and finally "assigned" at the end.
+            # We sort our moves by importance of state:
-                .sorted(key=lambda move: (move.state == 'assigned' and 2) or (move.state == 'waiting' and 1) or 0)
+                .sorted(key=lambda move: sort_map.get(move.state, 0))
-            elif moves_todo[0].state != 'assigned' and any(x.partially_available or x.state == 'assigned' for x in moves_todo):
+                if moves_todo[0].state in ('partially_available', 'confirmed'):
-        self.filtered(lambda picking: picking.location_id.usage in ('supplier', 'inventory', 'production')).force_assign()
+        # call `action_confirm` on every draft move
-        self.mapped('move_lines').filtered(lambda move: move.state in ['confirmed', 'waiting']).force_assign()
+        self.mapped('move_lines').filtered(lambda move: move.state in ['confirmed', 'waiting', 'partially_available']).force_assign()
-        draft_moves.action_confirm()
+        todo_moves = self.mapped('move_lines').filtered(lambda self: self.state in ['draft', 'partially_available', 'assigned', 'confirmed'])
-        return pack_operation_values
+    do_transfer = action_done #TODO:replace later
-            existing_packages.unlink()
+    def _check_entire_pack(self):
-        self.write({'recompute_pack_op': False})
+            origin_packages = picking.pack_operation_ids.mapped("package_id")
-        return True
+        for move in self:
-    def recompute_remaining_qty(self, done_qtys=False):
+    @api.multi
-                prod2move_ids[move.product_id.id] = [{'move': move, 'remaining_qty': move.product_qty}]
+        # Check backorder should check for other barcodes
-        self.do_transfer()
+                pack_operations_delete |= operation
-        need_rereserve, all_op_processed = self.picking_recompute_remaining_quantities(done_qtys=True)
+        self.ensure_one()
-    create_lots_for_picking = _create_lots_for_picking
+            quantity_todo.setdefault(move.product_id.id, 0)
-                'warehouse_id': self.id}
+                'warehouse_id': self.id,
-                pack.write({'qty_done': pack.product_qty})
+        for move in self.pick_id.move_lines:
-                pack.unlink()
+                move.quantity_done = move.product_uom_qty
-                order.unreserve_visible = True
+        return True
-    def _quants_removal_get_order(self, removal_strategy):
+    def _get_removal_strategy_order(self, removal_strategy):
-        return super(StockQuant, self)._quants_removal_get_order(removal_strategy=removal_strategy)
+        return super(StockQuant, self)._get_removal_strategy_order(removal_strategy)
-        quants_res = dict((item['product_id'][0], item['qty']) for item in Quant.read_group(domain_quant, ['product_id', 'qty'], ['product_id']))
+        quants_res = dict((item['product_id'][0], item['quantity']) for item in Quant.read_group(domain_quant, ['product_id', 'quantity'], ['product_id']))
-        self.env.cr.execute("""SELECT product_id, sum(qty) as product_qty, location_id, lot_id as prod_lot_id, package_id, owner_id as partner_id
+        self.env.cr.execute("""SELECT product_id, sum(quantity) as product_qty, location_id, lot_id as prod_lot_id, package_id, owner_id as partner_id
-        theoretical_qty = sum([x.qty for x in self._get_quants()])
+        theoretical_qty = sum([x.quantity for x in self._get_quants()])
-            (self - waiting).write({'state': 'confirmed'})
+        pass
-            procurements.check()
+    def action_assign(self):
-                                             (x.location_id.id == pack_operation.location_id.id) and (x.package_id.id == pack_operation.package_id.id)]
+    def action_cancel(self):
-            moves_to_unreserve.do_unreserve()
+        return True
-        self.product_qty = sum(self.quant_ids.mapped('qty'))
+        self.product_qty = sum(self.quant_ids.mapped('quantity'))
-from datetime import datetime
+# -*- coding: utf-8 -*-
-from odoo.exceptions import UserError
+from psycopg2 import OperationalError
-import logging
+from odoo import api, fields, models, _
-_logger = logging.getLogger(__name__)
+class StockQuant(models.Model):
-        index=True, ondelete="restrict", readonly=True, required=True)
+        ondelete='restrict', readonly=True, required=True)
-        help="The move the quant is reserved for")
+        auto_join=True, ondelete='restrict', readonly=True, required=True)
-    cost = fields.Float('Unit Cost', group_operator='avg')
+        ondelete='restrict', readonly=True)
-        help="Technical field used to record the destination location of a move that created a negative quant")
+        help='This is the owner of the quant', readonly=True)
-        self.name = '%s: %s%s' % (self.lot_id.name or self.product_id.code or '', self.qty, self.product_id.uom_id.name)
+    @api.multi
-    def _compute_inventory_value(self):
+    @api.constrains('quantity')
-            self._cr.execute('CREATE INDEX stock_quant_product_location_index ON stock_quant (product_id, location_id, company_id, qty, in_date, reservation_id)')
+            if quant.quantity > 1 and quant.lot_id and quant.product_id.tracking == 'serial':
-        return super(Quant, self).unlink()
+    @api.one
-        return res
+    def _get_removal_strategy(self, product_id, location_id):
-        return action
+    @api.model
-            move.write({'partially_available': True})
+    def _get_quantity(self, product_id, location_id, lot_id=None, package_id=None, owner_id=None, strict=False):
-        :param dest_package_id: ID of the package that must be set on the moved quant
+    def _get_available_quantity(self, product_id, location_id, lot_id=None, package_id=None, owner_id=None, strict=False):
-                    raise UserError(_('The serial number %s is already in stock.') % lot_name + _("Otherwise make sure the right stock/owner is set."))
+        self = self.sudo()
-                if float_compare(solving_qty, 0, precision_rounding=product_uom_rounding) <= 0:
+    def _increase_available_quantity(self, product_id, location_id, quantity, lot_id=None, package_id=None, owner_id=None, strict=True):
-            order = 'lot_id, in_date'
+                else:
-        return quants
+            self.create({
-        return domain
+    def _decrease_available_quantity(self, product_id, location_id, quantity, lot_id=None, package_id=None, owner_id=None, strict=True):
-            res.append((None, remaining_quantity))
+    def _increase_reserved_quantity(self, product_id, location_id, quantity, lot_id=None, package_id=None, owner_id=None, strict=False):
-        return res
+            quant.reserved_quantity += max_quantity_on_quant
-        return top_lvl_packages
+            quantity -= max_quantity_on_quant
-        return latest_move
+            if quantity == 0 or available_quantity == 0:
-        return new_quant
+    @api.model
-            SUM(sq.qty) AS product_qty
+            SUM(sq.quantity) AS product_qty
-            'qty': 30.0})
+            'quantity': 30.0})
-            'qty': 10.0,
+            'quantity': 10.0,
-                        st_vals['balance_start'] += line_vals['amount']
+                        st_vals['balance_start'] += float(line_vals['amount'])
-            raise UserError(_("You cannot use the session of another users. This session is owned by %s. "
+            raise UserError(_("You cannot use the session of another user. This session is owned by %s. "
-        tree = transaction.capture(self.acquirer_reference, self.amount)
+        tree = transaction.capture(self.acquirer_reference or '', self.amount)
-        tree = transaction.void(self.acquirer_reference)
+        tree = transaction.void(self.acquirer_reference or '')
-        domain=[('model', '=', 'sale.quote.template')])
+        domain=[('model', '=', 'sale.order')])
-        fmt = "%.{0}f".format(-precision if precision < 0 else 0)
+        fmt = "%.{0}f".format(display.decimal_places)
-            self.write({'state': 'done'})
+        for repair in self:
-            acq.s2s_process(post)
+            token = acq.s2s_process(post)
-from werkzeug import urls
+from werkzeug import urls, url_encode
-        if self.state == 'done':
+        if self.state in ['done', 'refunded']:
-
+        param_plus = {
-        if self.state not in ('draft', 'pending'):
+        if self.state not in ('draft', 'pending', 'refunding'):
-                'state': 'done',
+                'state': new_state,
-                'state': 'pending',
+                'state': new_state,
-        return {}
+        return {}
-            acquirer.form = acquirer.sudo()._registration_render(request.env.user.partner_id.id, {'error': {}, 'error_message': [], 'return_url': return_url, 'json': False, 'bootstrap_formatting': True})
+            acquirer.form = acquirer.sudo()._registration_render(request.env.user.partner_id.id, {'error': {}, 'error_message': [], 'return_url': return_url, 'json': False, 'bootstrap_formatting': True, 'verify_validity': True})
-                    1 as nbr,
+                    1 as nbr_cases,
-                raise UserError(_('You can not change a company chart of account once it has been installed'))
+        if self.chart_template_id and self.chart_template_id != self.company_id.chart_template_id:
-            return {}
+
-        help="This e-mail template will be sent on confirmation. Leave empty to send nothing.")
+        help="This e-mail template will be sent on confirmation. Leave empty to send nothing.",
-                    'ids': automatic_reconciliation_entries.mapped('journal_entry_ids').ids
+                    'ids': automatic_reconciliation_entries.mapped('journal_entry_ids').mapped('move_id').ids
-                str_domain = expression.OR([str_domain, ('partner_id.name', 'ilike', str)])
+                str_domain = expression.OR([str_domain, [('partner_id.name', 'ilike', str)]])
-            'credit': 0,
+            'debit': debit_value if debit_value > 0 else 0,
-            'debit': 0,
+            'credit': credit_value if credit_value > 0 else 0,
-from . import delivery_price_rule
+from . import delivery_grid
-       <my_provider>_get_shipping_price_from_so
+       <my_provider>_rate_shipment
-       <my_provider>_open_tracking_page
+       <my_provider>_get_tracking_link
-    delivery_type = fields.Selection([('fixed', 'Fixed Price'), ('base_on_rule', 'Based on Rules')], string='Provider', default='fixed', required=True)
+    delivery_type = fields.Selection([('fixed', 'Fixed Price')], string='Provider', default='fixed', required=True)
-    amount = fields.Float(string='Amount', help="Amount of the order to benefit from a free shipping, expressed in the company currency")
+
-    prod_environment = fields.Boolean("Environment", help="Set to True if your credentials are certified for production.")
+
-        self.prod_environment = not self.prod_environment
+        for c in self:
-            carrier.fixed_price = carrier.product_id.list_price
+    def available_carriers(self, partner):
-            carrier.product_id.list_price = carrier.fixed_price
+    def _match_address(self, partner):
-            self.price = computed_price * (1.0 + (float(self.margin) / 100.0))
+    @api.onchange('state_ids')
-    def get_shipping_price_from_so(self, order):
+    def rate_shipment(self, order):
-        :return list: A float, the estimated price for the shipping of the sales order
+        :param order: record of sale.order
-            return getattr(self, '%s_get_shipping_price_from_so' % self.delivery_type)(order)
+        if hasattr(self, '%s_rate_shipment' % self.delivery_type):
-        self.country_ids = [(6, 0, self.country_ids.ids + self.state_ids.mapped('country_id.id'))]
+    # ------------------------------------------------ #
-        self.state_ids = [(6, 0, self.state_ids.filtered(lambda state: state.id in self.country_ids.mapped('state_ids').ids).ids)]
+    fixed_price = fields.Float(compute='_compute_fixed_price', inverse='_set_product_fixed_price', store=True, string='Fixed Price')
-        return self
+    @api.depends('product_id.list_price', 'product_id.product_tmpl_id.list_price')
-        return True
+    def _set_product_fixed_price(self):
-        res.create_price_rules()
+    def fixed_rate_shipment(self, order):
-        return res
+    def fixed_get_tracking_link(self, pickings):
-        return price
+    def fixed_cancel_shipment(self, pickings):
-from odoo import api, models, fields
+from odoo import models, fields
-        return res
+    hs_code = fields.Char(string="HS Code", help="Standardized code for international shipping and goods declaration")
-                continue
+    carrier_id = fields.Many2one('delivery.carrier', string="Delivery Method", help="Fill this field if you plan to invoice the shipping based on picking.")
-                order.delivery_price = order.carrier_id.with_context(order_id=order.id).price
+                order.delivery_rating_success = False
-    def onchange_partner_id_dtype(self):
+    def onchange_partner_id_carrier_id(self):
-    def _delivery_unset(self):
+    def _remove_delivery_line(self):
-    def delivery_set(self):
+    def set_delivery_line(self):
-        self._delivery_unset()
+        self._remove_delivery_line()
-            else:
+            if order.state not in ('draft', 'sent'):
-
+            elif not order.delivery_rating_success:
-        if self.carrier_id and self.carrier_id.delivery_type not in ['fixed', 'base_on_rule'] and self.carrier_id.integration_level == 'rate_and_ship' and self.package_ids:
+        if self.carrier_id and self.carrier_id.integration_level == 'rate_and_ship':
-        self.sale_normal_delivery_charges.delivery_set()
+        self.sale_normal_delivery_charges.get_delivery_price()
-        self.delivery_sale_order_cost.delivery_set()
+        self.delivery_sale_order_cost.get_delivery_price()
-        self.sale_prepaid.delivery_set()
+        self.sale_prepaid.get_delivery_price()
-            return False
+
-            self._delivery_unset()
+            self._remove_delivery_line()
-                    verified_carrier = delivery.verify_carrier(self.partner_shipping_id)
+                    verified_carrier = delivery._match_address(self.partner_shipping_id)
-                self.delivery_set()
+                self.get_delivery_price()
-                self._delivery_unset()
+                self._remove_delivery_line()
-        return available_carriers
+        address = self.partner_shipping_id
-        self._delivery_unset()
+        self._remove_delivery_line()
-    _order = 'sequence, list_price'
+    _order = 'sequence, list_price, id'
-    def _get_name(self):
+    def _compute_name(self):
-    sequence = fields.Integer(required=True, help="Gives the sequence order when calculating delivery carrier.", default=10)
+    name = fields.Char(compute='_compute_name')
-    operator = fields.Selection([('==', '='), ('<=', '<='), ('<', '<'), ('>=', '>='), ('>', '>')], 'Operator', required=True, default='<=')
+
-    variable_factor = fields.Selection([('weight', 'Weight'), ('volume', 'Volume'), ('wv', 'Weight * Volume'), ('price', 'Price'), ('quantity', 'Quantity')], 'Variable Factor', required=True, default='weight')
+    variable_factor = fields.Selection([('weight', 'Weight'), ('volume', 'Volume'), ('wv', 'Weight * Volume'), ('price', 'Price'), ('quantity', 'Quantity')], 'Variable Factor', required=True, default='weight')
-    ],
+        if context.get('account_ids'):
-                order.post_visible = any((x.quantity_done > 0 and x.state not in ['done' 'cancel']) for x in order.move_finished_ids)
+            order.post_visible = any(order.move_raw_ids.filtered(lambda x: (x.quantity_done) > 0 and (x.state not in ['done', 'cancel']))) or \
-
+    @api.constrains('time_efficiency')
-                if date_deadline < date.today():
+                if date_deadline < date.today() and not opp['date_closed']:
-Validate contact (phone,mobile,fax) numbers and normalize them on leads and contacts:
+Validate contact (phone,mobile) numbers and normalize them on leads and contacts:
-        return ['phone', 'mobile', 'fax']
+        return ['phone', 'mobile']
-        opf = options and options.get('fields') or ["name", "address", "phone", "mobile", "fax", "email"]
+        opf = options and options.get('fields') or ["name", "address", "phone", "mobile", "email"]
-    fax = fields.Char()
+            else:
-        else:
+        if self.payment_term_id:
-    def get_next_char(self, number_next):
+    def _get_prefix_suffix(self):
-        failed_mails.unlink()
+        failed_mails.sudo().unlink()
-                            'type': 'rainbow',
+                            'type': 'rainbow_man',
-                                line[index] = dt.strftime(dt.strptime(ustr(line[index]).encode('utf-8'), user_format), server_format)
+                                line[index] = dt.strftime(dt.strptime(ustr(line[index].strip()).encode('utf-8'), user_format), server_format)
-        return True
+            if lead.user_id and lead.team_id and lead.planned_revenue:
-            date = self._context.get('date', fields.Date.today())
+            date = self._context.get('date') or fields.Date.today()
-    time_efficiency = fields.Float('Time Efficiency', related='resource_id.time_efficiency', store=True)
+    time_efficiency = fields.Float('Time Efficiency', related='resource_id.time_efficiency', default=100, store=True)
-        excluded = {
+        included = {
-                ('website_form_blacklisted', '=', True)
+                ('model_id', '=', self.id),
-            if k not in excluded
+            if k in included
-LINE_FIELDS = ['debit', 'credit', 'account_id', 'move_id', 'partner_id']
+LINE_FIELDS = ['debit', 'credit', 'account_id', 'partner_id']
-                    values[field] = _getattrstring(line, field)
+                    k = 'line_%d_%s' % (line.id, field)
-        pdf = request.env.ref('point_of_sale.sale_details_report').with_context(date_start=date_start, date_stop=date_stop).render_qweb_pdf(r)
+        pdf, _ = request.env.ref('point_of_sale.sale_details_report').with_context(date_start=date_start, date_stop=date_stop).render_qweb_pdf(r)
-            pdfhttpheaders = [('Content-Type', 'application/pdf'), ('Content-Length', len(pdf))]
+            pdf, _ = request.env.ref('sale.action_report_saleorder').sudo().render_qweb_pdf([sale_order_id])
-    def action_done(self, feedback=False):
+    def action_done(self):
-        allow_signup = self.env['ir.config_parameter'].get_param('auth_signup.allow_uninvited', 'False').lower() == 'true'
+        allow_signup = self.env['ir.config_parameter'].sudo().get_param('auth_signup.allow_uninvited', 'False').lower() == 'true'
-        self.update(vals)
+        result = {'domain': domain}
-        return {'domain': domain}
+                return result
-        if not self.product_uom:
+        if not self.product_uom or not self.product_id:
-from odoo import api, fields, models
+from odoo import api, fields, models, _
-#from . import test_sale_service
+from . import test_sale_timesheet
-        self.ancestor_ids = self.env['stock.quant.package'].search(['id', 'parent_of', self.id]).ids
+        if self.id:
-        soon_expired_contracts = self.search([
+    def update_state(self):
-        return soon_expired_contracts.write({
+            '&',
-        expired_contracts = self.search([
+        self.search([
-        return expired_contracts.write({
+            ('date_end', '<=', fields.Date.to_string(date.today() + relativedelta(days=1))),
-        self.phantom_js('/web/tests?mod=web', "", "", login='admin', timeout=120)
+        self.phantom_js('/web/tests?mod=web', "", "", login='admin', timeout=180)
-        spec = []
+        # group triggers by (model, path) to minimize the calls to search()
-        self.env.invalidate(spec)
+            mfield = self._fields[fname]
-            [('id', 'in', [msg['subtype_id'][0] for msg in message_values if msg['subtype_id']])]).read(['internal', 'description'])
+        subtype_ids = [msg['subtype_id'][0] for msg in message_values if msg['subtype_id']]
-        help='Encoding help. When selected, the associated purchase order lines are added to the vendor bill. Several PO can be selected.')
+    purchase_id = fields.Many2one(
-                res[group] += amount
+                taxes = tax.compute_all(line.price_reduce + base_tax, quantity=line.product_uom_qty,
-        """ Return the given model's existing field data. """
+    @tools.ormcache()
-        return {row['name']: row for row in cr.dictfetchall()}
+        cr.execute("SELECT * FROM ir_model_fields")
-        fields_data = self._existing_field_data(field.model_name)
+        fields_data = self._get_field_data(field.model_name)
-            fields_data = self._existing_field_data(model._name)
+            fields_data = self._get_field_data(model._name)
-                    field_data['relation_field'] in self._existing_field_data(field_data['relation'])
+                    field_data['relation_field'] in self._get_field_data(field_data['relation'])
-        fields_data = self._existing_field_data(model._name)
+        fields_data = self._get_field_data(model._name)
-        fields = [self._fields[n] for n in (field_names + inherited_field_names)]
+        # determine the fields that are stored as columns in tables; ignore 'id'
-            for field in fields
+            for field in (self._fields[name] for name in field_names + inherited_field_names)
-        qual_names = [qualify(name) for name in set(fields_pre + [self._fields['id']])]
+        qual_names = [qualify(name) for name in [self._fields['id']] + fields_pre]
-                    }
+        query_str = "SELECT %s FROM %s WHERE %s" % (",".join(qual_names), from_clause, where_clause)
-                        f = field.name
+                        name = field.name
-                            vals[f] = translate(vals['id'], vals[f])
+                            vals[name] = translate(vals['id'], vals[name])
-            # store result in cache for POST fields
+            # store result in cache
-                record = self.browse(vals['id'], self._prefetch)
+                record = self.browse(vals.pop('id'), self._prefetch)
-                field = self._fields[f]
+            for name in field_names:
-            field = self._fields[f]
+        for name in field_names:
-from odoo import api, fields, models
+from odoo import api, fields, models, _
-                res[group] += amount
+                taxes = tax.compute_all(line.price_reduce + base_tax, quantity=line.product_uom_qty,
-                        OrderedSet, pycompat)
+from odoo.tools import (assertion_report, config, existing_tables,
-        if missing:
+        table2model = {model._table: name for name, model in env.items() if not model._abstract}
-                    _logger.error("Model %s has no table.", name)
+            missing_tables = set(table2model).difference(existing_tables(cr, table2model))
-from odoo.exceptions import ValidationError, except_orm
+from odoo.exceptions import ValidationError, RedirectWarning, except_orm
-        return category.id if category.type == 'normal' else False
+        if category and category.type == 'normal':
-        product = product.with_context(quantity=1)
+        quantity = product._context.get('quantity') or 1
-                price = variant.currency_id.compute(variant.website_public_price, to_currency)
+                price = variant.currency_id.compute(variant.website_public_price, to_currency) / quantity
-                price = variant.website_public_price
+                price = variant.website_public_price / quantity
-    """,
+This module adds a checkbox on the accounting journals to allow the cancellation of journal entries.
-from odoo import api, fields, models
+from odoo import api, fields, models, _
-        return self.action_view_task_rating()
+        """ return the action to see all the rating of the project, and activate default filters """
-        return dict(action, domain=domain)
+        if self.use_issues:  # add default filter for issue rating
-        action = self.env['ir.actions.act_window'].for_xml_id('rating', 'action_view_rating')
+        action = self.env['ir.actions.act_window'].for_xml_id('rating_project', 'rating_rating_action_view_project_rating')
-        action = self.env['ir.actions.act_window'].for_xml_id('rating', 'action_view_rating')
+        action = self.env['ir.actions.act_window'].for_xml_id('rating_project', 'rating_rating_action_view_project_rating')
-    rating_text = fields.Char(string='Rating', compute='_compute_rating_text')
+    rating_text = fields.Selection([
-            rating.rating_text = text[rating.rating] or _('No rating yet')
+            if rating.rating >= RATING_LIMIT_SATISFIED:
-        action['domain'] = [('res_id', 'in', [s.id for s in self.channel_ids]), ('res_model', '=', 'mail.channel')]
+        action = self.env['ir.actions.act_window'].for_xml_id('im_livechat', 'rating_rating_action_view_livechat_rating')
-    res_id = fields.Integer(string='Document ID', required=True, help="Identifier of the rated object", index=True)
+    res_id = fields.Integer(string='Document', required=True, help="Identifier of the rated object", index=True)
-            if key >= 7:
+            if key >= RATING_LIMIT_SATISFIED:
-            elif key > 3:
+            elif key > RATING_LIMIT_OK:
-    _inherit = ['project.task.type']
+    _inherit = 'project.task.type'
-                vals.pop('code_digits')
+            if company.accounts_code_digits == values.get('code_digits'):
-    date_tz = fields.Selection('_tz_get', string='Timezone', required=True, default=lambda self: self.env.user.tz)
+    date_tz = fields.Selection('_tz_get', string='Timezone', required=True, default=lambda self: self.env.user.tz or 'UTC')
-                tmp_margin = line.price_subtotal - ((line.purchase_price or line.product_id.standard_price) * line.product_uos_qty)
+                price = line.purchase_price
-    token_implemented = fields.Boolean('Saving Card Data supported', compute='_compute_feature_support')
+    token_implemented = fields.Boolean('Saving Card Data supported', compute='_compute_feature_support', search='_search_is_tokenized')
-    module_sale_contract = fields.Boolean("Subscriptions")
+    module_sale_subscription = fields.Boolean("Subscriptions")
-    module_sale_contract = fields.Boolean("Subscriptions")
+    module_sale_subscription = fields.Boolean("Subscriptions")
-    module_website_contract = fields.Boolean("Subscriptions")
+    module_website_subscription = fields.Boolean("Subscriptions")
-    paperformat_id = fields.Many2one('report.paperformat', 'Paper format', default=lambda self: self.env.ref('report.paperformat_euro', raise_if_not_found=False))
+    paperformat_id = fields.Many2one('report.paperformat', 'Paper format', default=lambda self: self.env.ref('base.paperformat_euro', raise_if_not_found=False))
-            paperformat_euro = self.env.ref('report.paperformat_euro', False)
+            paperformat_euro = self.env.ref('base.paperformat_euro', False)
-             "but you can always use the 'Manual' payment method in order to manage payments outside of the software.")
+        help="Manual: Get paid by cash, check or any other method outside of Odoo.\n"\
-             "but you can always use the 'Manual' payment method in order to manage payments outside of the software.")
+        help="Manual:Pay bill by cash or any other method outside of Odoo.\n"\
-    payment_method_id = fields.Many2one('account.payment.method', string='Payment Method Type', required=True, oldname="payment_method")
+    payment_method_id = fields.Many2one('account.payment.method', string='Payment Method Type', required=True, oldname="payment_method",
-    journal_user = fields.Boolean('Active in Point of Sale',
+    journal_user = fields.Boolean('Use in Point of Sale',
-    pos_mercury_config_id = fields.Many2one('pos_mercury.configuration', string='Mercury configuration', help='The configuration of Mercury used for this journal')
+    pos_mercury_config_id = fields.Many2one('pos_mercury.configuration', string='Mercury Credentials', help='The configuration of Mercury used for this journal')
-        for order in self.filtered(lambda o: not o.account_move or order.state == 'paid'):
+        for order in self.filtered(lambda o: not o.account_move or o.state == 'paid'):
-        return category.id if category.type == 'normal' else False
+        return category and category.type == 'normal' and category.id or False
-        product_id = self.env['ir.config_parameter'].get_param('sale.default_deposit_product_id')
+        product_id = self.env['ir.config_parameter'].sudo().get_param('sale.default_deposit_product_id')
-                vals.pop('code_digits')
+            if company.accounts_code_digits == values.get('code_digits'):
-from odoo import fields, models
+from odoo import api, fields, models
-    if image.mode not in ["1", "L", "P", "RGB", "RGBA"]:
+    if image.mode not in ["1", "L", "P", "RGB", "RGBA"] or (filetype == 'JPEG' and image.mode == 'RGBA'):
-            cr.executemany('insert into wkf_witm_trans (trans_id,inst_id) values (%s,%s)', transitions)
+            cr.executemany('insert into wkf_witm_trans (trans_id,inst_id) values (%s,%s) except (select trans_id,inst_id from wkf_witm_trans)', transitions)
-    'auto_install': True,
+    'auto_install': False,
-        return result
+        action = self.env.ref('account.action_invoice_refund_out_tree').read()[0]
-        langs = self.search([('active', '=', False)])
+        """ Return the available languages as a list of (code, name) sorted by name. """
-        langs = self.with_context(active_test=False).search([])
+        """ Return the available languages to install as a list of (code, name) sorted by name. """
-        values = {
+        values.update({
-        }
+        })
-            'breadcrumb': request.env.user.partner_id == order_sudo.partner_id,
+            'no_breadcrumbs': request.env.user.partner_id.commercial_partner_id not in order_sudo.message_partner_ids,
-    def _redirect_to_record(cls, model, res_id):
+    def _redirect_to_record(cls, model, res_id, access_token=None):
-                record_action = record.get_access_action()
+                record_action = record_sudo.get_access_action(access_uid=uid)
-    def mail_action_view(self, model=None, res_id=None, message_id=None):
+    def mail_action_view(self, model=None, res_id=None, message_id=None, access_token=None, **kwargs):
-        choose where to redirect the user is the following :
+            choose where to redirect the user is the following :
-        return self._redirect_to_record(model, res_id)
+        return self._redirect_to_record(model, res_id, access_token)
-            they will be generated on the fly.
+
-                    'url': '/my/invoices',  # No controller /my/invoices/<int>, only a report pdf
+                    'url': '/my/invoices?',  # No controller /my/invoices/<int>, only a report pdf
-    def orders_followup(self, order=None, **kw):
+    @http.route(['/my/orders/<int:order>'], type='http', auth="public", website=True)
-        order_sudo = order.sudo()
+            if not access_token or not consteq(order_sudo.access_token, access_token):
-        values.update(get_records_pager(history, order))
+        values.update(get_records_pager(history, order_sudo))
-from odoo import api, exceptions, fields, models, _
+from odoo import api, fields, models
-from odoo.exceptions import ValidationError
+from werkzeug.urls import url_encode
-        portal users that have access to a confirmed order. """
+        """ Instead of the classic form view, redirect to the online order for
-            record = self.sudo(user)
+        user = self.env['res.users'].sudo().browse(access_uid) if access_uid else self.env.user
-                }
+            return {
-
+    def get_mail_url(self):
-    def get_access_action(self):
+    def get_access_action(self, access_uid=None):
-        if self.env.user.share or self.env.context.get('force_website'):
+        user, record = self.env.user, self
-                self.check_access_rule('read')
+                record.check_access_rule('read')
-        return super(AccountInvoice, self).get_access_action()
+        return super(AccountInvoice, self).get_access_action(access_uid)
-    def get_access_action(self):
+    def get_access_action(self, access_uid=None):
-            return super(BlogPost, self).get_access_action()
+        user = access_uid and self.env['res.users'].sudo().browse(access_uid) or self.env.user
-    def get_access_action(self):
+    def get_access_action(self, access_uid=None):
-    def get_access_action(self):
+    def get_access_action(self, access_uid=None):
-        if self.env.user.share or self.env.context.get('force_website'):
+            return super(SaleOrder, self).get_access_action(access_uid)
-                self.check_access_rule('read')
+                record.check_access_rule('read')
-        return super(SaleOrder, self).get_access_action()
+        return super(SaleOrder, self).get_access_action(access_uid)
-    def get_access_action(self):
+    def get_access_action(self, access_uid=None):
-        if self.env.user.share:
+        user, record = self.env.user, self
-                self.check_access_rule('read')
+                record.check_access_rule('read')
-        return super(Project, self).get_access_action()
+        return super(Project, self).get_access_action(access_uid)
-    def get_access_action(self):
+    def get_access_action(self, access_uid=None):
-        if self.env.user.share:
+        user, record = self.env.user, self
-                self.check_access_rule('read')
+                record.check_access_rule('read')
-        return super(Task, self).get_access_action()
+        return super(Task, self).get_access_action(access_uid)
-    def get_access_action(self):
+    def get_access_action(self, access_uid=None):
-        if self.env.user.share:
+        user, record = self.env.user, self
-                self.check_access_rule('read')
+                record.check_access_rule('read')
-        return super(Issue, self).get_access_action()
+        return super(Issue, self).get_access_action(access_uid)
-    def get_access_action(self):
+    def get_access_action(self, access_uid=None):
-            return super(SaleOrder, self).get_access_action()
+        user = access_uid and self.env['res.users'].sudo().browse(access_uid) or self.env.user
-    def get_access_action(self):
+    def get_access_action(self, access_uid=None):
-        return super(Slide, self).get_access_action()
+        return super(Slide, self).get_access_action(access_uid)
-    def get_formview_action(self):
+    def get_formview_action(self, access_uid=None):
-        view_id = self.sudo().get_formview_id(access_uid=self.env.uid)
+
-    def get_access_action(self):
+    def get_access_action(self, access_uid=None):
-        return self[0].get_formview_action()
+        return self[0].get_formview_action(access_uid=access_uid)
-from odoo.exceptions import AccessDenied
+from odoo.exceptions import AccessDenied, UserError
-            except SignupError:
+            except (SignupError, UserError):
-                    assert login, "No login provided."
+                    assert login, _("No login provided.")
-        assert values.get('password') == qcontext.get('confirm_password'), "Passwords do not match; please retype them."
+        if not values:
-from odoo import api, fields, models, _
+from odoo import api, exceptions, fields, models, _
-                raise SignupError("Signup token '%s' is not valid" % token)
+                raise exceptions.UserError(_("Signup token '%s' is not valid") % token)
-                raise SignupError("Signup token '%s' is no longer valid" % token)
+                raise exceptions.UserError(_("Signup token '%s' is no longer valid") % token)
-                raise SignupError('Signup is not allowed for uninvited users')
+                raise SignupError(_('Signup is not allowed for uninvited users'))
-from odoo.tools.safe_eval import safe_eval
+
-    auth_signup_uninvited = fields.Boolean(string='Allow external users to sign up')
+    auth_signup_uninvited = fields.Selection([
-        # we use safe_eval on the result, since the value of the parameter is a nonempty string
+        # the value of the parameter is a nonempty string
-            auth_signup_template_user_id=safe_eval(get_param('auth_signup.template_user_id', 'False')),
+            auth_signup_reset_password=get_param('auth_signup.reset_password', 'False').lower() == 'true',
-        set_param('auth_signup.allow_uninvited', repr(self.auth_signup_uninvited))
+        set_param('auth_signup.allow_uninvited', repr(self.auth_signup_uninvited == 'b2c'))
-        params = self.env['ir.config_parameter'].sudo()
+        get_param = self.env['ir.config_parameter'].sudo().get_param
-            google_maps_api_key=params.get_param('google_maps_api_key', default=''),
+            auth_signup_uninvited='b2c' if get_param('auth_signup.allow_uninvited', 'False').lower() == 'true' else 'b2b',
-        self.env['ir.config_parameter'].sudo().set_param('google_maps_api_key', (self.google_maps_api_key or '').strip())
+        set_param = self.env['ir.config_parameter'].sudo().set_param
-        for config in self.browse(cr, uid, config_ids, context=context):
+        for config in self.browse(cr, SUPERUSER_ID, config_ids, context=context):
-            res['product_qty'] = self.env['mrp.production'].browse(res.get['mo_id']).product_qty
+            res['product_qty'] = self.env['mrp.production'].browse(res['mo_id']).product_qty
-    _order = 'sequence, id'
+    _order = 'sequence, attribute_id, id'
-        return ", ".join([v.name for v in self.sorted(key=lambda r: r.attribute_id.name) if v.attribute_id in variable_attributes])
+        return ", ".join([v.name for v in self if v.attribute_id in variable_attributes])
-    'auto_install': False,
+    'auto_install': True,
-    'auto_install': True,
+    'auto_install': False,
-            {'type': 'activity_updated', 'activity_created': True})
+        if activity.date_deadline <= fields.Date.today():
-        res = super(MailActivity, self).write(values)
+        res = super(MailActivity, self).write(values)
-                    {'type': 'activity_updated', 'activity_deleted': True})
+                if activity.date_deadline <= fields.Date.today():
-                {'type': 'activity_updated', 'activity_deleted': True})
+            if activity.date_deadline <= fields.Date.today():
-            user_activities[activity['model']]['total_count'] += activity['count']
+            if activity['states'] in ('today','overdue'):
-            vals['image'] = self._get_default_image(vals.get('type'), vals.get('is_company'), vals.get('parent_id'))
+        self.env['bus.bus'].sendone(
-from odoo import _, api, fields, models, SUPERUSER_ID, tools
+from odoo import _, api, fields, models, modules, SUPERUSER_ID, tools
-from odoo import _, api, exceptions, fields, models
+from odoo import _, api, exceptions, fields, models, modules
-            result['domain'] = "[('id','in',%s])]" % (pick_ids.ids)
+            result['domain'] = "[('id','in',%s)]" % (pick_ids.ids)
-            if name not in MAGIC_COLUMNS
+            if self._log_access and name not in MAGIC_COLUMNS
-        for field in itertools.chain(MAGIC_COLUMNS, ('parent_left', 'parent_right')):
+        pop_fields = ['parent_left', 'parent_right']
-        for field in itertools.chain(MAGIC_COLUMNS, ('parent_left', 'parent_right')):
+        pop_fields = ['parent_left', 'parent_right']
-    query = "SELECT 1 FROM information_schema.tables WHERE table_name=%s"
+    query = "SELECT 1 FROM information_schema.tables WHERE table_name=%s AND table_schema != 'information_schema'"
-        product_context = dict(request.env.context, active_id=product.id)
+        product_context = dict(request.env.context,
-                'sale_pricelist_setting_split_1': True,
+                'multi_sales_price': True,
-        client.settimeout(0.5)
+        client.settimeout(2)
-        if not self.image and not self._context.get('yaml_onchange') and self.email:
+        if not self.image and self._context.get('gravatar_image') and self.email:
-                'name': line.name != '/' and line.move_id.name + ': ' + line.name or line.move_id.name,
+                'name': line.name and line.name != '/' and line.move_id.name + ': ' + line.name or line.move_id.name,
-                    }) for answer in question.answer_ids]
+    @api.model
-    ))
+    ), override=True) # docutils.nodes.address exists and is a bibliographic element
-    app.config.html_translator_class = 'odoo_ext.translator.BootstrapTranslator'
+    if hasattr(app, 'set_translator'):
-from openerp.tools import float_compare, float_round
+from openerp.tools import float_compare, float_round, float_repr
-                                        (aml.statement_id IS NULL AND aml.account_id IN %(account_payable_receivable)s) 
+                                        (aml.statement_id IS NULL AND aml.account_id IN %(account_payable_receivable)s 
-                    'amount': float_round(amount, precision_digits=precision),
+                    'amount': float_repr(float_round(amount, precision_digits=precision), precision_digits=precision),
-        liquidity_amt_clause = currency and '%(amount)s' or 'abs(%(amount)s)'
+        liquidity_amt_clause = currency and '%(amount)s::numeric' or 'abs(%(amount)s::numeric)'
-                " AND ("+field+" = %(amount)s OR (acc.internal_type = 'liquidity' AND "+liquidity_field+" = " + liquidity_amt_clause + ")) \
+                " AND ("+field+" = %(amount)s::numeric OR (acc.internal_type = 'liquidity' AND "+liquidity_field+" = " + liquidity_amt_clause + ")) \
-            if 'vat' in partner and (data['vat'] or False) != (partner.vat or False):
+            if 'vat' in data and (data['vat'] or False) != (partner.vat or False):
-    'images': ['static/description/bootswatch.png'],
+    'images': [
-=======================================
+========================================
-============================================================================================
+=============================================================================================
-====================================================================================
+========================================================================================
-=======================================================================
+===========================================================================
-==================================================================================================
+========================================================================================================================
-            if not module.description:
+            if not module.description_html:
-    """,
+    'description': "",
-        if request.context.get('lang') != "en_US" and 'translatable' not in request.context:
+        if request.context.get('edit_translations') and 'translatable' not in request.context:
-            if path[1] == request.website.default_lang_code:
+            if request.lang == request.website.default_lang_code:
-            if self.get_default_lang_code() and field != 'arch' and not isinstance(Model._fields[field], fields.Html):
+            if not self.env.context.get('lang') and self.get_default_lang_code():
-
+    _mail_post_access = 'read'
-    'depends': ['website', 'sale', 'payment', 'website_payment', 'website_portal_sale', 'website_account', 'website_mail', 'website_form', 'rating'],
+    'depends': ['website', 'sale', 'payment', 'website_payment', 'website_portal_sale', 'website_account', 'website_mail', 'website_form', 'website_rating'],
-        return response
+# -*- coding: utf-8 -*-
-from . import rating
+
-        'static/src/xml/chatter_message.xml'
+        'static/src/xml/website_mail.xml'
-from werkzeug.exceptions import NotFound
+
-            author_id = record.partner_id.id if hasattr(record, 'partner_id') else author_id
+    if token_field and token:
-                raise NotFound()
+            raise Forbidden()
-    def chatter_post(self, res_model='', res_id=None, message='', redirect=None, **kw):
+    def website_chatter_post(self, res_model, res_id, message, **kw):
-            url = url + "#message-%s" % (message.id,)
+            _message_post_helper(res_model, int(res_id), message, **kw)
-    )
+    website_message_ids = fields.One2many(domain=lambda self: [('model', '=', self._name), ('message_type', '=', 'comment'), ('path', '=', False)])
-    )
+
-    )
+    website_message_ids = fields.One2many(domain=lambda self: [('model', '=', self._name), ('message_type', 'in', ['email', 'comment'])])
-        string='Website Messages', help="Website communication history")
+
-                if old.env.lang:
+                if old.env.lang and callable(field.translate):
-        excluded = {
+        included = {
-                ('website_form_blacklisted', '=', True)
+                ('model_id', '=', self.id),
-            if k not in excluded
+            if k in included
-        tax_lines = self.tax_line_ids.browse([])
+        tax_lines = self.tax_line_ids.filtered('manual')
-        return category and category.id or False
+        return category.id if category.type == 'normal' else False
-                taxes = fiscal_position_id.map_tax(taxes)
+            fpos = line.order_id.fiscal_position_id
-            line.price_subtotal_incl = currency.round(line.price_subtotal_incl)
+            taxes = tax_ids_after_fiscal_position.compute_all(price, line.order_id.pricelist_id.currency_id, line.qty, product=line.product_id, partner=line.order_id.partner_id)
-                line.price_unit * (1 - (line.discount or 0.0) / 100.0), line.product_id.taxes_id, taxes)
+            price = line.price_unit * (1 - (line.discount or 0.0) / 100.0)
-                             ('l10n_fr_secure_sequence_number', '!=', False)],
+                             ('l10n_fr_secure_sequence_number', '!=', 0)],
-from odoo import http
+from odoo import http, _
-                                    ORDER BY date, id) AS b 
+        query = """SELECT a.date, a.balance_end
-        select_sql_clause = """SELECT sum(residual_company_signed) as total, min(date) as aggr_date from account_invoice where journal_id = %(journal_id)s and state = 'open'"""
+        (select_sql_clause, query_args) = self._get_bar_graph_select_query()
-        self.env.cr.execute(query, {'journal_id':self.id})
+        self.env.cr.execute(query, query_args)
-            query_results = self.env.cr.dictfetchall()
+
-                sum_late += cur.compute(result.get('amount_total'), currency) * factor
+            (number_waiting, sum_waiting) = self._count_results_and_sum_amounts(query_results_to_pay, currency)
-            'title': title, 
+            'title': title,
-    @api.depends('invoice_lines.invoice_id.state')
+    @api.depends('invoice_lines.invoice_id.state', 'invoice_lines.quantity')
-        return self.env.ref(DEFAULT_PAYMENT_TERM, False).id or partner.property_payment_term_id.id
+        return partner.property_payment_term_id.id or self.env.ref(DEFAULT_PAYMENT_TERM, False).id
-            'user_id': salesperson_id or self.salesperson_id.id,
+            'user_id': salesperson_id or self.salesperson_id.id or default_user_id,
-        date_range = self.env['ir.sequence.date_range'].search([('sequence_id', '=', self.id), ('date_from', '>=', date), ('date_from', '<=', date_to)], order='date_from desc')
+        date_range = self.env['ir.sequence.date_range'].search([('sequence_id', '=', self.id), ('date_from', '>=', date), ('date_from', '<=', date_to)], order='date_from desc', limit=1)
-        date_range = self.env['ir.sequence.date_range'].search([('sequence_id', '=', self.id), ('date_to', '>=', date_from), ('date_to', '<=', date)], order='date_to desc')
+        date_range = self.env['ir.sequence.date_range'].search([('sequence_id', '=', self.id), ('date_to', '>=', date_from), ('date_to', '<=', date)], order='date_to desc', limit=1)
-    @http.route(['/rating/<string:token>/<int:rate>/submit_feedback'], type="http", auth="public", method=['post'])
+    @http.route(['/rating/<string:token>/<int:rate>/submit_feedback'], type="http", auth="public", methods=['post'])
-
+import io
-        self.buffer = buffer
+        # TextIOWrapper closes its underlying buffer on close *and* can't
-            lines[0] = unicode(lines[0], 'utf8').lstrip(unicode( codecs.BOM_UTF8, "utf8"))
+            lines[0] = lines[0].lstrip(u"\ufeff")
-        self.buffer.write("# Translation of %(project)s.\n" \
+        self.buffer.write(u"# Translation of %(project)s.\n" \
-        self.buffer.write("#. module%s: %s\n" % (plurial, ', '.join(modules)))
+        self.buffer.write(u"#. module%s: %s\n" % (plurial, ', '.join(modules)))
-            self.buffer.write(''.join(('#. %s\n' % c for c in comments)))
+            self.buffer.write(u''.join(('#. %s\n' % c for c in comments)))
-            self.buffer.write("#: %s:%s:%s\n" % (typy, name, res_id))
+            self.buffer.write(u"#: %s:%s:%s\n" % (typy, name, res_id))
-            self.buffer.write("#, python-format\n")
+            self.buffer.write(u"#, python-format\n")
-              "msgstr %s\n\n"   \
+        msg = u"msgid %s\n"      \
-        self.buffer.write(msg.encode('utf8'))
+        self.buffer.write(msg)
-    'auto_install': True,
+    'auto_install': False,
-                })
+                solved_quants.write(solving_quant._prepare_history())
-                })
+            info = {'title': _('Less Payment'), 'outstanding': False, 'content': self._get_payments_vals()}
-                            ['header', 'content', 'footer', 'res_id', 'attachment_id', 'attachment_name'])
+                            ['header', 'content', 'footer', 'res_id', 'attachment_id', 'attachment_name', 'attachment_use'])
-        if res_id and len(self._ids) == 1 and self.attachment_use and self.attachment:
+        attachment_use = False
-            attachment_name=attachment_name
+            attachment_name=attachment_name,
-            if wkhtmltopdf_obj.attachment_id:
+            if wkhtmltopdf_obj.attachment_id and wkhtmltopdf_obj.attachment_use:
-            if wkhtmltopdf_obj.res_id and wkhtmltopdf_obj.attachment_name:
+            if wkhtmltopdf_obj.res_id and wkhtmltopdf_obj.attachment_name and not wkhtmltopdf_obj.attachment_id:
-    return bool(odoo.sql_db.db_connect(db_name))
+    try:
-            P = request.env['product.product']
+            P = request.env['product.product'].sudo()
-        return self.write({'src': self.source})
+        self.ensure_one()
-                move_lot.unlink()
+                move_lot.sudo().unlink()
-                move_lot.unlink()
+                move_lot.sudo().unlink()
-from odoo import http
+from odoo import http, _
-from odoo import http
+from odoo import http, _
-import operator
+from datetime import datetime, timedelta
-from odoo.tools import DEFAULT_SERVER_DATETIME_FORMAT, DEFAULT_SERVER_DATE_FORMAT
+from odoo.tools import DEFAULT_SERVER_DATE_FORMAT
-                    mass_mailing.next_departure = schedule_date
+            if mass_mailing.schedule_date:
-                mass_mailing.next_departure = cron_next_call
+                mass_mailing.next_departure = cron_time
-                self.update(values)
+        for lead in self:
-        return odoo.registry(self.db) if self.db else None
+        return odoo.registry(self.db)
-from odoo.tools.compat import izip
+from odoo.tools.pycompat import izip
-        for operation, operation_sudo in zip(self, self.sudo()):
+        for operation, operation_sudo in izip(self, self.sudo()):
-    max_date = fields.Datetime(string='Max Date of Matched Lines', compute='_compute_max_date',
+    max_date = fields.Date(string='Max Date of Matched Lines', compute='_compute_max_date',
-                    'key': 'Leads',
+                    'key': _('Leads'),
-                    'key': 'Previous Leads',
+                    'key': _('Previous Leads'),
-                'source_id': 'Source',
+                'create_date': _('Create Date'),
-                    'key': 'Sales',
+                    'key': _('Sales'),
-                    'key': 'Previous Sales',
+                    'key': _('Previous Sales'),
-    def __nonzero__(self):
+    def __bool__(self):
-    def __nonzero__(self):
+    def __bool__(self):
-            return False
+    def __bool__(self):
-    unpickler.find_global = None
+    unpickler = Unpickler(stream)
-from odoo.tools.safe_eval import safe_eval
+from odoo.tools.safe_eval import safe_eval, const_eval
-    'MAP_ADD', 'SET_ADD',
+# opcodes necessary to build literal values
-    # maps with constant keys optimisation https://bugs.python.org/issue27140
+    'DUP_TOP_TWO',  # replaces DUP_TOPX in P3
-    'DUP_TOP_TWO', # replaces DUP_TOPX in P3
+    # until Python 3.5, literal maps are compiled to creating an empty map
-    'INPLACE_XOR','INPLACE_OR'
+    'INPLACE_XOR','INPLACE_OR', 'STORE_SUBSCR',
-    'STORE_NAME', 'GET_ITER', 'FOR_ITER', 'LIST_APPEND', 'DELETE_NAME',
+    'POP_BLOCK', 'POP_EXCEPT', # Seems to be a special-case of POP_BLOCK for P3
-    'POP_JUMP_IF_TRUE', 'SETUP_EXCEPT', 'END_FINALLY',
+    'POP_JUMP_IF_TRUE', 'SETUP_EXCEPT', 'END_FINALLY', 'RAISE_VARARGS',
-    'CALL_FUNCTION_KW', 'CALL_FUNCTION_VAR', 'CALL_FUNCTION_VAR_KW',
+
-
+collections.Set.register(BaseModel)
-import xmlrpclib
+try:
-import xmlrpclib
+try:
-import xmlrpclib
+try:
-        names = [arg.id for arg in args.args]
+        if pycompat.PY2:
-            args=ast.arguments(
+            args=arguments(
-            raise QWebException("Error when compiling AST", e, path, etree.tostring(node[0]), name)
+            raise QWebException("Error when compiling AST", e, path, etree.tostring(node[0], encoding='unicode'), name)
-            raise QWebException("Error when compiling AST", e, path, node and etree.tostring(node[0]), name)
+            raise QWebException("Error when compiling AST", e, path, node and etree.tostring(node[0], encoding='unicode'), name)
-            values = dict(self.default_values(), **values)
+            new = self.default_values()
-                return compiled(self, append, values, options, log)
+                return compiled(self, append, new, options, log)
-                raise QWebException("Error to render compiling AST", e, path, node and etree.tostring(node[0]), name)
+                raise QWebException("Error to render compiling AST", e, path, node and etree.tostring(node[0], encoding='unicode'), name)
-        return dict(format=self.format)
+        return {'format': self.format}
-            ], defaults=[], vararg=None, kwarg=None),
+            args=arguments(args=[
-                body=body,
+                body=body or [ast.Pass()],
-            raise NameError("Unknown directive on %s" % etree.tostring(el))
+            raise NameError("Unknown directive on %s" % etree.tostring(el, encoding='unicode'))
-            options['nsmap'] = dict(options['nsmap'], **el.nsmap)
+            original_nsmap = dict(options['nsmap'])
-            options['nsmap'] = dict(options['nsmap'], **el.nsmap)
+            options['nsmap'].update(el.nsmap)
-                body=self._compile_directives(el, options),
+                body=self._compile_directives(el, options) or [ast.Pass()],
-                body=self._compile_directives(el, options),
+                body=self._compile_directives(el, options) or [ast.Pass()],
-            body=self._compile_tag(el, [], options, True),
+            body=self._compile_tag(el, [], options, True) or [ast.Pass()],
-                    body=self._compile_tag(el, [self._append(ast.Name(id=default_content, ctx=ast.Load()))], options, True),
+                    body=self._compile_tag(el, [self._append(ast.Name(id=default_content, ctx=ast.Load()))], options, True) or [ast.Pass()],
-from opcode import HAVE_ARGUMENT, opmap
+import dis
-    'LOAD_CONST', 'RETURN_VALUE', 'STORE_SUBSCR', 'STORE_MAP'] if x in opmap)
+    'LOAD_CONST', 'RETURN_VALUE', 'STORE_SUBSCR', 'STORE_MAP',
-    'CONTINUE_LOOP', 'RAISE_VARARGS', 'YIELD_VALUE',
+    'MAKE_FUNCTION', 'SLICE+0', 'SLICE+1', 'SLICE+2', 'SLICE+3', 'BUILD_SLICE',
-            i += 1
+if hasattr(dis, 'get_instructions'):
-        raise ValueError("forbidden opcode(s) in %r" % expr)
+    codes = set(_get_opcodes(code_obj)) - allowed_codes
-                order.post_visible = any((x.quantity_done > 0 and x.state not in ['done' 'cancel']) for x in order.move_finished_ids)
+            order.post_visible = any(order.move_raw_ids.filtered(lambda x: (x.quantity_done) > 0 and (x.state not in ['done', 'cancel']))) or \
-                PackOperation.create(vals)
+                PackOperation |= PackOperation.create(vals)
-        if tx.callback_model_id and tx.callback_res_id and tx.sudo().callback_method:
+        # (limited sudo env for checking callback presence, must work for manual transactions too)
-        for transaction in self.filtered(lambda tx: tx.callback_model_id and tx.callback_res_id and tx.sudo().callback_method):
+        for transaction in self:
-                res = getattr(record, transaction.sudo().callback_method)(transaction)
+                res = getattr(record, transaction.callback_method)(transaction)
-                self.state = moves_todo[0].state
+                self.state = moves_todo[0].state or 'draft'
-                self.state = moves_todo[-1].state
+                self.state = moves_todo[-1].state or 'draft'
-                    ORDER BY product_id, company_id, datetime DESC""", (tuple(not_real_cost_method_products.ids), date))
+                    ORDER BY product_id, company_id, datetime DESC, id DESC""", (tuple(not_real_cost_method_products.ids), date))
-                _logger.warning("%s: %s", report_name, e.name)
+            return report_model.render_html(docids, data=data)
-                    safe_eval(self.callback_eval, {'self': self})
+                if self.sudo().callback_eval and init_state != 'authorized':
-                    safe_eval(self.callback_eval, {'self': self})
+                if self.sudo().callback_eval:
-                safe_eval(self.callback_eval, {'self': self})
+            if self.sudo().callback_eval:
-                safe_eval(self.callback_eval, {'self': self})
+            if self.sudo().callback_eval:
-                safe_eval(self.callback_eval, {'self': self})
+            if self.sudo().callback_eval:
-            return werkzeug.utils.redirect('/web#model=%s&id=%s&view_type=form' % (record_sudo._name, record_sudo.id))
+    @api.model
-from operator import itemgetter
+from collections import OrderedDict
-            lunch_data = []
+            lunch_data = {}
-                lunch_data.append({
+                lunch_data[line.id] = {
-            lunch_data.sort(key=itemgetter('date', 'line_id'), reverse=True)
+                }
-        for procurement in self.procurement_ids:
+        for procurement in self.procurement_ids.filtered(lambda p: p.state != 'cancel'):
-        if res.status_code != requests.codes.ok:
+        try:
-            values['name'] = self.env['ir.sequence'].next_by_code('mrp.production') or _('New')
+            if values.get('picking_type_id'):
-        report = self.env['ir.actions.report.xml'].with_context(context).search([('report_name', '=', report_name)])
+        report = self.env['ir.actions.report.xml'].with_context(context).search([('report_name', '=', report_name)], limit=1)
-            if display_account in ['movement', 'not_zero'] and not currency.is_zero(res['balance']):
+            if display_account == 'not_zero' and not currency.is_zero(res['balance']):
-from openerp import workflow
+from openerp import api, workflow
-    validity_date = fields.Date(string='Expiration Date', readonly=True, states={'draft': [('readonly', False)], 'sent': [('readonly', False)]},
+    validity_date = fields.Date(string='Expiration Date', readonly=True, copy=False, states={'draft': [('readonly', False)], 'sent': [('readonly', False)]},
-                        if result.get(field):
+                        if not result.get(field, False) is False:
-        # I click on the "Make Payment" wizard to pay the PoS order with the total amount (-2*450 + -3*300 = -1800)
+                'tax_ids': [(6, 0, self.product3.taxes_id.ids)],
-            'amount': 0
+            'amount': 45,
-            'amount': 1800
+            'amount': 1845
-            'amount': (-1800)
+            'amount': (-1845)
-    @api.depends('product_id', 'purchase_price', 'product_uom_qty', 'price_unit')
+    @api.depends('product_id', 'purchase_price', 'product_uom_qty', 'price_unit', 'price_subtotal')
-            operation.from_loc = '%s%s' % (operation_sudo.location_id.name, self.product_id and operation_sudo.package_id.name or '')
+            operation.from_loc = '%s%s' % (operation_sudo.location_id.name, operation.product_id and operation_sudo.package_id.name or '')
-            imd_name VARCHAR(128)
+            imd_name VARCHAR(128),
-            SET res_id = imd.res_id
+            SET res_id = imd.res_id,
-                WHERE %s AND ti.value IS NOT NULL AND ti.value != ''
+                WHERE %s
-from odoo import api, models
+from odoo import api, fields, models
-            Model.browse(int(el.get('data-oe-id'))).write({field: value})
+            if self.get_default_lang_code() and field != 'arch' and not isinstance(Model._fields[field], fields.Html):
-        self.env.cr.execute(""" CREATE VIEW report_event_registration AS (
+    def _select(self):
-        'body_html': fields.html('Body', translate=True),
+        'body_html': fields.html('Body'),
-from odoo import api, fields, models
+from odoo import _, api, fields, models
-            price = line.price_unit * (1 - (line.discount or 0.0) / 100.0)
+            price = self.env['account.tax']._fix_tax_included_price(
-            self.to_loc = '%s%s' % (operation_sudo.location_dest_id.name, operation_sudo.result_package_id.name or '')
+            operation.from_loc = '%s%s' % (operation_sudo.location_id.name, self.product_id and operation_sudo.package_id.name or '')
-    @api.one
+    @api.multi
-        self.to_loc = '%s%s' % (self.location_dest_id.name, self.result_package_id.name or '')
+        for operation, operation_sudo in zip(self, self.sudo()):
-            'product_uom_id': self.product_2.uom_id.id,
+            'product_id': self.product_9.id,
-            'product_uom_id': self.product_4.uom_id.id,
+            'product_id': self.product_10.id,
-            'product_id': self.product_4.id,
+            'product_id': self.product_10.id,
-            'product_id': self.product_2.id,
+            'product_id': self.product_9.id,
-        #     test_bom_3.explode(self.product_2, 1)
+        with self.assertRaises(exceptions.UserError):
-            if not check_func(vat_country, vat_number):  # simple_vat_check
+        partner = request.env["res.partner"]
-                    error["vat"] = 'error'
+            partner_dummy = Partner.new({
-            attrs['domain'] = safe_eval(field_data['domain']) if field_data['domain'] else None
+            attrs['domain'] = safe_eval(field_data['domain'] or '[]')
-            attrs['domain'] = safe_eval(field_data['domain']) if field_data['domain'] else None
+            attrs['domain'] = safe_eval(field_data['domain'] or '[]')
-            attrs['domain'] = safe_eval(field_data['domain']) if field_data['domain'] else None
+            attrs['domain'] = safe_eval(field_data['domain'] or '[]')
-    'in_refund': 1,
+    'in_refund': -1,
-    'out_refund': -1,
+    'out_refund': 1,
-    @api.one
+    @api.multi
-        self.hide_payment_method = len(journal_payment_methods) == 1 and journal_payment_methods[0].code == 'manual'
+        for payment in self:
-
+    @api.model
-                    total += inv.residual_company_signed
+        total = 0
-        return self.env['account.invoice'].browse(self._context.get('active_ids'))
+    @api.model
-        invoices = self.env[active_model].browse(active_ids)
+        active_ids = self._context.get('active_ids')
-            raise UserError(_("You cannot mix customer invoices and vendor bills in a single payment."))
+        # Check all invoices have the same currency
-        communication = ' '.join([ref for ref in invoices.mapped('reference') if ref])
+        # Look if we are mixin multiple commercial_partner or customer invoices with vendor bills
-            'communication': communication,
+            'partner_id': False if multi else invoices[0].commercial_partner_id.id,
-        """ Hook for extension """
+    @api.multi
-            'amount': self.amount,
+            'invoice_ids': [(6, 0, invoices.ids)],
-            'partner_type': self.partner_type,
+            'partner_id': invoices[0].commercial_partner_id.id,
-        return {'type': 'ir.actions.act_window_close'}
+    def get_payments_vals(self):
-        self.partner_axelor = self.env.ref("base.res_partner_2")
+        self.partner_china_exp = self.env.ref("base.res_partner_3")
-    def create_invoice(self, amount=100, type='out_invoice', currency_id=None):
+    def create_invoice(self, amount=100, type='out_invoice', currency_id=None, partner=None):
-            'partner_id': self.partner_agrolait.id,
+            'partner_id': partner,
-            'name': type == 'out_invoice' and 'invoice to client' or 'invoice to supplier',
+            'name': type,
-        inv_2 = self.create_invoice(amount=200, currency_id=self.currency_eur_id)
+        inv_1 = self.create_invoice(amount=100, currency_id=self.currency_eur_id, partner=self.partner_agrolait.id)
-        register_payments.create_payment()
+        register_payments.create_payments()
-            'partner_id': self.partner_axelor.id,
+            'partner_id': self.partner_china_exp.id,
-            {'account_id': self.partner_axelor.property_account_payable_id.id, 'debit': 38.21, 'credit': 0.0, 'amount_currency': 50, 'currency_id': self.currency_chf_id},
+            {'account_id': self.partner_china_exp.property_account_payable_id.id, 'debit': 38.21, 'credit': 0.0, 'amount_currency': 50, 'currency_id': self.currency_chf_id},
-        res = super(AccountRegisterPayments, self).get_payment_vals()
+    def _prepare_payment_vals(self, invoices):
-    def get_payment_vals(self):
+    def _get_payment_vals(self):
-        payment = self.env['account.payment'].create(self.get_payment_vals())
+        payment = self.env['account.payment'].create(self._get_payment_vals())
-        res = super(HrExpenseRegisterPaymentWizard, self).get_payment_vals()
+    def _get_payment_vals(self):
-        ], string='Trigger condition', required=True, oldname="kind")
+        ], string='Trigger Condition', required=True, oldname="kind")
-    filter_domain = fields.Char(string='Domain', help="If present, this condition must be satisfied before executing the action rule.")
+    filter_domain = fields.Char(string='Apply on', help="If present, this condition must be satisfied before executing the action rule.")
-                               help="Base model on which the server action runs.")
+    model_id = fields.Many2one('ir.model', string='Model', required=True, ondelete='cascade',
-        help="Allows you to send pro-forma.")
+    group_proforma_sales = fields.Boolean(string="Pro-Forma Invoice", implied_group='sale.group_proforma_sales',
-    date_planned = fields.Datetime(string='Scheduled Date', compute='_compute_date_planned', store=True, index=True, oldname='minimum_planned_date')
+    date_planned = fields.Datetime(string='Scheduled Date', compute='_compute_date_planned', store=True, index=True)
-        return obj_data.get_object_reference(cr, uid, 'stock', 'picking_type_in')[1]
+        picking_id = self.pool['ir.model.data'].xmlid_to_res_id(cr, uid, 'stock.picking_type_in', raise_if_not_found=False)
-            ('state', 'in', ['open', 'paid', 'cancelled'])
+            ('state', 'in', ['open', 'paid', 'cancel'])
-            test_bom_3.explode(self.product_2, 1)
+        # with self.assertRaises(exceptions.UserError):
-    def _phone_get_country_code(self):
+    def _phone_get_country(self):
-        return self.env.user.company_id.country_id.code
+            return self.country_id
-        country_code = country.code if country else self._phone_get_country_code()
+        country = country or self._phone_get_country()
-            number, country_code if country_code else None,
+            number,
-    def phone_format(number, country_code, always_international=True, raise_exception=True):
+    def phone_format(number, country_code, country_phone_code, always_international=True, raise_exception=True):
-        if always_international and phone_nbr.country_code != country_code:
+        if always_international and phone_nbr.country_code != country_phone_code:
-    def phone_format(number, country_code, always_international=True, raise_exception=True):
+    def phone_format(number, country_code, country_phone_code, always_international=True, raise_exception=True):
-        help="Always encore phone numbers using international format. Otherwise"
+        help="Always encode phone numbers using international format. Otherwise"
-        help="This account is used when validating a vendor bill, for continental accounting or anglo-saxon without perpetual inventory valuation. For anglo-saxon accounting (US) with perpetual inventory valuation, this account is used when validating the customer invoice (set a Cost of Revenues/COGS account in this case).")
+        help="The expense is accounted for when a vendor bill is validated, except in anglo-saxon accounting with perpetual inventory valuation in which case the expense (Cost of Goods Sold account) is recognized at the customer invoice validation.")
-        help="This account is used when validating a vendor bill, for continental accounting or anglo-saxon without perpetual inventory valuation. For anglo-saxon accounting (US) with perpetual inventory valuation, this account is used when validating the customer invoice (set a Cost of Revenues/COGS account in this case). If the field is empty, it uses the one defined in the product category.")
+        help="The expense is accounted for when a vendor bill is validated, except in anglo-saxon accounting with perpetual inventory valuation in which case the expense (Cost of Goods Sold account) is recognized at the customer invoice validation. If the field is empty, it uses the one defined in the product category.")
-        #     test_bom_2.explode(self.product_7_1, 4)
+        #check recursion
-        templates_done = product.product_tmpl_id
+        V |= set([product.product_tmpl_id.id])
-                templates_done |= current_line.product_id.product_tmpl_id
+                for bom_line in bom.bom_line_ids:
-            test_bom_2.explode(self.product_7_1, 4)
+        #wrong test
-        help="This account will be used when validating a vendor bill in periodic valuation, or when receiving products with perpetual valuation.\n For continental accounting, always set an expense account. For anglo-saxon accounting (US), you should set an expense account Â for consumable, or an inventory account for products that you sell.")
+        help="This account is used when validating a vendor bill, for continental accounting or anglo-saxon without perpetual inventory valuation. For anglo-saxon accounting (US) with perpetual inventory valuation, this account is used when validating the customer invoice (set a Cost of Revenues/COGS account in this case).")
-        help="This account will be used when validating a vendor bill in periodic valuation, or when receiving products with perpetual valuation.\n For continental accounting, always set an expense account. For anglo-saxon accounting (US), you should set an expense account Â for consumable, or an inventory account for products that you sell. If the field is empty, it uses the one defined in the product category.")
+        help="This account is used when validating a vendor bill, for continental accounting or anglo-saxon without perpetual inventory valuation. For anglo-saxon accounting (US) with perpetual inventory valuation, this account is used when validating the customer invoice (set a Cost of Revenues/COGS account in this case). If the field is empty, it uses the one defined in the product category.")
-        help="This account will be used for invoices to value sales.")
+        help="This account will be used when validating a customer invoice.")
-        help="This account will be used for invoices to value expenses.")
+        help="This account will be used when validating a vendor bill in periodic valuation, or when receiving products with perpetual valuation.\n For continental accounting, always set an expense account. For anglo-saxon accounting (US), you should set an expense account Â for consumable, or an inventory account for products that you sell.")
-        help="This account will be used for invoices instead of the default one to value sales for the current product.")
+        help="Keep this field empty to use the default value from the product category.")
-        help="This account will be used for invoices instead of the default one to value expenses for the current product.")
+        help="This account will be used when validating a vendor bill in periodic valuation, or when receiving products with perpetual valuation.\n For continental accounting, always set an expense account. For anglo-saxon accounting (US), you should set an expense account Â for consumable, or an inventory account for products that you sell. If the field is empty, it uses the one defined in the product category.")
-        self.env.ref('base.main_company').write({'currency_id': self.env.ref('base.USD')})
+        self.env.ref('base.main_company').write({'currency_id': self.env.ref('base.USD').id})
-        return dict(default_purchase_tax_id=int(default_purchase_tax_id), default_sale_tax_id=int(default_sale_tax_id))
+    def get_values(self):
-    def set_default_tax_fields(self):
+    def set_values(self):
-    def set_chart_of_accounts(self):
+    @api.depends('company_id')
-        return settings
+    server_uri_google = fields.Char(string='Server uri')
-    def get_oauth_providers(self, fields):
+    def get_values(self):
-        self.ensure_one()
+        res.update(
-        rg = {
+        google_provider.write({
-        google_provider.write(rg)
+        })
-        get_param = self.env['ir.config_parameter'].get_param
+    def get_values(self):
-        }
+        res.update(
-        set_param = self.env['ir.config_parameter'].set_param
+    def set_values(self):
-        })
+    def get_values(self):
-        super(BaseConfigSettings, self).set_fields()
+    def set_values(self):
-class CRMSettings(models.TransientModel):
+class SaleConfigSettings(models.TransientModel):
-    def get_default_alias_prefix(self, fields):
+    def get_values(self):
-        return {'alias_prefix': alias.alias_name if alias else False}
+        res.update(
-    def set_generate_lead_from_alias(self):
+    def set_values(self):
-from odoo import fields, models
+from odoo import api, fields, models
-
+class BaseConfigSettings(models.TransientModel):
-    def set_calset(self):
+    def set_values(self):
-        return dict(cal_client_id=cal_client_id, cal_client_secret=cal_client_secret, server_uri=server_uri)
+    @api.model
-    google_drive_authorization_code = fields.Char(string='Authorization Code', default=_default_google_drive_authorization_code)
+    google_drive_authorization_code = fields.Char(string='Authorization Code')
-        ICP = self.env['ir.config_parameter']
+    @api.model
-        if authorization_code and authorization_code != ICP.get_param('google_drive_authorization_code'):
+        if authorization_code and authorization_code != params.get_param('google_drive_authorization_code'):
-        ICP.set_param('google_drive_refresh_token', refresh_token)
+        params.set_param('google_drive_authorization_code', authorization_code)
-        res.update(dict(
+    def get_values(self):
-        ))
+        )
-        super(HrExpenseConfigSettings, self).set_fields()
+    def set_values(self):
-    def set_default_max_unused_cars(self):
+    def set_values(self):
-    def get_default_max_unused_cars(self, fields):
+    def get_values(self):
-        return dict(max_unused_cars=int(max_unused_cars))
+        res.update(max_unused_cars=params.get_param('l10n_be_hr_payroll_fleet.max_unused_cars', default=3))
-class BaseConfiguration(models.TransientModel):
+class BaseConfigSettings(models.TransientModel):
-    def get_default_fail_counter(self, fields):
+    def get_values(self):
-            self.env['ir.config_parameter'].set_param("mail.catchall.domain", record.alias_domain or '')
+        res.update(
-        res.update(dict(
+    def get_values(self):
-        ))
+        )
-        super(MrpConfigSettings, self).set_fields()
+    def set_values(self):
-        res.update(dict(
+    def get_values(self):
-        ))
+        )
-        super(PosConfigSettings, self).set_fields()
+    def set_values(self):
-    def get_default_company_share_product(self, fields):
+    def get_values(self):
-        }
+        res.update(
-        self.ensure_one()
+    def set_values(self):
-    def set_lock_confirmed_po(self):
+    def get_values(self):
-        res.update(dict(
+    def get_values(self):
-        ))
+        )
-        super(StockConfigSettings, self).set_fields()
+    def set_values(self):
-    def get_multi_sales_price(self, fields):
+    @api.model
-        return dict(
+        res.update(
-        super(SaleConfigSettings, self).set_fields()
+    def set_values(self):
-        res.update(dict(
+    def get_values(self):
-        ))
+        )
-        super(StockConfigSettings, self).set_fields()
+    def set_values(self):
-        res.update(dict(
+    def get_values(self):
-        ))
+        )
-        super(StockConfigSettings, self).set_fields()
+    def set_values(self):
-        return True
+        if self.group_stock_multi_locations:
-    def get_default_fields(self, fields):
+    def get_values(self):
-        ))
+        res = super(WebsiteConfigSettings, self).get_values()
-    def set_fields(self):
+    def set_values(self):
-        super(WebsiteConfigSettings, self).set_fields()
+        super(WebsiteConfigSettings, self).set_values()
-    def set_automatic_invoice(self):
+    @api.model
-        return {'automatic_invoice': value}
+        self.env['ir.config_parameter'].sudo().set_param('sale.sale_pricelist_setting', self.sale_pricelist_setting)
-
+class WebsiteConfigSettings(models.TransientModel):
-        }
+    def get_values(self):
-            self.env['ir.config_parameter'].sudo().set_param('website_slides.google_app_key', wizard.website_slide_google_app_key)
+    def set_values(self):
-    def get_default_fields(self, fields):
+    def get_values(self):
-        # and call the method 'get_default_fields'
+        # other fields: call the method 'get_values'
-        res.update(self.get_default_fields(fields))
+            if method.startswith('get_default_'):
-    def set_fields(self):
+    def set_values(self):
-        # and the method 'set_fields'
+        # other fields: execute method 'set_values'
-        self.set_fields()
+            if method.startswith('set_') and method is not 'set_values':
-        config = env['res.config'].next() or {}
+        config = self.next() or {}
-        return self._next()
+        Reload the settings page
-            return action
+        self._install_modules(to_install)
-            }
+    @api.model
-                todo.create({'action_id': action_rec.id, 'name': _('Choose Accounting Template'), 'type': 'automatic'})
+                todo.create({'action_id': action_rec.id, 'name': _('Choose Accounting Template')})
-            self.write({'state': 'done'})
+
-            ctx['disable_log'] = True
+        ctx['disable_log'] = True
-                return todo
+        active_todo = Todos.search([('state', '=', 'open')], limit=1)
-class PosConfiguration(models.TransientModel):
+class PosConfigSettings(models.TransientModel):
-        res = super(PosConfiguration, self).get_default_fields(fields)
+        res = super(PosConfigSettings, self).get_default_fields(fields)
-        super(PosConfiguration, self).set_fields()
+        super(PosConfigSettings, self).set_fields()
-class SaleConfiguration(models.TransientModel):
+class SaleConfigSettings(models.TransientModel):
-        res = super(SaleConfiguration, self).get_default_fields(fields)
+        res = super(SaleConfigSettings, self).get_default_fields(fields)
-        super(SaleConfiguration, self).set_fields()
+        super(SaleConfigSettings, self).set_fields()
-        return {
+        res.update({
-        }
+        })
-    def set_default_fields(self):
+    def set_fields(self):
-        return dict(
+        res = super(HrExpenseConfigSettings, self).get_default_fields(fields)
-        )
+        ))
-        return dict(
+        res = super(MrpConfigSettings, self).get_default_fields(fields)
-        )
+        ))
-        return dict(
+        res = super(PosConfiguration, self).get_default_fields(fields)
-        )
+        ))
-        return dict(
+        res = super(StockConfigSettings, self).get_default_fields(fields)
-        )
+        ))
-        return dict(
+        res = super(SaleConfiguration, self).get_default_fields(fields)
-        )
+        ))
-        return dict(
+        res = super(StockConfigSettings, self).get_default_fields(fields)
-        )
+        ))
-        return dict(
+        res = super(StockConfigSettings, self).get_default_fields(fields)
-        )
+        ))
-    def set_default_fields(self):
+    def set_fields(self):
-        return dict(
+        res = super(WebsiteConfigSettings, self).get_default_fields(fields)
-        )
+        ))
-            if method.startswith('get_default_'):
+            if method.startswith('get_default_') and method is not 'get_default_fields':
-            if method.startswith('set_'):
+            if method.startswith('set_') and method is not 'set_fields':
-    po_lead = fields.Float(related='company_id.po_lead', default=lambda self: self.env.user.company_id.po_lead)
+    po_lead = fields.Float(related='company_id.po_lead')
-                value = self[name].ids
+                if self._fields[name].type == 'many2one':
-        'views/res_config_view.xml',
+        'views/account_config_settings_views.xml',
-from . import res_config
+from . import account_config_settings
-        'views/res_config_view.xml',
+        'views/account_config_settings_views.xml',
-from . import res_config
+from . import account_config_settings
-        'views/res_config_view.xml',
+        'views/account_config_settings_views.xml',
-        'views/res_config_view.xml',
+        'views/account_config_settings_views.xml',
-        'views/res_config_view.xml',
+        'views/account_config_settings_views.xml',
-        'views/res_config_views.xml',
+        'views/base_config_settings_views.xml',
-        'views/res_config_views.xml',
+        'views/base_config_settings_views.xml',
-from . import res_users
+from . import base_config_settings
-        'views/res_config_views.xml',
+        'views/base_config_settings_views.xml',
-        'views/res_config_views.xml',
+        'views/base_config_settings_views.xml',
-from . import res_config
+from . import base_config_settings
-        'views/res_config_view.xml',
+        'views/account_config_settings_views.xml',
-        'views/res_config_views.xml',
+        'views/sale_config_settings_views.xml',
-from . import res_config
+from . import sale_config_settings
-        'views/res_config_views.xml',
+        'views/base_config_settings_views.xml',
-from . import res_config
+from . import res_users
-        'views/res_config_views.xml',
+        'views/base_config_settings_views.xml',
-        'views/res_config_view.xml',
+        'views/attendance_config_settings_views.xml',
-        'views/res_config_views.xml',
+        'views/hr_expense_config_settings_views.xml',
-from . import res_config
+from . import hr_expense_config_settings
-        'views/res_config_views.xml',
+        'views/hr_timesheet_config_settings_views.xml',
-from . import res_config
+from . import hr_timesheet_config_settings
-        'views/res_config_view.xml',
+        'views/account_config_settings_views.xml',
-        "views/res_config_view.xml",
+        "views/account_config_settings_views.xml",
-from . import res_config
+from . import account_config_settings
-    _inherit = 'res.config.settings'
+    _inherit = 'account.config.settings'
-        'views/res_config_views.xml',
+        'views/base_config_settings_views.xml',
-from . import res_config
+from . import base_config_settings
-        'views/res_config_views.xml',
+        'views/mass_mailing_config_settings_views.xml',
-from . import res_config
+from . import mass_mailing_config_settings
-        'views/res_config_view.xml',
+        'views/base_config_settings_views.xml',
-        'views/res_config_view.xml',
+        'views/pos_config_settings_views.xml',
-        'views/res_config_views.xml',
+        'views/project_config_settings_views.xml',
-        'views/res_config_views.xml',
+        'views/hr_timesheet_config_settings_views.xml',
-        'views/res_config_views.xml',
+        'views/purchase_config_settings_views.xml',
-from . import stock_config_settings
+from . import purchase_config_settings
-from . import res_config
+from . import stock_config_settings
-             'views/res_config_view.xml',
+             'views/sale_config_settings_views.xml',
-from . import res_config
+from . import sale_config_settings
-        'views/res_config_views.xml',
+        'views/website_config_settings_views.xml',
-from . import ir_http
+from . import ir_http
-from . import website
+from . import website
-        'views/res_config.xml',
+        'views/website_config_settings_views.xml',
-        'website_livechat_data.xml',
+        'data/website_livechat_data.xml',
-    channel_id = fields.Many2one('im_livechat.channel', string='Website Live Channel', related='website_id.channel_id')
+# -*- coding: utf-8 -*-
-        'views/res_config_view.xml',
+        'views/mass_mailing_config_settings_views.xml',
-        'views/res_config_view.xml',
+        'views/website_config_settings_views.xml',
-from . import rating
+from . import rating
-from . import res_config
+from . import website_config_settings
-        'view/website_slides_backend.xml',
+        'views/website_config_settings_views.xml',
-from . import res_config
+
-                dashboard_data['dashboards']['visits']['ga_client_id'] = ga_client_id
+            config = request.env['website.config.settings'].sudo().create({})
-    def website_set_ga_client_id(self, ga_client_id):
+    @http.route('/website/dashboard/set_ga_data', type='json', auth='user')
-        if not ga_client_id.endswith('.apps.googleusercontent.com') or ga_client_id.startswith(" "):
+        if not ga_analytics_key or not ga_client_id.endswith('.apps.googleusercontent.com'):
-                    'message': 'The Google Analytics Client ID you have entered seems incorrect.',
+                    'title': 'Incorrect Client ID / Key',
-            'use_google_analytics_dashboard': True,
+        request.env['website.config.settings'].create({
-        })
+            'google_analytics_key': ga_analytics_key,
-            ga_dashboard = request.env['ir.values'].sudo().get_default('website.config.settings', 'has_google_analytics_dashboard')
+            ga_dashboard = request.env['ir.config_parameter'].sudo().get_param('website.has_google_analytics_dashboard')
-    def set_has_google_analytics(self):
+    @api.model
-    def set_has_google_maps(self):
+        return dict(
-            'website.config.settings', 'has_google_maps', self.has_google_maps)
+        self.env['ir.config_parameter'].sudo().set_param('website.has_google_analytics', self.has_google_analytics)
-        has_group_designer = request.env['res.users'].has_group('website.group_website_designer')
+        has_group_system = request.env.user.has_group('base.group_system')
-    default_new_propagation_minimum_delta = fields.Boolean(string="No Rescheduling Propagation", default_model="stock.config.settings", help="Rescheduling applies to any chain of operations (e.g. Make To Order, Pick Pack Ship). In the case of MTO sales, a vendor delay (updated incoming date) impacts the expected delivery date to the customer. \n This option allows to not propagate the rescheduling if the change is not critical.")
+    use_propagation_minimum_delta = fields.Boolean(
-from odoo import fields, models
+from odoo import api, fields, models
-    default_new_security_lead = fields.Boolean(string="Security Lead Time for Sales", default_model="stock.config.settings", help="Margin of error for dates promised to customers. Products will be scheduled for procurement and delivery that many days earlier than the actual promised date, to cope with unexpected delays in the supply chain.")
+    use_security_lead = fields.Boolean(
-        if self.env['ir.values'].get_default('sale.config.settings', 'auto_done_setting'):
+        if self.env['ir.config_parameter'].get_param('sale.auto_done_setting'):
-    multi_sales_price = fields.Boolean("Multiple sales price per product", default_model='sale.config.settings')
+    multi_sales_price = fields.Boolean("Multiple sales price per product")
-        default='subtotal',
+        ('total', 'Tax-Included Prices')], string="Tax Display",
-    deposit_product_id_setting = fields.Many2one(
+    default_deposit_product_id = fields.Many2one(
-
+
-
+    def get_default_sale_show_tax(self, fields):
-        product_id = self.env['ir.values'].get_default('sale.config.settings', 'deposit_product_id_setting')
+        product_id = self.env['ir.config_parameter'].get_param('sale.default_deposit_product_id')
-                self.env['ir.values'].sudo().set_default('sale.config.settings', 'deposit_product_id_setting', self.product_id.id)
+                self.env['ir.config_parameter'].sudo().set_param('sale.default_deposit_product_id', self.product_id.id)
-    sale_pricelist_setting_split_2 = fields.Selection([
+    # sale_pricelist_settings splitted in several entries for usability purpose
-        ], default=0, string="Sales Price")
+        (1, 'Prices computed from formulas (discounts, margins, roundings)')],
-                'sale_pricelist_setting_split_2': 0 if self.env['ir.values'].get_defaults_dict('sale.config.settings').get('sale_pricelist_setting', 'fixed') != 'formula' else 1}
+        sale_pricelist_setting = self.env['ir.config_parameter'].sudo().get_param('sale.sale_pricelist_setting')
-            'sale.config.settings', 'sale_pricelist_setting', sale_pricelist_setting)
+    def set_multi_sales_price(self):
-
+
-        if invoice_type == 'out_invoice':
+        if invoice_type == 'out_invoice' and self.env['ir.config_parameter'].sudo().get_param('sale.use_sale_note'):
-        return self.env.user.company_id.sale_note
+        return self.env['ir.config_parameter'].sudo().get_param('sale.use_sale_note') and self.env.user.company_id.sale_note or ''
-        if self.env.user.company_id.sale_note:
+        if self.env['ir.config_parameter'].sudo().get_param('sale.use_sale_note') and self.env.user.company_id.sale_note:
-    default_use_sale_note = fields.Boolean(string='Default Terms & Conditions')
+    use_sale_note = fields.Boolean(
-    @api.model
+
-    default_new_po_lead = fields.Boolean(string="Security Lead Time for Purchase", default_model="stock.config.settings", help="Margin of error for vendor lead times. When the system generates Purchase Orders for reordering products,they will be scheduled that many days earlier to cope with unexpected vendor delays.")
+    use_po_lead = fields.Boolean(
-    default_pricelist_setting = fields.Selection([
+    use_pos_sale_price = fields.Boolean("A single sale price per product", oldname='default_sale_price')
-        ], string="Multiple Prices per Products", default_model='pos.config.settings')
+        ], string="Multiple Prices per Products",
-    @api.onchange('default_sale_price')
+    @api.onchange('use_pos_sale_price')
-            self.default_pricelist_setting = 'percentage'
+        if not self.use_pos_sale_price:
-    @api.onchange('default_pricelist_setting')
+    @api.onchange('pos_pricelist_setting')
-        if self.default_pricelist_setting == 'percentage':
+        if self.pos_pricelist_setting == 'percentage':
-        elif self.default_pricelist_setting == 'formula':
+        elif self.pos_pricelist_setting == 'formula':
-from odoo import fields, models
+from odoo import api, fields, models
-    default_use_manufacturing_lead = fields.Boolean(string="Default Manufacturing Lead Time", default_model='mrp.config.settings')
+    use_manufacturing_lead = fields.Boolean(string="Default Manufacturing Lead Time", oldname='default_use_manufacturing_lead')
-            alias_record = self.env.ref('hr_expense.mail_alias_expense')
+            use_mailgateway = self.env['ir.config_parameter'].sudo().get_param('hr_expense.use_mailgateway')
-    group_analytic_accounting = fields.Boolean(string='Analytic Accounting',
+    group_analytic_accounting = fields.Boolean(
-    group_uom = fields.Boolean("Units of Measure",
+    group_uom = fields.Boolean(
-    default_alias_email = fields.Boolean(string='Let your employees record expenses by email', default_model='hr.expense.config.settings')
+    use_mailgateway = fields.Boolean(string='Let your employees record expenses by email')
-        return {'alias_prefix': alias_name}
+    def get_default_fields(self, fields):
-            self.env.ref('hr_expense.mail_alias_expense').write({'alias_name': record.alias_prefix})
+    def set_fields(self):
-    default_generate_lead_from_alias = fields.Boolean('Manual Assignation of Emails')
+    generate_lead_from_alias = fields.Boolean('Manual Assignation of Emails')
-            self.default_generate_lead_from_alias = False
+            self.generate_lead_from_alias = False
-            self.alias_prefix = False
+    @api.onchange('generate_lead_from_alias')
-            if timeline.loss_type != 'productive':
+            if wo.duration_expected <= wo.duration:
-                    timeline.copy({'date_start': maxdate, 'date_end': enddate, 'loss_id': loss_id.id})
+                    not_productive_timelines += timeline.copy({'date_start': maxdate, 'date_end': enddate})
-        _logger.info('The XML file does not fit the required schema !', exc_info=True)
+        _logger.info("The XML file '%s' does not fit the required schema !", xmlfile.name, exc_info=True)
-        pick_ids = sum([order.picking_ids.ids for order in self], [])
+        pick_ids = self.mapped('picking_ids')
-            result['domain'] = "[('id','in',[" + ','.join(str(id) for id in pick_ids) + "])]"
+            result['domain'] = "[('id','in',%s])]" % (pick_ids.ids)
-            result['res_id'] = pick_ids and pick_ids[0] or False
+            result['res_id'] = pick_ids.id
-                            self.run(cr, uid, [proc_id])
+                            self.check(cr, uid, [proc_id], context=context)
-            return report_model.render_html(docids, data=data)
+            try:
-                pack.unlink()
+        operations_to_delete = self.pick_id.pack_operation_ids.filtered(lambda o: o.qty_done <= 0)
-            if record.field_type in ['integer', 'float', 'char', 'text', 'datetime', 'monetary']:
+            if record.field_type in ['integer', 'float', 'char', 'text', 'monetary']:
-            working_intervals += self.interval_remove_leaves(working_interval, work_limits)
+
-        self.assertEqual(record.field_1, 1)
+        self.assertEqual(
-        self.assertEqual(b.call(), "This is model 1 record B")
+        self.assertEqual(
-                else:
+                key = self._get_account_move_line_group_data_type_key(data_type, values)
-    if urlparse.urlparse(url, scheme='http').scheme not in ('http', 'https'):
+    if urlparse(url, scheme='http').scheme not in ('http', 'https'):
-    if urlparse.urlparse(url, scheme='http').scheme not in ('http', 'https'):
+    if urls.url_parse(url, scheme='http').scheme not in ('http', 'https'):
-        for src, value in zip(terms_en, terms_fr):
+        for src, value in list(pycompat.izip(terms_en, terms_fr)):
-        for src, value in zip(terms_en, terms_fr):
+        for src, value in list(pycompat.izip(terms_en, terms_fr)):
-from openerp import api, SUPERUSER_ID
+from . import models
-import account
+from . import res_company
-from tools import parse_version as pv
+from .tools import parse_version as pv
-
+    def _get_move_values(self, qty, location_id, location_dest_id):
-                vals['product_uom_qty'] = abs(diff)
+                vals = self._get_move_values(abs(diff), line.product_id.property_stock_inventory.id, line.location_id.id)
-                vals['product_uom_qty'] = diff
+                vals = self._get_move_values(abs(diff), line.location_id.id, line.product_id.property_stock_inventory.id)
-    import pickle
+from openerp.tools import pickle
-        pickle.dump(data, fn, pickle.HIGHEST_PROTOCOL)
+        pickle.dump(data, fn, -1)
-    import pickle
+from openerp.tools import pickle
-        pickle.dump(data, fn, pickle.HIGHEST_PROTOCOL)
+        pickle.dump(data, fn, -1)
-    import pickle
+from openerp.tools import pickle
-        pickle.dump(data, fn, pickle.HIGHEST_PROTOCOL)
+        pickle.dump(data, fn, -1)
-    import pickle
+
-        pickle.dump(data, fn, pickle.HIGHEST_PROTOCOL)
+        pickle.dump(data, fn, protocol=-1)
-    def create(self, values):
+    def _prepare_add_missing_fields(self, values):
-                    values[field] = line._fields[field].convert_to_write(line[field], line)
+                    res[field] = line._fields[field].convert_to_write(line[field], line)
-                'product_id': self.product_id})],
+            'order_line': [
-        self.assertEqual(sale_order_so11.margin, 3000.00, "Sale order margin should be 3000.00")
+        self.assertEqual(sale_order_so11.margin, 6000.00, "Sale order margin should be 6000.00")
-        'Red Kanban Label', default='Blocked', translate=True,
+        'Red Kanban Label', default='Blocked', translate=True, required=True,
-        'Green Kanban Label', default='Ready for Next Stage', translate=True,
+        'Green Kanban Label', default='Ready for Next Stage', translate=True, required=True,
-        'Grey Kanban Label', default='In Progress', translate=True,
+        'Grey Kanban Label', default='In Progress', translate=True, required=True,
-        copy=False, default='normal', required=True, track_visibility='onchange',
+        copy=False, default='normal', required=True,
-        if 'kanban_state' in init_values and self.kanban_state == 'blocked':
+        if 'kanban_state_label' in init_values and self.kanban_state == 'blocked':
-        elif 'kanban_state' in init_values and self.kanban_state == 'done':
+        elif 'kanban_state_label' in init_values and self.kanban_state == 'done':
-                                  or (not is_a_bot and cls.get_nearest_lang(request.lang)))
+                                  or (not is_a_bot and cls.get_nearest_lang(request.lang))
-    l10n_fr_hash = fields.Char(readonly=True)
+    l10n_fr_secure_sequence_number = fields.Integer(readonly=True, copy=False)
-    def add_payment(self, data):
+    def _prepare_bank_statement_line_payment_values(self, data):
-        return statement_id
+        return args.get('statement_id', False)
-        vals = {
+    # Do not forward port in 10.0 and beyond
-         }
+            'location_id': location_id,
-            vals['product_uom_qty'] = -diff
+        if diff < 0:  # found more than expected
-            vals['product_uom_qty'] = diff
+            vals = self._get_move_values(cr, uid, inventory_line, abs(diff), inventory_line.location_id.id, inventory_location_id)
-        self.assertEqual(len(picking_out.move_lines[0].quant_ids), 2, 'We should have exactly 2 quants in the end')
+        self.assertEqual(len(picking_out.move_lines[0].quant_ids), 2, 'We should have exactly 2 quants in the end')
-            'task_ids': [(4, task.id) for task in selected_tasks],
+            'task_ids': selected_tasks.ids,
-        return self.env.ref(DEFAULT_PAYMENT_TERM, False).id or partner.property_payment_term_id.id
+        return partner.property_payment_term_id.id or self.env.ref(DEFAULT_PAYMENT_TERM, False).id
-            'user_id': salesperson_id or self.salesperson_id.id,
+            'user_id': salesperson_id or self.salesperson_id.id or default_user_id,
-                    statement.write({'balance_end_real': statement.balance_end})
+    def _check_pos_session_balance(self):
-                    # (trans.value -> trans.src) gives the original value back
+                    src = trans.src
-                    value1 = field.translate({trans.src: trans.value}.get, value0)
+                    value1 = field.translate({src: val}.get, value0)
-                    value2 = field.translate({trans.value: trans.src}.get, value1)
+                    value2 = field.translate({val: src}.get, value1)
-                        raise ValidationError(_("Translation is not valid:\n%s") % trans.value)
+                        raise ValidationError(_("Translation is not valid:\n%s") % val)
-                        vals['value'] = new_wo_lang[name]
+                        # the value should be the new value (given by copy())
-        help='Technical: used in views only.')
+        help='Technical: used in views only.', store=True)
-        help="This is the date on which an alert should be notified about the goods with this Serial Number.")
+        help='Date to determine the expired lots and serial numbers using the filter "Expiration Alerts".')
-                obj_line.analytic_line_ids.unlink()
+from odoo.tools import float_compare
-        self.assertEquals(timesheet4.timesheet_revenue, 152.68, "Revenue computation on invoice validation does not return the correct revenue !")
+        self.assertEquals(float_compare(timesheet1.timesheet_revenue, 385.85, precision_digits=2), 0, "Revenue computation on invoice validation does not return the correct revenue !")
-        ('invoiced', 'Bills Received'),
+        ('invoiced', 'No Bill to Receive'),
-            xml1.append(E.separator(string=_('Application'), colspan="2"))
+            xml1.append(E.separator(string=_('Application Accesses'), colspan="2"))
-    'test': ['test/recruitment_process.yml'],
+from . import test_recruitment_process
-            "Delivey cost is not correspond.")
+        self.assertEqual(float_compare(line.price_subtotal, 10.0, precision_digits=2), 0,
-            "Delivey cost is not correspond.")
+            "Delivery cost is not correspond.")
-                        for index, timesheet_line in enumerate(uninvoiced_timesheet_lines.sorted(key=lambda ts: ts.date)):
+                        for index, timesheet_line in enumerate(uninvoiced_timesheet_lines.sorted(key=lambda ts: (ts.date, ts.id))):
-                        for index, timesheet_line in enumerate(no_zero_timesheet_revenue.sorted(key=lambda ts: ts.date)):
+                        for index, timesheet_line in enumerate(no_zero_timesheet_revenue.sorted(key=lambda ts: (ts.date, ts.id))):
-    ], 'Payment', help="Require immediate payment by the customer when validating the order from the website quote")
+    ], 'Payment', default=0, help="Require immediate payment by the customer when validating the order from the website quote")
-    ], 'Payment', help="Require immediate payment by the customer when validating the order from the website quote")
+    ], 'Payment', default=0, help="Require immediate payment by the customer when validating the order from the website quote")
-            amount = current_currency.compute(line.amount, company_currency)
+            amount = current_currency.with_context(date=depreciation_date).compute(line.amount, company_currency)
-        pos_sessions = request.env['pos.session'].search([('state', '=', 'opened'), ('user_id', '=', request.session.uid)])
+        pos_sessions = request.env['pos.session'].search([
-            pos_config.current_session_state = session.state
+            session = pos_config.session_ids.filtered(lambda r: r.user_id.id == self.env.uid and \
-            pos_config.pos_session_username = pos_config.session_ids.filtered(lambda s: s.state == 'opened').user_id.name
+            session = pos_config.session_ids.filtered(lambda s: s.state == 'opened' and '(RESCUE FOR' not in s.name)
-
+        rescue_session = PosSession.search([
-        if self.search_count([('state', 'not in', ('closed', 'closing_control')), ('user_id', '=', self.user_id.id)]) > 1:
+        if self.search_count([
-        if self.search_count([('state', '!=', 'closed'), ('config_id', '=', self.config_id.id)]) > 1:
+        if self.search_count([
-from odoo.tools import float_compare, test_reports
+from odoo import fields, tools, report as odoo_report
-        current_datetime = day_dt
+
-        current_datetime = day_dt.replace(hour=0, minute=0, second=0, microsecond=0)
+
-        return res and res[0][0] or False
+        if res and hours < 0.0:
-        error, error_message = super(website_account, self).details_form_validate(data)
+        error, error_message = super(PortalAccount, self).details_form_validate(data)
-        return res and res[0][0] or False
+        if res and hours < 0.0:
-        today = fields.Datetime.from_string(fields.Date.context_today(self))
+        user_tz = pytz.timezone(self.env.context.get('tz') or self.env.user.tz or 'UTC')
-        'mail.template', "Use template",
+        'mail.template', "Automated Email",
-            error = self.get_preprocessor_error(''.join(result), source=source)
+            cmd_output = ''.join(result)
-        return super(sale_report, self)._select() + ", SUM(l.margin) AS margin"
+        return super(sale_report, self)._select() + ", SUM(l.margin / COALESCE(cr.rate, 1.0)) as margin"
-    @api.constrains('user_id')
+    @api.constrains('user_id')
-            'auth_oauth_facebook_client_id': rf[0]['client_id'],
+            'auth_oauth_google_enabled': rg[0]['enabled'] if rg else False,
-                    qty += inv_line.uom_id._compute_qty_obj(inv_line.uom_id, inv_line.quantity, line.product_uom)
+                    if inv_line.invoice_id.type == 'in_invoice':
-    @api.depends('expense_line_ids', 'expense_line_ids.total_amount')
+    @api.depends('expense_line_ids', 'expense_line_ids.total_amount', 'expense_line_ids.currency_id')
-        self.total_amount = sum(self.expense_line_ids.mapped('total_amount'))
+        if len(self.expense_line_ids.mapped('currency_id')) < 2:
-from openerp import SUPERUSER_ID, tools
+from openerp import SUPERUSER_ID, tools, api
-        'website_sale',
+        'website_portal_sale',
-from odoo.addons.website_portal.controllers.main import website_account
+from odoo.addons.website_portal_sale.controllers.main import website_account
-            for name in upd_todo:
+            for name in sorted(upd_todo, key=lambda name: self._fields[name]._sequence):
-
+from collections import OrderedDict
-        }
+        self.products = OrderedDict([
-from odoo.tools import pycompat
+from odoo.tools import pycompat, OrderedSet
-        self.path_args = set(path_args or [])
+        self.path_args = OrderedSet(path_args or [])
-        paths, fragments = [], []
+        path_args = OrderedSet(path_args or []) | self.path_args
-                    paths.append((key, slug(value)))
+                    paths[key] = slug(value)
-                    paths.append((key, value))
+                    paths[key] = u"%s" % value
-            path += '/' + key + '/%s' % value
+        for key in path_args:
-    sequence = fields.Integer(help='Used to order Companies in the company switcher', default=10)
+import itertools
-
+_global_seq = iter(itertools.count())
-                '_fields': {},                          # populated in _setup_base()
+                '_fields': OrderedDict(),               # populated in _setup_base()
-            for name in set(cls._fields) - cls0._proper_fields:
+            for name in OrderedSet(cls._fields) - cls0._proper_fields:
-            cls._proper_fields = set(cls._fields)
+            cls._proper_fields = OrderedSet(cls._fields)
-            for name, field in getmembers(cls, Field.__instancecheck__):
+            cls._fields = OrderedDict()
-            cls._proper_fields = set(cls._fields)
+            cls._proper_fields = OrderedSet(cls._fields)
-        assert dump == expected, "%s != %s" % (dump, expected)
+        assert modifiers == expected, "%s != %s" % (modifiers, expected)
-        assert dump == expected, "%s != %s" % (dump, expected)
+        assert modifiers == expected, "%s != %s" % (modifiers, expected)
-    test_modifiers("""<field name="a" attrs="{'invisible': [('b', '=', 'c')]}"/>""", '{"invisible": [["b", "=", "c"]]}')
+    test_modifiers('<field name="a"/>', {})
-    test_modifiers({"invisible": False}, '{}')
+    test_modifiers({}, {})
-    '<div style="color: #000000; font-size: 12pt; font-family: \'Times New Roman\'">',
+    '<div style="font-size: 12pt; font-family: \'Times New Roman\'; color: #000000">',
-                  'data-oe-expression="company.name">%s</span>' % (
+            etree.fromstring(result),
-            ),
+                u"My Test Company",
-                  'data-oe-expression="company.name">%s</span>' % (
+            etree.fromstring(result),
-            ),
+            )),
-        expected_result = """
+        expected_result = u"""
-            'arch': """
+            'arch': u"""
-        self.assertEquals(dedent_and_strip(view1.render()), dedent_and_strip(expected_result))
+        self.assertEqual(etree.fromstring(view1.render()), etree.fromstring(expected_result))
-        expected_result = """
+        expected_result = u"""
-            'arch': """
+            'arch': u"""
-        self.assertEquals(dedent_and_strip(view1.render()), dedent_and_strip(expected_result))
+        self.assertEqual(etree.fromstring(view1.render()), etree.fromstring(expected_result))
-            'arch': """
+            'arch': u"""
-        expected_result = """
+        expected_result = etree.fromstring(u"""
-        """
+        """)
-        self.assertEquals(dedent_and_strip(view1.render()), dedent_and_strip(expected_result))
+        self.assertEqual(etree.fromstring(view1.render()), expected_result)
-        expected_result = """
+        expected_result = u"""
-            'arch': """
+            'arch': u"""
-        self.assertEquals(dedent_and_strip(view1.render()), dedent_and_strip(expected_result))
+        self.assertEqual(etree.fromstring(view1.render()), etree.fromstring(expected_result))
-            'arch': """
+            'arch': u"""
-        expected_result = """<Invoice xmlns:cac="urn:oasis:names:specification:ubl:schema:xsd:CommonAggregateComponents-2">test</Invoice>"""
+        expected_result = etree.fromstring(u"""<Invoice xmlns:cac="urn:oasis:names:specification:ubl:schema:xsd:CommonAggregateComponents-2">test</Invoice>""")
-        self.assertEquals(dedent_and_strip(view1.render()), dedent_and_strip(expected_result))
+        self.assertEqual(etree.fromstring(view1.render()), expected_result)
-            'arch': """
+            'arch': u"""
-        expected_result = """
+        expected_result = etree.fromstring(u"""
-        """
+        """)
-        self.assertEquals(dedent_and_strip(view1.render()), dedent_and_strip(expected_result))
+        self.assertEqual(etree.fromstring(view1.render()), expected_result)
-            'arch': """
+            'arch': u"""
-        expected_result = """
+        expected_result = etree.fromstring(u"""
-        """
+        """)
-        self.assertEquals(dedent_and_strip(view1.render()), dedent_and_strip(expected_result))
+        self.assertEqual(etree.fromstring(view1.render()), expected_result)
-            'arch': """
+            'arch': u"""
-        expected_result = """
+        expected_result = etree.fromstring(u"""
-        """
+        """)
-        self.assertEquals(dedent_and_strip(view1.render()), dedent_and_strip(expected_result))
+        self.assertEqual(etree.fromstring(view1.render()), expected_result)
-            'arch': """
+            'arch': u"""
-        expected_result = """
+        expected_result = etree.fromstring(u"""
-        """
+        """)
-        self.assertEquals(dedent_and_strip(view1.render(dict(version_id=1.0))), dedent_and_strip(expected_result))
+        self.assertEqual(etree.fromstring(view1.render({'version_id': 1.0})), expected_result)
-            'arch': """
+            'arch': u"""
-        expected_result = """<cfdi:Comprobante xmlns:cfdi="http://www.sat.gob.mx/cfd/3" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.sat.gob.mx/cfd/3 http://www.sat.gob.mx/sitio_internet/cfd/3/cfdv32.xsd">abc</cfdi:Comprobante>"""
+        expected_result = etree.fromstring(u"""<cfdi:Comprobante xmlns:cfdi="http://www.sat.gob.mx/cfd/3" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.sat.gob.mx/cfd/3 http://www.sat.gob.mx/sitio_internet/cfd/3/cfdv32.xsd">abc</cfdi:Comprobante>""")
-        self.assertEquals(dedent_and_strip(view1.render()), dedent_and_strip(expected_result))
+        self.assertEqual(etree.fromstring(view1.render()), expected_result)
-            'arch': """
+            'arch': u"""
-        expected_result = """<cfdi:Comprobante xmlns:cfdi="http://www.sat.gob.mx/cfd/3" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.sat.gob.mx/cfd/3 http://www.sat.gob.mx/sitio_internet/cfd/3/cfdv32.xsd">abc</cfdi:Comprobante>"""
+        expected_result = etree.fromstring("""<cfdi:Comprobante xmlns:cfdi="http://www.sat.gob.mx/cfd/3" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.sat.gob.mx/cfd/3 http://www.sat.gob.mx/sitio_internet/cfd/3/cfdv32.xsd">abc</cfdi:Comprobante>""")
-        self.assertEquals(dedent_and_strip(view1.render()), dedent_and_strip(expected_result))
+        self.assertEqual(etree.fromstring(view1.render()), expected_result)
-            'arch': """
+            'arch': u"""
-                            "VALUES ('dummy', 'ir.ui.view', %s, 'base')" % view1.id)
+                            "VALUES ('dummy', 'ir.ui.view', %s, 'base')", [view1.id])
-            'arch': """
+            'arch': u"""
-            'cbc': 'urn:oasis:names:specification:ubl:schema:xsd:CommonBasicComponents-2'
+            (None, 'urn:oasis:names:specification:ubl:schema:xsd:Invoice-2'),
-        self.assertSetEqual(set(pycompat.items(expected_ns)) - set(pycompat.items(result_etree.nsmap)), set())
+        self.assertEqual(set(pycompat.items(result_etree.nsmap)), expected_ns)
-        self.assertEquals(result.count('Appel'), 2)
+        self.assertEqual(len(cac_lines), 2)
-        self.assertEquals(result.count('xmlns:cbc="urn:oasis:names:specification:ubl:schema:xsd:CommonBasicComponents-2"'), 1)
+        self.assertEqual(result.count(b'xmlns:cbc="urn:oasis:names:specification:ubl:schema:xsd:CommonBasicComponents-2"'), 1)
-            'arch': """
+            'arch': u"""
-            'arch': """
+            'arch': u"""
-        expected_result = """
+        expected_result = etree.fromstring(u"""
-        """
+        """)
-        self.assertEquals(dedent_and_strip(view1.with_context(check_view_ids=[view1.id, view2.id]).render()), dedent_and_strip(expected_result))
+        self.assertEqual(
-
+from lxml import etree
-class BaseCase(unittest.TestCase):
+class TreeCase(unittest.TestCase):
-            valid_styles = {}
+            valid_styles = collections.OrderedDict()
-            self.search([('leave_timesheet_project_id', '=', False)])._create_leave_project_task()
+    def init(self):
-    CP_kw = dict()
+    
-        p = ConfigParser.ConfigParser(**CP_kw)
+        p = ConfigParser.RawConfigParser()
-        p = ConfigParser.ConfigParser(**CP_kw)
+        p = ConfigParser.RawConfigParser()
-        p = ConfigParser.ConfigParser(**CP_kw)
+        p = ConfigParser.RawConfigParser()
-        p = ConfigParser.ConfigParser(**CP_kw)
+        p = ConfigParser.RawConfigParser()
-                pos_qty = any([x.qty > 0 for x in order.lines])
+                pos_qty = any([x.qty > 0 for x in order.lines if x.product_id.type in ['product', 'consu']])
-                neg_qty = any([x.qty < 0 for x in order.lines])
+                neg_qty = any([x.qty < 0 for x in order.lines if x.product_id.type in ['product', 'consu']])
-        self.assertFalse(self.lead.user_id, 'Accepting lead does not change the salesman.')
+        self.assertEqual(self.lead.team_id, team_before, 'Accepting lead does not change the sales team.')
-            for invoice_line in invoice.invoice_line_ids.filtered(lambda line: line.product_id.type == 'service'):
+            for invoice_line in invoice.invoice_line_ids.filtered(lambda line: line.product_id.type == 'service').sorted(key=lambda inv_line: (inv_line.invoice_id, inv_line.id)):
-                        for index, timesheet_line in enumerate(uninvoiced_timesheet_lines):
+                        for index, timesheet_line in enumerate(uninvoiced_timesheet_lines.sorted(key=lambda ts: ts.date)):
-                        for index, timesheet_line in enumerate(no_zero_timesheet_revenue):
+                        for index, timesheet_line in enumerate(no_zero_timesheet_revenue.sorted(key=lambda ts: ts.date)):
-                        invoiced_price_per_hour = float_round(invoice_line.price_subtotal / float(sum(uninvoiced_timesheet_lines.mapped('unit_amount'))), precision)
+                        invoiced_price_per_hour = invoice_line.currency_id.round(invoice_line.price_subtotal / float(sum(uninvoiced_timesheet_lines.mapped('unit_amount'))))
-        if self.allday and self.rrule and 'Z' not in self.rrule:
+        if self.allday and self.rrule and 'UNTIL' in self.rrule and 'Z' not in self.rrule:
-                lead._onchange_user_id()
+            # Ensure no duplicate is created
-                PriceRule.create(line_data)
+                line_data = {
-        recs = self.search(['|', ('code', operator, name), ('name', operator, name)] + args, limit=limit)
+        connector = '|'
-        domain_name = request.httprequest.environ.get('HTTP_HOST', '').split(':')[0]
+        domain_name = request and request.httprequest.environ.get('HTTP_HOST', '').split(':')[0] or None
-        request.context = dict(request.context, website_id=website_id)
+        if request:
-        if not request.website:
+        website = request and request.website or None
-        isocountry = request.session.geoip and request.session.geoip.get('country_code') or False
+        isocountry = request and request.session.geoip and request.session.geoip.get('country_code') or False
-                                                   request.session.get('website_sale_current_pl'),
+                                                   request and request.session.get('website_sale_current_pl') or None,
-        if request.session.get('website_sale_current_pl'):
+        if request and request.session.get('website_sale_current_pl'):
-        if self.allday and self.rrule and 'Z' not in self.rrule:
+        if self.allday and self.rrule and 'UNTIL' in self.rrule and 'Z' not in self.rrule:
-                        errors[mod_name] = exception_to_unicode(e)
+                import openerp.modules as addons
-                        errors[mod_name] = tools.ustr(e)
+                import openerp.modules as addons
-                               until=(end_dt + timedelta(days=1)).replace(hour=0, minute=0, second=0, microsecond=0),
+                               until=end_dt.replace(hour=23, minute=59, second=59, microsecond=999999),
-                res.append((leave.id, _("%s on %s : %.2f day(s)") % (leave.employee_id.name or leave.category_id.name, leave.holiday_status_id.name, leave.number_of_days_temp)))
+                if self.env.context.get('short_name'):
-                res.append((leave.id, _("Allocation of %s : %.2f day(s) To %s") % (leave.holiday_status_id.name, leave.number_of_days_temp,leave.employee_id.name)))
+                res.append((leave.id, _("Allocation of %s : %.2f day(s) To %s") % (leave.holiday_status_id.name, leave.number_of_days_temp, leave.employee_id.name)))
-                any(order.move_finished_ids.filtered(lambda x: (x.quantity_done) > 0 and (x.state not in ['done', 'cancel'])))
+            if order.product_tmpl_id._is_cost_method_standard():
-                moves.post()
+                moves.filtered(lambda m: m.state != 'posted').post()
-        rset1 = rrule.rrulestr(str(self.rrule), dtstart=event_date, forceset=True)
+        if self.allday and self.rrule and 'Z' not in self.rrule:
-        return [d.astimezone(pytz.UTC) for d in rset1]
+        return [d.astimezone(pytz.UTC) if d.tzinfo else d for d in rset1]
-
+import unittest
-        p = ConfigParser.ConfigParser()
+        p = ConfigParser.ConfigParser(**CP_kw)
-        p = ConfigParser.ConfigParser()
+        p = ConfigParser.ConfigParser(**CP_kw)
-    def import_module(self, module, path, force=False):
+    def _import_module(self, module, path, force=False):
-                        self.import_module(mod_name, path, force=force)
+                        self._import_module(mod_name, path, force=force)
-            error = "Database creation error: %s" % e
+            error = "Database creation error: %s" % str(e) or repr(e)
-            error = "Database duplication error: %s" % e
+            error = "Database duplication error: %s" % str(e) or repr(e)
-            error = "Database deletion error: %s" % e
+            error = "Database deletion error: %s" % str(e) or repr(e)
-            error = "Database backup error: %s" % e
+            error = "Database backup error: %s" % str(e) or repr(e)
-            error = "Database restore error: %s" % e
+            error = "Database restore error: %s" % str(e) or repr(e)
-            error = "Master password update error: %s" % e
+            error = "Master password update error: %s" % str(e) or repr(e)
-    _order = "applied_on, min_quantity desc, categ_id desc"
+    _order = "applied_on, min_quantity desc, categ_id desc, id"
-                        msg = self._construct_constraint_msg(country_code.lower())
+                        msg = partner._construct_constraint_msg(country_code.lower())
-    def payment_transaction_token(self, acquirer_id, order_id, token):
+    def payment_transaction_token(self, acquirer_id, order_id, access_token=None, tx_type=None):
-        if not Order or not Order.order_line or acquirer_id is None:
+        order = request.env['sale.order'].sudo().browse(order_id)
-            })
+        acquirer = request.env['payment.acquirer'].browse(int(acquirer_id))
-        return dict(success=False, error='Tx missmatch')
+        if not tx or not request.website.sale_get_transaction() or tx != request.website.sale_get_transaction():
-            request.session['sale_transaction_id'] = tx.id
+        # find or create transaction
-        )
+        return tx.render_sale_button(order, '/shop/payment/validate')
-from odoo import api, fields, models
+
-            tx._confirm_so(acquirer_name=acquirer_name)
+            tx._confirm_so()
-    def _confirm_so(self, acquirer_name=False):
+    def _confirm_so(self):
-                        _logger.warning('<%s> transaction MISMATCH for order %s (ID %s)', acquirer_name, tx.sale_order_id.name, tx.sale_order_id.id)
+                if tx.state == 'authorized' and tx.acquirer_id.capture_manually:
-        tx.sale_order_id._force_lines_to_invoice_policy_order()
+    def _generate_and_pay_invoice(self):
-        created_invoice = tx.sale_order_id.with_context(**ctx_company).action_invoice_create()
+        ctx_company = {'company_id': self.sale_order_id.company_id.id,
-                         acquirer_name, created_invoice.name, created_invoice.id, tx.sale_order_id.name, tx.sale_order_id.id)
+                         self.acquirer_id.provider, created_invoice.name, created_invoice.id, self.sale_order_id.name, self.sale_order_id.id)
-            if not tx.acquirer_id.journal_id:
+            if not self.acquirer_id.journal_id:
-                created_invoice.pay_and_reconcile(tx.acquirer_id.journal_id, pay_amount=created_invoice.amount_total)
+                                    self.acquirer_id.provider, self.sale_order_id.name, self.sale_order_id.id)
-                    created_invoice.payment_ids[0].payment_transaction_id = tx
+                    created_invoice.payment_ids[0].payment_transaction_id = self
-                            acquirer_name, tx.sale_order_id.name, tx.sale_order_id.id)
+                            self.acquirer_id.provider, self.sale_order_id.name, self.sale_order_id.id)
-            order = request.env['sale.order'].sudo().search([('id', '=', so_id), ('access_token', '=', so_token)])
+        access_token = kwargs.get('access_token')
-        writeoff_move = self.env['account.move'].create({
+        writeoff_move = self.env['account.move'].with_context(apply_taxes=True).create({
-                    sum(l.price_unit * l.quantity)/sum(nullif(l.quantity,0)) as avg_unit_price,
+                    sum(l.price_unit * l.quantity)/nullif(sum(l.quantity),0) as avg_unit_price,
-                            tx.sale_order_id.with_context(send_email=True).action_confirm()
+            # check tx state, confirm the potential SO
-                _logger.exception('Fail to confirm the order or send the confirmation email%s', tx and ' for the transaction %s' % tx.reference or '')
+                        if tx.acquirer_id.auto_confirm == 'generate_and_pay_invoice':
-    name = os.path.normpath(os.path.join(basedir, path))
+    name = os.path.normpath(os.path.normcase(os.path.join(basedir, path)))
-    name = os.path.normpath(os.path.join(basedir, path))
+    name = os.path.normpath(os.path.normcase(os.path.join(basedir, path)))
-    name = os.path.normpath(os.path.join(basedir, path))
+    name = os.path.normpath(os.path.normcase(os.path.join(basedir, path)))
-    name = os.path.normpath(os.path.join(basedir, path))
+    name = os.path.normpath(os.path.normcase(os.path.join(basedir, path)))
-    name = os.path.normpath(os.path.join(basedir, path))
+    name = os.path.normpath(os.path.normcase(os.path.join(basedir, path)))
-                            acquirer_name, tx.sale_order_id.name, tx.sale_order_id.id)
+    # --------------------------------------------------
-    payment_tx_id = fields.Many2one('payment.transaction', string='Last Transaction', copy=False)
+# -*- coding: utf-8 -*-
-    'summary': 'Add your sales document in the frontend portal (sales order, quotations, invoices)',
+    'summary': 'Add your sales document in the frontend portal (sales order, quotations)',
-Add your sales document in the frontend portal. Your customers will be able to connect to their portal to see the list (and the state) of their invoices (pdf report), sales orders and quotations (web pages).
+Add your sales document in the frontend portal. Your customers will be able to connect to their portal to see the list (and the state) of their sales orders and quotations (web pages).
-        'views/website_portal_sale_templates.xml',
+        'views/website_portal_sale_templates.xml',
-    'depends': ['website', 'sale', 'payment', 'website_payment', 'website_portal_sale', 'website_mail', 'website_form', 'rating'],
+    'depends': ['website', 'sale', 'payment', 'website_payment', 'website_portal_sale', 'website_account', 'website_mail', 'website_form', 'rating'],
-            color = '#ababab' if start_date.strftime('%a') == 'Sat' or start_date.strftime('%a') == 'Sun' else ''
+            color = '#ababab' if self._date_is_day_off(start_date) else ''
-            if current.strftime('%a') == 'Sat' or current.strftime('%a') == 'Sun':
+            if self._date_is_day_off(current) :
-            attributes = ProductAttribute.search([('attribute_line_ids.product_tmpl_id', 'in', products.ids)])
+            # get all products without limit
-            order.can_directly_mark_as_paid = order.state in ['sent', 'sale'] and order.payment_tx_id.state != 'done' and order.payment_acquirer_id.provider in ['transfer', 'manual']
+            order.can_directly_mark_as_paid = order.state in ['sent', 'sale'] and order.payment_tx_id and order.payment_acquirer_id.provider in ['transfer', 'manual']
-    payment_token_id = fields.Many2one('payment.token', string="Saved payment token", domain=[('acquirer_id.auto_confirm', '!=', 'authorize')],
+    payment_token_id = fields.Many2one('payment.token', string="Saved payment token", domain=[('acquirer_id.capture_manually', '=', False)],
-            res['domain'] = {'payment_token_id': [('partner_id', 'in', partners.ids), ('acquirer_id.auto_confirm', '!=', 'authorize')]}
+            res['domain'] = {'payment_token_id': [('partner_id', 'in', partners.ids), ('acquirer_id.capture_manually', '=', False)]}
-            self.payment_token_id = self.env['payment.token'].search([('partner_id', '=', self.partner_id.id), ('acquirer_id.auto_confirm', '!=', 'authorize')], limit=1)
+            self.payment_token_id = self.env['payment.token'].search([('partner_id', '=', self.partner_id.id), ('acquirer_id.capture_manually', '=', False)], limit=1)
-        if self.payment_token_id.acquirer_id.auto_confirm == 'authorize':
+        if self.payment_token_id.acquirer_id.capture_manually:
-        string='Order Confirmation', default='confirm_so', required=True)
+    # Formerly associated to `authorize` option from auto_confirm
-        help="Account journal used for automatic payment reconciliation.")
+        'account.journal', 'Payment Journal', domain=[('type', '=', 'bank')],
-
+    authorize_implemented = fields.Boolean('Authorize Mechanism Supported', compute='_compute_feature_support')
-    @api.multi
+            acquirer.authorize_implemented = acquirer.provider in feature_support['authorize']
-            'x_type': 'AUTH_CAPTURE' if self.auto_confirm != 'authorize' else 'AUTH_ONLY',
+            'x_type': 'AUTH_CAPTURE' if not self.capture_manually else 'AUTH_ONLY',
-        if self.acquirer_id.auto_confirm != "authorize":
+        if not self.acquirer_id.capture_manually:
-        self.authorize.auto_confirm = 'confirm_so'
+        # self.authorize.auto_confirm = 'confirm_so'
-        self.authorize.auto_confirm = 'authorize'
+        self.authorize.capture_manually = True
-        self.authorize.auto_confirm = 'authorize'
+        self.authorize.capture_manually = True
-            if tx.acquirer_id.journal_id:
+            if not tx.acquirer_id.journal_id:
-                        if tx.state == 'authorized' and tx.acquirer_id.auto_confirm == 'authorize':
+                        if tx.state == 'authorized' and tx.acquirer_id.capture_manually:
-                        if tx.state == 'done' and tx.acquirer_id.auto_confirm in ['confirm_so', 'generate_and_pay_invoice']:
+                        if tx.state == 'done':
-                                self._generate_and_pay_invoice(tx, acquirer_name)
+                            self._generate_and_pay_invoice(tx, acquirer_name)
-from odoo import api, exceptions, fields, models
+from odoo import api, exceptions, fields, models, _
-                valid_state = 'authorized' if tx.acquirer_id.auto_confirm == 'authorize' else 'done'
+                valid_state = 'authorized' if tx.acquirer_id.capture_manually else 'done'
-        ('delivery', 'Invoice what is delivered (manual)')
+        ('order', 'Invoice what is ordered'),
-from odoo import api, models, fields, tools, _
+from odoo import api, models, fields, _
-from odoo import api, models
+import logging
-        patcher = patch('odoo.addons.website_sale.models.sale_order.Website.get_pricelist_available', wraps=self._get_pricelist_available)
+        patcher = patch('odoo.addons.website_sale.models.website.Website.get_pricelist_available', wraps=self._get_pricelist_available)
-        ('delivery', 'Delivered quantities or service hours')
+        ('order', 'Invoice what is ordered (automatic)'),
-You could use this simplified accounting in case you work with an (external) account to keep your books, and you still want to keep track of payments. This module also offers you an easy method of registering payments, without having to encode complete abstracts of account.
+Core mechanisms for the accounting modules. To display the menuitems, install the module account_invoicing.
-    'application': True,
+    'application': False,
-    'depends': ['account', 'web_tour'],
+    'depends': ['account_invoicing', 'web_tour'],
-    'depends': ['sale'],
+    'depends': ['sale', 'account_invoicing'],
-                total_cost += (order.time_cycle_manual/60) * order.workcenter_id.costs_hour
+                total_cost += (order.time_cycle/60) * order.workcenter_id.costs_hour
-            price += bom.product_uom_id._compute_price(workcenter_cost, bom.product_id.uom_id)
+            price += bom.product_uom_id._compute_price(total_cost, bom.product_id.uom_id)
-        values = self._prepare_forum_values(forum=forum, searches=post)
+        values = self._prepare_forum_values(forum=forum, searches=post, header={'ask_hide': not forum.active})
-                elif 'kwargs' in kwargs:
+                elif 'kwargs' in kwargs and kwargs['kwargs'].get('context'):
-
+                else:
-        order_invoice_lines = {il.product_id.id: il.invoice_id for il in order.invoice_ids.mapped('invoice_line_ids')}
+        order_sudo = order.sudo()
-            'order': order.sudo(),
+            'order': order_sudo,
-        order_invoice_lines = {il.product_id.id: il.invoice_id for il in order.invoice_ids.mapped('invoice_line_ids')}
+
-            'order': order.sudo(),
+            'order': order_sudo,
-            result['recurrence'] = True
+            result['recurrency'] = True
-            error_key = json.loads(error.read()).get("error", "nc")
+            try:
-            self.message_subscribe(vals['partner_id'])
+            self.message_subscribe([vals['partner_id']])
-                elif not (field.store or field.column and field.column._fnct_inv):
+                elif not (field.store or field.column and field.column._fnct_inv or field.inherited):
-    message_bounce = fields.Integer('Bounce', help="Counter of the number of bounced emails for this contact")
+    message_bounce = fields.Integer('Bounce', help="Counter of the number of bounced emails for this contact", default=0)
-    message_bounce = fields.Integer('Bounce', help="Counter of the number of bounced emails for this contact")
+    message_bounce = fields.Integer('Bounce', help="Counter of the number of bounced emails for this contact", default=0)
-    message_bounce = fields.Integer(string='Bounced', help='Counter of the number of bounced emails for this contact.')
+    message_bounce = fields.Integer(string='Bounced', help='Counter of the number of bounced emails for this contact.', default=0)
-                        ''', (partner_info[2], tuple(self.ACCOUNT_TYPE),))
+                            ''' + date_partial
-import models
+from . import models
-import payment
+from . import payment
-        return super(AccountInvoice, self).copy(default)
+# -*- coding: utf-8 -*-
-            vals['name'] = self.env['ir.sequence'].next_by_code('sale.order') or _('New')
+            if 'company_id' in vals:
-    for k, v in pycompat.items(el):
+    for k, v in el.items():
-        self.assertTrue(sol.price_unit == 160 and sol.qty_delivered == 2 and sol.product_uom_qty == sol.qty_invoiced == 0, 'Sale: line is wrong after confirming vendor invoice')
+        self.assertEquals((sol.price_unit, sol.qty_delivered, sol.product_uom_qty, sol.qty_invoiced), (160, 2, 0, 0), 'Sale: line is wrong after confirming vendor invoice')
-            country = request.env['res.country'].browse(int(data.get('country_id')))
+            country = country.browse(int(data.get('country_id')))
-                error["vat"] = 'error'
+                if country.code and check_func(country.code, data["vat"]):
-        currency = self.currency_id or self.company_id.currency_id
+    @api.model
-              "%(street)s\n%(street2)s\n%(city)s %(state_code)s %(zip)s\n%(country_name)s"
+            self._get_default_address_format()
-    code = fields.Char(string='E-commerce Promotional Code')
+    code = fields.Char(string='E-commerce Promotional Code', groups="base.group_user")
-            pricelists |= all_pl.filtered(lambda pl: not show_visible and pl.code)
+            pricelists |= all_pl.filtered(lambda pl: not show_visible and pl.sudo().code)
-                code_pricelist = self.env['product.pricelist'].search([('code', '=', code)], limit=1)
+                code_pricelist = self.env['product.pricelist'].sudo().search([('code', '=', code)], limit=1)
-        if request.website.is_pricelist_available(pl_id.id):
+        if (pl_id.selectable or pl_id == request.env.user.partner_id.property_product_pricelist) \
-        return pl_id in self.get_pricelist_available(show_visible=True).ids
+        return pl_id in self.get_pricelist_available(show_visible=False).ids
-                record.action_validate()
+                record.action_approve()
-    leaves_count = fields.Integer('Number of Leaves', compute='_compute_leaves_count')
+    leaves_count = fields.Float('Number of Leaves', compute='_compute_leaves_count')
-        sum2  = ean[0] + ean[2] + ean[4] + ean[6]
+        sum1  = int(ean[1]) + int(ean[3]) + int(ean[5])
-import urllib
+import urllib2
-    url += urllib.quote(addr.encode('utf8'))
+    url += urllib2.quote(addr.encode('utf8'))
-        result = json.load(urllib.urlopen(url))
+        result = json.load(urllib2.urlopen(url))
-        self.mock_get_pricelist_available = self.patcher.start()
+        import odoo.addons.website_sale.models.sale_order
-        super(TestWebsitePriceList, self).tearDown()
+        if not self:
-                res[val.id]['total_margin'] = res[val.id]['turnover'] - res[val.id]['total_cost']
+            res[val.id]['total_margin'] = res[val.id]['turnover'] - res[val.id]['total_cost']
-        'Name', required=True,
+        'Name', required=True, translate=True,
-        self.alias_prefix = 'info' if self.default_generate_lead_from_alias else False
+        if self.default_generate_lead_from_alias:
-        })
+        self.invoice = self.AccountInvoice.with_context(
-        default.setdefault('code', _("%s (copy)") % (account['code'] or ''))
+        default.setdefault('code', _("%s (copy)") % (account['code'] or ''))
-        '''
+        """
-        '''
+        """
-            source_location_id = production.bom_id.routing_id.location_id.id
+        if production.routing_id:
-            }))
+            order_line_values = line._prepare_purchase_order_line(
-                    env = api.Environment(cr, SUPERUSER_ID, {})
+                    env = api.Environment(cr, SUPERUSER_ID, _context)
-            'Meetings'),
+            'Meetings', copy=False),
-        ('name_uniq', 'UNIQUE(name)', 'The payment line name must be unique!'),
+        ('name_uniq', 'UNIQUE(name, company_id)', 'The payment line name must be unique per company!'),
-            message = (tx.state == 'done' and 'Your payment was successful! It may take some time to be validated on our end.') or 'OOps! There was a problem with your payment.'
+            message = (tx.state == 'done' and _('Your payment was successful! It may take some time to be validated on our end.')) or _('Oops! There was a problem with your payment.')
-                'account_id', 'currency_id', 'payment_term_id', 'user_id', 'fiscal_position_id']:
+        for field in self._get_refund_copy_fields():
-                                    'journal_id', 'date'])
+                        invoice = inv.read(inv_obj._get_refund_modify_read_fields())
-                                         'payment_term_id', 'journal_id', 'team_id'):
+                        for field in inv_obj._get_refund_common_fields():
-    def _lead_create_contact(self, name, is_company, parent_id=False):
+    def _create_lead_partner_data(self, name, is_company, parent_id=False):
-        values = {
+        return {
-        return self.env['res.partner'].create(values)
+        Partner = self.env['res.partner']
-            contact_name = self.env['res.partner']._parse_partner_name(self.email_from)[0] if self.email_from else False
+            contact_name = Partner._parse_partner_name(self.email_from)[0] if self.email_from else False
-            partner_company = self._lead_create_contact(self.partner_name, True)
+            partner_company = Partner.create(self._create_lead_partner_data(self.partner_name, True))
-            return self._lead_create_contact(contact_name, False, partner_company.id if partner_company else False)
+            return Partner.create(self._create_lead_partner_data(contact_name, False, partner_company.id if partner_company else False))
-        return self._lead_create_contact(self.name, False)
+        return Partner.create(self._create_lead_partner_data(self.name, False))
-        return {}
+            domain = {'partner_bank_id': [('id', 'in', bank_ids.ids)]}
-                raise UserError('Not a portal: ' + group_portal.name)
+                raise UserError(_('Group %s is not a portal') % group_portal.name)
-            raise UserError('Invalid domain left operand')
+            raise UserError(_('Invalid domain left operand %s') % field)
-            raise UserError('Invalid domain operator')
+            raise UserError(_('Invalid domain operator %s') % operator)
-            raise UserError('Invalid domain right operand')
+            raise UserError(_('Invalid domain right operand %s') % value)
-            if not workitem.res_id or not record:
+            if not workitem.res_id or not record.exists():
-            raise UserError("No POS session")
+            raise UserError(_("No opened point of sale session for user %s found") % self.env.user.name)
-            raise UserError("No Mercury configuration associated with the journal.")
+            raise UserError(_("No Mercury configuration associated with the journal."))
-    smtp_pass = fields.Char(string='Password', size=64, help="Optional password for SMTP authentication")
+    smtp_user = fields.Char(string='Username', help="Optional username for SMTP authentication")
-                taxes_ids = fpos.map_tax(line.product_id.supplier_taxes_id.filtered(lambda tax: tax.company_id == requisition.company_id))
+                taxes_ids = fpos.map_tax(line.product_id.supplier_taxes_id.filtered(lambda tax: tax.company_id == requisition.company_id)).ids
-                attachment = self.env['ir.actions.report'].retrieve_attachment(invoice.id)
+                    attachment = self.env.ref('account.account_invoices').retrieve_attachment(invoice)
-    @api.model
+    @api.multi
-            if accounts['stock_input']:
+            if product.categ_id.property_valuation != 'manual_periodic' and accounts['stock_input']:
-        return ", ".join([v.name for v in self.sorted(key=lambda r: r.name) if v.attribute_id in variable_attributes])
+        return ", ".join([v.name for v in self.sorted(key=lambda r: r.attribute_id.name) if v.attribute_id in variable_attributes])
-                'account_id', 'currency_id', 'payment_term_id', 'user_id', 'fiscal_position_id']:
+        for field in self._get_refund_copy_fields():
-                                    'journal_id', 'date'])
+                        invoice = inv.read(inv_obj._get_refund_modify_read_fields())
-                                invoice[field] = invoice[field] and invoice[field][0]
+                        for field in inv_obj._get_refund_common_fields():
-        return pl_id in self.get_pricelist_available(show_visible=False).ids
+        return pl_id in self.get_pricelist_available(show_visible=True).ids
-                    raise ValidationError('You cannot have 2 timesheets that overlap!\nPlease use the menu \'My Current Timesheet\' to avoid this problem.')
+                    raise ValidationError(_('You cannot have 2 timesheets that overlap!\nPlease use the menu \'My Current Timesheet\' to avoid this problem.'))
-            raise ValidationError('Authorize.net Error Message(s):\n %s' % '\n'.join(messages))
+            raise ValidationError(_('Authorize.net Error Message(s):\n %s') % '\n'.join(messages))
-            error_msg = 'Authorize: received data with missing reference (%s) or trans_id (%s) or fingerprint (%s)' % (reference, trans_id, fingerprint)
+            error_msg = _('Authorize: received data with missing reference (%s) or trans_id (%s) or fingerprint (%s)') % (reference, trans_id, fingerprint)
-                raise ValidationError('The Customer Profile creation in Authorize.NET failed.')
+                raise ValidationError(_('The Customer Profile creation in Authorize.NET failed.'))
-            raise ValidationError('The payment amount must be strictly positive.')
+            raise ValidationError(_('The payment amount must be strictly positive.'))
-                raise ValidationError('Invalid BBA Structured Communication !')
+                raise ValidationError(_('Invalid BBA Structured Communication !'))
-                raise ValidationError('Transaction Authorization is not supported by this payment provider.')
+                raise ValidationError(_('Transaction Authorization is not supported by this payment provider.'))
-            raise ValidationError('Only transactions in the Authorized status can be captured.')
+            raise ValidationError(_('Only transactions in the Authorized status can be captured.'))
-            raise ValidationError('Only transactions in the Authorized status can be voided.')
+            raise ValidationError(_('Only transactions in the Authorized status can be voided.'))
-                if inv.currency_id.id != company_currency:
+                if inv.currency_id != company_currency:
-                    partner[field] = ''
+                    partner[field] = None
-                if date_deadline < date.today():
+                if date_deadline < date.today() and not opp.date_closed:
-                order = self.env['sale.order'].search([('procurement_group_id', '=', picking.group_id.id)])
+                order = self.env['sale.order'].sudo().search([('procurement_group_id', '=', picking.group_id.id)])
-            payment.write({'payment_reference': move.name})
+            payment and payment.write({'payment_reference': move.name})
-        return {
+
-            raise ValidationError('The payment amount must be strictly positive.')
+            raise ValidationError(_('The payment amount must be strictly positive.'))
-                domain += (('group_id', '=', group.id),)
+            domain = procurement._make_po_get_domain(partner)
-                return None
+                return []
-                return None
+                return []
-        result['domain'] = [('partner_id', 'in', self.ids)]
+        result['domain'] = [('partner_id', 'child_of', self.ids)]
-                raise UserError(_("You can't define a parent task if its project is not correctly configured. The sub-task's project of the parent task's project should be this task's project"))
+    subtask_project_id = fields.Many2one('project.project', string='Sub-task Project', ondelete="restrict",
-        ('timesheet', 'Timesheets on project'),
+        ('timesheet', 'Timesheets on project (one fare per SO/Project)'),
-            credit_wo = amount_wo < 0 and -amount_wo or 0.0
+            # Align the sign of the secondary currency writeoff amount with the sign of the writeoff
-        source = """<i class="fa-check"></i>"""
+        source = """<p>A <i class="fa-check"></i> B</p>"""
-        self.assertEquals(result, """<i class="fa-check"/>""")
+        self.assertEquals(result, """<p>A <i class="fa-check"/> B</p>""")
-from lxml import etree
+from lxml import etree, html
-    """ Return the translation of the given XML/HTML node. """
+def translate_xml_node(node, callback, parse, serialize):
-        text = etree.tostring(node, method=method, encoding='utf8').decode('utf8')
+        text = serialize(node)
-                node = etree.fromstring(encode(text), parser=parser)
+                node = parse(text)
-        return etree.tostring(result, method='xml', encoding='utf8').decode('utf8')
+        root = parse_xml(value)
-        result = translate_xml_node(root[0][0], callback, 'xml')
+        root = parse_html("<div>%s</div>" % value)
-        return etree.tostring(result, method='xml', encoding='utf8').decode('utf8')[5:-6]
+        return serialize_xml(result)[5:-6]
-        result = translate_xml_node(root[0][0], callback, 'html', parser)
+        root = parse_html("<div>%s</div>" % value)
-        value = etree.tostring(result, method='html', encoding='utf8').decode('utf8')[5:-6]
+        value = serialize_html(result)[5:-6]
-            views = self.search(conditions + [('model_ids.module', 'in', tuple(self.pool._init_modules))])
+            modules = tuple(self.pool._init_modules) + (self._context.get('install_mode_data', {}).get('module'),)
-
+        tree_view_ref = self.env.ref('account.invoice_tree', False)
-            'views': [(False, 'tree'), (form_view_ref and form_view_ref.id, 'form')],
+            'views': [(tree_view_ref.id, 'tree'), (form_view_ref.id, 'form')],
-    post_date = fields.Datetime('Published date', compute='_compute_post_date', inverse='_set_post_date', store=True)
+    post_date = fields.Datetime('Publishing date', compute='_compute_post_date', inverse='_set_post_date', store=True,
-            'ITAX_160-OUT': account_obj.search([('code', '=', '208.01.01')])}
+            'ITAX_010-OUT': account_obj.search([('code', '=', '118.01.01')]),
-            res = set(int(v) for v in preview_values)
+            field_type = ['id', 'integer', 'char', 'float', 'monetary', 'many2one', 'many2many', 'one2many']
-        return ['text', 'char', 'datetime', 'selection', 'many2one', 'one2many', 'many2many', 'html']
+        return ['id', 'text', 'char', 'datetime', 'selection', 'many2one', 'one2many', 'many2many', 'html']
-import odoo.addons.decimal_precision as dp
+from odoo.addons import decimal_precision as dp
-import odoo.addons.decimal_precision as dp
+from odoo.addons import decimal_precision as dp
-import odoo.addons.decimal_precision as dp
+from odoo.addons import decimal_precision as dp
-import odoo.addons.decimal_precision as dp
+from odoo.addons import decimal_precision as dp
-import odoo.addons.decimal_precision as dp
+from odoo.addons import decimal_precision as dp
-import odoo.addons.decimal_precision as dp
+from odoo.addons import decimal_precision as dp
-import odoo.addons.decimal_precision as dp
+from odoo.addons import decimal_precision as dp
-import odoo.addons.decimal_precision as dp
+from odoo.addons import decimal_precision as dp
-import odoo.addons.decimal_precision as dp
+from odoo.addons import decimal_precision as dp
-import odoo.addons.decimal_precision as dp
+from odoo.addons import decimal_precision as dp
-            raise ValidationError(_('You cannot add expense lines of another employee.'))
+            raise ValidationError(_('You cannot add expense lines of another employee.'))
-import odoo.addons.hw_proxy.controllers.main as hw_proxy
+from odoo.addons.hw_proxy.controllers import main as hw_proxy
-import odoo.addons.hw_proxy.controllers.main as hw_proxy
+from odoo.addons.hw_proxy.controllers import main as hw_proxy
-import xml.etree.ElementTree as ET
+from xml.etree import ElementTree as ET
-import odoo.addons.hw_proxy.controllers.main as hw_proxy
+from odoo.addons.hw_proxy.controllers import main as hw_proxy
-import odoo.addons.hw_proxy.controllers.main as hw_proxy
+from odoo.addons.hw_proxy.controllers import main as hw_proxy
-import odoo.addons.hw_proxy.controllers.main as hw_proxy
+from odoo.addons.hw_proxy.controllers import main as hw_proxy
-import xml.etree.ElementTree as ET
+from xml.etree import ElementTree as ET
-import odoo.addons.decimal_precision as dp
+from odoo.addons import decimal_precision as dp
-import odoo.addons.decimal_precision as dp
+from odoo.addons import decimal_precision as dp
-import odoo.addons.decimal_precision as dp
+from odoo.addons import decimal_precision as dp
-import odoo.addons.decimal_precision as dp
+from odoo.addons import decimal_precision as dp
-import xml.etree.ElementTree as ET
+from xml.etree import ElementTree as ET
-import odoo.addons.decimal_precision as dp
+from odoo.addons import decimal_precision as dp
-import odoo.addons.decimal_precision as dp
+from odoo.addons import decimal_precision as dp
-import odoo.addons.decimal_precision as dp
+from odoo.addons import decimal_precision as dp
-import odoo.addons.decimal_precision as dp
+from odoo.addons import decimal_precision as dp
-import odoo.addons.decimal_precision as dp
+from odoo.addons import decimal_precision as dp
-import odoo.addons.decimal_precision as dp
+from odoo.addons import decimal_precision as dp
-import odoo.addons.decimal_precision as dp
+from odoo.addons import decimal_precision as dp
-import odoo.addons.decimal_precision as dp
+from odoo.addons import decimal_precision as dp
-import odoo.addons.decimal_precision as dp
+from odoo.addons import decimal_precision as dp
-import odoo.addons.decimal_precision as dp
+from odoo.addons import decimal_precision as dp
-import xml.etree.ElementTree as ET
+from xml.etree import ElementTree as ET
-import odoo.addons.decimal_precision as dp
+from odoo.addons import decimal_precision as dp
-import odoo.addons.decimal_precision as dp
+from odoo.addons import decimal_precision as dp
-import odoo.addons.decimal_precision as dp
+from odoo.addons import decimal_precision as dp
-import odoo.osv.expression as expression
+from odoo.osv import expression
-import odoo.tests.common as common
+from odoo.tests import common
-import xml.etree.ElementTree as ET
+from xml.etree import ElementTree as ET
-import odoo.tools.config as config
+from odoo.tools import config
-                        acquired = odoo.addons.base.ir.ir_cron.ir_cron._acquire_job(db_name)
+                        acquired = ir_cron._acquire_job(db_name)
-            import odoo.addons.base as base
+            from odoo.addons import base
-import odoo.tools.config as config
+from odoo.tools import config
-import lxml.html.clean as clean
+from lxml.html import clean
-                traceback=traceback.format_exc(exception),
+                traceback=traceback.format_exc(),
-    if big_name in vals:
+    if vals.get(big_name):
-    elif medium_name in vals:
+    elif vals.get(medium_name):
-    elif small_name in vals:
+    elif vals.get(small_name):
-                                  or request.website.default_lang_code)
+                                  or request.website.default_lang_code
-        '/customers/tag/<tag_id>/country/<country_name>-<int:country_id>/page/<int:page>',
+        '/customers/country/<model("res.country"):country>',
-        Country = request.env['res.country']
+    def customers(self, country=None, industry=None, page=0, **post):
-        partner_name = post.get('search', '')
+        search_value = post.get('search')
-        if partner_name:
+        if search_value:
-                ('website_description', 'ilike', post.get("search"))
+                '|', '|',
-                if curr_country.exists():
+        if country:
-                        'country_id': (curr_country.id, curr_country.name)
+                        'country_id': (country.id, country.name)
-            url += '/country/%s' % country_id
+        if industry:
-            'current_country': curr_country if country_id else False,
+            'current_country_id': country.id if country else 0,
-        if not vals.get('name'):
+        if vals['name'] == _('New'):
-        return unbuild
+        return super(MrpUnbuild, self).create(vals)
-                                  'Please use a token from another provider than %s.' % self.payment_token_id.acquirer_id.name)
+            raise ValidationError(_('This feature is not available for payment acquirers set to the "Authorize" mode.\n'
-                    'code': journal.code
+                    'code': journal.code,
-        return self.env['ir.sequence'].create(seq)
+        seq = self.env['ir.sequence'].create(seq)
-                            valuation_price_unit = company_currency.with_context(date=inv.date_invoice).compute(valuation_price_unit, inv.currency_id)
+                            valuation_price_unit = company_currency.with_context(date=inv.date_invoice).compute(valuation_price_unit, inv.currency_id, round=False)
-                process = subprocess.Popen(['pylint'] + options + paths, stdout=subprocess.PIPE, stderr=devnull_file)
+            process = subprocess.Popen(['pylint'] + options + paths, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
-            out = process.communicate()[0]
+            out, err = process.communicate()
-                self.fail("\n" + out)
+                self.fail("\n" + out + "\n" + err)
-                if not session.cash_control:
+                if not session.cash_control and session.state != 'closed':
-    @api.depends('config_id.cash_control')
+    @api.depends('config_id', 'statement_ids')
-                pu = self.env['account.tax']._fix_tax_included_price(pu, product.taxes_id, order_line.tax_id)
+                pu = self.env['account.tax']._fix_tax_included_price(pu, product.taxes_id, order_line[0].tax_id)
-    date_open = fields.Datetime('Assigned', readonly=True, default=fields.Datetime.now)
+    date_open = fields.Datetime('Assigned', readonly=True, default=lambda self: fields.Datetime.now())
-            acm_line.with_context(check_move_validity=False).write({
+        for acm_line in reversed_move.line_ids.with_context(check_move_validity=False):
-            'user_id': lead.user_id.id,
+            'user_id': context.get('default_user_id') or lead.user_id.id,
-            partner_id = self._create_partner(cr, uid, lead_id.id, data.action, partner_id or lead_id.partner_id.id, context=context)
+            partner_id = self._create_partner(cr, uid, lead_id.id, data.action, partner_id or lead_id.partner_id.id, context=dict(context, default_user_id=data.user_id.id))
-                    partner_obj.write(cr, uid, [lead.partner_id.id], {'user_id': lead.user_id.id}, context=context)
+SYSCOHADA_LIST = ['BJ', 'BF', 'CM', 'CF', 'KM', 'CG', 'CI', 'GA', 'GN', 'GW', 'GQ', 'ML', 'NE', 'CD', 'SN', 'TD', 'TG']
-        if country_code in ['BJ', 'BF', 'CM', 'CF', 'KM', 'CG', 'CI', 'GA', 'GN', 'GW', 'GQ', 'ML', 'NE', 'CD', 'SN', 'TD', 'TG']:
+        if country_code in SYSCOHADA_LIST:
-    'depends': ['base_vat'],
+    'depends': ['account'],
-    'depends': ['account', 'base_iban', 'base_vat'],
+    'depends': [
-    "depends" : ["account", "base_vat", "base_iban"],
+    "depends" : [
-        'base_vat',
+        'account',
-    'depends': ['base_iban', 'account', 'base_vat'],
+    'depends': [
-    'depends': ['base', 'account', 'base_iban', 'base_vat'],
+    'depends': [
-    'depends': ['base_vat','base_iban'],
+    'depends': [
-    'depends': ['account', 'base_vat', 'base_iban'],
+    'depends': [
-    "depends" : ["account", "base_iban", "base_vat"],
+    "depends" : [
-    'depends' : ['account', 'base_iban', 'base_vat'],
+    'depends' : [
-    "depends" : ['account','base_vat'],
+    "depends" : [
-    "depends": ["account", "base_iban", "base_vat", "account_cancel"],
+    "depends": [
-    'depends' : ['account', 'base_vat'],
+    'depends' : [
-    'depends': ['base_iban', 'base_vat'],
+    'depends': [
-    'depends': ['sale_management', 'crm'],
+    'depends': ['sale', 'crm'],
-    date_open = fields.Datetime('Assigned', readonly=True)
+    date_open = fields.Datetime('Assigned', readonly=True, default=fields.Datetime.now)
-    'depends': ['event', 'sale'],
+    'depends': ['event', 'sale_management'],
-    'depends': ['stock', 'sale', 'account'],
+    'depends': ['stock', 'sale_management', 'account'],
-    'depends': ['point_of_sale', 'sale'],
+    'depends': ['point_of_sale', 'sale_management'],
-    'depends': ['base', 'product', 'delivery', 'stock', 'sale', 'purchase'],
+    'depends': ['base', 'product', 'delivery', 'stock', 'sale_management', 'purchase'],
-    'version': '1.0',
+    'version': '1.1',
-    'summary': 'Quotations, Sales Orders, Invoicing',
+    'summary': 'Sales internal machinery',
-* Monthly Turnover (Graph)
+This module contains all the common features of Sales Management and eCommerce.
-    'depends': ['sales_team', 'account', 'procurement', 'web_tour'],
+    'depends': ['sales_team', 'account', 'procurement'],
-}
+}
-    'depends': ['sale', 'crm'],
+    'depends': ['sale_management', 'crm'],
-    'depends': ['sale', 'hr_expense'],
+    'depends': ['sale_management', 'hr_expense'],
-    'depends':['sale'],
+    'depends':['sale_management'],
-    'depends': ['sale', 'stock_account'],
+    'depends': ['sale_management', 'stock_account'],
-    'depends': ['sale', 'hr_timesheet'],
+    'depends': ['sale_management', 'hr_timesheet'],
-    'depends': ['website', 'sale', 'mail', 'payment', 'website_portal_sale', 'website_mail'],
+    'depends': ['website', 'sale_management', 'mail', 'payment', 'website_portal_sale', 'website_mail'],
-    'depends': ['event', 'sale_management'],
+    'depends': ['event', 'sale'],
-    'depends': ['stock', 'sale_management', 'account'],
+    'depends': ['stock', 'sale', 'account'],
-    'depends': ['point_of_sale', 'sale_management'],
+    'depends': ['point_of_sale', 'sale'],
-    'depends': ['base', 'product', 'delivery', 'stock', 'sale_management', 'purchase'],
+    'depends': ['base', 'product', 'delivery', 'stock', 'sale', 'purchase'],
-    'version': '1.1',
+    'version': '1.0',
-    'summary': 'Sales internal machinery',
+    'sequence': 15,
-This module contains all the common features of Sales Management and eCommerce.
+Manage sales quotations and orders
-    'depends': ['sales_team', 'account', 'procurement'],
+    'website': 'https://www.odoo.com/page/crm',
-    'depends': ['sale_management', 'crm'],
+    'depends': ['sale', 'crm'],
-    'depends': ['sale_management', 'hr_expense'],
+    'depends': ['sale', 'hr_expense'],
-    'depends': ['sale_management'],
+    'depends':['sale'],
-    'depends': ['sale_management', 'stock_account'],
+    'depends': ['sale', 'stock_account'],
-    'depends': ['sale_management', 'hr_timesheet'],
+    'depends': ['sale', 'hr_timesheet'],
-    'depends': ['website', 'sale_management', 'mail', 'payment', 'website_portal_sale', 'website_mail'],
+    'depends': ['website', 'sale', 'mail', 'payment', 'website_portal_sale', 'website_mail'],
-    def convert_to_column(self, value, record):
+    def convert_to_column(self, value, record, values=None):
-from odoo.tools import mute_logger
+from odoo.tools import mute_logger, float_repr
-        self.assertEqual(amount, 14.7)
+        model = self.env['test_new_api.mixed']
-from odoo.tools import float_precision, float_repr, float_round, frozendict, html_sanitize, human_size, pg_varchar, ustr, OrderedSet, pycompat
+from odoo.tools import float_repr, float_round, frozendict, html_sanitize, human_size, pg_varchar, ustr, OrderedSet, pycompat
-    def convert_to_column(self, value, record):
+    def convert_to_column(self, value, record, values=None):
-    def convert_to_column(self, value, record):
+    def convert_to_column(self, value, record, values=None):
-    def convert_to_column(self, value, record):
+    def convert_to_column(self, value, record, values=None):
-    def convert_to_column(self, value, record):
+    def convert_to_column(self, value, record, values=None):
-            return float(value or 0.0)
+    def convert_to_column(self, value, record, values=None):
-            currency = record[self.currency_field]
+        # cache format: float
-        return float(value or 0.0)
+            value = record[self.currency_field].round(value)
-        return float(value)
+        return value
-    def convert_to_column(self, value, record):
+    def convert_to_column(self, value, record, values=None):
-    def convert_to_column(self, value, record):
+    def convert_to_column(self, value, record, values=None):
-    def convert_to_column(self, value, record):
+    def convert_to_column(self, value, record, values=None):
-    def convert_to_column(self, value, record):
+    def convert_to_column(self, value, record, values=None):
-    def convert_to_column(self, value, record):
+    def convert_to_column(self, value, record, values=None):
-                        val = field.convert_to_column(val, self)
+                        val = field.convert_to_column(val, self, vals)
-                    val = field.convert_to_column(vals[name], self)
+                    val = field.convert_to_column(vals[name], self, vals)
-            updates.append((self._inherits[parent_model], '%s', parent_id))
+            vals[self._inherits[parent_model]] = parent_id
-                updates.append((name, field.column_format, field.convert_to_column(val, self)))
+                column_val = field.convert_to_column(val, self, vals)
-                res[0]['state'] = [state_value, state_name]
+                res[0]['state'] = state_value
-        for field in ['name', 'reference', 'comment', 'date_due', 'partner_id', 'company_id',
+        for field in ['name', 'reference', 'comment', 'date_due', 'partner_id', 'company_id', 'team_id',
-                                    'partner_ref', 'payment_term_id', 'account_id',
+                                    'payment_term_id', 'account_id', 'team_id',
-                                         'payment_term_id', 'journal_id'):
+                                         'payment_term_id', 'journal_id', 'team_id'):
-            order = context.get('order', self._order)
+            order = context.get('order', self.pool[doc_model]._order)
-    bank_account_id = fields.Many2one('res.partner.bank', string="Bank Account", ondelete='restrict', copy=False)
+    bank_account_id = fields.Many2one('res.partner.bank', string="Bank Account", ondelete='restrict', copy=False, domain="[('partner_id','=', company_id)]")
-                raise UserError(_('You cannot empty the account number once set.\nIf you would like to delete the account number, you can do it from the Bank Accounts list.'))
+            if 'bank_account_id' in vals and not vals.get('bank_account_id'):
-    partner_id = fields.Many2one('res.partner', 'Account Holder', ondelete='cascade', index=True, domain=['|', ('is_company', '=', True), ('parent_id', '=', False)])
+    partner_id = fields.Many2one('res.partner', 'Account Holder', ondelete='cascade', index=True, domain=['|', ('is_company', '=', True), ('parent_id', '=', False)], default=lambda self: self.env.user.company_id.partner_id)
-                for tax in taxes.compute_all(line.price_unit * (100.0 - line.discount) / 100.0, cur, line.qty)['taxes']:
+                price = line.price_unit * (1 - (line.discount or 0.0) / 100.0)
-    date = fields.Date(readonly=True, states={'draft': [('readonly', False)], 'refused': [('readonly', False)]}, default=fields.Date.context_today, string="Date")
+    date = fields.Date(readonly=True, states={'draft': [('readonly', False)], 'refused': [('readonly', False)]}, default=fields.Date.context_today, string="Expense Date")
-    _order = 'sequence'
+    _order = 'website_published desc, sequence, name'
-    sequence = fields.Integer('Sequence', help="Determine the display order")
+    sequence = fields.Integer('Sequence', default=10, help="Determine the display order")
-        self.write(onchange_vals)
+        self.update(onchange_vals)
-        opportunities = self.search([('type', '=', 'opportunity'), ('user_id', '=', self._uid), ('activity_date_deadline', '!=', False)])
+        opportunities = self.search([('type', '=', 'opportunity'), ('user_id', '=', self._uid)])
-                    result['activity']['overdue'] += 1
+            if opp.activity_date_deadline:
-            if opp.date_closed:
+            if opp.date_closed and opp.stage_id.probability == 100:
-        ('generate_and_pay_invoice', 'Authorize & capture the amount, confirm the SO and auto-validate the invoice on acquirer confirmation')],
+        ('authorize', 'Authorize the amount and confirm the order on acquirer confirmation (capture manually)'),
-        "'let the customer decide', ecommerce customers will have a checkbox displayed on the payment page.")
+        ('ask', 'Let the customer decide (recommended for eCommerce)'),
-                raise ValidationError('Transaction Authorization is not supported by this payment provider.')
+                raise ValidationError('You cannot capture payments manually with this payment method. Please choose another Order Confirmation mode (in Configuration tab).')
-    partner_id = fields.Many2one('res.partner', 'Partner', track_visibility='onchange')
+    partner_id = fields.Many2one('res.partner', 'Customer', track_visibility='onchange')
-        self.order_line._update_registrations(confirm=False, cancel_to_draft=False)
+        # confirm registration if it was free (otherwise it will be confirmed once invoice fully paid)
-        </p>
+        %s
-        return index_template
+        return index_template % self.get_hw_screen_message()
-                    if user_lang and user_lang == record['lang']:
+                    if user_lang and user_lang == record['lang'] and field.translate is True:
-            if (data.get('vat', partner.vat) or False) != partner.vat:
+            if 'vat' in partner and (data['vat'] or False) != (partner.vat or False):
-            if data.get('name', partner.name) != partner.name:
+            if 'name' in data and (data['name'] or False) != (partner.name or False):
-    def postprocess_pdf_report(self, res_id, attachment_content, attachment_name):
+    def postprocess_pdf_report(self, res_id, pdfreport_path, attachment_name):
-        :param attachment_content: The pdf content newly generated by wkhtmltopdf.
+        :param pdfreport_path: The path to the pdf content newly generated by wkhtmltopdf.
-                self.postprocess_pdf_report(wkhtmltopdf_obj.res_id, content_read, wkhtmltopdf_obj.attachment_name)
+                self.postprocess_pdf_report(wkhtmltopdf_obj.res_id, pdfreport_path, wkhtmltopdf_obj.attachment_name)
-                content_read = pdfdocument.read()
+        with open(entire_report_path, 'rb') as pdfdocument:
-    @api.model
+    @api.multi
-            raise exceptions.HTTPException(description='Cannot convert into barcode.')
+            raise werkzeug.exceptions.HTTPException(description='Cannot convert into barcode.')
-    def toggle_enviroment_value(self):
+    def toggle_environment_value(self):
-        order = request.env['sale.order'].sudo().browse(sale_order_id)
+        order = request.env['sale.order'].sudo().browse(sale_order_id).exists()
-        return {'recall': flag, 'message': request.env['ir.ui.view'].render_template("website_sale.order_state_message", values)}
+        return {
-                shipping_partner_id = order.partner_invoice_id.id
+        render_values = self._get_shop_payment_values(order, **post)
-        return request.render("website_sale.payment", values)
+        if render_values['errors']:
-from odoo import http
+
-    def index(self, mod=None, **kwargs):
+    def test_suite(self, mod=None, **kwargs):
-                    computed_price = self.get_shipping_price_from_so(order)[0]
+                    computed_price = self.get_shipping_price_from_so(order)
-        ''' For every sales order, compute the price of the shipment
+    def get_shipping_price_from_so(self, order):
-        :return list: A list of floats, containing the estimated price for the shipping of the sales order
+        :param order: A recordset of a sales order
-            return getattr(self, '%s_get_shipping_price_from_so' % self.delivery_type)(orders)
+            return getattr(self, '%s_get_shipping_price_from_so' % self.delivery_type)(order)
-                    price_unit = order.carrier_id.get_shipping_price_from_so(order)[0]
+                    price_unit = order.carrier_id.get_shipping_price_from_so(order)
-            unlink_move_lots.unlink()
+            unlink_move_lots.sudo().unlink()
-##############################################################################
+# Part of Odoo. See LICENSE file for full copyright and licensing details.
-        self.check_amount_in_words = check_amount_in_words
+        self.check_amount_in_words = self.env['account.payment']._get_check_amount_in_words(self.amount)
-        self.check_amount_in_words = check_amount_in_words
+        self.check_amount_in_words = self._get_check_amount_in_words(self.amount)
-            refunds = invoice_ids.search([('origin', 'like', order.name)])
+            refunds = invoice_ids.search([('origin', 'like', order.name)]).filtered(lambda r: r.type in ['out_invoice', 'out_refund'])
-from . import product_template
+from .import sale_order
-        default=_get_default_template_id, readonly=True,
+        readonly=True,
-    mail_template_id = fields.Many2one('mail.template', 'Confirmation Mail',
+    mail_template_id = fields.Many2one(
-        #restrict the closing of FY if there are still unposted entries
+    def _validate_fiscalyear_lock(self, values):
-                moves.action_assign()
+                tracked_moves = moves.filtered(lambda move: move.product_id.tracking != 'none')
-        picking.action_assign()
+        contains_tracked_products = any([(product_id.tracking != 'none') for product_id in self.lines.mapped('product_id')])
-        if not any([(x.product_id.tracking != 'none') for x in picking.pack_operation_ids]):
+        if not contains_tracked_products:
-                pos_pack_lots = PosPackOperationLot.search([('order_id', '=',  order.id), ('product_id', '=', pack_operation.product_id.id)])
+                pos_pack_lots = PosPackOperationLot.search([('order_id', '=', order.id), ('product_id', '=', pack_operation.product_id.id)])
-            raise ValidationError(_("You cannot create two active sessions related to the same point of sale!"))
+            raise ValidationError(_("Another session is already opened for this point of sale."))
-    barcode = fields.Char(string='Barcode', help="BarCode", oldname='ean13')
+    barcode = fields.Char(string='Barcode', oldname='ean13')
-        for name, field_data in fields_data.iteritems():
+        for name, field_data in pycompat.items(fields_data):
-from . import assertion_report
+from . import assertion_report, pycompat
-        'data/website_quotation_data.xml',
+        'data/website_quote_data.xml',
-        'data/website_quotation_demo.xml'
+        'data/website_quote_demo.xml'
-import htmlentitydefs
+try:
-def html_entity_decode_char(m, defs=htmlentitydefs.entitydefs):
+def html_entity_decode_char(m, defs=entitydefs):
-from Queue import Queue
+try:
-from Queue import Queue, Empty
+try:
-import cgi
+from odoo.tools import misc
-        return 'window.top.%s(%s)' % (cgi.escape(jsonp), json.dumps({'result': written}))
+        return 'window.top.%s(%s)' % (misc.html_escape(jsonp), json.dumps({'result': written}))
-import cgi
+from odoo.tools import misc
-</feed>''' .format(key=spreadsheet_key, formula=cgi.escape(formula, quote=True), config=cgi.escape(config_formula, quote=True))
+</feed>''' .format(key=spreadsheet_key, formula=misc.html_escape(formula), config=misc.html_escape(config_formula))
-                line = werkzeug.utils.escape(line)
+                line = misc.html_escape(line)
-from odoo.tools import DEFAULT_SERVER_DATETIME_FORMAT
+from odoo.tools import DEFAULT_SERVER_DATETIME_FORMAT, misc
-        xml_transaction = soap_header + cgi.escape(xml_transaction) + soap_footer
+        xml_transaction = soap_header + misc.escape_html(xml_transaction) + soap_footer
-        media = (' media="%s"' % werkzeug.utils.escape(self.media)) if self.media else ''
+        media = (' media="%s"' % misc.html_escape(self.media)) if self.media else ''
-from odoo.tools import html_sanitize, append_content_to_html, plaintext2html, email_split
+from odoo.tools import html_sanitize, append_content_to_html, plaintext2html, email_split, misc
-            self.assertIn(cgi.escape(email), html_sanitize(email), 'html_sanitize stripped emails of original html')
+            self.assertIn(misc.html_escape(email), html_sanitize(email), 'html_sanitize stripped emails of original html')
-            self.assertNotIn(cgi.escape(email), sanitized, 'html_sanitize stripped emails of original html')
+            self.assertNotIn(misc.html_escape(email), sanitized, 'html_sanitize stripped emails of original html')
-            self.assertIn('<span data-o-mail-quote="1">%s' % cgi.escape(ext.decode('utf-8')), html)
+            self.assertIn('<span data-o-mail-quote="1">%s' % misc.html_escape(ext.decode('utf-8')), html)
-            self.assertIn('<span data-o-mail-quote="1">%s</span>' % cgi.escape(ext.decode('utf-8')), html)
+            self.assertIn('<span data-o-mail-quote="1">%s</span>' % misc.html_escape(ext.decode('utf-8')), html)
-                self.assertIn('<span data-o-mail-quote="1">%s</span>' % cgi.escape(text), new_html)
+                self.assertIn('<span data-o-mail-quote="1">%s</span>' % misc.html_escape(text), new_html)
-            self.assertIn('<span data-o-mail-quote="1">%s</span>' % cgi.escape(ext), html)
+            self.assertIn('<span data-o-mail-quote="1">%s</span>' % misc.html_escape(ext), html)
-            self.assertIn('<span data-o-mail-quote="1">%s</span>' % cgi.escape(ext), html)
+            self.assertIn('<span data-o-mail-quote="1">%s</span>' % misc.html_escape(ext), html)
-            self.assertIn('<span data-o-mail-quote="1">%s</span>' % cgi.escape(ext), html)
+            self.assertIn('<span data-o-mail-quote="1">%s</span>' % misc.html_escape(ext), html)
-            self.assertIn('<span data-o-mail-quote="1">%s</span>' % cgi.escape(ext.decode('utf-8')), html)
+            self.assertIn('<span data-o-mail-quote="1">%s</span>' % misc.html_escape(ext.decode('utf-8')), html)
-from odoo.tools import pycompat
+from odoo.tools import pycompat, misc, ustr
-            result,
+            ustr(result),
-                cgi.escape(s.encode('utf-8')),
+                misc.html_escape(s),
-from odoo.tools import pycompat
+from odoo.tools import pycompat, misc
-    src = part.sub(lambda m: ('cite=' not in m.group(1) and 'alt=' not in m.group(1)) and cgi.escape(m.group(1)) or m.group(1), src)
+    src = part.sub(lambda m: ('cite=' not in m.group(1) and 'alt=' not in m.group(1)) and misc.html_escape(m.group(1)) or m.group(1), src)
-    src = src.replace('%>', cgi.escape('%>'))
+    src = src.replace('<%', misc.html_escape('<%'))
-        html entities, using cgi.escape().
+        html entities, using misc.html_escape().
-    text = cgi.escape(ustr(text))
+    text = misc.html_escape(ustr(text))
-import itertools
+try:
-        for ca, cb in itertools.izip_longest(a, b):
+        for ca, cb in zip_longest(a, b):
-        for actual, expected in itertools.izip_longest(fields, expect):
+        for actual, expected in zip_longest(fields, expect):
-from itertools import izip_longest
+try:
-import itertools
+import html2text
-from odoo.tools import html2text, ustr, pycompat
+from odoo.tools import ustr, pycompat
-        if subtype == 'html' and not body_alternative and html2text:
+        if subtype == 'html' and not body_alternative:
-            text_utf8 = tools.html2text(email_body_utf8.decode('utf-8')).encode('utf-8')
+            text_utf8 = html2text.html2text(email_body_utf8.decode('utf-8')).encode('utf-8')
-    html2text = None
+        'html2text',
-import sgmllib
+import sgmllib # pylint: disable=deprecated-module
-
+import pickle as pickle_
-pickle = Pickle
+def _pickle_load(stream, errors=False):
-    import pickle
+import pickle
-import urllib2
+import requests
-        return json.loads(response)
+        return requests.get(endpoint, params={'access_token': access_token}).json()
-import werkzeug
+import werkzeug.urls
-                query['redirect'] = base + werkzeug.url_encode(fragment)
+                query['redirect'] = base + werkzeug.urls.url_encode(fragment)
-            res[partner.id] = urljoin(base_url, "/web/%s?%s" % (route, werkzeug.url_encode(query)))
+            res[partner.id] = werkzeug.urls.url_join(base_url, "/web/%s?%s" % (route, werkzeug.urls.url_encode(query)))
-import urllib
+
-    url += urllib.quote(addr.encode('utf8'))
+    url = 'https://maps.googleapis.com/maps/api/geocode/json'
-        result = json.load(urllib.urlopen(url))
+        result = requests.get(url, params={'sensor': 'false', 'address': addr}).json()
-import werkzeug.urls
+
-        data = werkzeug.url_encode({
+        data = {
-        })
+        }
-        except urllib2.HTTPError:
+            req = requests.post(GOOGLE_TOKEN_ENDPOINT, data=data, headers=headers, timeout=TIMEOUT)
-        encoded_params = werkzeug.url_encode({
+        encoded_params = urls.url_encode({
-        encoded_params = werkzeug.url_encode({
+        encoded_params = urls.url_encode({
-        data = werkzeug.url_encode({
+        data = {
-        })
+        }
-        except urllib2.HTTPError:
+        except requests.HTTPError:
-        data = werkzeug.url_encode({
+        data = {
-        })
+        }
-            if error.code == 400:  # invalid grant
+        except requests.HTTPError as error:
-            error_key = json.loads(error.read()).get("error", "nc")
+            error_key = json.loads(error.response.json()).get("error", "nc")
-        _logger.debug("Uri: %s - Type : %s - Headers: %s - Params : %s !" % (uri, type, headers, werkzeug.url_encode(params) if type == 'GET' else params))
+        _logger.debug("Uri: %s - Type : %s - Headers: %s - Params : %s !", (uri, type, headers, params))
-                req = urllib2.Request(preuri + uri, params, headers)
+            if type.upper() in ('GET', 'DELETE'):
-            status = resp.getcode()
+            res.raise_for_status()
-                response = json.loads(content)
+                response = res.json()
-                ask_time = datetime.strptime(resp.headers.get('date'), "%a, %d %b %Y %H:%M:%S %Z")
+                ask_time = datetime.strptime(res.headers.get('date'), "%a, %d %b %Y %H:%M:%S %Z")
-            if error.code in (204, 404):
+        except request.HTTPError as error:
-                _logger.exception("Bad google request : %s !", error.read())
+                _logger.exception("Bad google request : %s !", error.response.content)
-import urllib2
+from werkzeug import urls
-        url = "/calendar/v3/calendars/%s/events?fields=%s&access_token=%s" % ('primary', urllib2.quote('id,updated'), self.get_token())
+        url = "/calendar/v3/calendars/%s/events?fields=%s&access_token=%s" % ('primary', urls.url_quote('id,updated'), self.get_token())
-            if e.code == 401:  # Token invalid / Acces unauthorized
+        except requests.HTTPError as e:
-                if e.code == 410:  # GONE, Google is lost.
+            except requests.HTTPError as e:
-                error_key = json.loads(str(e))
+                error_key = e.response.json()
-import urllib2
+
-        data = werkzeug.url_encode({
+        data = {
-        })
+        }
-        except urllib2.HTTPError:
+            req = requests.post(GOOGLE_TOKEN_ENDPOINT, data=data, headers=headers, timeout=TIMEOUT)
-        return content.get('access_token')
+        return req.json().get('access_token')
-        except urllib2.HTTPError:
+            req = requests.post(request_url, headers=headers, timeout=TIMEOUT)
-        content = json.loads(content)
+        req = requests.post(request_url, data=json.dumps(data), headers=headers, timeout=TIMEOUT)
-            except urllib2.HTTPError:
+                req = requests.post(request_url, data=json.dumps(data), headers=headers, timeout=TIMEOUT)
-                except urllib2.HTTPError:
+                    requests.post(request_url, data=json.dumps(data), headers=headers, timeout=TIMEOUT)
-            req = urllib2.Request(
+            req = requests.post(
-        except (urllib2.HTTPError, urllib2.URLError):
+                headers={'content-type': 'application/atom+xml', 'If-Match': '*'},
-from werkzeug import url_encode, unescape
+from werkzeug import urls, utils
-    if urlparse(url).scheme not in ('http', 'https', 'ftp', 'ftps'):
+    if urls.url_parse(url).scheme not in ('http', 'https', 'ftp', 'ftps'):
-            vals['url'] = unescape(long_url)
+            vals['url'] = utils.unescape(long_url)
-        self.short_url = urljoin(base_url, '/r/%(code)s' % {'code': self.code})
+        self.short_url = urls.url_join(base_url, '/r/%(code)s' % {'code': self.code})
-        parsed = urlparse(self.url)
+        parsed = urls.url_parse(self.url)
-        self.redirected_url = '%s://%s%s?%s&%s#%s' % (parsed.scheme, parsed.netloc, parsed.path, url_encode(utms), parsed.query, parsed.fragment)
+        self.redirected_url = parsed.replace(query=urls.url_encode(utms)).to_url()
-            p = html.fromstring(ustr(page.read()).encode('utf-8'), parser=html.HTMLParser(encoding='utf-8'))
+            page = requests.get(url, timeout=5)
-            icon = urlopen('http://www.google.com/s2/favicons?domain=' + self.url, timeout=5).read()
+            icon = requests.get('http://www.google.com/s2/favicons', params={'domain': self.url}, timeout=5).content
-import re, sys, urllib, htmlentitydefs, codecs
+import re, sys, htmlentitydefs, codecs
-                        self.out("   ["+repr(link['count'])+"]: " + urlparse.urljoin(self.baseurl, link['href']))
+                        self.out("   ["+repr(link['count'])+"]: " + urls.url_join(self.baseurl, link['href']))
-from urllib import urlencode, quote as quote
+from werkzeug import urls
-        'urlencode': urlencode,
+        'quote': urls.url_quote,
-        (base_scheme, base_netloc, bpath, bparams, bquery, bfragment) = urlparse.urlparse(base_url)
+        base = urls.url_parse(base_url)
-            return new_url
+            new_url = urls.url_parse(url)
-import urlparse
+from werkzeug import urls
-                alias_domain = urlparse.urlsplit(domain).netloc.split(':')[0]
+                alias_domain = urls.url_parse(domain).host
-            uo.close()
+        r = requests.post(url, data=arguments, timeout=30)
-        track_url = urlparse.urljoin(
+        track_url = werkzeug.urls.url_join(
-                'params': werkzeug.url_encode({'db': self.env.cr.dbname})
+                'params': werkzeug.urls.url_encode({'db': self.env.cr.dbname})
-        url = urlparse.urljoin(
+        url = werkzeug.urls.url_join(
-                'params': werkzeug.url_encode({
+                'params': werkzeug.urls.url_encode({
-            return match.group(1) + urlparse.urljoin(domain, match.group(2))
+            return match.group(1) + werkzeug.urls.url_join(domain, match.group(2))
-import urllib2
+
-            except urllib2.URLError:
+            except IOError:
-                    content = mo.group(1)
+                r = requests.get('%s/export/html' % url)
-import urllib2
+import requests
-        return self.handleResult(result)
+        params['apikey'] = self.apiKey
-import urlparse
+from werkzeug import urls
-                'resURL': '%s' % urlparse.urljoin(base_url, AdyenController._return_url),
+                'resURL': urls.url_join(base_url, AdyenController._return_url),
-                'resURL': '%s' % urlparse.urljoin(base_url, AdyenController._return_url),
+                'resURL': urls.url_join(base_url, AdyenController._return_url),
-import urlparse
+from werkzeug import urls
-            'resURL': '%s' % urlparse.urljoin(base_url, AdyenController._return_url),
+            'resURL': urls.url_join(base_url, AdyenController._return_url),
-import werkzeug
+from werkzeug import urls, utils
-            'return_url': '%s' % urlparse.urljoin(base_url, return_url)
+            'return_url': urls.url_join(base_url, return_url)
-        return werkzeug.utils.redirect(post.get('return_url', '/'))
+        return utils.redirect(post.get('return_url', '/'))
-        response = strip_ns(response, XMLNS)
+        r = requests.post(self.url, data=data, headers={'Content-Type': 'text/xml'})
-            'x_cancel_url': '%s' % urlparse.urljoin(base_url, AuthorizeController._cancel_url),
+            'x_relay_url': urls.url_join(base_url, AuthorizeController._return_url),
-import urlparse
+from werkzeug import urls
-            'x_cancel_url': '%s' % urlparse.urljoin(base_url, AuthorizeController._cancel_url),
+            'x_relay_url': urls.url_join(base_url, AuthorizeController._return_url),
-import urlparse
+
-            sign = ''.join('%s=%s' % (k, urllib.unquote_plus(v)) for k, v in items)
+            sign = ''.join('%s=%s' % (k, urls.url_unquote_plus(v)) for k, v in items)
-            'Brq_returnreject': '%s' % urlparse.urljoin(base_url, BuckarooController._reject_url),
+            'Brq_return': urls.url_join(base_url, BuckarooController._return_url),
-import urlparse
+from werkzeug import urls
-            'Brq_returnreject': '%s' % urlparse.urljoin(base_url, BuckarooController._reject_url),
+            'Brq_return': urls.url_join(base_url, BuckarooController._return_url),
-
+import datetime
-import urlparse
+import requests
-from odoo.tools import float_round, DEFAULT_SERVER_DATE_FORMAT
+from odoo.tools import float_round, DEFAULT_SERVER_DATE_FORMAT, pycompat
-            'CANCELURL': '%s' % urlparse.urljoin(base_url, OgoneController._cancel_url),
+            'ACCEPTURL': urls.url_join(base_url, OgoneController._accept_url),
-        result = urllib2.urlopen(request).read()
+        result = requests.post(direct_order_url, data=data).content
-        result = urllib2.urlopen(request).read()
+        result = requests.post(query_direct_url, data=data).content
-            result = urllib2.urlopen(request).read()
+            result = requests.post(url, data=data).content
-import urlparse
+from werkzeug import urls
-            'CANCELURL': '%s' % urlparse.urljoin(base_url, OgoneController._cancel_url),
+            'ACCEPTURL': urls.url_join(base_url, OgoneController._accept_url),
-import urllib2
+
-            custom = json.loads(urllib.unquote_plus(post.pop('custom', False) or post.pop('cm', False) or '{}'))
+            custom = json.loads(urls.url_unquote_plus(post.pop('custom', False) or post.pop('cm', False) or '{}'))
-                pdt_post[split[0]] = urllib.unquote_plus(split[1]).decode('utf8')
+                pdt_post[split[0]] = urls.url_unquote_plus(split[1]).decode('utf8')
-        resp = uopen.read()
+        urequest = requests.post(validate_url, new_post)
-import urlparse
+from werkzeug import urls
-            'cancel_return': '%s' % urlparse.urljoin(base_url, PaypalController._cancel_url),
+            'paypal_return': urls.url_join(base_url, PaypalController._return_url),
-            'cancel_return': '%s' % urlparse.urljoin(base_url, PaypalController._cancel_url),
+            'return': urls.url_join(base_url, PaypalController._return_url),
-import urlparse
+
-                                curl='%s' % urlparse.urljoin(base_url, '/payment/payumoney/cancel')
+                                surl=urls.url_join(base_url, '/payment/payumoney/return'),
-import urlparse
+
-                    u'automaticResponseUrl=%s|' % urlparse.urljoin(base_url, SipsController._return_url) +
+                    u'normalReturnUrl=%s|' % urls.url_join(base_url, SipsController._return_url) +
-import urllib2
+
-        except (urllib2.URLError, ssl.SSLError):
+            r = requests.post('https://w1.mercurypay.com/ws/ws.asmx', data=xml_transaction, headers=headers, timeout=65)
-from urlparse import urljoin
+from werkzeug import urls
-            survey.result_url = urljoin(base_url, "survey/results/%s" % (slug(survey)))
+            survey.public_url = urls.url_join(base_url, "survey/start/%s" % (slug(survey)))
-from urlparse import urljoin
+
-            full_url = urljoin(base_url, url)
+            full_url = urls.url_join(base_url, url)
-import urlparse
+
-            url = urlparse.urlparse(url).path[1:]  # dirty hack to avoid incorrect urls
+            url = urls.url_parse(url).path[1:]  # dirty hack to avoid incorrect urls
-import urlparse
+import requests
-        url_object = urlparse.urlsplit(url)
+        url_object = urls.url_parse(url)
-            query = dict(urlparse.parse_qsl(url_object.query))
+            query = url_object.decode_query()
-        match = self.local_url_re.match(urlparse.urlsplit(url).path)
+        match = self.local_url_re.match(urls.url_parse(url).path)
-            image = I.open(cStringIO.StringIO(req.read()))
+            req = requests.get(url, timeout=REMOTE_CONNECTION_TIMEOUT)
-from urllib import urlencode
+from werkzeug import urls
-        return "/web#%s" % (urlencode(params),)
+        return "/web#%s" % (urls.url_encode(params),)
-import urllib2
+
-        except (urllib2.HTTPError, urllib2.URLError):
+            req = requests.get(url, params={
-        xmlroot = ET.fromstring(response.read())
+        xmlroot = ET.fromstring(response)
-import urlparse
+from werkzeug import urls
-            return '%s' % urlparse.urljoin(base_url, path)
+            return urls.url_join(base_url, path)
-import werkzeug
+
-    url = urlparse.urlparse(location)
+    url = urls.url_parse(location)
-        location = urlparse.urljoin(current_path, location)
+        location = urls.url_join(current_path, location)
-                _url = "%s?%s" % (_url, werkzeug.url_encode(url_args))
+                _url = "%s?%s" % (_url, urls.url_encode(url_args))
-                    return urlparse.urljoin(cdn_url, uri)
+                    return urls.url_join(cdn_url, uri)
-import urlparse
+from werkzeug import urls
-        code = r.getcode()
+        code = r.status_code
-            doc = lxml.html.fromstring(r.read())
+        if r.headers['Content-Type'].startswith('text/html'):
-                parts = urlparse.urlsplit(href)
+                parts = urls.url_parse(href)
-                ))
+                href = parts.replace(fragment='').to_url()
-            arch = lxml.html.parse(urlopen(kwargs.get('url')))
+            req = requests.get(kwargs.get('url'), stream=True)
-        except URLError:
+        except IOError:
-from urllib import urlencode
+
-            token_url = base_url + '/forum/validate_email?%s' % urlencode(params)
+            token_url = base_url + '/forum/validate_email?%s' % urls.url_encode(params)
-from werkzeug import url_encode
+from werkzeug import urls
-                url_encode({
+            source.url = urls.url_join(base_url, "%s?%s" % (source.job_id.website_url,
-from urlparse import urljoin
+from werkzeug import urls
-            token_url = urljoin(base_url, route % {
+            token_url = urls.url_join(base_url, route % {
-import urlparse
+from werkzeug import urls
-                fragment = urlparse.urlparse(response.location).fragment
+                fragment = urls.url_parse(response.location).fragment
-
+import requests
-import urllib2
+
-        baseurl = schema.netloc
+        baseurl = urls.url_parse(url).netloc
-            content = urllib2.urlopen(req).read()
+            response = requests.get(base_url, params=data)
-            result['error'] = e.reason
+        except requests.exceptions.HTTPError as e:
-        except HTTPError as e:
+            request = requests.get(url, params=params, headers={'Authorization': 'Bearer %s' % access_token}, timeout=URLOPEN_TIMEOUT)
-                          e.code, e.msg, e.fp.read())
+                          e.response.status_code, e.response.reason, e.response.content)
-from urllib2 import URLError, HTTPError
+
-        except URLError as e:
+        except requests.HTTPError as e:
-        except Exception as e:
+        except Exception:
-from urlparse import urlunsplit
+
-    return urlunsplit((
+    return urls.url_unparse((
-import urllib
+try:
-                    if os.path.isfile(urllib.url2pathname(small)):
+                    if os.path.isfile(url2pathname(small)):
-    from urlparse import urlparse
+from werkzeug import urls
-                can_aggregate = not urlparse(href).netloc and not href.startswith('/web/content')
+                can_aggregate = not urls.url_parse(href).netloc and not href.startswith('/web/content')
-from odoo.tools import pycompat
+import requests
-    from urllib2 import urlopen
+from odoo.tools import pycompat
-        apps_server = urlparse.urlparse(self.get_apps_server())
+        apps_server = urls.url_parse(self.get_apps_server())
-                up = urlparse.urlparse(url)
+                up = urls.url_parse(url)
-                    content = urlopen(url).read()
+                    response = requests.get(url)
-
+
-            website = urlparse.urlunparse(('http', netloc, path, params, query, fragment))
+        url = urls.url_parse(website)
-        return gravatar_image
+        res = requests.get(url, params={'d': '404', 's': '128'}, timeout=5)
-    from urlparse import parse_qs, urlparse
+from werkzeug import urls
-            debug = bool(parse_qs(urlparse(self.httprequest.referrer).query, keep_blank_values=True).get('debug'))
+            debug = 'debug' in urls.url_parse(self.httprequest.referrer).decode_query()
-            parsed = urlparse(referer)
+            parsed = urls.url_parse(referer)
-    escaped = quote(filename.encode('utf8'))
+    escaped = urls.url_quote(filename.encode('utf8'))
-    import urlparse
+from werkzeug import urls
-        us = urlparse.urlsplit(db_or_uri)
+        us = urls.url_parse(db_or_uri)
-        self.opener.addheaders.append(('Cookie', 'session_id=%s' % self.session_id))
+        self.opener = requests.Session()
-        return self.opener.open(url, data, timeout)
+        if data:
-        assert isinstance(self.size, (NoneType, int)), \
+        assert self.size is None or isinstance(self.size, int), \
-        ips =  [ c.split(':')[1].split(' ')[0] for c in commands.getoutput("/sbin/ifconfig").split('\n') if 'inet addr' in c ]
+        ips =  [ c.split(':')[1].split(' ')[0] for c in subprocess.check_output("/sbin/ifconfig").split('\n') if 'inet addr' in c ]
-import commands
+import subprocess
-BANNED_DEVICES = set([
+BANNED_DEVICES = {
-])
+}
-        devices = commands.getoutput("lsusb").split('\n')
+        devices = subprocess.check_output("lsusb").split('\n')
-            	resp+= "<div class='device' data-device='"+device+"'>"+device_name+"</div>\n"
+                resp += "<div class='device' data-device='"+device+"'>"+device_name+"</div>\n"
-from email import Encoders
+from email import encoders
-
+        _logger.debug(s)
-                Encoders.encode_base64(part)
+                encoders.encode_base64(part)
-    	""" When an invoice linked to a sales order selling registrations is
+        """ When an invoice linked to a sales order selling registrations is
-    for mod_name, mod_mod in pycompat.items(sys.modules):
+    for mod_name, mod_mod in list(pycompat.items(sys.modules)):
-        domain += [('product_id.active', '=', True)]
+        domain = self._get_orderpoint_domain(company_id=company_id)
-        pos_session = self.env['pos.session'].search([('state', '=', 'opened'), ('user_id', '=', self.env.uid)])
+        pos_session = self.env['pos.session'].search([('state', '=', 'opened'), ('user_id', '=', self.env.uid)], limit=1)
-                    _logger.error(e.message)
+                    _logger.error("%s", e)
-                qcontext['error'] = e.message or e.name
+                qcontext['error'] = str(e)
-                                raise ValueError(_("Column %s contains incorrect values. Error in line %d: %s") % (name, num + 1, ustr(e.message)))
+                                raise ValueError(_("Column %s contains incorrect values. Error in line %d: %s") % (name, num + 1, e))
-                                raise ValueError(_("Error Parsing Date [%s:L%d]: %s") % (name, num + 1, ustr(e.message)))
+                                raise ValueError(_("Error Parsing Date [%s:L%d]: %s") % (name, num + 1, e))
-                msg = e.message or (e.msg + '\n' + e.text)
+                msg = e
-                    _("The model configuration for the definition %s seems incorrect, please check it.\n\n%s not found") % (definition.name, e.message))
+                    _("The model configuration for the definition %s seems incorrect, please check it.\n\n%s not found") % (definition.name, e))
-                _logger.error("Can not get printer description: %s" % (e.message or repr(e)))
+                _logger.error("Can not get printer description: %s" % e)
-                        if error.message == IrMailServer.NO_VALID_RECIPIENT:
+                        if str(error) == IrMailServer.NO_VALID_RECIPIENT:
-            error = e.message.splitlines()[0].split('|')[-1] or ''
+            error = str(e).splitlines()[0].split('|')[-1] or ''
-            args = [False, e.message]
+            args = [False, str(e)]
-        return request.env['ir.actions.report'].get_wkhtmltopdf_state()
+        return request.env['ir.actions.report'].get_wkhtmltopdf_state()
-            return {'error': _('Internal server error, please try again later or contact administrator.\nHere is the error message: %s') % e.message}
+            return {'error': _('Internal server error, please try again later or contact administrator.\nHere is the error message: %s') % e}
-                return {'warning': {'title': _("Warning"), 'message': e.message}}
+                return {'warning': {'title': _("Warning"), 'message': e}}
-            return "console.error(%s);" % json.dumps(e.message)
+            return "console.error(%s);" % json.dumps(str(e))
-            self.bundle.css_errors.append(e.message)
+            self.bundle.css_errors.append(str(e))
-                self.raise_view_error("Can't validate view:\n%s" % (e.message or repr(e)), vid)
+                self.raise_view_error("Can't validate view:\n%s" % e, vid)
-            response = xmlrpclib.dumps(fault, allow_none=None, encoding=None)
+        info = sys.exc_info()
-        fault = xmlrpclib.Fault(odoo.tools.ustr(e.message), formatted_info)
+        fault = xmlrpclib.Fault(odoo.tools.ustr(e), formatted_info)
-        raise UserError('\n'.join([e.message for e in xml_errors.error_log]))
+        raise UserError('\n'.join(str(e) for e in xml_errors.error_log))
-                        raise "Should be never here, creation for OE is done before update !"
+                        raise AssertionError("Should be never here, creation for OE is done before update !")
-        raise to_type, message, tb
+        raise pycompat.reraise(to_type, to_type(message), tb)
-            raise "t-call-assets cannot contain children nodes"
+            raise SyntaxError("t-call-assets cannot contain children nodes")
-            if e[0] not in [errno.EINTR]:
+            if e.args[0] not in [errno.EINTR]:
-            if e[0] not in [errno.EINTR]:
+            if e.args[0] not in [errno.EINTR]:
-                    raise ParseError, (ustr(e), etree.tostring(rec).rstrip(), rec.getroottree().docinfo.URL, rec.sourceline), exc_info[2]
+                    pycompat.reraise(
-        raise ValueError, '"%s" while compiling\n%r' % (ustr(e), expr), exc_info[2]
+        pycompat.reraise(ValueError, ValueError('"%s" while compiling\n%r' % (ustr(e), expr)), exc_info[2])
-        raise ValueError, '%s: "%s" while evaluating\n%r' % (ustr(type(e)), ustr(e), expr), exc_info[2]
+        pycompat.reraise(ValueError, ValueError('%s: "%s" while evaluating\n%r' % (ustr(type(e)), ustr(e), expr)), exc_info[2])
-import pyPdf
+import PyPDF2
-                pdf = pyPdf.PdfFileReader(f)
+                pdf = PyPDF2.PdfFileReader(f, overwriteWarnings=False)
-from pyPdf import PdfFileWriter, PdfFileReader
+from PyPDF2 import PdfFileWriter, PdfFileReader
-        reader = PdfFileReader(pdfreport)
+        reader = PdfFileReader(pdfreport, overwriteWarnings=False)
-                        'pyPdf',
+                        'PyPDF2',
-        'pypdf',
+        'pypdf2',
-        pdfreport = file(document, 'rb')
+        pdfreport = open(document, 'rb')
-        # 'reduce',
+
-            exec sys.stdin in local_vars
+            exec(sys.stdin, local_vars)
-        self.leave_start_datetime = datetime.today() + relativedelta(weeks=0, days=1, weekday=0)
+        self.leave_start_datetime = datetime.today().replace(hour=7, minute=0) + relativedelta(weeks=0, days=1, weekday=0)
-                    if name not in existing_pages:
+                    if name not in existing_page_names:
-    employee_id = fields.Many2one('hr.employee', "Employee", default=_default_employee_id)
+    employee_id = fields.Many2one('hr.employee', "Employee")
-            employee_id = values.get('employee_id') or self.employee_id.id or self._default_employee_id().id
+            employee_id = values.get('employee_id') or self.employee_id.id or (self.env.user.employee_ids and self.env.user.employee_ids[0].id or False)
-from . import test_sale_service
+# -*- coding: utf-8 -*-
-                revenue = so_line.currency_id.compute(delivered_revenue, analytic_account.currency_id)  # amount from SO should be convert into analytic account currency
+                sale_price_unit = so_line.currency_id.compute(so_line.price_unit, analytic_account.currency_id)  # amount from SO should be convert into analytic account currency
-                total_revenue_so = so_line.currency_id.compute(total_revenue_so, analytic_account.currency_id)
+                sale_price_unit = so_line.currency_id.compute(so_line.price_unit, analytic_account.currency_id)
-                    so_line.currency_id.compute(unit_amount * (so_line.price_unit) * (1-so_line.discount), analytic_account.currency_id),
+                    analytic_account.currency_id.round(unit_amount * so_line.currency_id.compute(so_line.price_unit, analytic_account.currency_id) * (1-so_line.discount)),
-                                line_revenue = invoiced_price_per_hour * timesheet_line.unit_amount
+                                line_revenue = invoice_line.currency_id.compute(invoiced_price_per_hour, timesheet_line.company_currency_id) * timesheet_line.unit_amount
-                                line_revenue = invoice_line.price_subtotal - total_revenue
+                                line_revenue = invoice_line.currency_id.compute(invoice_line.price_subtotal, timesheet_line.company_currency_id) - total_revenue
-                                'timesheet_revenue': float_round(line_revenue, precision),
+                                'timesheet_revenue': timesheet_line.company_currency_id.round(line_revenue),
-                                'timesheet_revenue': float_round(line_revenue, precision),
+                                'timesheet_revenue': timesheet_line.company_currency_id.round(line_revenue),
-            :param target_currency: currency (browse_record or ID) you want the move line debit/credit converted into
+            :param target_currency: currency (Model or ID) you want the move line debit/credit converted into
-            :param browse_record chart_template: the account.chart.template record
+            :param BaseModel chart_template: the account.chart.template record
-        """ Extracts the input browse_record and fields list (with
+        """ Extracts the input BaseModel and fields list (with
-            :param browse_record partner: specific recipient partner
+            :param Model partner: specific recipient partner
-         - ``user``: browse_record of the current user
+         - ``user``: Model of the current user
-           :param campaign_rec: browse_record of campaign
+           :param Model record: to find duplicates workitems for.
-               the PO line is not yet attached to a PO.
+           :param Model seller: used to fetch the delivery delay (if no seller
-from odoo import http
+from odoo import http, models
-                if isinstance(value, browse_record):
+                if isinstance(value, models.BaseModel):
-        if not found and raise_if_not_found is False return None
+        """ Return a Model object, or ``None`` if ``raise_if_not_found`` is 
-        Converts the specified field of the browse_record ``record`` to HTML
+        Converts the specified field of the ``record`` to HTML
-        :returns: res.lang browse_record
+        :returns: Model[res.lang]
-        pass
+Command = CommandType('Command', (object,), {'run': lambda self, args: None})
-class Field(object):
+class Field(MetaField('DummyField', (object,), {})):
-    __metaclass__ = ControllerType
+Controller = ControllerType('Controller', (object,), {})
-                   Collector, LastOrderedSet, OrderedSet
+                   Collector, LastOrderedSet, OrderedSet, pycompat
-class BaseModel(object):
+class BaseModel(MetaModel('DummyModel', (object,), {'_register': False})):
-    __metaclass__ = MetaModel
+import warnings
-            return isinstance(inst, BaseModel) and not inst
+class BRM(type):
-        'views/product_view.xml',
+        'views/product_view.xml',
-from odoo import api, fields, models
+
-    @api.model
+    @api.multi
-        template = self.env.ref('report.view_company_report_form', False)
+        template = self.env.ref('base.view_company_report_form')
-            template = self.env.ref('report.view_company_report_form', False)
+            template = self.env.ref('base.view_company_report_form')
-            stream.close()
+        try:
-                record_ids = model.search(cr, SUPERUSER_ID, [('id', '=', res_id), (email_fname, 'ilike', email)], context=context)
+                ctx = dict(context or {}, active_test=False)
-            'timesheet_menu': self.env.ref('hr_timesheet_sheet.menu_act_hr_timesheet_sheet_form_my_current', raise_if_not_found=False),
+            'timesheet_menu': self.env.ref('hr_timesheet.timesheet_menu_root', raise_if_not_found=False),
-from . import report
+from . import report
-    'depends': ['hr_timesheet_sheet', 'hr_attendance'],
+    'depends': ['hr_timesheet', 'hr_attendance'],
-                           ('file', 'report_file'), ('report_type', 'report_type'), ('parser', 'parser')):
+        for field, dest in (('attachment', 'attachment'),
-    description = fields.Text('Private Note')
+    description = fields.Html('Private Note')
-            tax_ids = order.fiscal_position_id.map_tax(self.product_id.taxes_id).ids
+        taxes = self.product_id.taxes_id.filtered(lambda r: not order.company_id or r.company_id == order.company_id)
-            tax_ids = self.product_id.taxes_id.ids
+            tax_ids = taxes.ids
-                    tax_ids = order.fiscal_position_id.map_tax(self.product_id.taxes_id).ids
+                taxes = self.product_id.taxes_id.filtered(lambda r: not order.company_id or r.company_id == order.company_id)
-                    tax_ids = self.product_id.taxes_id.ids
+                    tax_ids = taxes.ids
-        for move in self.filtered(lambda move: not move.price_unit):
+        for move in self._set_default_price_moves():
-                        moves_to_cancel |= st_line.journal_entry_ids
+                        moves_to_cancel |= move
-    day_close = fields.Float(compute='_compute_day', string='Days to Close', store=True)
+    day_open = fields.Float(compute='_compute_day', string='Days to Assign', store=True, group_operator="avg")
-    working_hours_close = fields.Float(compute='_compute_day', string='Working Hours to close the Issue', store=True)
+    working_hours_open = fields.Float(compute='_compute_day', string='Working Hours to assign the Issue', store=True, group_operator="avg")
-    salary_expected = fields.Float("Expected Salary", help="Salary Expected by Applicant")
+    salary_proposed = fields.Float("Proposed Salary", group_operator="avg", help="Salary Proposed by the Organisation")
-        """ Parse a text response for a PDT verification .
+        """ Parse a text response for a PDT verification.
-            new_post['at'] = request.env['ir.config_parameter'].sudo().get_param('payment_paypal.pdt_token')
+            new_post['at'] = tx and tx.acquirer_id.paypal_pdt_token or ''
-        if resp == 'VERIFIED' or pdt_request and resp == 'SUCCESS':
+        if resp in ['VERIFIED', 'SUCCESS']:
-        elif resp == 'INVALID' or pdt_request and resp == 'FAIL':
+        elif resp in ['INVALID', 'FAIL']:
-    'depends': ['event', 'sale'],
+    'depends': ['event', 'sale_management'],
-    'depends': ['stock', 'sale', 'account'],
+    'depends': ['stock', 'sale_management', 'account'],
-    'depends': ['point_of_sale', 'sale'],
+    'depends': ['point_of_sale', 'sale_management'],
-    'depends': ['base', 'product', 'delivery', 'stock', 'sale', 'purchase'],
+    'depends': ['base', 'product', 'delivery', 'stock', 'sale_management', 'purchase'],
-    'version': '1.0',
+    'version': '1.1',
-    'summary': 'Quotations, Sales Orders, Invoicing',
+    'summary': 'Sales internal machinery',
-* Monthly Turnover (Graph)
+This module contains all the common features of Sales Management and eCommerce.
-    'depends': ['sales_team', 'account', 'procurement', 'web_tour'],
+    'depends': ['sales_team', 'account', 'procurement'],
-    'depends': ['sale', 'crm'],
+    'depends': ['sale_management', 'crm'],
-    'depends': ['sale', 'hr_expense'],
+    'depends': ['sale_management', 'hr_expense'],
-    'depends':['sale'],
+    'depends': ['sale_management'],
-    'depends': ['sale', 'stock_account'],
+    'depends': ['sale_management', 'stock_account'],
-    'depends': ['sale', 'hr_timesheet'],
+    'depends': ['sale_management', 'hr_timesheet'],
-    'depends': ['website', 'sale', 'mail', 'payment', 'website_portal_sale', 'website_mail'],
+    'depends': ['website', 'sale_management', 'mail', 'payment', 'website_portal_sale', 'website_mail'],
-
+            },
-        for num in pycompat.range(1, 100):
+        for num in range(1, 100):
-                for num in pycompat.range(1, 100):
+                for num in range(1, 100):
-        for st_line, datum in zip(self, data):
+        for st_line, datum in pycompat.izip(self, data):
-                aml_dict['tax_ids'] = map(lambda id: (4, id, None), aml_dict['tax_ids'])
+                aml_dict['tax_ids'] = [(4, id, None) for id in aml_dict['tax_ids']]
-            ('type', 'in', filter(None, map(TYPE2JOURNAL.get, inv_types))),
+            ('type', 'in', [TYPE2JOURNAL[ty] for ty in inv_types if ty in TYPE2JOURNAL]),
-        payment_lines = []
+        payment_lines = set()
-        self.payment_move_line_ids = self.env['account.move.line'].browse(list(set(payment_lines)))
+            payment_lines.update(line.mapped('matched_credit_ids.credit_move_id.id'))
-        for onchange_method, changed_fields in onchanges.items():
+        for onchange_method, changed_fields in pycompat.items(onchanges):
-            for tax in tax_grouped.values():
+            for tax in pycompat.values(tax_grouped):
-        for tax in taxes_grouped.values():
+        for tax in pycompat.values(taxes_grouped):
-            for key, val in line2.items():
+            for key, val in pycompat.items(line2):
-            for name, field in line._fields.iteritems():
+            for name, field in pycompat.items(line._fields):
-        res = map(lambda l: (l[0].name, l[1]), res)
+        res = sorted(pycompat.items(res), key=lambda l: l[0].sequence)
-            account_ids = tuple(filter(None, [self.default_debit_account_id.id, self.default_credit_account_id.id]))
+            account_ids = tuple(ac for ac in [self.default_debit_account_id.id, self.default_credit_account_id.id] if ac)
-        partial_rec_ids = [x.id for x in partial_rec_set.keys()]
+        partial_rec_ids = [x.id for x in partial_rec_set]
-        for key, value in generated_tax_res['account_dict'].items():
+        for key, value in pycompat.items(generated_tax_res['account_dict']):
-from odoo.tools import DEFAULT_SERVER_DATETIME_FORMAT
+from odoo.tools import DEFAULT_SERVER_DATETIME_FORMAT, pycompat
-        for key, acc in accounts.items():
+        for key, acc in list(pycompat.items(accounts)):
-        return [('id', 'in', map(itemgetter(0), res))]
+        return [('id', 'in', [r[0] for r in res])]
-        for partner, child_ids in all_partners_and_children.items():
+        for partner, child_ids in pycompat.items(all_partners_and_children):
-            if account.id in account_result.keys():
+            if account.id in account_result:
-        move_lines = dict(map(lambda x: (x, []), accounts.ids))
+        move_lines = {x: [] for x in accounts.ids}
-        ids = map(lambda x: x[0], self.env.cr.fetchall())
+        ids = (x[0] for x in self.env.cr.fetchall())
-        res = dict(map(lambda x:(x,[]), partner_ids))
+        res = {x: [] for x in partner_ids}
-            res[account.id] = dict((fn, 0.0) for fn in mapping.keys())
+            res[account.id] = dict.fromkeys(mapping, 0.0)
-            request = "SELECT account_id as id, " + ', '.join(mapping.values()) + \
+            request = "SELECT account_id as id, " + ', '.join(pycompat.values(mapping)) + \
-                for value in res[report.id]['account'].values():
+                for value in pycompat.values(res[report.id]['account']):
-                for value in res[report.id]['account'].values():
+                for value in pycompat.values(res[report.id]['account']):
-                for key, value in res2.items():
+                for key, value in pycompat.items(res2):
-                for key, value in res2.items():
+                for key, value in pycompat.items(res2):
-            for report_id, value in comparison_res.items():
+            for report_id, value in pycompat.items(comparison_res):
-                    for account_id, val in comparison_res[report_id].get('account').items():
+                    for account_id, val in pycompat.items(comparison_res[report_id].get('account')):
-                for account_id, value in res[report.id]['account'].items():
+                for account_id, value in pycompat.items(res[report.id]['account']):
-        self.assertEquals(sum([res['credit'] for res in result.values()]), 60.61)
+        self.assertEquals(sum(res['debit'] for res in pycompat.values(result)), 60.61)
-            self.assertEquals(aml.currency_id.id, line['currency_id'])
+            self.assertEquals(aml.currency_id.id, line['currency_id'])
-from odoo.tools import DEFAULT_SERVER_DATE_FORMAT as DF
+from odoo.tools import DEFAULT_SERVER_DATE_FORMAT as DF, pycompat
-            for k, v in vals['value'].iteritems():
+            for k, v in pycompat.items(vals['value']):
-            for name, values in tracked_values.iteritems():
+            for name, values in pycompat.items(tracked_values):
-            'domain': "[('id','in',[" + ','.join(map(str, created_move_ids)) + "])]",
+            'domain': "[('id','in',[" + ','.join(str(id) for id in created_move_ids) + "])]",
-            return [(col, item.get(col)) for col in cols if col in item.keys()]
+                cols = list(item)
-        for fname, fvalue in onchange_res['value'].iteritems():
+        for fname, fvalue in pycompat.items(onchange_res['value']):
-        if not len(vals.keys()) == 1 and vals.get('state') == 'clear':
+        if not len(vals) == 1 and vals.get('state') == 'clear':
-            ('target_version', '=', '.'.join(map(str, version_info[:2])))
+            ('target_version', '=', '.'.join(str(v) for v in version_info[:2]))
-                for k, v in token_infos.items():
+                for k, v in pycompat.items(token_infos):
-        assert values.values(), "The form was not properly filled in."
+        assert values, "The form was not properly filled in."
-    return ''.join(random.SystemRandom().choice(chars) for _ in pycompat.range(20))
+    return ''.join(random.SystemRandom().choice(chars) for _ in range(20))
-
+from odoo.tools import pycompat
-            for k, v in vals.items():
+            for k, v in pycompat.items(vals):
-                        self.update({key: val for key, val in res['value'].iteritems() if key in self._fields})
+                        self.update({key: val for key, val in pycompat.items(res['value']) if key in self._fields})
-            for t_id, job in jobs.items():
+            for t_id, job in pycompat.items(jobs):
-                                              country])))
+    return tools.ustr(', '.join(
-from odoo.tools import DEFAULT_SERVER_DATE_FORMAT, DEFAULT_SERVER_DATETIME_FORMAT
+from odoo.tools import DEFAULT_SERVER_DATE_FORMAT, DEFAULT_SERVER_DATETIME_FORMAT, pycompat
-    for mime, (ext, handler, req) in FILE_TYPE_DICT.iteritems()
+    for mime, (ext, handler, req) in pycompat.items(FILE_TYPE_DICT)
-        for name, field in model_fields.iteritems():
+        for name, field in pycompat.items(model_fields):
-                           for attr, value in itertools.chain.from_iterable(states.itervalues())):
+                           for attr, value in itertools.chain.from_iterable(pycompat.values(states))):
-        for row in itertools.imap(sheet.row, range(sheet.nrows)):
+        for row in pycompat.imap(sheet.row, range(sheet.nrows)):
-        import_fields = filter(None, fields)
+        import_fields = [f for f in fields if f]
-            list(row) for row in itertools.imap(mapper, rows_to_import)
+            list(row) for row in pycompat.imap(mapper, rows_to_import)
-        split_value = filter(None, float_regex.split(value))
+        split_value = [g for g in float_regex.split(value) if g]
-        for name, field in all_fields.iteritems():
+        for name, field in pycompat.items(all_fields):
-        return next(iter(self.SHEETS.itervalues()))
+        return next(iter(pycompat.values(self.SHEETS)))
-        self.assertItemsEqual(result.keys(), ['matches', 'headers', 'fields', 'preview', 'headers_type', 'options', 'advanced_mode', 'debug'])
+        self.assertItemsEqual(list(result), ['matches', 'headers', 'fields', 'preview', 'headers_type', 'options', 'advanced_mode', 'debug'])
-        self.assertItemsEqual(result.keys(), ['matches', 'headers', 'fields', 'preview', 'headers_type', 'options', 'advanced_mode', 'debug'])
+        self.assertItemsEqual(list(result), ['matches', 'headers', 'fields', 'preview', 'headers_type', 'options', 'advanced_mode', 'debug'])
-        self.assertItemsEqual(result.keys(), ['matches', 'headers', 'fields', 'preview', 'headers_type', 'options','advanced_mode', 'debug'])
+        self.assertItemsEqual(list(result), ['matches', 'headers', 'fields', 'preview', 'headers_type', 'options','advanced_mode', 'debug'])
-        self.assertItemsEqual(result.keys(), ['matches', 'headers', 'fields', 'preview', 'headers_type', 'options', 'advanced_mode', 'debug'])
+        self.assertItemsEqual(list(result), ['matches', 'headers', 'fields', 'preview', 'headers_type', 'options', 'advanced_mode', 'debug'])
-from odoo.tools import convert_file, exception_to_unicode
+from odoo.tools import convert_file, exception_to_unicode, pycompat
-        for mod, error in errors.items():
+        for mod, error in pycompat.items(errors):
-        ids = map(itemgetter(0), self._cr.fetchall())
+        ids = (row[0] for row in self._cr.fetchall())
-            num = filter(lambda s: s.isdigit(), match.group(1))        # get the digits only
+            num = [s for s in match.group(1) if s.isdigit()]        # get the digits only
-        res = filter(None, calendar_id.split('-'))
+        res = [bit for bit in calendar_id.split('-') if bit]
-            email = filter(lambda x: x.__contains__('@'), common_nameval)  # TODO JEM : should be refactored
+            email = [x for x in common_nameval if '@' in x] # TODO JEM : should be refactored
-        for meeting in self.env['calendar.event'].browse(all_meetings.keys()):
+        for meeting in self.env['calendar.event'].browse(all_meetings):
-    interval = fields.Selection(list(_interval_selection.iteritems()), 'Unit', required=True, default='hours')
+    interval = fields.Selection(list(pycompat.items(_interval_selection)), 'Unit', required=True, default='hours')
-        return zip(start_dates, stop_dates)
+        return list(pycompat.izip(start_dates, stop_dates))
-        if date_field in self._fields.keys() and self._fields[date_field].type in ('date', 'datetime'):
+        if date_field in self._fields and self._fields[date_field].type in ('date', 'datetime'):
-            for i in pycompat.range(0, 7):
+            for i in range(0, 7):
-        real = self.browse(set(id_map.values()))
+        real = self.browse(set(pycompat.values(id_map)))
-        real = self.browse(set(id_map.values()))
+        real = self.browse(set(pycompat.values(id_map)))
-        real = self.browse(set({x: calendar_id2real_id(x) for x in self.ids}.values()))
+        real = self.browse({calendar_id2real_id(x) for x in self.ids})
-        select = map(lambda x: (x, calendar_id2real_id(x)), self.ids)
+        select = [(x, calendar_id2real_id(x)) for x in self.ids]
-                for f in r.keys():
+                for f in r:
-                    args[index] = (args[index][0], args[index][1], map(lambda x: get_real_ids(x), args[index][2]))
+                    args[index] = (args[index][0], args[index][1], [get_real_ids(x) for x in args[index][2]])
-            for virtual_id in self.env[doc_model].browse(doc_dict.keys()).get_recurrent_ids([], order=order):
+            for virtual_id in self.env[doc_model].browse(doc_dict).get_recurrent_ids([], order=order):
-                data[field_name] = _concat_all(field_name, self)  # contact field of all opportunities
+                data[field_name] = '\n\n'.join(it for it in self.mapped(field_name) if it)
-
+from odoo.tools import mute_logger, pycompat
-        for column, field in model_fields.iteritems():
+        for column, field in pycompat.items(model_fields):
-            for model, field in models.iteritems()
+            for model, field in pycompat.items(models)
-        data.update({key: registration[key] for key in registration.keys() if key in self._fields})
+        data.update({key: value for key, value in pycompat.items(registration) if key in self._fields})
-                lines.append((0, 0, {'registration_id': registration.id}))
+            lines = [
-        for vehicle, value in res.items():
+        for vehicle, value in pycompat.items(res):
-        for definition, goals in goals_by_definition.items():
+        for definition, goals in pycompat.items(goals_by_definition):
-                    for (start_date, end_date), query_goals in subqueries.items():
+                    for (start_date, end_date), query_goals in pycompat.items(subqueries):
-                        subquery_domain.append((field_name, 'in', list(set(query_goals.values()))))
+                        subquery_domain.append((field_name, 'in', list(set(pycompat.values(query_goals)))))
-            for goal, values in goals_to_write.iteritems():
+            for goal, values in pycompat.items(goals_to_write):
-        if (set(values.keys()) and sync_fields) and 'oe_update_date' not in values.keys() and 'NewMeeting' not in self._context:
+        if (set(values) and sync_fields) and 'oe_update_date' not in values and 'NewMeeting' not in self._context:
-from odoo.tools import exception_to_unicode
+from odoo.tools import exception_to_unicode, pycompat
-                     if not callable(v))
+        methods = {k: v for k, v in pycompat.items(attrs)
-            for key, val in attrs.iteritems():
+            for key, val in pycompat.items(attrs):
-            for key, val in kw.iteritems():
+            for key, val in pycompat.items(kw):
-
+Struct = Meta('Struct', (object,), {})
-        for key, val in kw.items():
+        for key, val in pycompat.items(kw):
-                ('google_internal_event_id', 'in', all_event_from_google.keys())
+                ('google_internal_event_id', 'in', pycompat.keys(all_event_from_google))
-        for event in all_event_from_google.values():
+        for event in pycompat.values(all_event_from_google):
-            event_to_synchronize[base_event] = sorted(event_to_synchronize[base_event].iteritems(), key=operator.itemgetter(0))
+            event_to_synchronize[base_event] = sorted(pycompat.items(event_to_synchronize[base_event]), key=operator.itemgetter(0))
-
+from odoo.tools import pycompat
-        for name, field in self._fields.items():
+        for name, field in pycompat.items(self._fields):
-from odoo.tools import email_split, float_is_zero
+from odoo.tools import email_split, float_is_zero, pycompat
-            lines = map(lambda x: (0, 0, expense._prepare_move_line(x)), move_lines)
+            lines = [(0, 0, expense._prepare_move_line(x)) for x in move_lines]
-        for move in move_group_by_sheet.values():
+        for move in pycompat.values(move_group_by_sheet):
-            return map(int, leaves.sorted(key=sort_key, reverse=True))
+            return leaves.sorted(key=sort_key, reverse=True).ids
-            res += [attendances] + leaves.values()
+            res.append(attendances)
-        return [value for code, value in result_dict.items()]
+        return [value for code, value in pycompat.items(result_dict)]
-                'input_line_ids': map(lambda x: (2, x,), self.input_line_ids.ids),
+                'input_line_ids': [(2, x,) for x in self.input_line_ids.ids],
-                'worked_days_line_ids': map(lambda x: (2, x,), self.worked_days_line_ids.ids),
+                'worked_days_line_ids': [(2, x,) for x in self.worked_days_line_ids.ids],
-            for payslip_id, lines_dict in result.iteritems():
+            for payslip_id, lines_dict in pycompat.items(result):
-                for rule_categ_id, line_ids in lines_dict.iteritems():
+                for rule_categ_id, line_ids in pycompat.items(lines_dict):
-        for payslip_id, lines_dict in result.iteritems():
+        for payslip_id, lines_dict in pycompat.items(result):
-            for register, lines in lines_dict.iteritems():
+            for register, lines in pycompat.items(lines_dict):
-            for key, value in self._onchange_job_id_internal(job_id)['value'].iteritems():
+            for key, value in pycompat.items(self._onchange_job_id_internal(job_id)['value']):
-        high_level_message_bytes = map(ord, high_level_message)
+        high_level_message_bytes = (ord(b) for b in high_level_message)
-        ordered_cmds = sorted(self.cmds.keys(), key=lambda x: self.cmds[x]['_order'])
+        ordered_cmds = sorted(self.cmds, key=lambda x: self.cmds[x]['_order'])
-                        encoding = remaining.items()[0][0]
+                        (encoding, _) = remaining.popitem()
-            total = sum(repartition.values())
+            total = sum(pycompat.values(repartition))
-        return channel_infos_dict.values()
+        return list(pycompat.values(channel_infos_dict))
-        for category_name, amount in salaries.items():
+        for category_name, amount in pycompat.items(salaries):
-
+from odoo.tools import pycompat
-        keys = map(lambda c: c.value, self.sheet_tax_codes.row(0))
+        keys = [c.value for c in self.sheet_tax_codes.row(0)]
-            d =  OrderedDict(zip(keys, row))
+            row = (c.value for c in self.sheet_tax_codes.row(i))
-        keys = map(lambda c: c.value, self.sheet_taxes.row(0))
+        keys = [c.value for c in self.sheet_taxes.row(0)]
-            yield OrderedDict(zip(keys, row))
+            row = (c.value for c in self.sheet_taxes.row(i))
-        keys = map(lambda c: c.value, self.sheet_fiscal_pos_map.row(0))
+        keys = [c.value for c in self.sheet_fiscal_pos_map.row(0)]
-            yield OrderedDict(zip(keys, row))
+            row = (c.value for c in self.sheet_fiscal_pos_map.row(i))
-        tax_codes_iterator = self.iter_tax_codes()
+        tax_codes_iterator = self.iter_tax_codes
-            writer.writerow(map(_e, row.values()))
+            writer.writerow(pycompat.imap(_e, pycompat.values(row)))
-            writer.writerow(map(_e, row.values()[3:]) + [cur_seq])
+            writer.writerow(list(pycompat.imap(_e, list(pycompat.values(row))[3:])) + [cur_seq])
-            writer.writerow(map(_e, row.values()))
+            writer.writerow(pycompat.imap(_e, pycompat.values(row)))
-from odoo.tools import ustr
+from odoo.tools import ustr, pycompat
-        for fname, value in create_vals.iteritems():
+        for fname, value in pycompat.items(create_vals):
-        return {
+        return list(pycompat.values({
-        }.values()
+        }))
-        self.previous_order_ids = {
+        self.previous_order_ids = list(pycompat.values({
-        }.values()
+        }))
-for k in unifiable.keys():
+for k in unifiable:
-    if not UNICODE_SNOB and c in unifiable_n.keys():
+    if not UNICODE_SNOB and c in unifiable_n:
-    if not UNICODE_SNOB and c in unifiable.keys():
+    if not UNICODE_SNOB and c in unifiable:
-                for abbr, definition in self.abbr_list.items():
+                for abbr, definition in pycompat.items(self.abbr_list):
-from odoo.tools import ormcache
+from odoo.tools import ormcache, pycompat
-        last_messages = self.env['mail.message'].browse(channels_preview.keys()).message_format()
+        last_messages = self.env['mail.message'].browse(channels_preview).message_format()
-        return channels_preview.values()
+        return list(pycompat.values(channels_preview))
-        force_mode = force or (all(data for data in partner_data.values()) and all(data for data in channel_data.values()))
+        force_mode = force or (all(data for data in pycompat.values(partner_data)) and all(data for data in pycompat.values(channel_data)))
-            '|', ('partner_id', 'in', partner_data.keys()), ('channel_id', 'in', channel_data.keys())])
+            '|', ('partner_id', 'in', list(partner_data)), ('channel_id', 'in', list(channel_data))])
-            for pid, data in partner_data.iteritems():
+            employee_pids = self.env['res.users'].sudo().search([('partner_id', 'in', list(partner_data)), ('share', '=', False)]).mapped('partner_id').ids
-            for cid, data in channel_data.iteritems():
+            for cid, data in pycompat.items(channel_data):
-        gen_new_cids = [cid for cid in channel_data.keys() if cid not in c_exist]
+        gen_new_pids = [pid for pid in partner_data if pid not in p_exist]
-                new_cids = set(channel_data.keys()) - set([sub.channel_id.id for sub in doc_followers if sub.channel_id]) - set(gen_new_cids)
+                new_pids = set(partner_data) - set([sub.partner_id.id for sub in doc_followers if sub.partner_id]) - set(gen_new_pids)
-        for server_id, record_ids in groups.iteritems():
+        for server_id, record_ids in pycompat.items(groups):
-
+from odoo.tools import pycompat
-        for key, message in message_tree.iteritems():
+        for key, message in pycompat.items(message_tree):
-        doc_ids = doc_dict.keys()
+        doc_ids = list(doc_dict)
-        for doc_model, doc_dict in model_ids.iteritems():
+        for doc_model, doc_dict in pycompat.items(model_ids):
-            author_ids = [mid for mid, message in message_values.iteritems()
+            author_ids = [mid for mid, message in pycompat.items(message_values)
-            author_ids = [mid for mid, message in message_values.iteritems()
+            author_ids = [mid for mid, message in pycompat.items(message_values)
-            parent_ids = [message.get('parent_id') for mid, message in message_values.iteritems()
+            parent_ids = [message.get('parent_id') for mid, message in pycompat.items(message_values)
-            notified_ids += [mid for mid, message in message_values.iteritems()
+            notified_ids += [mid for mid, message in pycompat.items(message_values)
-            notified_ids = [mid for mid, message in message_values.iteritems() if message.get('notified')]
+            notified_ids = [mid for mid, message in pycompat.items(message_values) if message.get('notified')]
-            for doc_model, doc_ids in model_record_ids.items():
+            for doc_model, doc_ids in pycompat.items(model_record_ids):
-                notified_ids += [mid for mid, message in message_values.iteritems()
+                notified_ids += [mid for mid, message in pycompat.items(message_values)
-        for model, doc_ids in model_record_ids.items():
+        for model, doc_ids in pycompat.items(model_record_ids):
-            document_related_ids += [mid for mid, message in message_values.iteritems()
+            document_related_ids += [mid for mid, message in pycompat.items(message_values)
-        records = self.env[model].browse(filter(None, res_ids))  # filter to avoid browsing [None]
+        records = self.env[model].browse(it for it in res_ids if it)  # filter to avoid browsing [None]
-        for res_id, record in res_to_rec.iteritems():
+        for res_id, record in pycompat.items(res_to_rec):
-            for res_id, result in results.iteritems():
+            for res_id, result in pycompat.items(results):
-        for res_id, lang in langs.iteritems():
+        for res_id, lang in pycompat.items(langs):
-            for res_id, recipients in default_recipients.iteritems():
+            for res_id, recipients in pycompat.items(default_recipients):
-        for res_id, values in results.iteritems():
+        for res_id, values in pycompat.items(results):
-        for res_id, template in res_ids_to_templates.iteritems():
+        for res_id, template in pycompat.items(res_ids_to_templates):
-        for template, template_res_ids in templates_to_res_ids.iteritems():
+        for template, template_res_ids in pycompat.items(templates_to_res_ids):
-                for res_id, field_value in generated_field_values.iteritems():
+                for res_id, field_value in pycompat.items(generated_field_values):
-        for key, val in self._context.iteritems():
+        for key, val in pycompat.items(self._context):
-        thread.message_auto_subscribe(create_values.keys(), values=create_values)
+        thread.message_auto_subscribe(list(create_values), values=create_values)
-            tracked_fields = track_thread._get_tracked_fields(values.keys())
+            tracked_fields = track_thread._get_tracked_fields(list(values))
-            tracked_fields = track_self._get_tracked_fields(values.keys())
+            tracked_fields = track_self._get_tracked_fields(list(values))
-        self.message_auto_subscribe(values.keys(), values=values)
+        self.message_auto_subscribe(list(values), values=values)
-        for name, field in self._fields.items():
+        for name, field in pycompat.items(self._fields):
-        if not any(change for rec_id, (change, tracking_value_ids) in tracking.iteritems()):
+        if not any(change for rec_id, (change, tracking_value_ids) in pycompat.items(tracking)):
-        for field_name, (template, post_kwargs) in templates.iteritems():
+        for field_name, (template, post_kwargs) in pycompat.items(templates):
-        for col_name, col_info in tracked_fields.items():
+        for col_name, col_info in pycompat.items(tracked_fields):
-        token = '%s?%s' % (base_link, ' '.join('%s=%s' % (key, params[key]) for key in sorted(params.keys())))
+        token = '%s?%s' % (base_link, ' '.join('%s=%s' % (key, params[key]) for key in sorted(params)))
-                         for ng_res in self.env[model_name].sudo().browse(aliases.keys()).name_get()))
+                         for ng_res in self.env[model_name].sudo().browse(aliases).name_get()))
-            left_ids = set(res_ids).difference(set(aliases.keys()))
+            left_ids = set(res_ids).difference(set(aliases))
-            for res_id in aliases.keys():
+            for res_id in aliases:
-        left_ids = set(res_ids).difference(set(aliases.keys()))
+        left_ids = set(res_ids).difference(set(aliases))
-        for model_name, model in self.env.iteritems():
+        for model_name, model in pycompat.items(self.env):
-        return filter(lambda x: x, self._find_partner_from_emails(tools.email_split(s)))
+        return [x for x in self._find_partner_from_emails(tools.email_split(s)) if x]
-                partner_to_subscribe = filter(lambda item: item in self._context.get('mail_post_autofollow_partner_ids'), partner_ids)
+                partner_to_subscribe = [p for p in partner_ids if p in self._context.get('mail_post_autofollow_partner_ids')]
-        for name, field in self._fields.items():
+        for name, field in pycompat.items(self._fields):
-        for pid, subtypes in new_partners.items():
+        for pid, subtypes in pycompat.items(new_partners):
-        for cid, subtypes in new_channels.items():
+        for cid, subtypes in pycompat.items(new_channels):
-        for email_type, recipient_template_values in recipients.iteritems():
+        for email_type, recipient_template_values in pycompat.items(recipients):
-                         set([self.mt_mg_nodef.id, self.mt_al_nodef.id]))
+        items = [it[2] for it in generic]
-        self.assertEqual(specific.keys(), [self.test_public.id])
+        self.assertEqual(list(specific), [self.test_public.id])
-            [result.pop(field, None) for field in result.keys() if field not in fields]
+            [result.pop(field, None) for field in list(result) if field not in fields]
-            author_ids = [mid for mid, message in message_values.iteritems()
+            author_ids = [mid for mid, message in pycompat.items(message_values)
-                for res_id, mail_values in all_mail_values.iteritems():
+                for res_id, mail_values in pycompat.items(all_mail_values):
-        for fname, value in values.iteritems():
+        for fname, value in pycompat.items(values):
-        for model, id_map in workitem_map.iteritems():
+        for model, id_map in pycompat.items(workitem_map):
-            condition = [('id', 'in', id_map.keys()), condition_name]
+            condition = [('id', 'in', list(id_map)), condition_name]
-                res = filter(lambda x: x['stage_id'] == (state_value, state_name), read_group_res)
+                res = [x for x in read_group_res if x['stage_id'] == (state_value, state_name)]
-                    res = filter(lambda x: x['stage_id'] == state_value, read_group_all_states)
+                    res = [x for x in read_group_all_states if x['stage_id'] == state_value]
-                self.mailing_domain = "[('list_ids', 'in', [%s]), ('opt_out', '=', False)]" % (','.join(map(str,self.contact_list_ids.ids)),)
+                self.mailing_domain = "[('list_ids', 'in', [%s]), ('opt_out', '=', False)]" % (','.join(str(id) for id in self.contact_list_ids.ids),)
-                res = filter(lambda x: x['state'] == state_value, read_group_res)
+                res = [x for x in read_group_res if x['state'] == state_value]
-                    res = filter(lambda x: x['state'] == state_value, read_group_all_states)
+                    res = [x for x in read_group_all_states if x['state'] == state_value]
-            workcenter.workorder_count = sum(count for state, count in result[workcenter.id].items() if state not in ('done', 'cancel'))
+            workcenter.workorder_count = sum(count for state, count in pycompat.items(result[workcenter.id]) if state not in ('done', 'cancel'))
-            count = dict(map(lambda x: (x['picking_type_id'] and x['picking_type_id'][0], x['picking_type_id_count']), data))
+            count = {x['picking_type_id'] and x['picking_type_id'][0]: x['picking_type_id_count'] for x in data}
-            res['consume_line_ids'] = map(lambda x: (0,0,x), lines) + map(lambda x:(4, x), existing_lines)
+            res['consume_line_ids'] = [(0,0,x) for x in lines] + [(4, x) for x in existing_lines]
-            'domain': [('id', 'in', new_invoice.values())],
+            'domain': [('id', 'in', list(pycompat.values(new_invoice)))],
-from odoo.tools import html2plaintext
+from odoo.tools import html2plaintext, pycompat
-        for k, field in self._fields.iteritems():
+        for k, field in pycompat.items(self._fields):
-        for k, v in vals.items():
+        for k, v in list(pycompat.items(vals)):
-        for k, field in self._fields.iteritems():
+        for k, field in pycompat.items(self._fields):
-from odoo.tools import consteq, float_round, image_resize_images, ustr
+from odoo.tools import consteq, float_round, image_resize_images, ustr, pycompat
-            if any(getattr(f, 'required_if_provider', None) == acquirer.provider and not acquirer[k] for k, f in self._fields.items()):
+            if any(getattr(f, 'required_if_provider', None) == acquirer.provider and not acquirer[k] for k, f in pycompat.items(self._fields)):
-                fields_wl = set(self._fields.keys()) & set(values.keys())
+                fields_wl = set(self._fields) & set(values)
-            signing_string = ':'.join(map(escapeVal, parms.keys() + parms.values()))
+            signing_string = ':'.join(
-        raw_values_ordered = OrderedDict(sorted(raw_values.items(), key=lambda t: t[0]))
+        raw_values_ordered = OrderedDict(sorted(pycompat.items(raw_values), key=lambda t: t[0]))
-            messages = map(lambda m: m.text, response.findall('messages/message/text'))
+            messages = [m.text for m in response.findall('messages/message/text')]
-from odoo.tools import mute_logger
+from odoo.tools import mute_logger, pycompat
-            values = el.values()
+            values = list(pycompat.values(el.attrib))
-        post = dict((key.upper(), value) for key, value in post.items())
+        post = {key.upper(): value for key, value in pycompat.items(post)}
-    return dict((key.upper(), val) for key, val in data.items())
+    return {key.upper(): val for key, val in pycompat.items(data)}
-            for key in values.keys():
+            for key in list(values):
-            items = sorted(values.items(), key=lambda pair: pair[0].lower())
+            items = sorted(pycompat.items(values), key=lambda pair: pair[0].lower())
-        items = sorted((k.upper(), v) for k, v in values.items())
+        items = sorted((k.upper(), v) for k, v in pycompat.items(values))
-        lines = filter(None, response.split('\n'))
+        lines = [line for line in response.split('\n') if line]
-from odoo.tools import float_is_zero
+from odoo.tools import float_is_zero, pycompat
-                for group_key, group_value in grouped_data.iteritems():
+                for group_key, group_value in pycompat.items(grouped_data):
-        for group_key, group_data in grouped_data.iteritems():
+        for group_key, group_data in pycompat.items(grouped_data):
-                pack_operation.write({'pack_lot_ids': map(lambda x: (0, 0, x), pack_lots), 'qty_done': qty_done})
+                pack_operation.write({'pack_lot_ids': [(0, 0, x) for x in pack_lots], 'qty_done': qty_done})
-            'taxes': taxes.values(),
+            'taxes': list(pycompat.values(taxes)),
-            } for (product, price_unit, discount), qty in products_sold.items()], key=lambda l: l['product_name'])
+            } for (product, price_unit, discount), qty in pycompat.items(products_sold)], key=lambda l: l['product_name'])
-            not_invoiced_orders_names = list(map(lambda a: a.name, not_invoiced_posorders))
+            not_invoiced_orders_names = [a.name for a in not_invoiced_posorders]
-        vals = ProductPricelistItem.default_get(ProductPricelistItem._fields.keys())
+        vals = ProductPricelistItem.default_get(list(ProductPricelistItem._fields))
-            for product_id, price in subres.items():
+            for product_id, price in pycompat.items(subres):
-        categ_ids = categ_ids.keys()
+        categ_ids = list(categ_ids)
-        return dict((product_id, res_tuple[0]) for product_id, res_tuple in self._compute_price_rule(zip(products, quantities, partners), date=date, uom_id=uom_id).iteritems())
+        return {
-        return dict((key, price[0]) for key, price in self.price_rule_get(prod_id, qty, partner=partner).items())
+        return {key: price[0] for key, price in pycompat.items(self.price_rule_get(prod_id, qty, partner=partner))}
-        return pricelist.get_products_price(zip(**products_by_qty_by_partner))
+        return pricelist.get_products_price(
-        return sorted([data['form'][key] for key in data['form'].keys() if key.startswith('qty') and data['form'][key]])
+        return sorted([data['form'][key] for key in data['form'] if key.startswith('qty') and data['form'][key]])
-        res = dict.fromkeys(mapped_fields.keys(), False)
+        res = dict.fromkeys(mapped_fields, False)
-            for field in mapped_fields.keys():
+            for field in mapped_fields:
-        for d in dates.keys():
+        for d in dates:
-        for field, value in dates_dict.items():
+        for field, value in pycompat.items(dates_dict):
-                for l in res_val[key].keys():
+            for key in res_val:
-            for k, v in res[val.id].items():
+            for k, v in pycompat.items(res[val.id]):
-        return filter(lambda x: x.split('@')[0] not in aliases, email_list)
+        return [x for x in email_list if x.split('@')[0] not in aliases]
-        partner_ids = filter(None, task._find_partner_from_emails(email_list, force_create=False))
+        partner_ids = [p for p in task._find_partner_from_emails(email_list, force_create=False) if p]
-        partner_ids = filter(None, self._find_partner_from_emails(email_list, force_create=False))
+        partner_ids = [p for p in self._find_partner_from_emails(email_list, force_create=False) if p]
-            current_objects = filter(None, headers.get('X-Odoo-Objects', '').split(','))
+            current_objects = [h for h in headers.get('X-Odoo-Objects', '').split(',') if h]
-        return filter(lambda x: x.split('@')[0] not in self.mapped('project_id.alias_name'), email_list)
+        return [x for x in email_list if x.split('@')[0] not in self.mapped('project_id.alias_name')]
-        partner_ids = filter(None, issue._find_partner_from_emails(email_list))
+        partner_ids = [p for p in issue._find_partner_from_emails(email_list) if p]
-        partner_ids = filter(None, self._find_partner_from_emails(email_list))
+        partner_ids = [p for p in self._find_partner_from_emails(email_list) if p]
-            current_objects = filter(None, headers.get('X-Odoo-Objects', '').split(','))
+            current_objects = [h for h in headers.get('X-Odoo-Objects', '').split(',') if h]
-            result['domain'] = "[('id','in',[" + ','.join(map(str, pick_ids)) + "])]"
+            result['domain'] = "[('id','in',[" + ','.join(str(id) for id in pick_ids) + "])]"
-            rating_number = sum(values.values())
+            rating_number = sum(pycompat.values(values))
-            project.percentage_satisfaction_project = activity['great'] * 100 / sum(activity.values()) if sum(activity.values()) else -1
+            project.percentage_satisfaction_project = activity['great'] * 100 / sum(pycompat.values(activity)) if sum(pycompat.values(activity)) else -1
-        self.percentage_satisfaction_task = activity['great'] * 100 / sum(activity.values()) if sum(activity.values()) else -1
+        self.percentage_satisfaction_task = activity['great'] * 100 / sum(pycompat.values(activity)) if sum(pycompat.values(activity)) else -1
-                activity_sum = sum(activity_task.values())
+                activity_sum = sum(pycompat.values(activity_task))
-                activity_sum += sum(activity_issue.values())
+                activity_sum += sum(pycompat.values(activity_issue))
-        self.percentage_satisfaction_issue = activity['great'] * 100 / sum(activity.values()) if sum(activity.values()) else -1
+        self.percentage_satisfaction_issue = activity['great'] * 100 / sum(pycompat.values(activity)) if sum(pycompat.values(activity)) else -1
-        return list(set(map(int, (self.attendance_ids.mapped('dayofweek')))))
+        return list({int(d) for d in self.attendance_ids.mapped('dayofweek')})
-        return sum(map(lambda i: float(i.hour_to) - float(i.hour_from), attendances))
+        return sum(float(i.hour_to) - float(i.hour_from) for i in attendances)
-                for name, field in line._fields.iteritems():
+                for name, field in pycompat.items(line._fields):
-            partner_ids = [partner_ids.get('id')] + partner_ids.get('child_ids')
+            item = next(p for p in partner_child_ids if p['id'] == partner.id)
-from odoo.tools import float_is_zero, float_compare, DEFAULT_SERVER_DATETIME_FORMAT
+from odoo.tools import float_is_zero, float_compare, DEFAULT_SERVER_DATETIME_FORMAT, pycompat
-        for invoice in invoices.values():
+        for invoice in pycompat.values(invoices):
-        return [inv.id for inv in invoices.values()]
+        return [inv.id for inv in pycompat.values(invoices)]
-        res = map(lambda l: (l[0].name, l[1]), res)
+        res = sorted(pycompat.items(res), key=lambda l: l[0].sequence)
-        for line, qty in lines.items():
+        for line, qty in pycompat.items(lines):
-            'order_line': [(0, 0, {'name': p.name, 'product_id': p.id, 'product_uom_qty': 2, 'product_uom': p.uom_id.id, 'price_unit': p.list_price}) for (_, p) in self.products.iteritems()],
+            'order_line': [(0, 0, {'name': p.name, 'product_id': p.id, 'product_uom_qty': 2, 'product_uom': p.uom_id.id, 'price_unit': p.list_price}) for (_, p) in pycompat.items(self.products)],
-        self.assertEqual(so.amount_total, sum([2 * p.list_price for (k, p) in self.products.iteritems()]), 'Sale: total amount is wrong')
+        self.assertEqual(so.amount_total, sum([2 * p.list_price for (k, p) in pycompat.items(self.products)]), 'Sale: total amount is wrong')
-        self.assertEqual(inv.amount_total, sum([2 * p.list_price if p.invoice_policy == 'order' else 0 for (k, p) in self.products.iteritems()]), 'Sale: invoice total amount is wrong')
+        self.assertEqual(inv.amount_total, sum([2 * p.list_price if p.invoice_policy == 'order' else 0 for (k, p) in pycompat.items(self.products)]), 'Sale: invoice total amount is wrong')
-        self.assertEqual(inv.amount_total, sum([2 * p.list_price if p.invoice_policy == 'delivery' else 0 for (k, p) in self.products.iteritems()]), 'Sale: second invoice total amount is wrong')
+        self.assertEqual(inv.amount_total, sum([2 * p.list_price if p.invoice_policy == 'delivery' else 0 for (k, p) in pycompat.items(self.products)]), 'Sale: second invoice total amount is wrong')
-            'order_line': [(0, 0, {'name': p.name, 'product_id': p.id, 'product_uom_qty': 2, 'product_uom': p.uom_id.id, 'price_unit': p.list_price}) for (_, p) in self.products.iteritems()],
+            'order_line': [(0, 0, {'name': p.name, 'product_id': p.id, 'product_uom_qty': 2, 'product_uom': p.uom_id.id, 'price_unit': p.list_price}) for (_, p) in pycompat.items(self.products)],
-        self.assertTrue(prod_exp_1 in map(lambda so: so.product_id, so.order_line), 'Sale Expense: expense product should be in so')
+        self.assertIn(prod_exp_1, so.mapped('order_line.product_id'), 'Sale Expense: expense product should be in so')
-        self.assertTrue(prod_exp_2 in map(lambda so: so.product_id, so.order_line), 'Sale Expense: expense product should be in so')
+        self.assertIn(prod_exp_2, so.mapped('order_line.product_id'), 'Sale Expense: expense product should be in so')
-        for procurement_id, production_id in res.items():
+        for procurement_id, production_id in pycompat.items(res):
-                    for product_id in components.keys():
+                    for product_id in components:
-            'order_line': [(0, 0, {'name': p.name, 'product_id': p.id, 'product_uom_qty': 2, 'product_uom': p.uom_id.id, 'price_unit': p.list_price}) for (_, p) in self.products.iteritems()],
+            'order_line': [(0, 0, {'name': p.name, 'product_id': p.id, 'product_uom_qty': 2, 'product_uom': p.uom_id.id, 'price_unit': p.list_price}) for (_, p) in pycompat.items(self.products)],
-            'order_line': [(0, 0, {'name': p.name, 'product_id': p.id, 'product_uom_qty': 2, 'product_uom': p.uom_id.id, 'price_unit': p.list_price}) for (_, p) in self.products.iteritems()],
+            'order_line': [(0, 0, {'name': p.name, 'product_id': p.id, 'product_uom_qty': 2, 'product_uom': p.uom_id.id, 'price_unit': p.list_price}) for (_, p) in pycompat.items(self.products)],
-from odoo.tools import DEFAULT_SERVER_DATETIME_FORMAT, float_compare, float_round
+from odoo.tools import DEFAULT_SERVER_DATETIME_FORMAT, float_compare, \
-            for location_id, location_data in location_data.iteritems():
+            for location_id, location_data in pycompat.items(location_data):
-from odoo.tools import float_utils
+from odoo.tools import float_utils, pycompat
-            for void_field in [item[0] for item in product_data.items() if item[1] is None]:
+            for void_field in [item[0] for item in pycompat.items(product_data) if item[1] is None]:
-from odoo.tools import DEFAULT_SERVER_DATETIME_FORMAT
+from odoo.tools import DEFAULT_SERVER_DATETIME_FORMAT, pycompat
-        if any(fname in frozen_fields for fname in vals.keys()) and any(move.state == 'done' for move in self):
+        if any(fname in frozen_fields for fname in vals) and any(move.state == 'done' for move in self):
-        for key, moves in to_assign.items():
+        for key, moves in pycompat.items(to_assign):
-        return self.browse(lot_move_qty.keys())._move_quants_by_lot_v10(quants_taken, false_quants, ops, lot_qty, lot_move_qty, quant_dest_package_id)
+        return self.browse(lot_move_qty)._move_quants_by_lot_v10(quants_taken, false_quants, ops, lot_qty, lot_move_qty, quant_dest_package_id)
-            for lot_id in lot_quantities.keys():
+            for lot_id in lot_quantities:
-            if operation.pack_lot_ids and float_compare(sum(lot_quantities.values()), qty, precision_rounding=operation.product_id.uom_id.rounding) != 0.0:
+            if operation.pack_lot_ids and float_compare(sum(pycompat.values(lot_quantities)), qty, precision_rounding=operation.product_id.uom_id.rounding) != 0.0:
-            for move in prout_move_qty.keys():
+            for move in list(prout_move_qty):
-from odoo.tools import DEFAULT_SERVER_DATETIME_FORMAT
+from odoo.tools import DEFAULT_SERVER_DATETIME_FORMAT, pycompat
-            count = dict(map(lambda x: (x['picking_type_id'] and x['picking_type_id'][0], x['picking_type_id_count']), data))
+            count = {
-        all_products = valid_quants.mapped('product_id') | self.env['product.product'].browse(p.id for p in forced_qties.keys()) | self.move_lines.mapped('product_id')
+        all_products = valid_quants.mapped('product_id') | self.env['product.product'].browse(p.id for p in forced_qties) | self.move_lines.mapped('product_id')
-        for product, qty in forced_qties.items():
+        for product, qty in pycompat.items(forced_qties):
-        for mapping, qty in qtys_grouped.items():
+        for mapping, qty in pycompat.items(qtys_grouped):
-                    for lot in lots_grouped.get(mapping, {}).keys()],
+                    for lot in lots_grouped.get(mapping, {})],
-            for product, remaining_qty in pack_operation._get_remaining_prod_quantities().items():
+            for product, remaining_qty in pycompat.items(pack_operation._get_remaining_prod_quantities()):
-from odoo.tools import DEFAULT_SERVER_DATETIME_FORMAT
+from odoo.tools import DEFAULT_SERVER_DATETIME_FORMAT, pycompat
-        return self._compute_complete_name().items()
+        return list(pycompat.items(self._compute_complete_name()))
-from odoo.tools import DEFAULT_SERVER_DATE_FORMAT
+from odoo.tools import DEFAULT_SERVER_DATE_FORMAT, pycompat
-        for field_name, values in sub_locations.iteritems():
+        for field_name, values in pycompat.items(sub_locations):
-        for field_name, values in data.iteritems():
+        for field_name, values in pycompat.items(data):
-        for picking_type, values in data.iteritems():
+        for picking_type, values in pycompat.items(data):
-            route_push_values.update((values or {}).items() + (push_values or {}).items())
+            route_push_values.update(values or {})
-            route_pull_values.update((values or {}).items() + (pull_values or {}).items())
+            route_pull_values.update(values or {})
-        for field_name, values in picking_type_values.iteritems():
+        for field_name, values in pycompat.items(picking_type_values):
-            for key, value in self.onchange_product_id_dict(self.product_id.id).iteritems():
+            for key, value in pycompat.items(self.onchange_product_id_dict(self.product_id.id)):
-from odoo.tools import float_compare, float_round
+from odoo.tools import float_compare, float_round, pycompat
-        for cost, qty in quant_cost_qty.iteritems():
+        for cost, qty in pycompat.items(quant_cost_qty):
-                for quant, value in quant_dict.items():
+                for quant, value in pycompat.items(quant_dict):
-                   for cost_line, val_amount in val_to_cost_lines.iteritems()):
+                   for cost_line, val_amount in pycompat.items(val_to_cost_lines)):
-            for key, value in towrite_dict.items():
+            for key, value in pycompat.items(towrite_dict):
-    return dict((k, dictionary[k]) for k in matched_keys)
+    return {k: v for k, v in pycompat.items(dictionary) if k.startswith(string)}
-        current_page_index = pages.index((filter(lambda p: p[1].id == page_id, pages))[0])
+        current_page_index = pages.index(next(p for p in pages if p[1].id == page_id))
-            result_summary = {'answers': answers.values(), 'comments': comments}
+            result_summary = {'answers': list(pycompat.values(answers)), 'comments': comments}
-            for cell in product(rows.keys(), answers.keys()):
+            for cell in product(rows, answers):
-            if all([True if not answer.strip() else False for answer in answer_candidates.values()]) and answer_candidates:
+            if all(not answer.strip() for answer in pycompat.values(answer_candidates)) and answer_candidates:
-                answer_number = len(set([sk.rsplit('_', 1)[0] for sk in answer_candidates.keys()]))
+                answer_number = len({sk.rsplit('_', 1)[0] for sk in answer_candidates})
-        for urltype, urltxt in urltypes.iteritems():
+        for urltype, urltxt in pycompat.items(urltypes):
-            for field, value in expected_values.iteritems():
+            for field, value in pycompat.items(expected_values):
-        num = map(float, random.sample(range(1, 100), 3))
+        num = [float(n) for n in random.sample(range(1, 100), 3)]
-        for key in exresult.keys():
+        for key in exresult:
-        for action, val in actions.iteritems():
+        for action, val in pycompat.items(actions):
-from odoo.tools import topological_sort, html_escape
+from odoo.tools import topological_sort, html_escape, pycompat
-    loadable = http.addons_manifest.keys()
+    loadable = list(http.addons_manifest)
-    for k, v in el.items():
+    for k, v in pycompat.items(el):
-                dict(map(operator.itemgetter('name', 'value'), fields)))
+            {f['name']: f['value'] for f in fields})
-        return dictheaders.items()
+        return list(pycompat.items(dictheaders))
-        fields_sequence = sorted(fields.iteritems(),
+        fields_sequence = sorted(pycompat.items(fields),
-                           for attrs in field.get('states', {}).values()):
+                           for attrs in pycompat.values(field.get('states', {}))):
-            model, map(operator.itemgetter('name'), export_fields_list))
+            model, [f['name'] for f in export_fields_list])
-            for k, v in self.fields_info(model, export_fields).iteritems())
+            for k, v in pycompat.items(self.fields_info(model, export_fields)))
-        field_names = map(operator.itemgetter('name'), fields)
+        field_names = [f['name'] for f in fields]
-        self.mods = map(str, range(1000))
+        self.mods = [str(i) for i in range(1000)]
-        y = map(lambda t: t['y'], filter(lambda x: x['y'] if x['x'] == 20 else None, nodes.values()))
+        y = [
-            for color, expr in bgcolors.items():
+            for color, expr in pycompat.items(bgcolors):
-            for shape, expr in shapes.items():
+            for shape, expr in pycompat.items(shapes):
-from odoo.tools import ustr
+from odoo.tools import ustr, pycompat
-        classes = ' '.join(itertools.imap(escape, aclasses))
+        classes = ' '.join(pycompat.imap(escape, aclasses))
-                          if not k.startswith('data-oe-'))
+        attributes = {k: v for k, v in pycompat.items(el.attrib)
-        for menu_id, menu_xmlid in xmlids.iteritems():
+        for menu_id, menu_xmlid in pycompat.items(xmlids):
-        for key, value in self.args.items():
+        for key, value in pycompat.items(self.args):
-        for key, value in kw.items():
+        for key, value in pycompat.items(kw):
-                pages_with_website = map(lambda p: "%d-%d" % (current_website.id, p), range(1, pages + 1))
+                pages_with_website = ["%d-%d" % (current_website.id, p) for p in range(1, pages + 1)]
-from odoo.tools import config
+from odoo.tools import config, pycompat
-        for key, val in arguments.items():
+        for key, val in pycompat.items(arguments):
-        return map(process, items)
+        return [process(it) for it in items]
-        for name, value in atts.iteritems():
+        for name, value in pycompat.items(atts):
-            for key, val in arguments.items():
+            for key, val in list(pycompat.items(arguments)):
-                {'url': get_url(page), 'num': page} for page in pycompat.range(pmin, pmax+1)
+                {'url': get_url(page), 'num': page} for page in range(pmin, pmax+1)
-        converters = rule._converters.values()
+        converters = list(pycompat.values(rule._converters))
-            convitems.sort(key=lambda x: hasattr(x[1], 'domain') and (x[1].domain != '[]'))
+            convitems = sorted(
-                for key, val in value.items():
+                for key, val in pycompat.items(value):
-        for slug, expected in tests.iteritems():
+        for slug, expected in pycompat.items(tests):
-        self.assertIn(code, pycompat.range(200, 300), "%s Fetching %s returned error response (%d)" % (msg, url, code))
+        self.assertIn(code, range(200, 300), "%s Fetching %s returned error response (%d)" % (msg, url, code))
-    return dict(('data-oe-%s' % key, str(value)) for key, value in kwargs.iteritems())
+    return {'data-oe-%s' % key: str(value) for key, value in pycompat.items(kwargs)}
-        active_tag_ids = tag and map(int, [unslug(t)[1] for t in tag.split(',')]) or []
+        active_tag_ids = tag and [int(unslug(t)[1]) for t in tag.split(',')] or []
-            return ','.join(map(slug, tag_ids))
+            return ','.join(slug(tag) for tag in tag_ids)
-                blog_post.teaser = ' '.join(filter(None, content.split(' '))[:50]) + '...'
+                blog_post.teaser = ' '.join(itertools.islice(
-            'searchbar_filters': OrderedDict(sorted(searchbar_filters.items())),
+            'searchbar_filters': OrderedDict(sorted(pycompat.items(searchbar_filters))),
-        google_map_partner_ids = ','.join(map(str, [p.id for p in partners]))
+        google_map_partner_ids = ','.join(str(p.id) for p in partners)
-        for salesman_id, leads_ids in salesmans_leads.items():
+        for salesman_id, leads_ids in pycompat.items(salesmans_leads):
-            values['partner_declined_ids'] = map(lambda p: (4, p, 0), partner_ids.ids)
+            values['partner_declined_ids'] = [(4, p, 0) for p in partner_ids.ids]
-        for partner_id, partner_leads in partners_leads.items():
+        for partner_id, partner_leads in pycompat.items(partners_leads):
-        google_map_partner_ids = ','.join(map(str, partners.ids))
+        google_map_partner_ids = ','.join(str(it) for it in partners.ids)
-            for key, search in domain_search.items():
+            for key, search in pycompat.items(domain_search):
-        for key, value in details.iteritems():
+        for key, value in pycompat.items(details):
-            for registration in registrations.values():
+        for key, value in pycompat.items(global_values):
-        return registrations.values()
+        return list(pycompat.values(registrations))
-            for key, value in registration.iteritems():
+            for key, value in pycompat.items(registration):
-        for key, value in data.iteritems():
+        for key, value in pycompat.items(data):
-        tickets = request.env['event.event.ticket'].browse(ticket_post.keys())
+        tickets = request.env['event.event.ticket'].browse(tuple(ticket_post))
-from odoo.tools import html_escape as escape, html2plaintext
+from odoo.tools import html_escape as escape, html2plaintext, pycompat
-                for loc in locations.keys():
+                for loc in list(locations):
-        for day, tracks in days_tracks.iteritems():
+        for day, tracks in pycompat.items(days_tracks):
-from odoo.tools import DEFAULT_SERVER_DATE_FORMAT, DEFAULT_SERVER_DATETIME_FORMAT
+from odoo.tools import DEFAULT_SERVER_DATE_FORMAT, DEFAULT_SERVER_DATETIME_FORMAT, pycompat
-        for field_name, field_value in values.items():
+        for field_name, field_value in pycompat.items(values):
-        missing_required_fields = [label for label, field in authorized_fields.iteritems() if field['required'] and not label in data['record']]
+        missing_required_fields = [label for label, field in pycompat.items(authorized_fields) if field['required'] and not label in data['record']]
-            k: v for k, v in self.get_authorized_fields(self.model).iteritems()
+            k: v for k, v in pycompat.items(self.get_authorized_fields(self.model))
-        for key, val in model._inherits.iteritems():
+        for key, val in pycompat.items(model._inherits):
-        default_values = model.default_get(fields_get.keys())
+        default_values = model.default_get(list(fields_get))
-        for field in fields_get.keys():
+        for field in list(fields_get):
-        posts = dict(map(lambda x: (x.id, (x.parent_id or x, x.parent_id and x or False)), posts_ids))
+        posts_ids = Post.search([('id', 'in', list(posts))])
-        for tag in filter(None, tags.split(',')):
+        for tag in (tag for tag in tags.split(',') if tag):
-        for post, post_sudo in itertools.izip(self, self.sudo()):
+        for post, post_sudo in pycompat.izip(self, self.sudo()):
-        if any(key not in ['state', 'active', 'is_correct', 'closed_uid', 'closed_date', 'closed_reason_id', 'tag_ids'] for key in vals.keys()) and any(not post.can_edit for post in self):
+        if any(key not in ['state', 'active', 'is_correct', 'closed_uid', 'closed_date', 'closed_reason_id', 'tag_ids'] for key in vals) and any(not post.can_edit for post in self):
-                    translation_ids = map(lambda t_id: t_id['id'], translations)
+                    translation_ids = [t_id['id'] for t_id in translations]
-        if office_id and office_id in map(lambda x: x.id, offices):
+        if office_id and office_id in [x.id for x in offices]:
-            percentage[grade] = repartition[grade] * 100 / sum(repartition.values()) if sum(repartition.values()) else 0
+            percentage[grade] = repartition[grade] * 100 / sum(pycompat.values(repartition)) if sum(pycompat.values(repartition)) else 0
-                countries = filter(lambda d:d['country_id'], countries)
+                countries = [d for d in countries if d['country_id']]
-        google_map_partner_ids = ",".join(map(str, google_map_partner_ids))
+        google_map_partner_ids = ",".join(str(it) for it in google_map_partner_ids)
-        if [err for err in error.values() if err == 'missing']:
+        if [err for err in pycompat.values(error) if err == 'missing']:
-        unknown = [k for k in data.iterkeys() if k not in self.MANDATORY_BILLING_FIELDS + self.OPTIONAL_BILLING_FIELDS]
+        unknown = [k for k in data if k not in self.MANDATORY_BILLING_FIELDS + self.OPTIONAL_BILLING_FIELDS]
-            'searchbar_filters': OrderedDict(sorted(searchbar_filters.items())),
+            'searchbar_filters': OrderedDict(sorted(pycompat.items(searchbar_filters))),
-            'searchbar_filters': OrderedDict(sorted(searchbar_filters.items())),
+            'searchbar_filters': OrderedDict(sorted(pycompat.items(searchbar_filters))),
-            'searchbar_filters': OrderedDict(sorted(searchbar_filters.items())),
+            'searchbar_filters': OrderedDict(sorted(pycompat.items(searchbar_filters))),
-            'option': bool(filter(lambda x: not x.line_id, order_sudo.options)),
+            'option': any(not x.line_id for x in order_sudo.options),
-                'class': " ".join(map(lambda x: x.html_class or '', p.website_style_ids))
+                'class': " ".join(x.html_class for x in p.website_style_ids if x.html_class)
-        rows = map(lambda x: x[1], rows)
+        rows = sorted(pycompat.items(self.table))
-            cols.sort()
+            cols = sorted(pycompat.items(rows[col]))
-            rows[col] = [c for c in map(lambda x: x[1], cols) if c]
+            rows[col] = [r[1] for r in cols if r[1]]
-        attrib_set = set([v[1] for v in attrib_values])
+        attrib_values = [[int(x) for x in v.split("-")] for v in attrib_list if v]
-        attrib_set = set([v[1] for v in attrib_values])
+        attrib_values = [[int(x) for x in v.split("-")] for v in attrib_list if v]
-        return {k: v for k, v in kw.items() if "attribute" in k}
+        return {k: v for k, v in pycompat.items(kw) if "attribute" in k}
-        required_fields = filter(None, (all_form_values.get('field_required') or '').split(','))
+        required_fields = [f for f in (all_form_values.get('field_required') or '').split(',') if f]
-        if [err for err in error.values() if err == 'missing']:
+        if [err for err in pycompat.items(error) if err == 'missing']:
-        for k, v in values.items():
+        for k, v in pycompat.items(values):
-            for field_name, field_value in post.items():
+            for field_name, field_value in pycompat.items(post):
-        for p, p2 in zip(self, self2):
+        for p, p2 in pycompat.izip(self, self2):
-        for k, v in attributes.items():
+        for k, v in pycompat.items(attributes):
-        for country, result in country_list.items():
+        for country, result in pycompat.items(country_list):
-        for country, result in country_list.items():
+        for country, result in pycompat.items(country_list):
-        for country, result in country_list.items():
+        for country, result in pycompat.items(country_list):
-        for country, result in country_list.items():
+        for country, result in pycompat.items(country_list):
-        response.qcontext.update(digital=any(digital_content))
+        digital_content = any(x.product_id.type == 'digital' for x in order_lines)
-            template_ids = map(lambda x: P.browse(x).product_tmpl_id.id, purchased_products)
+            template_ids = request.env['product.product'].browse(purchased_products).mapped('product_tmpl_id').ids
-        return map(lambda x: x['product_id'][0], purchases)
+        return purchases.mapped('product_id').ids
-        r.qcontext['optional_product_ids'] = map(lambda p: p.with_context({'active_id': p.id}), product.optional_product_ids)
+        r.qcontext['optional_product_ids'] = [p.with_context({'active_id': p.id}) for p in product.optional_product_ids]
-        for k, v in kw.items():
+        for k, v in pycompat.items(kw):
-        vals = map(slide_mapped_dict, slide.get_related_slides(slides_to_suggest))
+        vals = [slide_mapped_dict(s) for s in slide.get_related_slides(slides_to_suggest)]
-            vals += map(slide_mapped_dict, slide.get_most_viewed_slides(add_more_slide))
+            vals.extend(slide_mapped_dict(s) for s in slide.get_most_viewed_slides(add_more_slide))
-from odoo.tools import image
+from odoo.tools import image, pycompat
-            for key, value in values.iteritems():
+            for key, value in pycompat.items(values):
-            for key, value in doc_data.iteritems():
+            for key, value in pycompat.items(doc_data):
-            for key, value in doc_data.iteritems():
+            for key, value in pycompat.items(doc_data):
-        attrs = {name.lower(): value for name, value in attributes.iteritems()}
+        attrs = {name.lower(): value for name, value in attributes.items()}
-            (name, value) for name, value in node.attributes.iteritems()
+            (name, value) for name, value in node.attributes.items()
-                            for name,  value in attrs.iteritems()),
+                            for name,  value in attrs.items()),
-
+        done_count = self.search_count([
-            'todo': len(total) - len(done),
+            'done': done_count,
-        for record, record_bin in zip(self, self_bin):
+        for record, record_bin in pycompat.izip(self, self_bin):
-from odoo.tools import config, human_size, ustr, html_escape
+from odoo.tools import config, human_size, ustr, html_escape, pycompat
-        for fname, filepath in checklist.iteritems():
+        for fname, filepath in pycompat.items(checklist):
-        for res_model, res_ids in model_ids.iteritems():
+        for res_model, res_ids in pycompat.items(model_ids):
-        for res_model, targets in model_attachments.iteritems():
+        for res_model, targets in pycompat.items(model_attachments):
-                ids.difference_update(itertools.chain(*targets.itervalues()))
+                ids.difference_update(itertools.chain(*pycompat.values(targets)))
-from odoo.tools import config, ormcache, mute_logger
+from odoo.tools import config, ormcache, mute_logger, pycompat
-        for key, func in _default_parameters.iteritems():
+        for key, func in pycompat.items(_default_parameters):
-from odoo.tools import ustr
+from odoo.tools import ustr, pycompat
-    return {k: v for k, v in record.iteritems() if k in REFERENCING_FIELDS}
+    return {k: v for k, v in pycompat.items(record) if k in REFERENCING_FIELDS}
-    return {k: v for k, v in record.iteritems() if k not in REFERENCING_FIELDS}
+    return {k: v for k, v in pycompat.items(record) if k not in REFERENCING_FIELDS}
-                error_params = {k: sanitize(v) for k, v in error_params.iteritems()}
+                error_params = {k: sanitize(v) for k, v in pycompat.items(error_params)}
-                error_params = tuple(map(sanitize, error_params))
+                error_params = tuple(sanitize(v) for v in error_params)
-            for name, field in model._fields.iteritems()
+            for name, field in pycompat.items(model._fields)
-            for field, value in record.iteritems():
+            for field, value in pycompat.items(record):
-        fieldset = set(record.iterkeys())
+        fieldset = set(record)
-        return env[self.model].browse(map(int, value.split(',')))
+        return env[self.model].browse(int(v) for v in value.split(','))
-        for name, arg in arguments.items():
+        for name, arg in list(pycompat.items(arguments)):
-from odoo.tools import html2text, ustr
+from odoo.tools import html2text, ustr, pycompat
-    return filter(try_coerce_ascii, candidates)
+    return [c for c in candidates if try_coerce_ascii(c)]
-    return COMMASPACE.join(map(encode_addr, addresses))
+    return COMMASPACE.join(encode_addr(a) for a in addresses)
-        for key, value in headers.iteritems():
+        for key, value in pycompat.items(headers):
-        smtp_to_list = filter(None, tools.flatten(map(extract_rfc2822_addresses, [email_to, email_cc, email_bcc])))
+        smtp_to_list = [
-        vals=",".join(map("%({0})s".format, values)),
+        vals=",".join("%({0})s".format(v) for v in values),
-        condition=" AND ".join(map("{0}=%({0})s".format, selectors)),
+        assignment=",".join("{0}=%({0})s".format(s) for s in setters),
-            self = self.with_context({k: v for k, v in self._context.iteritems() if k != '__last_update'})
+            self = self.with_context({k: v for k, v in pycompat.items(self._context) if k != '__last_update'})
-                _("View:") + " " + view.name,
+                _("Fields: %s") % ", ".join(str(f) for f in fields),
-        diff = {key for key, val in params.items() if field_data[key] != val}
+        diff = {key for key, val in pycompat.items(params) if field_data[key] != val}
-        for field in model._fields.itervalues():
+        for field in pycompat.values(model._fields):
-            res.complete_name = ".".join(filter(None, [res.module, res.name]))
+            res.complete_name = ".".join(n for n in [res.module, res.name] if n)
-        for model, id_name in model_id_name.iteritems():
+        for model, id_name in pycompat.items(model_id_name):
-                    for parent_model, parent_field in self.env[model]._inherits.iteritems():
+                    for parent_model, parent_field in pycompat.items(self.env[model]._inherits):
-                for parent_model, parent_field in record._inherits.iteritems():
+                for parent_model, parent_field in pycompat.items(record._inherits):
-                for parent_model, parent_field in record._inherits.iteritems():
+                for parent_model, parent_field in pycompat.items(record._inherits):
-                    for parent_model_name, parent_field in current_model._inherits.iteritems():
+                    for parent_model_name, parent_field in pycompat.items(current_model._inherits):
-            for parent_model, parent_field in record._inherits.iteritems():
+            for parent_model, parent_field in pycompat.items(record._inherits):
-from odoo.tools import func, misc
+from odoo.tools import func, misc, pycompat
-                assets_domain = [('url', 'in', assets.keys())]
+                assets_domain = [('url', 'in', list(assets))]
-                if any(asset._content is None for asset in assets.itervalues()):
+                if any(asset._content is None for asset in pycompat.values(assets)):
-            path = filter(None, self.url.split('/'))
+            path = (segment for segment in self.url.split('/') if segment)
-        tools.ormcache('id_or_xml_id', 'tuple(map(options.get, self._get_template_cache_keys()))'),
+        tools.ormcache('id_or_xml_id', 'tuple(options.get(k) for k in self._get_template_cache_keys())'),
-                for k, v in json.loads(field_options).iteritems():
+                for k, v in pycompat.items(json.loads(field_options)):
-                    path = filter(None, href.split('/'))
+                    path = [segment for segment in href.split('/') if segment]
-                    path = filter(None, src.split('/'))
+                    path = [segment for segment in src.split('/') if segment]
-from itertools import chain, izip, tee, count
+from itertools import tee, count
-from odoo.tools import pycompat
+from odoo.tools import pycompat, freehash
-                defaults=map(self.visit, args.defaults),
+                defaults=[self.visit(default) for default in args.defaults],
-                setattr(newnode, field, map(transformer.visit, value))
+                setattr(newnode, field, [transformer.visit(v) for v in value])
-        enum = pycompat.range(enum)
+        enum = range(enum)
-        enum = enum.iteritems()
+        enum = pycompat.items(enum)
-        enum = izip(*tee(enum))
+        enum = pycompat.izip(*tee(enum))
-    for k in base_ctx.keys():
+    for k in list(base_ctx):
-        return hash(frozenset((key, freehash(val)) for key, val in self.iteritems()))
+        return hash(frozenset((key, freehash(val)) for key, val in pycompat.items(self)))
-            raise "Unknown directive on %s" % ("', '".join(directives), etree.tostring(el))
+            raise NameError("Unknown directive on %s" % etree.tostring(el))
-            for ns_prefix, ns_definition in set(el.nsmap.items()) - set(options['nsmap'].items()):
+            for ns_prefix, ns_definition in set(pycompat.items(el.nsmap)) - set(pycompat.items(options['nsmap'])):
-            for key, value in el.attrib.items():
+            ns = itertools.chain(pycompat.items(options['nsmap']), pycompat.items(el.nsmap))
-        tag = u'<%s%s' % (el_tag, u''.join([u' %s="%s"' % (name, escape(unicodifier(value))) for name, value in attrib.iteritems()]))
+        tag = u'<%s%s' % (el_tag, u''.join([u' %s="%s"' % (name, escape(unicodifier(value))) for name, value in pycompat.items(attrib)]))
-        nsprefixmap = {v: k for k, v in options['nsmap'].items() + el.nsmap.items()}
+        nsprefixmap = {v: k for k, v in itertools.chain(pycompat.items(options['nsmap']), pycompat.items(el.nsmap))}
-        for key, value in el.attrib.iteritems():
+        for key, value in pycompat.items(el.attrib):
-        for name, value in el.attrib.iteritems():
+        for name, value in pycompat.items(el.attrib):
-        if any(name.startswith('t-att') or not name.startswith('t-') for name, value in el.attrib.iteritems()):
+        if any(name.startswith('t-att') or not name.startswith('t-') for name, value in pycompat.items(el.attrib)):
-            # for name, value in t_attrs.iteritems():
+            # for name, value in pycompat.items(t_attrs):
-                        attr='iteritems',
+                        value=ast.Name(id='pycompat', ctx=ast.Load()),
-                    args=[], keywords=[],
+                    args=[ast.Name(id='t_attrs', ctx=ast.Load())], keywords=[],
-            for ns_prefix, ns_definition in set(el.nsmap.items()) - set(options['nsmap'].items()):
+            for ns_prefix, ns_definition in set(pycompat.items(el.nsmap)) - set(pycompat.items(options['nsmap'])):
-        body = [self._append(ast.Str(u'<%s%s' % (el_tag, u''.join([u' %s="%s"' % (name, escape(unicodifier(value))) for name, value in extra_attrib.iteritems()]))))]
+        body = [self._append(ast.Str(u'<%s%s' % (el_tag, u''.join([u' %s="%s"' % (name, escape(unicodifier(value))) for name, value in pycompat.items(extra_attrib)]))))]
-        if next_el is not None and {'t-else', 't-elif'} & set(next_el.attrib.keys()):
+        if next_el is not None and {'t-else', 't-elif'} & set(next_el.attrib):
-                for key, value in options['nsmap'].items():
+                for key, value in pycompat.items(options['nsmap']):
-            for key, format in sequences.iteritems():
+            for key, format in pycompat.items(sequences):
-            for field_name, field in env[model]._fields.items():
+            for field_name, field in pycompat.items(env[model]._fields):
-        for mname, ids in model_ids.iteritems():
+        for mname, ids in pycompat.items(model_ids):
-        for name, fld in record._fields.items():
+        for name, fld in pycompat.items(record._fields):
-    qs_keys = request.httprequest.args.keys()
+    qs_keys = list(request.httprequest.args)
-        for view, view_wo_lang in zip(self, self.with_context(lang=None)):
+        for view, view_wo_lang in pycompat.izip(self, self.with_context(lang=None)):
-        for view, view_wo_lang in zip(self, self.with_context(lang=None)):
+        for view, view_wo_lang in pycompat.izip(self, self.with_context(lang=None)):
-            views = self.search(conditions + [('id', 'in', list(self._context.get('check_view_ids') or (0,)) + map(int, views))])
+            views = self.search(conditions + [('id', 'in', list(self._context.get('check_view_ids') or (0,)) + views.ids)])
-                            value = (separator or ' ').join(filter(lambda s: s not in to_remove, values) + to_add)
+                            to_add = (
-        for field, nodes in field_nodes.iteritems():
+        for field, nodes in pycompat.items(field_nodes):
-        for k in fields.keys():
+        for k in list(fields):
-                       'tuple(map(self._context.get, self._read_template_keys()))'),
+                       'tuple(self._context.get(k) for k in self._read_template_keys())'),
-        for model_key, model_value in Model._fields.iteritems():
+        for model_key, model_value in pycompat.items(Model._fields):
-                for node_key, node_value in Node._fields.iteritems():
+                for node_key, node_value in pycompat.items(Node._fields):
-        rec = self.browse(map(itemgetter(0), self._cr.fetchall()))
+        rec = self.browse(it[0] for it in self._cr.fetchall())
-                for (xmod, name), (model, res_id) in self.pool.model_data_reference_ids.items()
+                for (xmod, name), (model, res_id) in pycompat.items(self.pool.model_data_reference_ids)
-from odoo.tools import pickle
+from odoo.tools import pickle, pycompat
-        return defaults.values()
+        return list(pycompat.values(defaults))
-        return sorted(results.values())
+        return sorted(pycompat.values(results))
-            module.menus_by_module = "\n".join(sorted(map(attrgetter('complete_name'), browse('ir.ui.menu'))))
+            module.views_by_module = "\n".join(sorted(format_view(v) for v in browse('ir.ui.view')))
-            for module_name, url in urls.iteritems():
+            for module_name, url in pycompat.items(urls):
-            for module_name, url in urls.iteritems():
+            for module_name, url in pycompat.items(urls):
-            with_urls = [module_name for module_name, url in urls.iteritems() if url]
+            with_urls = [module_name for module_name, url in pycompat.items(urls) if url]
-            to_install = self.search([('name', 'in', urls.keys()), ('state', '=', 'uninstalled')])
+            to_install = self.search([('name', 'in', list(urls)), ('state', '=', 'uninstalled')])
-            return sorted(self.env[model].fields_get(fnames).iteritems())
+            return sorted(pycompat.items(self.env[model].fields_get(fnames)))
-        for ref, id in refs.iteritems():
+        for ref, id in pycompat.items(refs):
-                value = map(makeref, value)
+                value = [makeref(v) for v in value]
-                operator, value = 'in', map(makeref, target_ids)
+                target_ids = [n[0] for n in target_names]
-        for fname, value in values.iteritems():
+        for fname, value in pycompat.items(values):
-from odoo.tools import ustr
+from odoo.tools import ustr, pycompat
-        return map(attrgetter('name'), self._already_installed())
+        return [m.name for m in self._already_installed()]
-        selectable = [name for name, field in self._fields.iteritems()
+        selectable = [name for name, field in pycompat.items(self._fields)
-                   for module_name, to_install in installer.iteritems()
+                   for module_name, to_install in pycompat.items(installer)
-                          for requirements, consequences in self._install_if.iteritems()
+                          for requirements, consequences in pycompat.items(self._install_if)
-        for name, field in self._fields.iteritems():
+        for name, field in pycompat.items(self._fields):
-                field_groups = Groups.concat(*map(ref, field_group_xmlids))
+                field_groups = Groups.concat(*(ref(it) for it in field_group_xmlids))
-    _disallowed_datetime_patterns = tools.DATETIME_FORMATS_MAP.keys()
+    _disallowed_datetime_patterns = list(tools.DATETIME_FORMATS_MAP)
-            for pattern, replacement in tools.DATETIME_FORMATS_MAP.iteritems():
+            for pattern, replacement in pycompat.items(tools.DATETIME_FORMATS_MAP):
-    res = separator.join(map(reverse, reverse(splits)))
+    res = separator.join(reverse(s) for s in reverse(splits))
-            partner_ids = map(lambda x: x[0], self.env.cr.fetchall())
+            partner_ids = [row[0] for row in self.env.cr.fetchall()]
-from odoo.tools import partition
+from odoo.tools import partition, pycompat
-    return 'sel_groups_' + '_'.join(map(str, ids))
+    return 'sel_groups_' + '_'.join(str(it) for it in ids)
-    return map(int, name[11:].split('_'))
+    return [int(v) for v in name[11:].split('_')]
-        for group, group1 in zip(self, self.sudo()):
+        for group, group1 in pycompat.izip(self, self.sudo()):
-            values = filter(bool, group.split('/'))
+            values = [v for v in group.split('/') if v]
-                if (vals['id'] != self._uid):
+            for vals in result:
-            for key in values.keys():
+            for key in list(values):
-                vals = {'users': zip(repeat(4), group.with_context(active_test=False).users.ids)}
+                vals = {'users': list(pycompat.izip(repeat(4), group.with_context(active_test=False).users.ids))}
-            if len(set(order.itervalues())) == len(gs):
+            if len(set(pycompat.values(order))) == len(gs):
-        for app, gs in sorted(by_app.iteritems(), key=lambda it: it[0].sequence or 0):
+        for app, gs in sorted(pycompat.items(by_app), key=lambda it: it[0].sequence or 0):
-        for key, val in values.iteritems():
+        for key, val in pycompat.items(values):
-            values1['groups_id'] = zip(repeat(3), rem) + zip(repeat(4), add)
+            values1['groups_id'] = list(itertools.chain(
-        fields1 = fields or self.fields_get().keys()
+        fields1 = fields or list(self.fields_get())
-        ids = map(int, partners)
+        ids = partners.ids
-        self.assertEqual(ids, map(int, partners))
+        self.assertEqual(ids, partners.ids)
-        for name, field in partners._fields.iteritems():
+        for name, field in pycompat.items(partners._fields):
-        country_ids = set(cid for cids in country_id_cache.itervalues() for cid in cids)
+        country_ids = set(cid for cids in pycompat.values(country_id_cache) for cid in cids)
-from odoo.tools import mute_logger
+from odoo.tools import mute_logger, pycompat
-        for name, cat_ids in partners_config.iteritems():
+        for name, cat_ids in pycompat.items(partners_config):
-        base_domain = [('id', 'in', pids.values())]
+        base_domain = [('id', 'in', list(pycompat.values(pids)))]
-            for frac, exp, prec in zip(fractions, expecteds, precisions):
+        for magnitude in range(7):
-                    for x in pycompat.range(0, 10000, 97):
+                    for x in range(0, 10000, 97):
-def noid(d):
+def noid(seq):
-    return d
+    for d in seq:
-        self.assertItemsEqual(map(noid, filters), [
+        self.assertItemsEqual(noid(filters), [
-        self.assertItemsEqual(map(noid, filters), [
+        self.assertItemsEqual(noid(filters), [
-        self.assertItemsEqual(map(noid, filters), [
+        self.assertItemsEqual(noid(filters), [
-        self.assertItemsEqual(map(noid, filters), [
+        self.assertItemsEqual(noid(filters), [
-        self.assertItemsEqual(map(noid, filters), [
+        self.assertItemsEqual(noid(filters), [
-        self.assertItemsEqual(map(noid, filters), [
+        self.assertItemsEqual(noid(filters), [
-        self.assertItemsEqual(map(noid, filters), [
+        self.assertItemsEqual(noid(filters), [
-        self.assertItemsEqual(map(noid, filters), [
+        self.assertItemsEqual(noid(filters), [
-        self.assertItemsEqual(map(noid, filters), [
+        self.assertItemsEqual(noid(filters), [
-        for name, date in partners_data.items():
+        for name, date in pycompat.items(partners_data):
-        results = self.env['res.partner'].resolve_2many_commands('child_ids', map(CREATE, values))
+        results = self.env['res.partner'].resolve_2many_commands('child_ids', [CREATE(v) for v in values])
-        commands = map(LINK_TO, ids)
+        commands = [LINK_TO(v) for v in ids]
-        commands = map(DELETE, ids)
+        commands = [DELETE(v) for v in ids]
-        self.assertSetEqual(set(expected_ns.items()) - set(result_etree.nsmap.items()), set())
+        self.assertSetEqual(set(pycompat.items(expected_ns)) - set(pycompat.items(result_etree.nsmap)), set())
-        ids = Cron.search([('id', 'in', cron_ids.values())], order='user_id').ids
+        ids = Cron.search([('id', 'in', list(pycompat.values(cron_ids)))], order='user_id').ids
-        found_ids = Cats.search([('id', 'in', cat_ids.values())]).ids
+        found_ids = Cats.search([('id', 'in', list(pycompat.values(cat_ids)))]).ids
-        keys = sorted(kw.keys())
+        keys = sorted(kw)
-                  for index, v in zip(itertools.count(), [4, 42, 36, 4, 13])]
+                  for index, v in pycompat.izip(itertools.count(), [4, 42, 36, 4, 13])]
-                  for index, v in zip(itertools.count(10), [8, 12, 8, 55, 33, 13])]
+                  for index, v in pycompat.izip(itertools.count(10), [8, 12, 8, 55, 33, 13])]
-            for i in pycompat.range(10000000):
+            for i in range(10000000):
-        for parent, child in zip(categories, categories[1:]):
+        for parent, child in pycompat.izip(categories, categories[1:]):
-                rec.display_name = rec.name
+                rec.display_name = rec.name
-            map(str, range(10)))
+            [str(i) for i in range(10)])
-        # 'bad-python3-import', # TODO: more stuff used in report
+
-        'xrange-builtin',
+    ]
-        # 'reduce-builtin',
+        # 'file',
-from odoo.tools import frozendict, classproperty
+from odoo.tools import frozendict, classproperty, pycompat
-        for item in sorted(self.kwargs.iteritems()):
+        for item in sorted(pycompat.items(self.kwargs)):
-        for key, value in attrs.items():
+        for key, value in list(pycompat.items(attrs)):
-        recs_list = filter(None, recs_list)
+        recs_list = [r for r in recs_list if r]
-            for field, field_cache in self.cache.iteritems()
+            for field, field_cache in pycompat.items(self.cache)
-            records = self[field.model_name].browse(ids)
+        for field, field_dump in pycompat.items(cache_dump):
-        names = commands.keys()
+        names = list(commands)
-        args = {key: val for key, val in kwargs.iteritems() if val is not Default}
+        args = {key: val for key, val in pycompat.items(kwargs) if val is not Default}
-        for key, val in self._slots.iteritems():
+        for key, val in pycompat.items(self._slots):
-        for attr, value in field._attrs.iteritems():
+        for attr, value in pycompat.items(field._attrs):
-        for record, other in zip(records, others):
+        for record, other in pycompat.izip(records, others):
-        for mname, fnames in model0._depends.iteritems():
+        for mname, fnames in pycompat.items(model0._depends):
-                        for source, target in zip(recs, recs.with_env(env)):
+                        for source, target in pycompat.izip(recs, recs.with_env(env)):
-            for path, fields in bypath.iteritems():
+        for model_name, bypath in pycompat.items(bymodel):
-                self.selection = OrderedDict(self.selection + selection_add).items()
+                self.selection = list(pycompat.items(OrderedDict(self.selection + selection_add)))
-            self.delegate = name in model._inherits.values()
+            self.delegate = name in pycompat.values(model._inherits)
-from odoo.tools import ustr, consteq, frozendict
+from odoo.tools import ustr, consteq, frozendict, pycompat, unique
-                         if not k.startswith("_ignored_"))
+        arguments ={k: v for k, v in pycompat.items(arguments)
-            for k, v in cookies.iteritems():
+            for k, v in pycompat.items(cookies):
-        for k, v in attrs.items():
+        for k, v in pycompat.items(attrs):
-            subclasses = uniq(c for c in get_subclasses(cls) if c is not cls)
+            subclasses = list(unique(c for c in get_subclasses(cls) if c is not cls))
-        for k in self.keys():
+        for k in list(self):
-        for f in req.files.values():
+        for f in pycompat.values(req.files):
-                for name, (storename, filename, content_type) in data['files'].iteritems():
+                for name, (storename, filename, content_type) in pycompat.items(data['files']):
-            for f, _, _ in files.values():
+            for f, _, _ in pycompat.values(files):
-        for key, val in attrs.iteritems():
+        for key, val in pycompat.items(attrs):
-            for mname, fnames in base._depends.iteritems():
+            for mname, fnames in pycompat.items(base._depends):
-        cls._constraints = cls._constraints.values()
+        cls._constraints = list(pycompat.values(cls._constraints))
-        fields_to_export = map(fix_import_export_id_paths, fields_to_export)
+        fields_to_export = [fix_import_export_id_paths(f) for f in fields_to_export]
-        fields = map(fix_import_export_id_paths, fields)
+        fields = [fix_import_export_id_paths(f) for f in fields]
-                      for fnames, value in itertools.izip(fields_, row)
+                      for fnames, value in pycompat.izip(fields_, row)
-                indices, subfields = zip(*((index, fnames[1:] or [None])
+                indices, subfields = pycompat.izip(*((index, fnames[1:] or [None])
-                relfield_data = filter(any, map(itemgetter_tuple(indices), record_span))
+                relfield_data = [it for it in pycompat.imap(itemgetter_tuple(indices), record_span) if any(it)]
-        field_names = {name: field.string for name, field in self._fields.iteritems()}
+        field_names = {name: field.string for name, field in pycompat.items(self._fields)}
-        for model, names in parent_fields.iteritems():
+        for model, names in pycompat.items(parent_fields):
-        for fname, field in self._fields.iteritems():
+        for fname, field in pycompat.items(self._fields):
-            for parent_model, parent_field in self._inherits.iteritems()
+            for parent_model, parent_field in pycompat.items(self._inherits)
-            for name, field in self._fields.iteritems()
+            for name, field in pycompat.items(self._fields)
-        for name, value in defaults.iteritems():
+        for name, value in pycompat.items(defaults):
-            for key, line in result.iteritems():
+            for key, line in pycompat.items(result):
-        return result.values()
+        return list(pycompat.values(result))
-        fields = fields or [f.name for f in self._fields.itervalues() if f.store]
+        fields = fields or [f.name for f in pycompat.values(self._fields) if f.store]
-        data = map(lambda r: {k: self._read_group_prepare_data(k,v, groupby_dict) for k,v in r.iteritems()}, fetched_data)
+        data = ({k: self._read_group_prepare_data(k,v, groupby_dict) for k,v in pycompat.items(r)} for r in fetched_data)
-        cols = [name for name, field in self._fields.iteritems()
+        cols = [name for name, field in pycompat.items(self._fields)
-            for field in self._fields.itervalues():
+            for field in pycompat.values(self._fields):
-        for parent_model, parent_field in self._inherits.iteritems():
+        for parent_model, parent_field in pycompat.items(self._inherits):
-            for name, field in parent._fields.iteritems():
+            for name, field in pycompat.items(parent._fields):
-        for name, field in fields.iteritems():
+        for name, field in pycompat.items(fields):
-        for table, field_name in self._inherits.items():
+        for table, field_name in pycompat.items(self._inherits):
-        for field in self._fields.itervalues():
+        for field in pycompat.values(self._fields):
-        for name, field in cls._fields.iteritems():
+        for name, field in pycompat.items(cls._fields):
-        for field in cls._fields.itervalues():
+        for field in pycompat.values(cls._fields):
-        for fields in groups.itervalues():
+        for fields in pycompat.values(groups):
-            for field in cls._fields.itervalues():
+            for field in pycompat.values(cls._fields):
-        for fname, field in self._fields.iteritems():
+        for fname, field in pycompat.items(self._fields):
-                               for key, val in description.iteritems()
+                               for key, val in pycompat.items(description)
-            fields = filter(valid, self._fields)
+            fields = [name for name in self._fields if valid(name)]
-            invalid_fields = set(filter(lambda name: not valid(name), fields))
+            invalid_fields = {name for name in fields if not valid(name)}
-                for f in self._fields.itervalues()
+                for f in pycompat.values(self._fields)
-        fields = map(self._fields.get, field_names + inherited_field_names)
+        fields = [self._fields[n] for n in (field_names + inherited_field_names)]
-        qual_names = map(qualify, set(fields_pre + [self._fields['id']]))
+        qual_names = [qualify(name) for name in set(fields_pre + [self._fields['id']])]
-                        ', '.join(map(repr, extras._ids)),
+                        missing._ids, extras._ids,
-        for key, val in vals.iteritems():
+        for key, val in pycompat.items(vals):
-        protected_fields = map(self._fields.get, new_vals)
+        protected_fields = [self._fields[n] for n in new_vals]
-            parents_changed = map(operator.itemgetter(0), cr.fetchall())
+            parents_changed = [x[0] for x in cr.fetchall()]
-        for name, val in vals.iteritems():
+        for name, val in pycompat.items(vals):
-                       for key, val in self._context.iteritems()
+                       for key, val in pycompat.items(self._context)
-        for parent_model, parent_field in self._inherits.iteritems():
+        for parent_model, parent_field in pycompat.items(self._inherits):
-        for key, val in vals.iteritems():
+        for key, val in pycompat.items(vals):
-        protected_fields = map(self._fields.get, new_vals)
+        protected_fields = [self._fields[n] for n in new_vals]
-            for parent_model, parent_field in self._inherits.iteritems()
+            for parent_model, parent_field in pycompat.items(self._inherits)
-        for name, val in vals.items():
+        for name, val in list(pycompat.items(vals)):
-        for parent_model, parent_vals in tocreate.iteritems():
+        for parent_model, parent_vals in pycompat.items(tocreate):
-        for name, field in self._fields.iteritems():
+        for name, field in pycompat.items(self._fields):
-        for name, val in vals.iteritems():
+        for name, val in pycompat.items(vals):
-            for name, val in vals.iteritems():
+            for name, val in pycompat.items(vals):
-                           for key, val in self._context.iteritems()
+                           for key, val in pycompat.items(self._context)
-        whitelist = set(name for name, field in self._fields.iteritems() if not field.inherited)
+        whitelist = set(name for name, field in pycompat.items(self._fields) if not field.inherited)
-            for parent_model, parent_field in model._inherits.items():
+            for parent_model, parent_field in pycompat.items(model._inherits):
-            for name, field in model._fields.iteritems():
+            for name, field in pycompat.items(model._fields):
-                          for name, field in self._fields.iteritems()
+                          for name, field in pycompat.items(self._fields)
-        for name, field in fields_to_copy.iteritems():
+        for name, field in pycompat.items(fields_to_copy):
-        for name, field in old._fields.iteritems():
+        for name, field in pycompat.items(old._fields):
-                for (old_line, new_line) in zip(old_lines, new_lines):
+                for (old_line, new_line) in pycompat.izip(old_lines, new_lines):
-                for key, val in results.iteritems()}
+                for key, val in pycompat.items(results)}
-        return filter(None, list(self._ids))
+        return [it for it in self._ids if it]
-            for name, value in values.iteritems()
+            for name, value in pycompat.items(values)
-            for name, value in values.iteritems()
+            for name, value in pycompat.items(values)
-        for name, value in values.iteritems():
+        for name, value in pycompat.items(values):
-            func = lambda rec: filter(None, rec.mapped(name))
+            func = lambda rec: any(rec.mapped(name))
-        return self.browse(map(attrgetter('id'), sorted(self, key=key, reverse=reverse)))
+        return self.browse(item.id for item in sorted(self, key=key, reverse=reverse))
-            for name, value in values.iteritems():
+            for name, value in pycompat.items(values):
-        ids = filter(None, self._prefetch[self._name] - set(self.env.cache[field]))
+        ids = [it for it in self._prefetch[self._name] - set(self.env.cache[field]) if it]
-            fields = self._fields.values()
+            fields = list(pycompat.values(self._fields))
-            fields = map(self._fields.__getitem__, fnames)
+            fields = [self._fields[n] for n in fnames]
-                for vals, ids in updates.iteritems():
+                for vals, ids in pycompat.items(updates):
-            map(recs._recompute_done, fs)
+            for f in fs:
-                for subinfo in info['fields'][name].get('views', {}).itervalues():
+                for subinfo in pycompat.values(info['fields'][name].get('views', {})):
-                self.update({key: val for key, val in res['value'].iteritems() if key in self._fields})
+                self.update({key: val for key, val in pycompat.items(res['value']) if key in self._fields})
-                    warning['message'] = '\n\n'.join(filter(None, [
+                    warning['message'] = '\n\n'.join(s for s in [
-                    ]))
+                    ] if s)
-                for name, oldval in values.iteritems():
+                for name, oldval in pycompat.items(values):
-            for name, field in self._recs._fields.iteritems():
+            for name, field in pycompat.items(self._recs._fields):
-        for name, field in self._recs._fields.iteritems():
+        for name, field in pycompat.items(self._recs._fields):
-        xml_id = 'module_category_' + ('_'.join(map(lambda x: x.lower(), category))).replace('&', 'and').replace(' ', '_')
+        xml_id = 'module_category_' + ('_'.join(x.lower() for x in category)).replace('&', 'and').replace(' ', '_')
-
+from odoo.tools import pycompat
-        additional_data = dict((key, {'id': 0, 'state': 'uninstalled', 'dbdemo': False, 'installed_version': None}) for key in self.keys())
+        additional_data = {key: {'id': 0, 'state': 'uninstalled', 'dbdemo': False, 'installed_version': None} for key in pycompat.keys(self)}
-            for k, v in additional_data[package.name].items():
+        for package in pycompat.values(self):
-            unmet_deps = filter(lambda p: p not in self, dependencies[package])
+            unmet_deps = [p for p in dependencies[package] if p not in self]
-        done = set(self.keys())
+        done = set(pycompat.keys(self))
-            level_modules = sorted((name, module) for name, module in self.items() if module.depth==level)
+            level_modules = sorted((name, module) for name, module in pycompat.items(self) if module.depth==level)
-        return itertools.chain(iter(self.children), *map(iter, self.children))
+        return itertools.chain(
-            _check_module_names(cr, itertools.chain(tools.config['init'].keys(), tools.config['update'].keys()))
+            _check_module_names(cr, itertools.chain(tools.config['init'], tools.config['update']))
-            module_names = [k for k, v in tools.config['init'].items() if v]
+            module_names = [k for k, v in pycompat.items(tools.config['init']) if v]
-            module_names = [k for k, v in tools.config['update'].items() if v]
+            module_names = [k for k, v in pycompat.items(tools.config['update']) if v]
-                Module.browse(modules_to_remove.values()).module_uninstall()
+                Module.browse(pycompat.values(modules_to_remove)).module_uninstall()
-        for model in env.values():
+        for model in pycompat.values(env):
-            versions = list(set(
+            versions = sorted({
-                for ver, lf in lv.items()
+                for lv in pycompat.values(self.migrations[pkg.name])
-            versions.sort(key=lambda k: parse_version(convert_version(k)))
+            }, key=lambda k: parse_version(convert_version(k)))
-            for x in mapping.keys():
+            for x in mapping:
-        info.update(itertools.izip(
+        info.update(pycompat.izip(
-        return map(clean, filter(is_really_module, os.listdir(dir)))
+        return [
-        suite = unittest.TestSuite(itertools.ifilter(position, tests))
+        suite = unittest.TestSuite(t for t in tests if position(t))
-            itertools.imap(unwrap_suite, subtests)):
+            unwrap_suite(t) for t in subtests):
-                        lazy_property, table_exists, topological_sort, OrderedSet)
+                        lazy_property, table_exists, topological_sort,
-            for db_name in cls.registries.keys():
+            for db_name in list(pycompat.keys(cls.registries)):
-            for field in model._fields.itervalues()
+            for model in pycompat.values(self)
-        models = env.values()
+        models = list(pycompat.values(env))
-                   for name, model in env.items()
+                   for name, model in pycompat.items(env)
-            deps = {name: model._depends for name, model in env.items()}
+            deps = {name: model._depends for name, model in pycompat.items(env)}
-            for name, model in env.items():
+            for name, model in pycompat.items(env):
-        for model in self.models.itervalues():
+        for model in pycompat.values(self.models):
-                            subquery = cr.mogrify(subquery, [tuple(filter(None, res_ids))])
+                            subquery = cr.mogrify(subquery, [tuple(it for it in res_ids if it)])
-                        params = map(partial(field.convert_to_column, record=model), params)
+                        params = [field.convert_to_column(p, record=model) for p in params]
-    for state, modifs in (field.get("states",{})).items():
+    for state, modifs in pycompat.items(field.get("states",{})):
-    for attr, default_value in default_values.items():
+    for attr, default_value in pycompat.items(default_values):
-series = serie = major_version = '.'.join(map(str, version_info[:2]))
+version = '.'.join(str(s) for s in version_info[:2]) + RELEASE_LEVELS_DISPLAY[version_info[3]] + str(version_info[4] or '') + version_info[5]
-    server_version = '.'.join(map(str, version_info[:2]))
+    server_version = '.'.join(str(v) for v in version_info[:2])
-                for key in registry._sql_error.keys():
+                for key in pycompat.keys(registry._sql_error):
-from odoo.tools import stripped_sys_argv, dumpstacks, log_ormcache_stats
+from odoo.tools import stripped_sys_argv, dumpstacks, log_ormcache_stats, pycompat
-            for db_name, registry in registries.iteritems():
+            for db_name, registry in pycompat.items(registries):
-        for (pid, worker) in self.workers.items():
+        for (pid, worker) in pycompat.items(self.workers):
-            fd_in = fds.keys() + [self.pipe[0]]
+            fds = {w.watchdog_pipe[0]: w for k, w in pycompat.items(self.workers)}
-            for pid in self.workers.keys():
+            for pid in self.workers:
-        for pid in self.workers.keys():
+        for pid in self.workers:
-    for mod_name, mod_mod in sys.modules.items():
+    for mod_name, mod_mod in pycompat.items(sys.modules):
-for name, typeoid in types_mapping.items():
+for name, typeoid in pycompat.items(types_mapping):
-        return map(self.__build_dict, self._obj.fetchmany(size))
+        return [self.__build_dict(row) for row in self._obj.fetchmany(size)]
-        return map(self.__build_dict, self._obj.fetchall())
+        return [self.__build_dict(row) for row in self._obj.fetchall()]
-                sqllogitems = sqllogs[type].items()
+                sqllogitems = pycompat.items(sqllogs[type])
-            for _ in pycompat.range(self._depth):
+            for _ in range(self._depth):
-        return doc and ' '.join(filter(None, map(str.strip, doc.splitlines()))) or None
+        return doc and ' '.join(l.strip() for l in doc.splitlines() if not l.isspace()) or None
-    return ' '.join(filter(None, [start_word, units_name, (start_word or units_name) and (end_word or cents_name) and 'and', end_word, cents_name]))
+    return ' '.join(w for w in [start_word, units_name, (start_word or units_name) and (end_word or cents_name) and 'and', end_word, cents_name] if w)
-__version__ = '.'.join(map(str, __version_info__))
+__version__ = '.'.join(str(v) for v in __version_info__)
-        keys_expr = "tuple(map(%s.get, %r))" % (cont_expr, self.keys)
+        keys_expr = "tuple(%s.get(k) for k in %r)" % (cont_expr, self.keys)
-        for key in reg.cache.iterkeys():
+    for dbname, reg in pycompat.items(Registry.registries):
-    for key, count in sorted(entries.items()):
+    for key, count in sorted(pycompat.items(entries)):
-from . import appdirs
+from . import appdirs, pycompat
-        for logger, level in dict(it.split(':') for it in loggers).iteritems()
+        for logger, level in pycompat.items(dict(it.split(':') for it in loggers))
-        self.options['translate_modules'] = opt.translate_modules and map(lambda m: m.strip(), opt.translate_modules.split(',')) or ['all']
+        self.options['translate_modules'] = opt.translate_modules and [m.strip() for m in opt.translate_modules.split(',')] or ['all']
-        dev_split = opt.dev_mode and  map(str.strip, opt.dev_mode.split(',')) or []
+        dev_split = opt.dev_mode and  [s.strip() for s in opt.dev_mode.split(',')] or []
-        loglevelnames = dict(zip(self._LOGLEVELS.values(), self._LOGLEVELS.keys()))
+        loglevelnames = dict(pycompat.izip(pycompat.values(self._LOGLEVELS), pycompat.keys(self._LOGLEVELS)))
-        for opt in sorted(self.options.keys()):
+        for opt in sorted(pycompat.keys(self.options)):
-        for sec in sorted(self.misc.keys()):
+        for sec in sorted(pycompat.keys(self.misc)):
-            for opt in sorted(self.misc[sec].keys()):
+            for opt in sorted(pycompat.keys(self.misc[sec])):
-                ids = map(lambda x: x[f_use], env[f_model].browse(ids).read([f_use]))
+                ids = [x[f_use] for x in env[f_model].browse(ids).read([f_use])]
-                    f_val = [(6, 0, map(lambda x: x[f_use], s))]
+                    f_val = [(6, 0, [x[f_use] for x in s])]
-            if att in el.keys():
+            if att in el.attrib:
-            grp_lst = map(lambda x: "ref('%s')" % x, groups.split(','))
+            grp_lst = [("ref('%s')" % x) for x in groups.split(',')]
-            datas.append(map(ustr, line))
+            datas.append([ustr(v) for v in line])
-        for frac, exp, prec in zip(fractions, expecteds, precisions):
+    for magnitude in range(7):
-                for x in pycompat.range(0, 10000, 97):
+                for x in range(0, 10000, 97):
-        for name in obj_dict.keys():
+        for name in list(obj_dict):
-        least_rank = min(map(lambda x: x['x'], self.result.values()))
+        least_rank = min(x['x'] for x in pycompat.values(self.result.values))
-        max_level = max(map(lambda x: len(x), self.levels.values()))
+        max_level = max(len(x) for x in pycompat.values(self.levels.values))
-            max_level = max(map(lambda x: len(x), self.levels.values()))
+            max_level = max(len(x) for x in pycompat.values(self.levels.values))
-            min_order = math.fabs(min(map(lambda x: x['y'], self.result.values())))
+            min_order = math.fabs(min(x['y'] for x in pycompat.values(self.result.values)))
-            self.max_order = max(map(lambda x: x['y'], self.result.values()))
+            self.max_order = max(x['y'] for x in pycompat.values(self.result.values))
-        max_rank = max(map(lambda x: x, self.levels.keys()))
+        max_rank = max(x for x in self.levels)
-                        if sec_node in self.partial_order.keys():
+                        if sec_node in pycompat.keys(self.partial_order):
-    for name,node in node_res.items():
+    for name,node in pycompat.items(node_res):
-        for i,j in self.iteritems():
+        for i,j in pycompat.items(self):
-        return self.d.keys()
+        return list(pycompat.keys(self.d))
-                for key, val in attrs.iteritems():
+                for key, val in pycompat.items(attrs):
-                el.attrib['style'] = '; '.join('%s: %s' % (key, val) for (key, val) in valid_styles.iteritems())
+                el.attrib['style'] = '; '.join('%s: %s' % (key, val) for (key, val) in pycompat.items(valid_styles))
-    return separator.join(map(decode_smtp_header, filter(None, message.get_all(header, []))))
+    return separator.join(decode_smtp_header(h) for h in message.get_all(header, []) if h)
-        for dirname, mime in _ooxml_dirs.iteritems():
+        for dirname, mime in pycompat.items(_ooxml_dirs):
-from itertools import islice, izip, groupby, repeat
+from itertools import islice, groupby, repeat
-            map(r.append, flatten(e))
+            r.extend(flatten(e))
-    return izip(pycompat.range(len(l)-1, -1, -1), reversed(l))
+    return pycompat.izip(range(len(l)-1, -1, -1), reversed(l))
-                map(visit, elems[n])
+                for it in elems[n]:
-    map(visit, elems)
+    for el in elems:
-        for key, value in kwargs.items():
+        for key, value in pycompat.items(kwargs):
-                ifaces = filter(None, [namestr[i:i+32].split('\0', 1)[0] for i in range(0, outbytes, 32)])
+                ifaces = [namestr[i:i+32].split('\0', 1)[0] for i in range(0, outbytes, 32)]
-                for ifname in [iface for iface in ifaces if iface != 'lo']:
+                for ifname in [iface for iface in ifaces if iface if iface != 'lo']:
-    for threadId, stack in sys._current_frames().items():
+    for threadId, stack in pycompat.items(sys._current_frames()):
-            return hash(frozenset(map(freehash, arg)))
+            return hash(frozenset(freehash(item) for item in arg))
-        return hash(frozenset((key, freehash(val)) for key, val in self.iteritems()))
+        return hash(frozenset((key, freehash(val)) for key, val in pycompat.items(self)))
-    return len(str1) == len(str2) and sum(ord(x)^ord(y) for x, y in zip(str1, str2)) == 0
+    return len(str1) == len(str2) and sum(ord(x)^ord(y) for x, y in pycompat.izip(str1, str2)) == 0
-        symlinks = filter(lambda dirname: os.path.islink(os.path.join(dirpath, dirname)), dirnames)
+        symlinks = (dirname for dirname in dirnames if os.path.islink(os.path.join(dirpath, dirname)))
-            for a, b in zip(pvs, pvs[1:]):
+            for a, b in pycompat.izip(pvs, pvs[1:]):
-    # pylint: disable=long-builtin,xrange-builtin
+    # pylint: disable=long-builtin,dict-iter-method
-    range = xrange
+    keys = lambda d: iter(d.iterkeys())
-    range = range
+    keys = lambda d: iter(d.keys())
-    'xrange': pycompat.range,
+    'xrange': range,
-            for fk, field in view_res.get('fields',{}).items():
+            for fk, field in pycompat.items(view_res.get('fields',{})):
-        for name, value in result.items():
+        for name, value in pycompat.items(result.attrib):
-            for src, row in sorted(grouped_rows.items()):
+            for src, row in sorted(pycompat.items(grouped_rows)):
-            for mod, modrows in rows_by_module.items():
+            for mod, modrows in pycompat.items(rows_by_module):
-            dic.update(zip(fields, row))
+            dic.update(pycompat.izip(fields, row))
-        for src, target in pot_targets.iteritems():
+        for src, target in pycompat.items(pot_targets):
-from . import yaml_tag
+from . import yaml_tag, pycompat
-        and isinstance(node.keys()[0], tag_constructor)
+        and len(node) == 1 \
-            assertion, expressions = node.items()[0]
+            assertion, expressions = next(pycompat.items(node))
-        record, fields = node.items()[0]
+        record, fields = next(pycompat.items(node))
-            for field_name, field_value in vals.iteritems():
+            for field_name, field_value in pycompat.items(vals):
-                    field_value = map(process, field_value or [])
+                    field_value = [process(v) for v in (field_value or [])]
-            for field_name, field_value in vals.iteritems():
+            for field_name, field_value in pycompat.items(vals):
-                    field_value = map(process, field_value or [])
+                    field_value = [process(v) for v in (field_value or [])]
-            for field_name, field_elem in elems.iteritems():
+            for field_name, field_elem in pycompat.items(elems):
-                    for key, val in result.get('value', {}).iteritems()
+                    for key, val in pycompat.items(result.get('value', {}))
-        for field_name, expression in fields.iteritems():
+        for field_name, expression in pycompat.items(fields):
-            for key, val in record_dict.iteritems()
+            for key, val in pycompat.items(record_dict)
-        python, statements = node.items()[0]
+        python, statements = next(pycompat.items(node))
-        function, params = node.items()[0]
+        function, params = next(pycompat.items(node))
-        _, fields = node.items()[0]
+        _, fields = next(pycompat.items(node))
-        for fieldname, expression in fields.items():
+        for fieldname, expression in pycompat.items(fields):
-                args = node.items()[0]
+                args = next(pycompat.items(node))
-        return "<%s %s>" % (self.__class__.__name__, sorted(self.__dict__.items()))
+        return "<%s %s>" % (self.__class__.__name__, sorted(pycompat.items(self.__dict__)))
-    data_files['babel'] = map(lambda f: join(dirname(babel.__file__), f), others)
+    data_files['babel'] = [join(dirname(babel.__file__), f) for f in others]
-    data_files['babel/messages'] = map(lambda f: join(dirname(babel.__file__), 'messages', f), others)
+    data_files['babel/messages'] = [join(dirname(babel.__file__), 'messages', f) for f in others]
-    return data_files.items()
+    return list(data_files.items())
-    classifiers=filter(None, classifiers.split('\n')),
+    classifiers=[c for c in classifiers.split('\n') if c],
-        sys.exit('Unknow command. Command available: %r' % (cmds.keys(),))
+        sys.exit('Unknow command. Command available: %r' % (list(cmds,))
-                partial_rec = rec.env['account.partial.reconcile'].create({
+                # DO NOT FORWARDPORT! ONLY FOR v9
-        res.create_tax_cash_basis_entry(value_before_reconciliation)
+        # DO NOT FORWARDPORT! ONLY FOR v9
-    event_ok = fields.Boolean(string='Event Registration', help='Determine if a product needs '
+    event_ok = fields.Boolean(string='Is an Event Ticket', help='Determine if a product needs '
-    available_in_pos = fields.Boolean(string='Available in the Point of Sale', help='Check if you want this product to appear in the Point of Sale', default=True)
+    available_in_pos = fields.Boolean(string='Available in Point of Sale', help='Check if you want this product to appear in the Point of Sale', default=True)
-        'Sale Price', default=1.0,
+        'Sales Price', default=1.0,
-        ], string="Control Purchase Bills",
+        ], string="Control Policy",
-    intrastat_id = fields.Many2one('report.intrastat.code', string='Intrastat code')
+    intrastat_id = fields.Many2one('report.intrastat.code', string='Intrastat Code')
-        [('no', 'No'), ('cost', 'At cost'), ('sales_price', 'At sale price')],
+        [('no', 'No'), ('cost', 'At cost'), ('sales_price', 'Sales price')],
-    landed_cost_ok = fields.Boolean('Landed Costs')
+    landed_cost_ok = fields.Boolean('Is a Landed Cost')
-            'description': procurement.name + '\n',
+            'description': procurement.name + '<br/>',
-        cls._model_cache_key = tuple(c for c in cls.mro() if not getattr(c, 'pool', None))
+        cls._model_cache_key = tuple(c for c in cls.mro() if getattr(c, 'pool', None) is None)
-        record = request.env[model.model].sudo().create(values)
+        record = request.env[model.model].sudo().with_context(mail_create_nosubscribe=True).create(values)
-from . import project_timesheet
+from . import models
-        'project_timesheet_view.xml',
+        'views/hr_timesheet_views.xml',
-        'demo/hr_timesheet_demo.xml',
+        'data/hr_timesheet_demo.xml',
-                    safe_eval(self.callback_eval, {'self': self})
+                if self.sudo().callback_eval and init_state != 'authorized':
-                    safe_eval(self.callback_eval, {'self': self})
+                if self.sudo().callback_eval:
-                safe_eval(self.callback_eval, {'self': self})
+            if self.sudo().callback_eval:
-                safe_eval(self.callback_eval, {'self': self})
+            if self.sudo().callback_eval:
-                safe_eval(self.callback_eval, {'self': self})
+            if self.sudo().callback_eval:
-    currency_id = fields.Many2one(string="Currency", related='company_id.currency_id')
+    currency_id = fields.Many2one(string="Currency", related='company_id.currency_id', readonly=True)
-    trial_date_end = fields.Date('End of Trial Period')
+    date_start = fields.Date('Start Date', required=True, default=fields.Date.today,
-    wage = fields.Monetary('Wage', digits=(16, 2), required=True, help="The monthly gross wage of the employee.")
+    wage = fields.Monetary('Wage', digits=(16, 2), required=True, help="Employee's monthly gross wage.")
-    resource_calendar_id = fields.Many2one(required=True)
+    ], string='Scheduled Pay', index=True, default='monthly',
-    hr_responsible_id = fields.Many2one('res.users', "HR Responsible", track_visibility='onchange')
+    hr_responsible_id = fields.Many2one('res.users', "HR Responsible", track_visibility='onchange',
-    ], string="Transport", default='company_car')
+    ], string="Transport", default='company_car',
-    double_holidays = fields.Monetary(compute='_compute_holidays_advantages', string='Double holidays')
+    thirteen_month = fields.Monetary(compute='_compute_holidays_advantages', string='13th Month',
-    monthly_yearly_costs = fields.Monetary(compute='_compute_monthly_yearly_costs', string='Monthly Equivalent Cost', readonly=True)
+        string='Total Employee Cost', groups="hr.group_hr_manager",
-        default=lambda self: self.get_attribute('commission_on_target', 'default_value'))
+        default=lambda self: self.get_attribute('commission_on_target', 'default_value'),
-        default=lambda self: self.get_attribute('fuel_card', 'default_value'))
+        default=lambda self: self.get_attribute('fuel_card', 'default_value'),
-        help="Your internet subscription will be paid up to this amount.")
+        help="The employee's internet subcription will be paid up to this amount.")
-        default=lambda self: self.get_attribute('representation_fees', 'default_value'))
+        default=lambda self: self.get_attribute('representation_fees', 'default_value'),
-        help="Your mobile subscription will be paid up to this amount.")
+        help="The employee's mobile subscription will be paid up to this amount.")
-        help="Your international mobile subscription will be paid up to this amount.")
+        help="The employee's mobile subscription for international communication will be paid up to this amount.")
-        default=lambda self: self.get_attribute('meal_voucher_amount', 'default_value'))
+        default=lambda self: self.get_attribute('meal_voucher_amount', 'default_value'),
-        default=lambda self: self.get_attribute('holidays', 'default_value'))
+        default=lambda self: self.get_attribute('holidays', 'default_value'),
-    retained_net_amount = fields.Monetary(sting="Net Retained")
+    additional_net_amount = fields.Monetary(string="Net Supplements",
-        default=lambda self: self.get_attribute('eco_checks', 'default_value'))
+        default=lambda self: self.get_attribute('eco_checks', 'default_value'),
-    car_id = fields.Many2one('fleet.vehicle', string='Car',
+    car_id = fields.Many2one('fleet.vehicle', string='Company Car',
-        default=lambda self: self.env['fleet.vehicle'].search([('driver_id', '=', self.employee_id.address_home_id.id)], limit=1))
+        default=lambda self: self.env['fleet.vehicle'].search([('driver_id', '=', self.employee_id.address_home_id.id)], limit=1),
-    name = fields.Char(string='Job Title', required=True, index=True, translate=True)
+    name = fields.Char(string='Job Position', required=True, index=True, translate=True)
-    job_id = fields.Many2one('hr.job', 'Job Title')
+    job_id = fields.Many2one('hr.job', 'Job Position')
-    job_id = fields.Many2one('hr.job', string='Job Title')
+    job_id = fields.Many2one('hr.job', string='Job Position')
-    car_value = fields.Float(string="Catalog Value (VAT incl.)", help='Value of the bought vehicle')
+    car_value = fields.Float(string="Catalog Value (VAT Incl.)", help='Value of the bought vehicle')
-    co2_fee = fields.Float(compute='_compute_co2_fee', string="CO2 fee (monthly)")
+    co2_fee = fields.Float(compute='_compute_co2_fee', string="CO2 Fee")
-        string="Total Depreciated Cost", help="This includes all the depreciated costs and the CO2 fee")
+        string="Total Cost (Depreciated)", help="This includes all the depreciated costs and the CO2 fee")
-    atn = fields.Float(compute='_compute_car_atn')
+    atn = fields.Float(compute='_compute_car_atn', string="ATN")
-    default_recurring_cost_amount_depreciated = fields.Float(string="Recurring Cost (Depreciated)",
+    default_recurring_cost_amount_depreciated = fields.Float(string="Cost (Depreciated)",
-    default_total_depreciated_cost = fields.Float(compute='_compute_default_total_depreciated_cost')
+    default_total_depreciated_cost = fields.Float(compute='_compute_default_total_depreciated_cost', string="Total Cost (Depreciated)")
-    @api.depends('default_co2', 'default_recurring_cost_amount_depreciated')
+    @api.depends('co2_fee', 'default_recurring_cost_amount_depreciated')
-            model.default_total_depreciated_cost = model.default_co2 + model.default_recurring_cost_amount_depreciated
+            model.default_total_depreciated_cost = model.co2_fee + model.default_recurring_cost_amount_depreciated
-            'description': self.name + '\n',
+            'description': self.name + '<br/>',
-            raise UserError(_('Only an HR Officer or Manager can approve leave requests.'))
+        self._check_security_action_approve()
-    def action_validate(self):
+    def _check_security_action_validate(self):
-            raise UserError(_('Only an HR Officer or Manager can refuse leave requests.'))
+        self._check_security_action_refuse()
-        self.env['ir.property'].create({
+        product_property = self.env['ir.property'].create({
-            'company_id': new_company.id,
+        # multi-company security rules prevents access
-            'company_id': self.id,
+        location.sudo().write({'company_id': self.id})
-        self.env['stock.warehouse'].create({'name': company.name, 'code': company.name[:5], 'company_id': company.id})
+
-                    SUM ((invoice_type.sign * ail.quantity) / (u.factor * u2.factor)) AS product_qty,
+                    SUM ((invoice_type.sign * ail.quantity) / u.factor * u2.factor) AS product_qty,
-    ], string='Status', track_visibility='onchange', help='Status of the contract', default='draft')
+    ], string='Status', group_expand='_expand_states',
-    holidays = fields.Float(string="Holidays", default=20)
+    commission_on_target = fields.Monetary(string="Commission on Target",
-    eco_checks = fields.Monetary("Eco Vouchers", default=250)
+    eco_checks = fields.Monetary("Eco Vouchers",
-    @api.depends('model_id', 'license_plate', 'total_depreciated_cost', 'acquisition_date')
+    @api.depends('model_id', 'license_plate', 'log_contracts', 'total_depreciated_cost', 'acquisition_date')
-    'depends' : ['base_setup', 'product', 'analytic', 'report', 'web_planner'],
+    'depends' : ['base_setup', 'product', 'analytic', 'web_planner'],
-        return self.env['report'].get_action(self, 'account.report_invoice')
+        return self.env.ref('account.account_invoices').report_action(self)
-            report_invoice = self.env['report']._get_report_from_name('account.report_invoice')
+            report_invoice = self.env['ir.actions.report']._get_report_from_name('account.report_invoice')
-                    attachment = self.env['report']._attachment_stored(invoice, report_invoice)[invoice.id]
+                attachment = self.env['ir.actions.report'].retrieve_attachment(invoice.id)
-    def render_html(self, docids, data=None):
+    def get_report_values(self, docids, data=None):
-        docargs = {
+        return {
-    def render_html(self, docids, data=None):
+    def get_report_values(self, docids, data=None):
-        docargs = {
+        return {
-    def render_html(self, docids, data=None):
+    def get_report_values(self, docids, data=None):
-        docargs = {
+        return {
-    def render_html(self, docids, data=None):
+    def get_report_values(self, docids, data=None):
-        docargs = {
+        return {
-    def render_html(self, docids, data=None):
+    def get_report_values(self, docids, data=None):
-        docargs = {
+        return {
-    def render_html(self, docids, data=None):
+    def get_report_values(self, docids, data=None):
-        docargs = {
+        return {
-    def render_html(self, docids, data=None):
+    def get_report_values(self, docids, data=None):
-        docargs = {
+        return {
-        return self.env['report'].get_action(self, 'account.report_financial', data=data, config=False)
+        return self.env.ref('account.action_report_financial').report_action(self, data=data, config=False)
-        return self.env['report'].with_context(landscape=True).get_action(self, 'account.report_agedpartnerbalance', data=data)
+        return self.env.ref('account.action_report_aged_partner_balance').with_context(landscape=True).report_action(self, data=data)
-        return self.env['report'].with_context(landscape=True).get_action(records, 'account.report_generalledger', data=data)
+        return self.env.ref('account.action_report_general_ledger').with_context(landscape=True).report_action(records, data=data)
-        return self.env['report'].get_action(self, 'account.report_partnerledger', data=data)
+        return self.env.ref('account.action_report_partnerledger').report_action(self, data=data)
-        return self.env['report'].with_context(landscape=True).get_action(self, 'account.report_journal', data=data)
+        return self.env.ref('account.action_report_journal').with_context(landscape=True).report_action(self, data=data)
-        return self.env['report'].get_action(records, 'account.report_trialbalance', data=data)
+        return self.env.ref('account.action_report_trial_balance').report_action(records, data=data)
-        report = Report._get_report_from_name('account_test.report_accounttest')
+    def get_report_values(self, docids, data=None):
-        docargs = {
+        return {
-    'depends' : ['base', 'decimal_precision', 'mail', 'report'],
+    'depends' : ['base', 'decimal_precision', 'mail'],
-        self.company_id.act_discover_fonts()
+    @api.model
-    'depends': ['base_setup', 'mail', 'report'],
+    'depends': ['base_setup', 'mail'],
-    'depends': ['hr', 'report', 'barcodes'],
+    'depends': ['hr', 'barcodes'],
-    'depends': ['hr_contract', 'account_accountant', 'report', 'web_tour'],
+    'depends': ['hr_contract', 'account_accountant', 'web_tour'],
-    'depends': ['hr', 'calendar', 'resource', 'report'],
+    'depends': ['hr', 'calendar', 'resource'],
-        holidays_report = Report._get_report_from_name('hr_holidays.report_holidayssummary')
+    def get_report_values(self, docids, data=None):
-        docargs = {
+        return {
-        return self.env['report'].get_action(departments, 'hr_holidays.report_holidayssummary', data=datas)
+        return self.env.ref('hr_holidays.action_report_holidayssummary').report_action(departments, data=datas)
-        return self.env['report'].get_action(employees, 'hr_holidays.report_holidayssummary', data=datas)
+        return self.env.ref('hr_holidays.action_report_holidayssummary').report_action(employees, data=datas)
-    def render_html(self, docids, data=None):
+    def get_report_values(self, docids, data=None):
-        docargs = {
+        return {
-    def render_html(self, docids, data=None):
+    def get_report_values(self, docids, data=None):
-        docargs = {
+        return {
-        return self.env['report'].get_action([], 'hr_payroll.report_contributionregister', data=datas)
+        return self.env.ref('hr_payroll.action_contribution_register').report_action([], data=datas)
-            return self.env['report'].get_action(self, 'l10n_ch.isr_report_main')
+            return self.env.ref('l10n_ch.l10n_ch_isr_report').report_action(self)
-                pdf = self.env['report'].get_pdf([res_id], 'l10n_ch.isr_report_main')
+                pdf = self.env.ref('l10n_ch.l10n_ch_isr_report').render_qweb_pdf([res_id])[0]
-    def render_html(self, docids, data=None):
+    def get_report_values(self, docids, data=None):
-        docargs = {
+        return {
-    def render_html(self, docids, data=None):
+    def get_report_values(self, docids, data=None):
-        docargs = {
+        return {
-    def render_html(self, docids, data=None):
+    def get_report_values(self, docids, data=None):
-        docargs = {
+        return {
-    def render_html(self, docids, data=None):
+    def get_report_values(self, docids, data=None):
-        docargs = {
+        return {
-    def render_html(self, docids, data=None):
+    def get_report_values(self, docids, data=None):
-        docargs = {
+        return {
-        return self.env['report'].get_action(self, 'l10n_in_hr_payroll.report_hrsalarybymonth', data=data)
+        return self.env.ref('l10n_in_hr_payroll.action_report_hrsalarybymonth').report_action(self, data=data)
-        return self.env['report'].get_action(self, 'l10n_in_hr_payroll.report_hryearlysalary', data=data)
+        return self.env.ref('l10n_in_hr_payroll.action_report_hryearlysalary').report_action(self, data=data)
-    'depends': ['l10n_generic_coa', 'report'],
+    'depends': ['l10n_generic_coa'],
-                    result, format = Template.env['report'].get_pdf([res_id], report_service), 'pdf'
+                    result, format = report.render_qweb_pdf([res_id])
-    def render_html(self, docids, data=None):
+    def get_report_values(self, docids, data=None):
-        return self.env['report'].render('mrp.mrp_bom_cost_report', {'lines': res})
+        return self.env['ir.actions.report'].render_template('mrp.mrp_bom_cost_report', {'lines': res})
-        docargs = {
+    def get_report_values(self, docids, data=None):
-        return self.env['report'].get_action(self, 'mrp_repair.report_mrprepairorder')
+        return self.env.ref('mrp_repair.action_report_mrp_repair_order').report_action(self)
-        pdf = request.env['report'].with_context(date_start=date_start, date_stop=date_stop).get_pdf(r, 'point_of_sale.report_saledetails')
+        pdf = request.env.ref('point_of_sale.sale_details_report').with_context(date_start=date_start, date_stop=date_stop).render_qweb_pdf(r)
-    def render_html(self, docids, data=None):
+    def get_report_values(self, docids, data=None):
-        return self.env['report'].render('point_of_sale.report_saledetails', data)
+        return data
-        Report = self.env['report']
+    def get_report_values(self, docids, data=None):
-        return Report.sudo().render('account.report_invoice', {'docs': self.env['account.invoice'].sudo().browse(ids_to_print)})
+        return self.env['ir.actions.report'].sudo().render_template('account.report_invoice', {'docs': self.env['account.invoice'].sudo().browse(ids_to_print)})
-            [], 'point_of_sale.report_saledetails', data=data)
+        return self.env.ref('point_of_sale.sale_details_report').report_action([], data=data)
-    'depends': ['base', 'decimal_precision', 'mail', 'report'],
+    'depends': ['base', 'decimal_precision', 'mail'],
-    def render_html(self, docids, data=None):
+    def get_report_values(self, docids, data=None):
-        docargs = {
+        return {
-        return self.env['report'].get_action([], 'product.report_pricelist', data=datas)
+        return self.env.ref('product.action_report_pricelist').report_action([], data=datas)
-    'depends': ['stock_account', 'report'],
+    'depends': ['stock_account'],
-        return self.env['report'].get_action(self, 'purchase.report_purchasequotation')
+        return self.env.ref('purchase.report_purchase_quotation').report_action(self)
-    'depends': ['sales_team', 'account', 'procurement', 'report', 'web_tour'],
+    'depends': ['sales_team', 'account', 'procurement', 'web_tour'],
-        return self.env['report'].get_action(self, 'sale.report_saleorder')
+        return self.env.ref('sale.action_report_saleorder').report_action(self)
-    def render_html(self, docids, data=None):
+    def get_report_values(self, docids, data=None):
-        docargs = {
+        return {
-        return self.env["report"].get_action(self, 'stock.report_picking')
+        return self.env.ref('stock.action_report_picking').report_action(self)
-        return self.env["report"].with_context(active_ids=pickings.ids, active_model='stock.picking').get_action([], 'stock.report_picking')
+        return self.env.ref('stock.action_report_picking').with_context(active_ids=pickings.ids, active_model='stock.picking').report_action([])
-
+from werkzeug import url_decode
-from odoo.tools import topological_sort
+from odoo.tools import topological_sort, html_escape
-        pdf = request.env['report'].sudo().get_pdf([invoice_id], 'account.report_invoice')
+        pdf = request.env.ref('account.account_invoices').sudo().render_qweb_pdf([invoice_id])[0]
-            pdf = request.env['report'].sudo().with_context(set_viewport_size=True).get_pdf([order_sudo.id], 'website_quote.report_quote')
+            pdf = request.env.ref('website_quote.report_web_quote').sudo().with_context(set_viewport_size=True).render_qweb_pdf([order_sudo.id])[0]
-            pdf = request.env['report'].sudo().get_pdf([sale_order_id], 'sale.report_saleorder', data=None)
+            pdf = request.env.ref('sale.action_report_saleorder').sudo().render_qweb_pdf([sale_order_id])
-from . import report
+        'res/report_paperformat_views.xml',
-from odoo.tools.safe_eval import safe_eval, test_python_expr
+from pytz import timezone
-
+# -*- coding: utf-8 -*-
-        report = Report._get_report_from_name('base.report_irmodulereference')
+    def get_report_values(self, docids, data=None):
-        docargs = {
+        return {
-        return Report.render('base.report_irmodulereference', docargs)
+from . import report_paperformat
-                self.env['report'].get_html(report_records.ids, report.report_name)
+                report.render_qweb_html(report_records.ids)
-    rml_footer = fields.Text(related="company_id.rml_footer", string='Custom Report Footer', help="Footer text displayed at the bottom of all reports.")
+    report_footer = fields.Text(related="company_id.report_footer", string='Custom Report Footer', help="Footer text displayed at the bottom of all reports.")
-        data, format = render_report(self.env.cr, self.env.uid, richard_payslip.ids, 'hr_payroll.report_payslip', {}, {})
+        data, data_format = self.env.ref('hr_payroll.action_report_payslip').render(richard_payslip.ids)
-            open(os.path.join(config['test_report_directory'], 'hr_payroll-payslip.'+ format), 'wb+').write(data)
+            open(os.path.join(config['test_report_directory'], 'hr_payroll-payslip.'+ data_format), 'wb+').write(data)
-        data, format = render_report(self.env.cr, self.env.uid, richard_payslip.ids, 'hr_payroll.report_payslipdetails', {}, {})
+        data, data_format = self.env.ref('hr_payroll.payslip_details_report').render(richard_payslip.ids)
-            open(os.path.join(config['test_report_directory'], 'hr_payroll-payslipdetails.'+ format), 'wb+').write(data)
+            open(os.path.join(config['test_report_directory'], 'hr_payroll-payslipdetails.'+ data_format), 'wb+').write(data)
-        data, format = render_report(self.env.cr, self.env.uid, payment_advice.ids, 'l10n_in_hr_payroll.report_payrolladvice', {}, {})
+        data, data_format = self.env.ref('l10n_in_hr_payroll.payroll_advice').render(payment_advice.ids)
-            open(os.path.join(config['test_report_directory'], 'l10n_in_hr_payroll_summary_report' + format), 'wb+').write(data)
+            open(os.path.join(config['test_report_directory'], 'l10n_in_hr_payroll_summary_report' + data_format), 'wb+').write(data)
-    report_template = fields.Many2one('ir.actions.report.xml', 'Optional report to print and attach')
+    report_template = fields.Many2one('ir.actions.report', 'Optional report to print and attach')
-                        result, format = odoo_report.render_report(self._cr, self._uid, [res_id], report_service, {'model': template.model}, Template._context)
+                    if report.report_type not in ['qweb-html', 'qweb-pdf']:
-    _inherit = 'ir.actions.report.xml'
+class IrActionsReport(models.Model):
-        return super(IrActionsReportXml, self).search(args, offset=offset, limit=limit, order=order, count=count)
+        return super(IrActionsReport, self).search(args, offset=offset, limit=limit, order=order, count=count)
-    report_id = fields.Many2one('ir.actions.report.xml', "Report", help='The report to generate when this activity is activated')
+    report_id = fields.Many2one('ir.actions.report', "Report", help='The report to generate when this activity is activated')
-        return self.report_id.render_report(workitem.res_id, self.report_id.report_name, None)
+        return self.report_id.render(workitem.res_id)
-                'type': 'ir.actions.report.xml',
+                'type': 'ir.actions.report',
-from odoo.tools import float_compare, mute_logger
+from odoo.tools import float_compare, mute_logger, test_reports
-from . import ir_actions_report_xml
+from . import  ir_actions_report
-    _inherit = 'ir.actions.report.xml'
+    _inherit = 'ir.actions.report'
-        """Used in the ir.actions.report.xml form view in order to search naively after the view(s)
+        """Used in the ir.actions.report form view in order to search naively after the view(s)
-        # Get the ir.actions.report.xml record we are working on.
+        # Get the ir.actions.report record we are working on.
-        """Return an action of type ir.actions.report.xml.
+        """Return an action of type ir.actions.report.
-        report = self.env['ir.actions.report.xml'].with_context(context).search([('report_name', '=', report_name)])
+        report = self.env['ir.actions.report'].with_context(context).search([('report_name', '=', report_name)])
-            'type': 'ir.actions.report.xml',
+            'type': 'ir.actions.report',
-        """Get the first record of ir.actions.report.xml having the ``report_name`` as value for
+        """Get the first record of ir.actions.report having the ``report_name`` as value for
-        report_obj = self.env['ir.actions.report.xml']
+        report_obj = self.env['ir.actions.report']
-    report_ids = fields.One2many('ir.actions.report.xml', 'paperformat_id', 'Associated reports', help="Explicitly associated reports")
+    report_ids = fields.One2many('ir.actions.report', 'paperformat_id', 'Associated reports', help="Explicitly associated reports")
-                company.write({'paperformat_id': paperformat_id})
+            if paperformat_euro:
-        for report in self.env['ir.actions.report.xml'].search(domain):
+        for report in self.env['ir.actions.report'].search(domain):
-        data, report_format = self.env['ir.actions.report.xml'].render_report(self.invoice.ids, 'report_intrastat.report_intrastatinvoice', {})
+        data, data_format = self.env.ref('report_intrastat.account_intrastatinvoices').render(self.invoice.ids)
-            open(os.path.join(tools.config['test_report_directory'], 'report_intrastat-intrastat_report.' + report_format), 'wb+').write(data)
+            open(os.path.join(tools.config['test_report_directory'], 'report_intrastat-intrastat_report.' + data_format), 'wb+').write(data)
-            if action_type == 'ir.actions.report.xml':
+            if action_type == 'ir.actions.report':
-            reports = request.env['ir.actions.report.xml']
+            reports = request.env['ir.actions.report']
-    _name = 'ir.actions.report.xml'
+class IrActionsReport(models.Model):
-    type = fields.Char(default='ir.actions.report.xml')
+    type = fields.Char(default='ir.actions.report')
-                                   required=True, default="pdf",
+    report_type = fields.Selection([('qweb-pdf', 'PDF'), ('qweb-html', 'HTML')], required=True, default="pdf",
-    report_file = fields.Char(related='report_rml', string='Report File', required=False, readonly=False, store=True,
+    report_file = fields.Char(string='Report File', required=False, readonly=False, store=True,
-                'value': "ir.actions.report.xml,%s" % report.id,
+                'value': "ir.actions.report,%s" % report.id,
-            return report.create(self._cr, self._uid, res_ids, data, context=self._context)
+    def render_html(self, res_ids, data=None):
-    action = fields.Reference(selection=[('ir.actions.report.xml', 'ir.actions.report.xml'),
+    action = fields.Reference(selection=[('ir.actions.report', 'ir.actions.report'),
-            'ir.actions.report.xml': lambda action: action.model,
+            'ir.actions.report': lambda action: action.model,
-                if action._name in ('ir.actions.report.xml', 'ir.actions.act_window'):
+                action_def = dict([(k, v.convert_to_read(action[k], action)) for k, v in action._fields.items()])
-        dmodels = ['ir.ui.view', 'ir.actions.report.xml', 'ir.ui.menu']
+        dmodels = ['ir.ui.view', 'ir.actions.report', 'ir.ui.menu']
-            module.reports_by_module = "\n".join(sorted(map(attrgetter('name'), browse('ir.actions.report.xml'))))
+            module.reports_by_module = "\n".join(sorted(map(attrgetter('name'), browse('ir.actions.report'))))
-                           help="Set the font into the report header, it will be used as default font in the RML reports of the user company")
+    report_header = fields.Text(string='Company Tagline', help="Appears by default on the top right corner of your printed documents (report header).")
-        reports = self.env['ir.actions.report.xml'].search([])
+        reports = self.env['ir.actions.report'].search([])
-        ir_values.set_action('Nice Report', action_slot='client_print_multi', model='res.partner', action='ir.actions.report.xml,%d' % report_id, res_id=False)
+        ir_values.set_action('Nice Report', action_slot='client_print_multi', model='res.partner', action='ir.actions.report,%d' % report_id, res_id=False)
-            resprint = [clean(print_)
+            resprint = [print_[2]
-            resaction = [clean(action)
+            resaction = [action[2]
-            resrelate = [clean(action)
+            resrelate = [action[2]
-                           ('report_type', 'report_type'), ('parser', 'parser')):
+        for field,dest in (('attachment','attachment'),('attachment_use','attachment_use'), ('usage','usage'),
-        id = self.env['ir.model.data']._update("ir.actions.report.xml", self.module, res, xml_id, noupdate=self.isnoupdate(data_node), mode=self.mode)
+        id = self.env['ir.model.data']._update("ir.actions.report", self.module, res, xml_id, noupdate=self.isnoupdate(data_node), mode=self.mode)
-            value = 'ir.actions.report.xml,'+str(id)
+            value = 'ir.actions.report,'+str(id)
-            self.env['ir.actions.report.xml'].browse(id).write({'ir_values_id': action.id})
+            self.env['ir.actions.report'].browse(id).write({'ir_values_id': action.id})
-            value = 'ir.actions.report.xml,'+str(id)
+            value = 'ir.actions.report,'+str(id)
-            self.env['ir.actions.report.xml'].browse(id).write({'ir_values_id': False})
+            self.env['ir.actions.report'].browse(id).write({'ir_values_id': False})
-    
+
-    (res_data, res_format) = res
+    env = odoo.api.Environment(cr, uid, context)
-        elif action['type']=='ir.actions.report.xml':
+        elif action['type']=='ir.actions.report':
-            res = try_report(cr, uid, 'report.'+action['report_name'], ids, datas, context, our_module=our_module)
+            res = try_report(cr, uid, action['report_name'], ids, datas, context, our_module=our_module)
-        for field,dest in (('rml','report_rml'),('file','report_rml'),('xml','report_xml'),('xsl','report_xsl'),('attachment','attachment'),('attachment_use','attachment_use')):
+        for field,dest in (('file', 'report_file'), ('attachment','attachment'),('attachment_use','attachment_use')):
-        id = self.sudo_env['ir.model.data']._update("ir.actions.report.xml", \
+        id = self.sudo_env['ir.model.data']._update("ir.actions.report", \
-            value = 'ir.actions.report.xml,%s' % id
+            value = 'ir.actions.report,%s' % id
-version_info = (11, 0, 0, ALPHA, 1, '')
+version_info = (10, 'saas~16', 0, FINAL, 0, '')
-        if self.env.uid:  # if the user if logged (portal user), he can be identify
+        if self.env.user and self.env.user.active:  # valid session user (not public)
-    def watch_parent(self, beat=4):
+    def process_limits(self):
-        ppid = os.getppid()
+        self.ppid = os.getppid()
-                return
+            self.process_limits()
-        gevent.spawn(self.watch_parent)
+        gevent.spawn(self.watchdog)
-    me_dbname = me.dbname
+    me_dbname = getattr(me, 'dbname', 'n/a')
-        result = OrderedDict((group.id, {}) for group in groups)
+        # field.group_expand is the name of a method that returns the groups
-                result[left_id] = left_side
+        for line in read_group_result:
-                result[left_id][count_field] = left_side[count_field]
+                result[key][count_field] = line[count_field]
-        return result
+        for value in values:
-from . import ir_attachment
+from . import mrp_document
-            'res_model': 'ir.attachment',
+            'res_model': 'mrp.document',
-        _logger.exception("Call of self.pool.get('%s').%s(cr, uid, *%r) failed in Job %s" % (model_name, method_name, args, job_id))
+            _logger.exception("Call of self.pool.get('%s').%s(cr, uid, *%r) failed in Job %s" % (model_name, method_name, args, job_id))
-                    recips = tools.email_split(partners_email[res_id])
+                else:
-        view_id = self.env.ref('delivery.choose_delivery_package_view_form').id;
+        view_id = self.env.ref('delivery.choose_delivery_package_view_form').id
-                'current_package_carrier_type': self.carrier_id.delivery_type if self.carrier_id.delivery_type not in ['base_on_rule', 'fixed'] else 'none',
+        if self.carrier_id and self.carrier_id.delivery_type not in ['base_on_rule', 'fixed']:
-        }
+        else:
-        'product.packaging', 'product_id', 'Packaging',
+        'product.packaging', 'product_id', 'Product Packages',
-    name = fields.Char('Packaging Type', required=True)
+    name = fields.Char('Package Type', required=True)
-        'product.packaging', string="Packaging", compute="_compute_packaging_ids", inverse="_set_packaging_ids",
+        'product.packaging', string="Product Packages", compute="_compute_packaging_ids", inverse="_set_packaging_ids",
-    product_packaging = fields.Many2one('product.packaging', string='Packaging', default=False)
+    product_packaging = fields.Many2one('product.packaging', string='Package', default=False)
-        help="Select or scan the packaging used to transfer products in operations. This allows to update or check the unit # transferred (which must be a multiple of the unit # per package). Packaging types are set on product detail form.")
+    group_stock_packaging = fields.Boolean('Product Packages',
-        help="Put products in packages and get shipping labels per package unit thanks to shipping connectors.")
+    group_stock_tracking_lot = fields.Boolean("Delivery Packages",
-                        ast.Str(str(tmpl)),
+                        self._compile_format(str(tmpl)),
-        seller_delay = int(self.product_id._select_seller(self.product_id).delay)
+        seller_delay = int(self.product_id._select_seller(product_id=self.product_id, quantity=self.product_qty).delay)
-            _logger.error('id: %s is to long (max: 64)', id)
+from . import controllers
-        """
+        invoice_lines = self.env['account.invoice.line']
-                self.env['account.invoice.line'].create(vals)
+                invoice_lines |= self.env['account.invoice.line'].create(vals)
-from odoo import api, models
+from odoo.exceptions import UserError
-        values.update(self._get_timesheet_cost(values))
+        values.update(self._get_timesheet_values(values))
-            values.update(line._get_timesheet_cost(values))
+            values.update(line._get_timesheet_values(values))
-    def _get_timesheet_cost(self, values):
+    def _get_timesheet_values(self, values):
-            return {
+            result.update({
-        return {}
+            })
-                result.update(self._get_timesheet_cost(result))
+                result.update(self._get_timesheet_values(result))
-        help="This field contains the information related to the numbering of the refund entries of this journal.", copy=False)
+    refund_sequence_id = fields.Many2one('ir.sequence', string='Credit Note Entry Sequence',
-    refund_sequence = fields.Boolean(string='Dedicated Refund Sequence', help="Check this box if you don't want to share the same sequence for invoices and refunds made from this journal", default=False)
+    refund_sequence = fields.Boolean(string='Dedicated Credit Note Sequence', help="Check this box if you don't want to share the same sequence for invoices and credit notes made from this journal", default=False)
-        help="Account that will be set on invoice tax lines for refunds. Leave empty to use the expense account.", oldname='account_paid_id')
+    refund_account_id = fields.Many2one('account.account', domain=[('deprecated', '=', False)], string='Tax Account on Credit Notes', ondelete='restrict',
-        """ Match statement lines with existing payments (eg. checks) and/or payables/receivables (eg. invoices and refunds) and/or new move lines (eg. write-offs).
+        """ Match statement lines with existing payments (eg. checks) and/or payables/receivables (eg. invoices and credit notes) and/or new move lines (eg. write-offs).
-    'in_refund': 'in_invoice',          # Vendor Refund
+    'out_refund': 'out_invoice',        # Customer Credit Note
-            ('in_refund','Vendor Refund'),
+            ('out_refund','Customer Credit Note'),
-    refund_invoice_id = fields.Many2one('account.invoice', string="Invoice for which this invoice is the refund")
+    refund_invoice_id = fields.Many2one('account.invoice', string="Invoice for which this invoice is the credit note")
-        help="Total amount in the currency of the invoice, negative for refunds.")
+        help="Total amount in the currency of the invoice, negative for credit notes.")
-        help="Total amount in the currency of the company, negative for refunds.")
+        help="Total amount in the currency of the company, negative for credit notes.")
-        help='Bank Account Number to which the invoice will be paid. A Company bank account if this is a Customer Invoice or Vendor Refund, otherwise a Partner bank account number.',
+        help='Bank Account Number to which the invoice will be paid. A Company bank account if this is a Customer Invoice or Vendor Credit Note, otherwise a Partner bank account number.',
-                raise UserError(_('You cannot delete an invoice which is not draft or cancelled. You should refund it instead.'))
+                raise UserError(_('You cannot delete an invoice which is not draft or cancelled. You should create a credit note instead.'))
-            #because it's probably a double encoding of the same bill/refund
+            # refuse to validate a vendor bill/credit note if there already exists one with the same reference for the same partner,
-                    raise UserError(_("Duplicated vendor reference detected. You probably encoded twice the same vendor bill/refund."))
+                    raise UserError(_("Duplicated vendor reference detected. You probably encoded twice the same vendor bill/credit note."))
-            'in_refund': _('Vendor Refund'),
+            'out_refund': _('Credit Note'),
-        """ Prepare the dict of values to create the new refund from the invoice.
+        """ Prepare the dict of values to create the new credit note from the invoice.
-            refund generation (making sure to call super() to establish
+            credit note generation (making sure to call super() to establish
-            :param string date_invoice: refund creation date from the wizard
+            :param record invoice: invoice as credit note
-            :param string description: description of the refund from the wizard
+            :param string description: description of the credit note from the wizard
-            :return: dict of value to create() the refund
+            :return: dict of value to create() the credit note
-                'in_invoice': ('vendor bill refund')}
+            invoice_type = {'out_invoice': ('customer invoices credit note'),
-        help="Total amount in the currency of the company, negative for refunds.")
+        help="Total amount in the currency of the company, negative for credit note.")
-                                raise UserError(_('Please define a sequence for the refunds'))
+                                raise UserError(_('Please define a sequence for the credit notes'))
-                    name += _("Customer Refund")
+                    name += _("Customer Credit Note")
-                    name += _("Vendor Refund")
+                    name += _("Vendor Credit Note")
-        ('in_refund', 'Vendor Refund'),
+        ('out_refund', 'Customer Credit Note'),
-                    -- Temporary table to decide if the qty should be added or retrieved (Invoice vs Refund) 
+                    -- Temporary table to decide if the qty should be added or retrieved (Invoice vs Credit Note)
-        # I refund the invoice Using Refund Button
+        # I created a credit note Using Add Credit Note Button
-            description='Refund To China Export',
+            description='Credit Note for China Export',
-        # I clicked on refund button.
+        # I clicked on Add Credit Note button.
-    """Refunds invoice"""
+    """Credit Notes"""
-    _description = "Invoice Refund"
+    _description = "Credit Note"
-    date_invoice = fields.Date(string='Refund Date', default=fields.Date.context_today, required=True)
+    date_invoice = fields.Date(string='Credit Note Date', default=fields.Date.context_today, required=True)
-    filter_refund = fields.Selection([('refund', 'Create a draft refund'), ('cancel', 'Cancel: create refund and reconcile'), ('modify', 'Modify: create refund, reconcile and create a new draft invoice')],
+    filter_refund = fields.Selection([('refund', 'Create a draft credit note'), ('cancel', 'Cancel: create credit note and reconcile'), ('modify', 'Modify: create credit note, reconcile and create a new draft invoice')],
-                    raise UserError(_('Cannot refund draft/cancelled invoice.'))
+                    raise UserError(_('Cannot create credit note for the draft/cancelled invoice.'))
-                    raise UserError(_('Cannot refund invoice which is already reconciled, invoice should be unreconciled first. You can only refund this invoice.'))
+                    raise UserError(_('Cannot create a credit note for the invoice which is already reconciled, invoice should be unreconciled first, then only you can add credit note for this invoice.'))
-                subject = _("Invoice refund")
+                subject = _("Credit Note")
-             "This description will be copied to every Purchase Order, Receipt and Vendor Bill/Refund.")
+             "This description will be copied to every Purchase Order, Receipt and Vendor Bill/Credit Note.")
-             "This description will be copied to every Sales Order, Delivery Order and Customer Invoice/Refund")
+             "This description will be copied to every Sales Order, Delivery Order and Customer Invoice/Credit Note")
-
+    def _message_post_after_hook(self, message):
-
+            'website_sale_order': order,
-class SuppliferInfo(models.Model):
+class SupplierInfo(models.Model):
-        return [{'values': data, 'title': graph_title, 'key': graph_key, 'area': True}]
+        color = '#875A7B' if '+e' in version else '#7c7bad'
-        return [{'values': data, 'area': True}]
+        [graph_title, graph_key] = self._graph_title_and_key()
-        return [{'values': data}]
+        [graph_title, graph_key] = self._graph_title_and_key()
-            return ['', _('Expected Revenue')] # no more title
+            return ['', _('Pipeline: Expected Revenue')] # no more title
-            return ['', _('Untaxed Amount')] # no more title
+            return ['', _('Sales: Untaxed Amount')] # no more title
-            return ['', _('Untaxed Total')] # no more title
+            return ['', _('Sales: Untaxed Total')] # no more title
-            return ['', _('Untaxed Total')]
+            return ['', _('Invoices: Untaxed Total')]
-            if line.account_id.internal_type in ('receivable', 'payable'):
+            if line.account_id == self.account_id:
-    'version': '1.2',
+    'version': '2.0',
-                    {'name': _('Exchange Difference'), 'type': 'general', 'code': _('EXCH'), 'favorite': False, 'sequence': 9},]
+                    {'name': _('Exchange Difference'), 'type': 'general', 'code': _('EXCH'), 'favorite': False, 'sequence': 9},
-                if not move.move_lot_ids:
+                if not move.move_lot_ids.filtered(lambda x: not x.lot_produced_id):
-            cls.pool.model_cache[cls._model_cache_key] = cls
+        cls.pool.model_cache[cls._model_cache_key] = cls
-        if value is None or value == False:
+        if value is None or value is False:
-        if value is None or value == False:
+        if value is None or value is False:
-
+        ('name_unique', 'UNIQUE(model, name)', "Field names must be unique per model."),
-        with self.assertRaises(ValidationError):
+        with self.assertRaises(IntegrityError):
-        with self.assertRaises(ValidationError):
+        with self.assertRaises(IntegrityError):
-            registry.signal_registry_change()
+            registry.registry_invalidated = True
-            self.pool.signal_caches_change()
+            self.pool.signal_changes()
-            registry.signal_registry_change()
+            # setup models; this automatically removes model from registry
-            self.pool.signal_registry_change()
+        # clean up registry first
-            registry.signal_registry_change()
+            # setup models; this re-initializes models in registry
-        self.pool.signal_caches_change()
+        self.pool.cache_invalidated = True
-        # use a test cursor instead of a real cursor
+        # check that the registry is properly reset
-                assert set(registry[self.MODEL]._fields) == fnames
+        def check_registry():
-            pass
+        cls.pool._clear_cache()
-from contextlib import closing
+from contextlib import closing, contextmanager
-        self.cache_cleared = False
+        # Flags indicating invalidation of the registry or the cache.
-                del cls.registries[db_name]
+                registry = cls.registries.pop(db_name)
-            cr.commit()
+    @lazy_property
-                self.cache_cleared = False
+                self.cache_invalidated = False
-        if odoo.multi_process:
+    def signal_changes(self):
-            # signal it through the database to other processes
+        # no need to notify cache invalidation in case of registry invalidation,
-                self.cache_cleared = False
+
-    registry.signal_caches_change()
+    with registry.manage_changes():
-    registry.signal_caches_change()
+    with registry.manage_changes():
-        model.pool.cache_cleared = True
+        model.pool._clear_cache()
-    cr.commit()
+    def _add_manual_models(self):
-            self.pool.clear_manual_fields()
+            self.clear_caches()
-        self.pool.clear_manual_fields()
+        self.clear_caches()
-                    field_data['relation_field'] in self.pool.get_manual_fields(self._cr, field_data['relation'])
+                    field_data['relation_field'] in self._existing_field_data(field_data['relation'])
-                registry.clear_manual_fields()
+                registry.clear_caches()
-        self._add_manual_fields()
+        # 2. add manual fields
-    registry.clear_manual_fields()
+    registry.clear_caches()
-    registry.clear_manual_fields()
+    registry.clear_caches()
-        # load custom models (except when loading 'base')
+        # add manual models
-                model_class._build_model(self, cr)
+            env['ir.model']._add_manual_models()
-        attrs = super(IrModelFields, self)._instanciate_attrs(field_data, partial)
+    def _instanciate_attrs(self, field_data):
-            self.pool.setup_models(self._cr, partial=(not self.pool.ready))
+            self.pool.setup_models(self._cr)
-        attrs = super(IrModelField, self)._instanciate_attrs(field_data, partial)
+    def _instanciate_attrs(self, field_data):
-            self.pool.setup_models(self._cr, partial=(not self.pool.ready))
+            self.pool.setup_models(self._cr)
-                self.pool.setup_models(self._cr, partial=(not self.pool.ready))
+                self.pool.setup_models(self._cr)
-            self.pool.setup_models(self._cr, partial=(not self.pool.ready))
+            self.pool.setup_models(self._cr)
-    def _instanciate_attrs(self, field_data, partial):
+    def _instanciate_attrs(self, field_data):
-            if partial and field_data['relation'] not in self.env:
+            if not self.pool.loaded and field_data['relation'] not in self.env:
-            if partial and not (
+            if not self.pool.loaded and not (
-            if partial and field_data['relation'] not in self.env:
+            if not self.pool.loaded and field_data['relation'] not in self.env:
-    def _instanciate(self, field_data, partial):
+    def _instanciate(self, field_data):
-        return fields.Field.by_type[field_data['ttype']](**attrs)
+        attrs = self._instanciate_attrs(field_data)
-    def _add_manual_fields(self, partial):
+    def _add_manual_fields(self):
-                field = IrModelFields._instanciate(field_data, partial)
+                field = IrModelFields._instanciate(field_data)
-    def _setup_base(self, partial):
+    def _setup_base(self):
-        self._add_manual_fields(partial)
+        self._add_manual_fields()
-            self.env[parent]._setup_base(partial)
+            self.env[parent]._setup_base()
-    def _setup_fields(self, partial):
+    def _setup_fields(self):
-                if partial and field.manual:
+                if not self.pool.loaded and field.manual:
-            registry.setup_models(cr, partial=True)
+            registry.setup_models(cr)
-            registry.setup_models(cr, partial=True)
+            registry.setup_models(cr)
-        self.ready = False
+        # Indicates that the registry is
-    def setup_models(self, cr, partial=False):
+    def setup_models(self, cr):
-            model._setup_base(partial)
+            model._setup_base()
-            model._setup_fields(partial)
+            model._setup_fields()
-        db_registry = openerp.modules.registry.RegistryManager.new(dbname)
+        db_registry = openerp.modules.registry.Registry.new(dbname)
-        return Registry(db_name).signal_registry_change()
+
-                recips = tools.email_split(mail_values.get('email_to'))
+                if mail_values.get('email_to'):
-
+            ProcurementSudo = self.env['procurement.order'].sudo()
-        related='invoice_id.company_id', store=True, readonly=True)
+        related='invoice_id.company_id', store=True, readonly=True, related_sudo=False)
-    company_currency_id = fields.Many2one('res.currency', related='invoice_id.company_currency_id', readonly=True)
+        related='invoice_id.partner_id', store=True, readonly=True, related_sudo=False)
-                continue
+        for line in self.purchase_id.order_line - self.invoice_line_ids.mapped('purchase_line_id'):
-    purchase_id = fields.Many2one('purchase.order', related='purchase_line_id.order_id', string='Purchase Order', store=False, readonly=True,
+    purchase_id = fields.Many2one('purchase.order', related='purchase_line_id.order_id', string='Purchase Order', store=False, readonly=True, related_sudo=False,
-                holiday.write({'meeting_id': meeting.id})
+                holiday._validate_leave_request()
-    layout_category_sequence = fields.Integer(related='layout_category_id.sequence', string='Layout Sequence', store=True, default=0)
+    layout_category_sequence = fields.Integer(related='layout_category_id.sequence', string='Layout Sequence', store=True)
-        return super(AccountConfigSettings, self).create(values)
+        return super(AccountConfigSettings, self).create(values)
-            ('account_id.chart_template_id', '=', self.id)
+            ('chart_template_id', '=', self.id)
-            new_fp = self.create_record_with_xmlid(company, position, 'account.fiscal.position', {'company_id': company.id, 'name': position.name, 'note': position.note})
+            fp_vals = self._get_fp_vals(company, position)
-    _schema.debug("Table %r: column %r changed to type %s", tablename, columntype, columntype)
+        query = '''
-                    SUM(invoice_type.sign * ABS(ail.price_subtotal_signed)) AS price_total,
+                    SUM(ail.price_subtotal_signed) AS price_total,
-            return env['ir.ui.view'].with_context(lang=lang).render_template(
+            response_content = env['ir.ui.view'].with_context(lang=lang).render_template(
-            attendee = env['calendar.attendee'].search([('access_token', '=', token)])
+            attendee = env['calendar.attendee'].search([('access_token', '=', token), ('event_id', '=', int(id))])
-            # If user is logged, redirect to form view of event
+            # If user is internal and logged, redirect to form view of event
-            if request.session.uid:
+            if request.session.uid and request.env['res.users'].browse(request.session.uid).user_has_groups('base.group_user'):
-                warehouse.mto_pull_id.write({'name': warehouse.mto_pull_id.name.replace(warehouse.name, new_name, 1)})
+                if warehouse.mto_pull_id:
-from openerp.tools.float_utils import float_compare
+from openerp.tools.float_utils import float_compare, float_is_zero
-            res.append(tmp)
+            if not float_is_zero(tmp['product_uom_qty'], precision_rounding=order_line.product_uom.rounding):
-import models
+from . import models
-import report
+from . import wizard
-import web_planner
+from . import partner
-import account_journal
+from . import account_financial_report
-import wizard_tax_adjustments
+from . import account_reconcile
-import models
+from . import models
-import res_config
+from . import res_config
-import models
+from . import models
-import product
+from . import account_analytic_default
-import report
+from . import models
-import product
+from . import account
-import account_asset_report
+from . import account_asset_report
-import asset_modify
+from . import asset_depreciation_confirmation_wizard
-import account_journal
+from . import account_bank_statement_import
-import wizard
+from . import wizard
-import journal_creation
+from . import journal_creation
-import models
+from . import models
-import account_analytic_account
+from . import account_budget
-import test_account_budget
+from . import common
-import models
+from . import models
-import account_bank_statement
+from . import account_bank_statement
-import wizard
+from . import models
-import account_payment
+from . import account_journal
-import print_prenumbered_checks
+from . import print_prenumbered_checks
-import models
+from . import models
-import account_tax
+from . import account_tax
-import report
+from . import models
-import accounting_assert_test
+from . import accounting_assert_test
-import report_account_test
+from . import report_account_test
-import models
+from . import models
-import account_voucher
+from . import account_voucher
-import models
+from . import models
-import analytic_account
+from . import analytic_account
-import wizard
+from . import models
-import anonymization
+from . import anonymization
-import anonymize_wizard
+from . import anonymize_wizard
-import models
+from . import models
-import res_users
+from . import res_users
-import models
+from . import models
-import auth_ldap_config_settings
+from . import res_company
-import models
+from . import controllers
-import main
+from . import main
-import res_users
+from . import auth_oauth
-import models
+from . import controllers
-import main
+from . import main
-import res_partner
+from . import res_config
-import models
+from . import models
-import barcode_events_mixin
+from . import barcodes
-import models
+from . import models
-import res_partner
+from . import res_city
-import models
+from . import models
-import base_address_extended
+from . import base_address_extended
-import test_street_fields
+from . import test_street_fields
-import tests
+from . import models
-import ir_actions
+from . import base_automation
-import test_base_automation
+from . import test_models
-import wizard
+from . import models
-import main
+from . import main
-import res_config
+from . import ir_translation
-import base_gengo_translations
+from . import base_gengo_translations
-import models
+from . import models
-import res_partner
+from . import res_partner
-import models
+from . import models
-import res_partner_bank
+from . import res_partner_bank
-import models
+from . import controllers
-import main
+from . import main
-import test_models
+from . import base_import
-    import odf_ods_reader
+    from . import odf_ods_reader
-import test_base_import
+from . import test_base_import
-import models
+from . import controllers
-import main
+from . import main
-import ir_ui_view
+from . import base_import_module
-import models
+from . import models
-import res_config
+from . import res_config
-import models
+from . import models
-import res_config
+from . import res_company
-import models
+from . import controllers
-import main
+from . import main
-import board
+from . import board
-import controllers
+from . import models
-import main
+from . import main
-import res_partner
+from . import bus
-import wizard
+from . import controllers
-import bus
+from . import main
-import calendar
+from . import ir_attachment
-import mail_invite
+from . import mail_invite
-import wizard
+from . import controllers
-import main
+from . import main
-import web_planner
+from . import res_users
-import crm_opportunity_report
+from . import crm_activity_report
-import test_crm_ui
+from . import test_crm_lead
-import crm_merge_opportunities
+from . import base_partner_merge
-import models
+from . import models
-import mail_channel
+from . import mail_channel
-import wizard
+from . import wizard
-import crm_lead2projectissue_wizard
+from . import crm_lead2projectissue_wizard
-import wizard
+from . import models
-import stock_move
+from . import delivery_carrier
-import choose_delivery_package
+from . import choose_delivery_package
-import models
+from . import models
-import ir_attachment
+from . import ir_attachment
-import report
+from . import models
-import res_partner
+from . import event
-import event_confirm
+from . import event_confirm
-import wizard
+from . import models
-import event
+from . import account_invoice
-import test_event_sale
+from . import test_event_sale
-import event_edit_registration
+from . import event_edit_registration
-import models
+from . import models
-import mail_mail
+from . import fetchmail
-import models
+from . import models
-import fleet_vehicle_model
+from . import fleet_vehicle
-import wizard
+from . import models
-import badge
+from . import goal
-import grant_badge
+from . import update_goal
-import controllers
+from . import models
-from models.google_service import TIMEOUT     # noqa
+from .models.google_service import TIMEOUT     # noqa
-import main
+from . import main
-import google_service
+from . import google_service
-import models
+from . import controllers
-import main
+from . import main
-import res_config
+from . import calendar
-import models
+from . import models
-import res_config
+from . import google_drive
-import models
+from . import models
-import google_drive
+from . import base_config_settings
-import models
+from . import models
-import res_users
+from . import hr
-import models
+from . import models
-import res_config
+from . import hr_attendance
-import test_hr_attendance_process
+from . import test_hr_attendance_constraints
-import models
+from . import models
-import hr_contract
+from . import hr_contract
-import wizard
+from . import models
-import web_planner
+from . import account_move_line
-import hr_expense_register_payment
+from . import hr_expense_refuse_reason
-import wizard
+from . import models
-import hr_employee
+from . import gamification
-import gamification_badge_user_wizard
+from . import gamification_badge_user_wizard
-import wizard
+from . import controllers
-import main
+from . import main
-import hr_holidays
+from . import resource
-import hr_holidays_leaves_report
+from . import holidays_summary_report
-import test_holidays_flow
+from . import test_holidays_flow
-import hr_holidays_summary_employees
+from . import hr_holidays_summary_department
-import models
+from . import models
-import equipment
+from . import equipment
-import models
+from . import controllers
-import hr_org_chart
+from . import hr_org_chart
-import hr_employee
+from . import hr_employee
-import wizard
+from . import models
-import hr_payslip
+from . import hr_contract
-import report_contribution_register
+from . import report_payslip_details
-import hr_payroll_contribution_register_report
+from . import hr_payroll_payslips_by_employees
-import wizard
+from . import models
-import hr_payroll_account
+from . import hr_payroll_account
-import test_hr_payroll_account
+from . import test_hr_payroll_account
-import hr_payroll_payslips_by_employees
+from . import hr_payroll_payslips_by_employees
-import report
+from . import models
-import calendar
+from . import hr_department
-import hr_recruitment_report
+from . import hr_recruitment_report
-import models
+from . import models
-import hr_applicant
+from . import hr_job
-import report
+from . import hr_timesheet
-import project_report
+from . import project_report
-import report
+from . import models
-import res_company
+from . import hr_attendance
-import hr_timesheet_attendance_report
+from . import hr_timesheet_attendance_report
-import test_hr_timesheet_sheet
+from . import test_hr_timesheet_sheet
-import wizard
+from . import models
-import res_company
+from . import account_analytic_line
-import hr_timesheet_current
+from . import hr_timesheet_current
-import controllers
+from . import controllers
-import main
+from . import main
-import escpos
+from . import controllers
-import main
+from . import main
-import xml.etree.ElementTree as ET
+from hashlib import md5
-from exceptions import *
+from .constants import *
-        id = md5.new(img).digest()
+        id = md5(img).digest()
-from exceptions import *
+from .escpos import *
-import controllers
+from . import controllers
-import main
+from . import main
-import controllers
+from . import controllers
-import main
+from . import main
-import controllers
+from . import controllers
-import main
+from . import main
-import controllers
+from . import controllers
-import main
+from . import main
-import controllers
+from . import controllers
-import main
+from . import main
-import controllers
+from . import controllers
-import main
+from . import main
-import report
+from . import controllers
-import main
+from . import main
-import rating
+from . import im_livechat_channel
-import im_livechat_report_operator
+from . import im_livechat_report_channel
-import models
+from . import models
-import l10n_be_hr_payroll
+from . import l10n_be_hr_payroll
-import models
+from . import models
-import hr_contract
+from . import fleet
-import wizard
+from . import models
-import l10n_be_intrastat
+from . import l10n_be_intrastat
-import xml_decl
+from . import xml_decl
-import models
+from . import models
-import account_invoice
+from . import res_partner
-import models
+from . import models
-import account
+from . import account
-import models
+from . import models
-import res_config
+from . import account_invoice
-import models
+from . import wizard
-import eu_service_tax_rate
+from . import eu_service_tax_rate
-import wizard
+from . import wizard
-import models
+from . import models
-import l10n_fr
+from . import l10n_fr
-import wizard
+from . import wizard
-import account_fr_fec
+from . import account_fr_fec
-import report
+from . import models
-import l10n_fr_hr_payroll_config_settings
+from . import l10n_fr_hr_payroll
-import fiche_paye
+from . import fiche_paye
-import wizard
+from . import models
-import l10n_in_hr_payroll
+from . import l10n_in_hr_payroll
-import payslip_report
+from . import report_payslip_details
-import hr_yearly_salary_detail
+from . import hr_salary_employee_bymonth
-import models
+from . import models
-import l10n_multilang
+from . import account
-import models
+from . import models
-import res_partner
+from . import res_partner
-import controller
+from . import models
-import main
+from . import main
-import link_tracker
+from . import link_tracker
-import models
+from . import wizard
-import lunch
+from . import lunch
-import test_lunch
+from . import test_lunch
-import lucky_order
+from . import lucky_order
-import tests.test_mail_model
+from . import models
-import bus
+from . import main
-import html2text
+from . import mail_message_subtype
-import test_update_notification
+from . import test_mail_followers
-import email_template_preview
+from . import invite
-import models
+from . import models
-import maintenance
+from . import maintenance
-import test_maintenance
+from . import test_maintenance
-import report
+from . import models
-import marketing_campaign
+from . import ir_actions
-import campaign_analysis
+from . import campaign_analysis
-import test_marketing_campaign_flow
+from . import test_marketing_campaign_flow
-import wizard
+from . import controllers
-import web_editor
+from . import main
-import link_tracker
+from . import mass_mailing
-import mail_compose_message
+from . import test_mailing
-import models
+from . import models
-import event
+from . import event
-import models
+from . import models
-import event
+from . import event
-import report
+from . import models
-import account_invoice
+from . import membership
-import report_membership
+from . import report_membership
-import membership_invoice
+from . import membership_invoice
-import report
+from . import models
-import stock_warehouse
+from . import ir_attachment
-import mrp_bom_structure_report
+from . import mrp_bom_cost_report
-import test_procurement
+from . import test_bom
-import change_production_qty
+from . import mrp_product_produce
-import wizard
+from . import models
-import stock_move
+from . import mrp_bom
-import test_mrp_byproduct
+from . import test_mrp_byproduct
-import change_production_qty
+from . import change_production_qty
-import wizard
+from . import models
-import mrp_repair
+from . import mrp_repair
-import test_mrp_repair
+from . import test_mrp_repair
-import mrp_repair_make_invoice
+from . import mrp_repair_cancel
-import models
+from . import models
-import res_users
+from . import note
-import models
+from . import models
-import note
+from . import note
-import models
+from . import models
-import res_config
+from . import pad
-import models
+from . import models
-import project_task
+from . import project_config_settings
-import models
+from . import models
-import account_payment
+from . import payment_acquirer
-import common
+from . import common
-import controllers
+from . import models
-import main
+from . import main
-import payment
+from . import payment
-import controllers
+from . import models
-import main
+from . import main
-import payment
+from . import payment
-from authorize_request import AuthorizeAPI
+from .authorize_request import AuthorizeAPI
-import controllers
+from . import models
-import main
+from . import main
-import payment
+from . import payment
-import controllers
+from . import models
-import main
+from . import main
-import ogone
+from . import ogone
-import payment
+from . import payment
-import controllers
+from . import models
-import main
+from . import main
-import payment
+from . import payment
-import test_paypal
+from . import test_paypal
-import controllers
+from . import models
-import main
+from . import main
-import payment
+from . import payment
-import controllers
+from . import models
-import main
+from . import main
-import payment
+from . import payment
-import controllers
+from . import models
-import main
+from . import main
-import payment
+from . import payment
-import test_stripe
+from . import test_stripe
-import controllers
+from . import models
-import main
+from . import main
-import payment
+from . import payment
-import wizard
+from . import models
-import web_editor
+from . import main
-import res_users
+from . import account_bank_statement
-import pos_order_report
+from . import pos_invoice
-import test_point_of_sale_ui
+from . import test_point_of_sale_flow
-import pos_payment
+from . import pos_box
-import models
+from . import models
-import pos_cache
+from . import pos_cache
-import models
+from . import models
-import pos_config
+from . import pos_config
-import models
+from . import models
-import pos_mercury_transaction
+from . import pos_mercury
-import models
+from . import models
-import pos_config
+from . import pos_config
-import models
+from . import models
-import pos_restaurant
+from . import pos_config
-import models
+from . import models
-import pos_session
+from . import pos_config
-import wizard
+from . import models
-import procurement
+from . import procurement
-import test_procurement
+from . import test_procurement
-import procurement_order_compute_all
+from . import procurement_order_compute_all
-import sale
+from . import sale
-import wizard
+from . import models
-import decimal_precision
+from . import base_config_settings
-import product
+from . import product_template
-import res_partner
+from . import product_attribute
-import product_pricelist
+from . import product_pricelist
-import product_price_list
+from . import product_price_list
-import models
+from . import models
-import account_invoice
+from . import product
-import models
+from . import models
-import stock_quant
+from . import production_lot
-import models
+from . import models
-import product
+from . import product
-import models
+from . import wizard
-import product_product
+from . import product_product
-import product_margin
+from . import product_margin
-import wizard
+from . import models
-import web_planner
+from . import project
-import project_report
+from . import project_report
-import project_task_merge_wizard
+from . import project_task_merge_wizard
-import report
+from . import models
-import project_issue_config_settings
+from . import project_issue
-import project_issue_report
+from . import project_issue_report
-import test_issue_demo
+from . import test_subscribe_issue
-import models
+from . import models
-import account_analytic_line
+from . import project_issue
-import report
+from . import models
-import stock
+from . import account_invoice
-import purchase_report
+from . import purchase_report
-import test_purchase_lead_time
+from . import test_onchange_product_id
-import models
+from . import models
-import purchase_mrp
+from . import purchase_mrp
-import models
+from . import models
-import purchase_requisition
+from . import purchase_requisition
-import test_purchase_requisition
+from . import test_purchase_requisition
-import controllers
+from . import models
-import main
+from . import main
-import rating
+from . import rating
-import models
+from . import models
-import project
+from . import project
-import models
+from . import models
-import project_issue
+from . import project_issue
-import tests
+from . import controllers
-import main
+from . import main
-import res_company
+from . import abstract_report
-import test_reports
+from . import test_reports
-import report
+from . import models
-import report_intrastat
+from . import report_intrastat
-import report_intrastat_report
+from . import report_intrastat_report
-import test_report_intrastat
+from . import test_report_intrastat
-import tests.test_resource_model
+from . import models
-import res_users
+from . import resource
-import wizard
+from . import models
-import sales_team
+from . import account_invoice
-import invoice_report
+from . import sale_report
-import test_sale_order
+from . import test_sale_to_invoice
-import test_sale_ui
+from . import test_sale_ui
-from test_sale_common import TestSale
+from .test_sale_common import TestSale
-import mail_compose_message
+from . import sale_make_invoice_advance
-import models
+from . import models
-import sale_order
+from . import account_invoice
-import test_sale_expense
+from . import test_sale_expense
-import report      # noqa
+from . import models      # noqa
-import sale_order
+from . import sale_order
-import sale_report
+from . import sale_report
-import models
+from . import sale_mrp
-import procurement
+from . import procurement
-import test_sale_mrp_lead_time
+from . import test_move_explode
-import models
+from . import models
-import sale_order
+from . import sale_order
-import test_requested_date
+from . import test_requested_date
-import models
+from . import models
-import project
+from . import project
-import sale_report
+from . import sale_report
-import test_sale_stock_lead_time
+from . import test_sale_stock
-import models
+from . import models
-import sale_order
+from . import account
-import test_sale_service
+from . import test_sale_timesheet
-import models
+from . import models
-import res_config
+from . import crm_team
-import wizard
+from . import controllers
-import main
+from . import main
-import web_planner
+from . import barcode
-import report_stock_forecast
+from . import report_stock_forecast
-import test_shipment
+from . import test_product
-import stock_backorder_confirmation
+from . import stock_picking_return
-import wizard
+from . import models
-import stock_config_settings
+from . import account_chart_template
-import stock_history
+from . import stock_history
-import wizard_valuation_history
+from . import stock_change_standard_price
-import models
+from . import models
-import stock
+from . import procurement
-import models
+from . import models
-import stock_landed_cost
+from . import product
-import wizard
+from . import models
-import stock_picking_wave
+from . import stock_picking_wave
-import stock_picking_to_wave
+from . import stock_picking_to_wave
-import tests
+from . import controllers
-import main
+from . import main
-import ir_autovacuum
+from . import survey
-import test_survey_ui
+from . import test_survey
-import survey_email_compose_message
+from . import survey_email_compose_message
-import models
+from . import models
-import survey
+from . import survey
-import models
+from . import models
-import ir_http
+from . import utm
-import models
+from . import controllers
-import ir_http
+from . import ir_http
-import test_serving_base
+from . import test_js
-import tests
+from . import controllers
-import main
+from . import main
-import ir_translation
+from . import ir_attachment
-import test_models
+from . import test_models
-import test_converter
+from . import test_ui
-import models
+from . import models
-import web_planner
+from . import web_planner
-import models
+from . import controllers
-import main
+from . import main
-import res_users
+from . import res_users
-import models
+from . import models
-import tour
+from . import ir_http
-import tests
+from . import controllers
-import main
+from . import backend
-import web_planner
+from . import ir_actions
-import test_views
+from . import test_converter
-import base_language_install
+from . import base_language_install
-import models
+from . import controllers
-import main
+from . import main
-import website_blog
+from . import mail_message
-import models
+from . import models
-import website_crm_config_settings
+from . import crm_lead
-import test_website_crm
+from . import test_website_crm
-import wizard
+from . import controllers
-import main
+from . import main
-import res_partner
+from . import crm_lead
-import crm_partner_report
+from . import crm_lead_report
-import crm_forward_to_partner
+from . import crm_forward_to_partner
-import models
+from . import controllers
-import main
+from . import main
-import res_partner
+from . import res_partner
-import models
+from . import controllers
-import main
+from . import main
-import event
+from . import event
-import test_ui
+from . import test_ui
-import report
+from . import controllers
-import main
+from . import main
-import event
+from . import event
-import report_event_registrations_questions
+from . import report_event_registrations_questions
-import models
+from . import controllers
-import main
+from . import main
-import website
+from . import product
-import test_ui
+from . import test_ui
-import models
+from . import controllers
-import main
+from . import main
-import event
+from . import event_track
-import models
+from . import controllers
-import main
+from . import main
-import models
+from . import models
-import tests
+from . import controllers
-import main
+from . import main
-import forum
+from . import gamification
-import test_forum_process
+from . import common
-import models
+from . import controllers
-import main
+from . import main
-import forum_post
+from . import forum_documentation_toc
-import models
+from . import controllers
-import main
+from . import main
-import base_gengo_translations
+from . import base_gengo_translations
-import controllers
+from . import controllers
-import main
+from . import main
-import models
+from . import controllers
-import main
+from . import main
-import hr_employee
+from . import hr_employee
-import models
+from . import controllers
-import main
+from . import main
-import hr_recruitment
+from . import hr_recruitment
-import test_website_hr_recruitment
+from . import test_website_hr_recruitment
-import controller
+from . import controller
-import main
+from . import main
-import models
+from . import controllers
-import main
+from . import main
-import website
+from . import im_livechat
-import models
+from . import controllers
-import main
+from . import main
-import update
+from . import mail_message
-import models
+from . import controllers
-import main
+from . import main
-import mail_mail
+from . import mail_channel
-import models
+from . import controllers
-import main
+from . import main
-import membership
+from . import membership
-import controllers
+from . import models
-import main
+from . import main
-import res_partner
+from . import res_partner
-import controllers
+from . import models
-import main
+from . import main
-import website
+from . import payment
-import wizard
+from . import controllers
-import main
+from . import main
-import test_portal
+from . import test_load_process
-import portal_wizard
+from . import portal_wizard
-import models
+from . import controllers
-import website_portal
+from . import website_portal
-import purchase
+from . import purchase
-import models
+from . import controllers
-import main
+from . import main
-import payment
+from . import account_invoice
-import models
+from . import controllers
-import main
+from . import main
-import project
+from . import project
-import test_access_rights
+from . import test_access_rights
-import models
+from . import controllers
-import main
+from . import main
-import project_issue
+from . import project_issue
-import models
+from . import controllers
-import main
+from . import main
-import product_template
+from . import sale_order
-import models
+from . import controllers
-import main
+from . import main
-import project
+from . import project
-import models
+from . import controllers
-import website_mail
+from . import backend
-import website
+from . import ir_http
-import test_website_sale_pricelist
+from . import test_sale_process
-import controllers
+from . import models
-import main
+from . import main
-import website_sale_comparison
+from . import website_sale_comparison
-import controllers
+from . import models
-import main
+from . import main
-import sale_order
+from . import res_country
-import models
+from . import controllers
-import main
+from . import main
-import product
+from . import ir_attachment
-import models
+from . import controllers
-import main
+from . import main
-import sale_order
+from . import product
-import test_customize
+from . import test_customize
-import models
+from . import models
-import website
+from . import website
-import controllers
+from . import models
-import main
+from . import main
-import product_wishlist
+from . import product_wishlist
-import models
+from . import controllers
-import main
+from . import main
-import slides
+from . import res_config
-import models
+from . import models
-import ir_module_module
+from . import ir_module_module
-import models
+from . import controllers
-import main
+from . import main
-import website_twitter_tweet
+from . import website_twitter
-import tools
+from . import addons
-import http
+from . import cli
-import tests
+from . import ir
-import ir_logging
+from . import ir_model
-import urllib2
+from io import BytesIO
-            image = Image.open(StringIO(value.decode('base64')))
+            image = Image.open(BytesIO(value.decode('base64')))
-from urlparse import urlparse
+import json
-import logging
+from .qweb import QWeb, Contextifier
-from lxml import etree, html
+import logging
-from itertools import count
+
-builtin_defaults = {name: getattr(__builtin__, name) for name in dir(__builtin__)}
+try:
-import report
+from . import module
-import urlparse
+try:
-                    content = urllib2.urlopen(url).read()
+                    content = urlopen(url).read()
-                    zipfile.ZipFile(StringIO(content)).extractall(tmp)
+                    zipfile.ZipFile(io.BytesIO(content)).extractall(tmp)
-import ir_module_reference_print
+from . import ir_module_reference_print
-import base_update_translations
+from . import base_module_update
-import cStringIO
+import io
-        with contextlib.closing(cStringIO.StringIO()) as buf:
+        with contextlib.closing(io.BytesIO()) as buf:
-import cStringIO
+import io
-        with contextlib.closing(cStringIO.StringIO()) as buf:
+        with contextlib.closing(io.BytesIO()) as buf:
-import preview_report
+from . import preview_report
-import ir_property
+from . import res_country
-import urlparse
+
-            image_content = urllib2.urlopen(url + "?d=404&s=128", timeout=5).read()
+            image_content = urlopen(url + "?d=404&s=128", timeout=5).read()
-import test_translate
+from . import test_acl
-import test_res_partner_bank
+from . import test_user_has_group
-from StringIO import StringIO
+import io
-invalid_form = etree.parse(StringIO('''\
+invalid_form = etree.parse(io.BytesIO('''\
-valid_form = etree.parse(StringIO('''\
+valid_form = etree.parse(io.BytesIO('''\
-invalid_graph = etree.parse(StringIO('''\
+invalid_graph = etree.parse(io.BytesIO('''\
-valid_graph = etree.parse(StringIO('''\
+valid_graph = etree.parse(io.BytesIO('''\
-invalid_tree = etree.parse(StringIO('''\
+invalid_tree = etree.parse(io.BytesIO('''\
-valid_tree = etree.parse(StringIO('''\
+valid_tree = etree.parse(io.BytesIO('''\
-import models
+from . import models
-import test_ir_rules
+from . import test_ir_rules
-import controllers
+from . import controllers
-import models
+from . import models
-import models
+from . import models
-import tests
+from . import models
-import test_pylint
+from . import test_pylint
-                self.fail(msg="\n" + out)
+                self.fail("\n" + out)
-from command import Command, main
+from .command import Command, main
-import start
+from . import deploy
-import deprecation
+from . import deprecation
-from tools.func import frame_codeinfo
+from .tools.func import frame_codeinfo
-import xmlrpclib
+try:
-        if value and value > xmlrpclib.MAXINT:
+        if value and value > MAXINT:
-import urlparse
+try:
-            debug = bool(urlparse.parse_qs(urlparse.urlparse(self.httprequest.referrer).query, keep_blank_values=True).get('debug'))
+            debug = bool(parse_qs(urlparse(self.httprequest.referrer).query, keep_blank_values=True).get('debug'))
-            parsed = urlparse.urlparse(referer)
+            parsed = urlparse(referer)
-    escaped = urllib2.quote(filename.encode('utf8'))
+    escaped = quote(filename.encode('utf8'))
-import zipimport
+import logging
-import release
+from . import release
-import tools
+from . import sql_db
-    from tools.translate import resetlocale
+    from .tools.translate import resetlocale
-import osv
+from . import osv
-import server
+from . import common
-import security
+from . import security
-import security
+from . import security
-import security
+from . import security
-import socket
+try:
-import urlparse
+try:
-from tools.func import frame_codeinfo
+from . import tools
-from common import *
+from . import common
-import models
+from . import models
-import xmlrpclib
+try:
-from xml_utils import *
+from . import win32
-from translate import _
+from .translate import _
-    import _winreg
+    try:
-import ConfigParser
+try:
-import appdirs
+from . import appdirs
-import cStringIO
+import io
-    input = cStringIO.StringIO(csvcontent) #FIXME
+    input = io.BytesIO(csvcontent) #FIXME
-from func import synchronized
+from .func import synchronized
-import logging
+import io
-from which import which
+from .which import which
-from cache import *
+from .config import config
-                fo = StringIO()
+                fo = io.BytesIO()
-        unpickler = cPickle.Unpickler(stream)
+        unpickler = pickle_.Unpickler(stream)
-        return cls.load(StringIO(text))
+        return cls.load(io.BytesIO(text))
-    dump = cPickle.dump
+    dumps = pickle_.dumps
-import config
+from . import config
-from odoo import sql_db, SUPERUSER_ID
+from . import config, pycompat
-            return sql_db.db_connect(db_name)
+            return odoo.sql_db.db_connect(db_name)
-                    env = odoo.api.Environment(cr, SUPERUSER_ID, {})
+                    env = odoo.api.Environment(cr, odoo.SUPERUSER_ID, {})
-    env = odoo.api.Environment(cr, SUPERUSER_ID, {})
+    env = odoo.api.Environment(cr, odoo.SUPERUSER_ID, {})
-    env = odoo.api.Environment(cr, SUPERUSER_ID, context or {})
+    env = odoo.api.Environment(cr, odoo.SUPERUSER_ID, context or {})
-    env = odoo.api.Environment(cr, SUPERUSER_ID, {})
+    env = odoo.api.Environment(cr, odoo.SUPERUSER_ID, {})
-    partner_id = fields.Many2one('res.partner', string='Subcontracting Partner')
+    member_ids = fields.Many2many('res.users', 'maintenance_team_users_rel', string="Team Members")
-            request.message_subscribe_users(user_ids=[request.owner_user_id.id])
+        if request.owner_user_id or request.technician_user_id:
-            self.message_subscribe_users(user_ids=[vals['owner_user_id']])
+        if vals.get('owner_user_id') or vals.get('technician_user_id'):
-        return self.env['report'].get_action(self, 'account.report_financial', data=data)
+        return self.env['report'].get_action(self, 'account.report_financial', data=data, config=False)
-from odoo.tools.misc import formatLang
+from odoo.tools import float_is_zero, float_compare, pycompat
-        if isinstance( pay_journal, ( int, long ) ):
+        if isinstance(pay_journal, pycompat.integer_types):
-PY2 = sys.version_info[0]
+PY2 = sys.version_info[0] == 2
-            'AMOUNT': self.amount * 100,
+            'AMOUNT': int(self.amount * 100),
-
+    _rec_name = 'complete_name'
-
+    _rec_name = 'complete_name'
-        seq_id = preferred_sequences[0] if preferred_sequences else seq_ids[0]
+        seq_ids = self.search([('code', '=', sequence_code), ('company_id', 'in', [force_company, False])], order='company_id')
-from odoo.tools import DEFAULT_SERVER_DATETIME_FORMAT
+from odoo.tools import DEFAULT_SERVER_DATETIME_FORMAT, pycompat
-        for num in xrange(1, 100):
+        for num in pycompat.range(1, 100):
-                for num in xrange(1, 100):
+                for num in pycompat.range(1, 100):
-from odoo.tools import float_is_zero
+from odoo.tools import float_is_zero, pycompat
-            if isinstance(aml_dict['move_line'], (int, long)):
+            if isinstance(aml_dict['move_line'], pycompat.integer_types):
-            if aml_dict.get('tax_ids') and aml_dict['tax_ids'] and isinstance(aml_dict['tax_ids'][0], (int, long)):
+            if aml_dict.get('tax_ids') and isinstance(aml_dict['tax_ids'][0], pycompat.integer_types):
-    return ''.join(random.SystemRandom().choice(chars) for i in xrange(20))
+    return ''.join(random.SystemRandom().choice(chars) for _ in pycompat.range(20))
-from odoo.tools import DEFAULT_SERVER_DATE_FORMAT, DEFAULT_SERVER_DATETIME_FORMAT
+from odoo.tools import DEFAULT_SERVER_DATE_FORMAT, DEFAULT_SERVER_DATETIME_FORMAT, pycompat
-    if isinstance(ids, (basestring, int, long)):
+    if isinstance(ids, (basestring, pycompat.integer_types)):
-        return ids
+        # seq of (field, should_reverse)
-            for i in xrange(0, 7):
+            for i in pycompat.range(0, 7):
-            if not isinstance(ls, (basestring, int, long)) and len(ls) >= 2:
+            if not isinstance(ls, (basestring, pycompat.integer_types)) and len(ls) >= 2:
-                    if result is not None and isinstance(result, (float, int, long)):
+                    if result is not None and isinstance(result, (float, pycompat.integer_types)):
-                                if isinstance(queried_value, tuple) and len(queried_value) == 2 and isinstance(queried_value[0], (int, long)):
+                                if isinstance(queried_value, tuple) and len(queried_value) == 2 and isinstance(queried_value[0], pycompat.integer_types):
-            file(os.path.join(config['test_report_directory'], 'hr_payroll-payslip.'+ format), 'wb+').write(data)
+            open(os.path.join(config['test_report_directory'], 'hr_payroll-payslip.'+ format), 'wb+').write(data)
-            file(os.path.join(config['test_report_directory'], 'hr_payroll-payslipdetails.'+ format), 'wb+').write(data)
+            open(os.path.join(config['test_report_directory'], 'hr_payroll-payslipdetails.'+ format), 'wb+').write(data)
-        ordered_cmds.sort(lambda x,y: cmp(self.cmds[x]['_order'], self.cmds[y]['_order']))
+        ordered_cmds = sorted(self.cmds.keys(), key=lambda x: self.cmds[x]['_order'])
-        if isinstance(res_ids, (int, long)):
+        if isinstance(res_ids, pycompat.integer_types):
-            file(os.path.join(config['test_report_directory'], 'l10n_in_hr_payroll_summary_report' + format), 'wb+').write(data)
+            open(os.path.join(config['test_report_directory'], 'l10n_in_hr_payroll_summary_report' + format), 'wb+').write(data)
-        'reduce': reduce,
+        'reduce': functools.reduce,
-        if isinstance(res_ids, (int, long)):
+        if isinstance(res_ids, pycompat.integer_types):
-        if isinstance(res_ids, (int, long)):
+        if isinstance(res_ids, pycompat.integer_types):
-        if isinstance(res_ids, (int, long)):
+        if isinstance(res_ids, pycompat.integer_types):
-            elif isinstance(partner_id, (int, long)):
+            elif isinstance(partner_id, pycompat.integer_types):
-        for email_chunk in email_chunks:
+        recipients_nbr = len(recipients)
-                recipient_values = tig.message_get_recipient_values(notif_message=message, recipient_ids=email_chunk.ids)
+                recipient_values = tig.message_get_recipient_values(notif_message=message, recipient_ids=email_chunk)
-                recipient_values = self.env['mail.thread'].message_get_recipient_values(notif_message=None, recipient_ids=email_chunk.ids)
+                recipient_values = self.env['mail.thread'].message_get_recipient_values(notif_message=None, recipient_ids=email_chunk)
-            elif isinstance(partner_id, (int, long)):
+            elif isinstance(partner_id, pycompat.integer_types):
-        if isinstance(res_ids, (int, long)):
+        if isinstance(res_ids, pycompat.integer_types):
-        if isinstance(res_ids, (int, long)):
+        if isinstance(res_ids, pycompat.integer_types):
-            'AMOUNT': long(self.amount * 100),
+            'AMOUNT': self.amount * 100,
-            elif isinstance(pricelist_id_or_name, (int, long)):
+            elif isinstance(pricelist_id_or_name, pycompat.integer_types):
-            elif isinstance(pricelist_id_or_name, (int, long)):
+            elif isinstance(pricelist_id_or_name, pycompat.integer_types):
-            pdfreport = file(document, 'rb')
+            pdfreport = open(document, 'rb')
-            file(os.path.join(tools.config['test_report_directory'], 'report_intrastat-intrastat_report.' + report_format), 'wb+').write(data)
+            open(os.path.join(tools.config['test_report_directory'], 'report_intrastat-intrastat_report.' + report_format), 'wb+').write(data)
-        ]
+        self._days = [dt.date() for dt in rrule.rrule(rrule.DAILY, dtstart=WAR_START, until=WAR_END)]
-                for name, field in lines[i]._fields.iteritems():
+            for i, line in enumerate(lines):
-                        lines[i][name] = False
+                        result[i][2][name] = [(6, 0, line[name].ids)]
-            for x in xrange(0, len(confirmed_moves.ids), 100):
+            for moves_chunk in split_every(100, confirmed_moves.ids):
-                self.env['stock.move'].browse(confirmed_moves.ids[x:x + 100]).action_assign()
+                self.env['stock.move'].browse(moves_chunk).action_assign()
-            if isinstance(self.env.context['location'], (int, long)):
+            if isinstance(self.env.context['location'], pycompat.integer_types):
-                if isinstance(self.env.context['warehouse'], (int, long)):
+                if isinstance(self.env.context['warehouse'], pycompat.integer_types):
-        if self._context.get('location') and isinstance(self._context['location'], (int, long)):
+        if self._context.get('location') and isinstance(self._context['location'], pycompat.integer_types):
-        elif isinstance(view_id, (int, long)):
+        elif isinstance(view_id, pycompat.integer_types):
-        elif isinstance(view_id, (int, long)):
+        elif isinstance(view_id, pycompat.integer_types):
-        if 'website_id' in self._context and not isinstance(xml_id, (int, long)):
+        if 'website_id' in self._context and not isinstance(xml_id, pycompat.integer_types):
-from odoo.tools import ustr
+from odoo.tools import ustr, pycompat
-        if isinstance(template, (int, long)):
+        if isinstance(template, pycompat.integer_types):
-                {'url': get_url(page), 'num': page} for page in xrange(pmin, pmax+1)
+                {'url': get_url(page), 'num': page} for page in pycompat.range(pmin, pmax+1)
-            convitems.sort(lambda x, y: cmp(gd(x), gd(y)))
+            convitems.sort(key=lambda x: hasattr(x[1], 'domain') and (x[1].domain != '[]'))
-        self.assertIn(code, xrange(200, 300), "%s Fetching %s returned error response (%d)" % (msg, url, code))
+        self.assertIn(code, pycompat.range(200, 300), "%s Fetching %s returned error response (%d)" % (msg, url, code))
-        if isinstance(group_ids, (int, long)):
+        if isinstance(group_ids, pycompat.integer_types):
-        if isinstance(name, (int, long)) or is_child_view(name):
+        if isinstance(name, pycompat.integer_types) or is_child_view(name):
-        enum = xrange(enum)
+        enum = pycompat.range(enum)
-            if isinstance(res_id, (int, long)):
+            if isinstance(res_id, pycompat.integer_types):
-                menus = menus[long(offset):]
+                menus = menus[offset:]
-                menus = menus[:long(limit)]
+                menus = menus[:limit]
-from odoo.tools import config, graph, ConstantMapping, SKIPPED_ELEMENT_TYPES
+from odoo.tools import config, graph, ConstantMapping, SKIPPED_ELEMENT_TYPES, pycompat
-        if isinstance(template, (int, long)):
+        if isinstance(template, pycompat.integer_types):
-        assert isinstance(self.id, (int, long))
+        assert isinstance(self.id, pycompat.integer_types)
-            elif isinstance(value, (int, long)):
+            elif isinstance(value, pycompat.integer_types):
-from odoo.tools import mute_logger
+from odoo.tools import mute_logger, pycompat
-        self.assertIsInstance(count2, (int, long))
+        self.assertIsInstance(count1, pycompat.integer_types)
-        for i in xrange(4):
+        for i in range(4):
-from odoo.tools import float_compare, float_is_zero, float_repr, float_round, float_split_str
+from odoo.tools import float_compare, float_is_zero, float_repr, float_round, float_split_str, pycompat
-                frac, exp, prec = fractions[i], expecteds[i], precisions[i]
+        for magnitude in pycompat.range(7):
-                        n = x * 10**magnitude
+                    for x in pycompat.range(0, 10000, 97):
-                        f_exp = ('-' if f != 0 and sign == -1 else '') + str(n) + exp 
+                        f_exp = ('-' if f != 0 and sign == -1 else '') + str(n) + exp
-            for i in xrange(1, 10):
+            for i in range(1, 10):
-            for i in xrange(1, 10):
+            for i in range(1, 10):
-        for i in xrange(1, 5):
+        for i in range(1, 5):
-        for i in xrange(1, 5):
+        for i in range(1, 5):
-        for i in xrange(1, 5):
+        for i in range(1, 5):
-        for i in xrange(1, 5):
+        for i in range(1, 5):
-        s = misc.CountingStream(xrange(1))
+        s = misc.CountingStream(range(1))
-        s = misc.CountingStream(xrange(42))
+        s = misc.CountingStream(range(42))
-from odoo.tools import mute_logger
+from odoo.tools import mute_logger, pycompat
-            self.assertIsInstance(defaults['partner_id'], (bool, int, long))
+            self.assertIsInstance(defaults['partner_id'], (bool, pycompat.integer_types))
-        self.assertIsInstance(res[1], (int, long))
+        self.assertIsInstance(res[1], pycompat.integer_types)
-            for i in xrange(10000000):
+            for i in pycompat.range(10000000):
-        self.assertIsInstance(instance.unknown, (int, long))
+        self.assertIsInstance(instance.unknown, pycompat.integer_types)
-                       html_sanitize, human_size, pg_varchar, ustr, OrderedSet
+from odoo.tools import float_precision, float_repr, float_round, frozendict, html_sanitize, human_size, pg_varchar, ustr, OrderedSet, pycompat
-        if isinstance(value, (int, long)) and \
+        if isinstance(value, pycompat.integer_types) and \
-            body = "%s(%s);" % (self.jsonp, json.dumps(response),)
+            body = "%s(%s);" % (self.jsonp, json.dumps(response, default=ustr),)
-            body = json.dumps(response)
+            body = json.dumps(response, default=ustr)
-        "arguments": to_jsonable(e.args),
+        "arguments": e.args,
-
+from odoo.tools import pycompat
-IdType = (int, long, str, unicode, NewId)
+IdType = pycompat.integer_types + (str, unicode, NewId)
-        return res if isinstance(res, (int, long)) else len(res)
+        return res if isinstance(res, pycompat.integer_types) else len(res)
-            if self._fields[name].type == 'many2many' and value and isinstance(value[0], (int, long)):
+            if self._fields[name].type == 'many2many' and value and isinstance(value[0], pycompat.integer_types):
-            (ids if isinstance(i, (int, long)) else new_ids).append(i)
+            (ids if isinstance(i, pycompat.integer_types) else new_ids).append(i)
-        self.children.sort(lambda x, y: cmp(x.name, y.name))
+        self.children.sort(key=lambda x: x.name)
-                        if not isinstance(fp, file):
+                        # FIXME: imp.load_source removed in P3, and so is the ``file`` object...
-        execfile(modfile, new_mod.__dict__)
+        exec(open(modfile, 'rb').read(), new_mod.__dict__)
-            elif isinstance(value, (int, long)):
+            elif isinstance(value, pycompat.integer_types):
-            if args and isinstance(args[0], (long, int)):
+            if args and isinstance(args[0], pycompat.integer_types):
-                        if len(args) > 3 and isinstance(args[3], (long, int, list)):
+                        if len(args) > 3 and isinstance(args[3], (pycompat.integer_types, list)):
-        odoo.tools.convert_yaml_import(cr, 'base', file(test_file), 'test', {}, 'init')
+        odoo.tools.convert_yaml_import(cr, 'base', open(test_file, 'rb'), 'test', {}, 'init')
-                for r in sqllogitems:
+                for r in sorted(sqllogitems, key=lambda k: k[1]):
-            for _ in xrange(self._depth):
+            for _ in pycompat.range(self._depth):
-            phantom = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=None)
+            phantom = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=None, close_fds=True)
-                p.write(file(self.rcfile, 'w'))
+                p.write(open(self.rcfile, 'w'))
-    else:
+    if isinstance(xmlfile, basestring):
-        normalized_value += cmp(normalized_value,0) * epsilon
+        normalized_value += math.copysign(epsilon, normalized_value)
-        sign = cmp(normalized_value, 0)
+        sign = math.copysign(1.0, normalized_value)
-            frac, exp, prec = fractions[i], expecteds[i], precisions[i]
+    for magnitude in pycompat.range(7):
-                for x in xrange(0,10000,97):
+                for x in pycompat.range(0, 10000, 97):
-                    f_exp = ('-' if f != 0 and sign == -1 else '') + str(n) + exp 
+                    f_exp = ('-' if f != 0 and sign == -1 else '') + str(n) + exp
-            self.levels[level].sort(lambda x, y: cmp(self.result[x]['y'], self.result[y]['y']))
+            self.levels[level].sort(key=lambda x: self.result[x]['y'])
-    img = file(sys.argv[1],'rb').read().encode('base64')
+    img = open(sys.argv[1],'rb').read().encode('base64')
-    file(sys.argv[2], 'wb').write(new.decode('base64'))
+    open(sys.argv[2], 'wb').write(new.decode('base64'))
-                fd = file(os.path.join(newdir, filename), 'w')
+                fd = open(os.path.join(newdir, filename), 'w')
-    """Like enumerate but in the other sens
+    """Like enumerate but in the other direction
-    return izip(xrange(len(l)-1, -1, -1), reversed(l))
+    return izip(pycompat.range(len(l)-1, -1, -1), reversed(l))
-       from the slices (tuple,list,...)
+       
-    'reduce': reduce,
+    'reduce': functools.reduce,
-    'xrange': xrange,
+    'xrange': pycompat.range,
-        file(os.path.join(tools.config['test_report_directory'], rname+ '.'+res_format), 'wb+').write(res_data)
+        open(os.path.join(tools.config['test_report_directory'], rname+ '.'+res_format), 'wb+').write(res_data)
-        assert isinstance(action_id, (long, int))
+        assert isinstance(action_id, pycompat.integer_types)
-from odoo.tools import config
+from odoo.tools import config, pycompat
-                buf = file(join(tmpmoddir, pofilename), 'w')
+                buf = open(join(tmpmoddir, pofilename), 'w')
-            if isinstance(res_id, (int, long)) or \
+            if isinstance(res_id, pycompat.integer_types) or \
-execfile(join(dirname(__file__), 'odoo', 'release.py'))  # Load release variables
+exec(open(join(dirname(__file__), 'odoo', 'release.py'), 'rb').read())  # Load release variables
-execfile(join(dirname(__file__), '..', 'odoo', 'release.py'))
+exec(open(join(dirname(__file__), '..', 'odoo', 'release.py'), 'rb').read())
-execfile(join(dirname(__file__), '..', 'server', 'odoo', 'release.py'))
+exec(open(join(dirname(__file__), '..', 'server', 'odoo', 'release.py'), 'rb').read())
-execfile(os.path.join(os.path.dirname(__file__), '..', '..', 'odoo', 'release.py'))
+exec(open(os.path.join(os.path.dirname(__file__), '..', '..', 'odoo', 'release.py'), 'rb').read())
-                    })
+                #To add an external identifiers to all inherits model
-            aml = order.statement_ids.mapped('journal_entry_ids').mapped('line_ids') | order.account_move.line_ids | order.invoice_id.move_id.line_ids
+            aml = order.statement_ids.mapped('journal_entry_ids') | order.account_move.line_ids | order.invoice_id.move_id.line_ids
-            except:
+            except Exception:
-        help="""Ability to select a package type in sales orders and 
+        help="""Ability to select a package type in sales orders and
-    module_timesheet_grid_sale = fields.Boolean("Timesheets")
+    module_sale_timesheet = fields.Boolean("Timesheets")
-}
+}
-        'hr_dashboard.xml',
+        'views/hr_views.xml',
-    department_id = fields.Many2one('hr.department', "Department", related='user_id.employee_ids.department_id', store=True, readonly=True)
+
-            vals['account_id'] = project.analytic_account_id.id
+        vals = self._update_timesheet_values(vals)
-        return super(AccountAnalyticLine, self).write(vals)
+        if vals.get('employee_id'):
-            # Nominal employee cost = 1 * company project UoM (project_time_mode_id)
+
-                'amount': -unit_amount * cost,
+                'amount': amount_converted,
-                'account_id': values.get('account_id') or self.account_id.id or emp.account_id.id,
+                'account_id': account_id,
-    account_id = fields.Many2one('account.account', string='Account')
+    timesheet_cost = fields.Monetary('Timesheet Cost', currency_field='currency_id', default=0.0)
-            'user_id': self.manager.id,
+            'employee_id': self.employee_user.id,
-            'user_id': self.user.id,
+            'employee_id': self.employee_user.id,
-            'user_id': self.user.id,
+            'employee_id': self.employee_user.id,
-            'user_id': self.manager.id,
+            'employee_id': self.employee_manager.id,
-            'user_id': self.user.id,
+            'employee_id': self.employee_user.id,
-            'user_id': self.user.id,
+            'employee_id': self.employee_user.id,
-            'user_id': self.manager.id,
+            'employee_id': self.employee_manager.id,
-            'user_id': self.user.id,
+            'employee_id': self.employee_user.id,
-            project.task_count = len(project.task_ids)
+            project.task_count = result.get(project.id, 0)
-                parts[0], _ = intersperse(parts[0], eval_lang_grouping, thousands_sep)
+                parts[0] = intersperse(parts[0], eval_lang_grouping, thousands_sep)[0]
-        assert json == expected, "%s != %s" % (json, expected)
+        dumped = simplejson.dumps(modifiers)
-        assert json == expected, "%s != %s" % (json, expected)
+        dumped = simplejson.dumps(modifiers)
-    company_id = fields.Many2one('res.company', default=_get_default_company_id, required=True)
+    company_id = fields.Many2one('res.company', string='Company',
-        field = cls._fields.pop(name)
+        field = cls._fields.pop(name, None)
-        'views/hr_payroll_views.xml',
+        'views/hr_contract_views.xml',
-        'views/res_config_views.xml',
+        'views/hr_payroll_config_settings_views.xml',
-import res_config
+import hr_contract
-from datetime import datetime, timedelta
+from datetime import datetime
-        return self.write({'state': 'close'})
+from odoo.exceptions import UserError, ValidationError
-    #TODO move this function into hr_contract module, on hr.employee object
+    # TODO move this function into hr_contract module, on hr.employee object
-        #a contract is valid if it ends between the given dates
+        # a contract is valid if it ends between the given dates
-        #OR if it starts between the given dates
+        # OR if it starts between the given dates
-        #OR if it starts before the date_from and finish after the date_end (or never finish)
+        # OR if it starts before the date_from and finish after the date_end (or never finish)
-            #delete old payslip lines
+            # delete old payslip lines
-        return [(rule.id, rule.sequence) for rule in self] + children_rules
+class HrPayslipRun(models.Model):
-                raise UserError(_('Wrong python code defined for salary rule %s (%s).') % (self.name, self.code))
+    name = fields.Char(required=True, readonly=True, states={'draft': [('readonly', False)]})
-    payslip_count = fields.Integer(compute='_compute_payslip_count', string='Payslips', groups="hr_payroll.group_hr_payroll_user")
+    def draft_payslip_run(self):
-            employee.payslip_count = len(employee.slip_ids)
+    def close_payslip_run(self):
-    'data':[
+    'data': [
-from odoo.addons import decimal_precision as dp
+from odoo import api, fields, models, _
-    retained_net_amount = fields.Float('Net retained ', digits=dp.get_precision('Payroll'))
+    transport_mode = fields.Selection([
-    spouse_fiscal_status = fields.Selection([('without income','Without Income'),('with income','With Income')], string='Tax status for spouse')
+    spouse_fiscal_status = fields.Selection([
-        read_group_result = self.env['hr.applicant'].read_group([('job_id', '=', self.id)], ['job_id'], ['job_id'])
+        read_group_result = self.env['hr.applicant'].read_group([('job_id', 'in', self.ids)], ['job_id'], ['job_id'])
-        if 'emp_id' in init_values and record.emp_id:
+        if 'emp_id' in init_values and record.emp_id and record.emp_id.active:
-        clause_final = [('employee_id', '=', employee.id), '|', '|'] + clause_1 + clause_2 + clause_3
+        clause_final = [('employee_id', '=', employee.id), ('state', '=', 'open'), '|', '|'] + clause_1 + clause_2 + clause_3
-    def get_worked_day_lines(self, contract_ids, date_from, date_to):
+    def get_worked_day_lines(self, contracts, date_from, date_to):
-        @param contract_ids: list of contract id
+        @param contract: Browse record of contracts
-        for contract in self.env['hr.contract'].browse(contract_ids).filtered(lambda contract: contract.resource_calendar_id):
+        for contract in contracts.filtered(lambda contract: contract.resource_calendar_id):
-                    leave_time = (interval[1] - interval[0]).seconds/3600
+                    leave_time = (interval[1] - interval[0]).seconds / 3600
-    def get_inputs(self, contract_ids, date_from, date_to):
+    def get_inputs(self, contracts, date_from, date_to):
-            localdict['categories'].dict[category.code] = amount
+            localdict['categories'].dict[category.code] = category.code in localdict['categories'].dict and localdict['categories'].dict[category.code] + amount or amount
-        input_line_ids = self.get_inputs(contract_ids, date_from, date_to)
+        contracts = self.env['hr.contract'].browse(contract_ids)
-        worked_days_line_ids = self.get_worked_day_lines(contract_ids, date_from, date_to)
+        contracts = self.env['hr.contract'].browse(contract_ids)
-        input_line_ids = self.get_inputs(contract_ids, date_from, date_to)
+        input_line_ids = self.get_inputs(contracts, date_from, date_to)
-    employee_id = fields.Many2one('hr.employee', string='Employee', required=True)
+    employee_id = fields.Many2one('hr.employee', string='Employee')
-    trial_date_end = fields.Date('Trial End Date')
+    trial_date_end = fields.Date('End of Trial Period')
-    wage = fields.Float('Wage', digits=(16, 2), required=True, help="Basic Salary of the employee")
+    wage = fields.Monetary('Wage', digits=(16, 2), required=True, help="The monthly gross wage of the employee.")
-    visa_expire = fields.Date('Visa Expire Date')
+        ('cancel', 'Cancelled')
-    ], groups="hr.group_hr_user")
+    ], groups="hr.group_hr_user", default="male")
-        ('married', 'Married'),
+        ('married', 'Married (or similar)'),
-    ], string='Marital Status', groups="hr.group_hr_user")
+    ], string='Marital Status', groups="hr.group_hr_user", default='single')
-        'views/fleet_view.xml',
+        'views/fleet_vehicle_model_views.xml',
-import fleet
+# -*- coding: utf-8 -*-
-        self.scheduler_manage_contract_expiration()
+# -*- coding: utf-8 -*-
-    cost_ids = fields.One2many('fleet.vehicle.cost', 'parent_id', 'Included Services')
+    cost_ids = fields.One2many('fleet.vehicle.cost', 'parent_id', 'Included Services', copy=True)
-    acquisition_date = fields.Date('Acquisition Date', required=False, help='Date when the vehicle has been bought')
+    acquisition_date = fields.Date('Immatriculation Date', required=False, help='Date when the vehicle has been immatriculated')
-    car_value = fields.Float(help='Value of the bought vehicle')
+    car_value = fields.Float(string="Catalog Value (VAT incl.)", help='Value of the bought vehicle')
-            record.contract_count = LogContract.search_count([('vehicle_id', '=', record.id)])
+            record.contract_count = LogContract.search_count([('vehicle_id', '=', record.id), ('state', '=', 'open')])
-from odoo.exceptions import UserError
+from odoo.exceptions import UserError, ValidationError
-                parts[0], _ = intersperse(parts[0], eval_lang_grouping, thousands_sep)
+                parts[0] = intersperse(parts[0], eval_lang_grouping, thousands_sep)[0]
-        assert json == expected, "%s != %s" % (json, expected)
+        dump = json.dumps(modifiers)
-        assert json == expected, "%s != %s" % (json, expected)
+        dump = json.dumps(modifiers)
-        self.phantom_js('/web/tests?mod=web', "", "", login='admin')
+        self.phantom_js('/web/tests?mod=web', "", "", login='admin', timeout=120)
-        ('task', 'Create a task and track hours')])
+        ('task', 'Create a task per order line to track hours')])
-        assert len(self.ids) == 1, "you can open only one session at a time"
+        """ open the pos interface """
-        assert len(self.ids) == 1, "you can open only one session at a time"
+        """ open session button
-        assert len(self.ids) == 1, "you can open only one session at a time"
+        """ new session button
-        assert len(self.ids) == 1, "you can open only one session at a time"
+        """ close session button
-    group_website_multiimage = fields.Boolean(string='Multi-Images', implied_group='website_sale.group_website_multi_image')
+    group_website_multiimage = fields.Boolean(string='Multi-Images', implied_group='website_sale.group_website_multi_image', group='base.group_portal,base.group_user,base.group_public')
-    group_show_price_total = fields.Boolean("Show total", implied_group='sale.group_show_price_total')
+    group_show_price_subtotal = fields.Boolean(
-        orders_to_plan.write({'state': 'planned'})
+        return orders_to_plan.write({'state': 'planned'})
-        self.write({'state': 'done'})
+        return self.write({'state': 'done'})
-        self.write({'state': 'done'})
+        return self.write({'state': 'done'})
-        self.write({'state': 'progress',
+        return self.write({'state': 'progress',
-        self.write({'state': 'done', 'date_finished': fields.Datetime.now()})
+        return self.write({'state': 'done', 'date_finished': fields.Datetime.now()})
-        self.write({'state': 'cancel'})
+        return self.write({'state': 'cancel'})
-        self.write({'state': 'done',
+        return self.write({'state': 'done',
-        return self.descendants(model_names, '_inherit')
+        return self.descendants(model_names, '_inherit', '_inherits')
-        prev_order = self.env['lunch.order.line'].search([('user_id', '=', self.env.uid), ('product_id.active', '!=', False)], limit=20, order='id desc')
+        prev_order = self.env['lunch.order.line'].search([('user_id', '=', self.env.uid), ('product_id.active', '!=', False)], limit=20, order='date desc, id desc')
-            lunch_data = {}
+            lunch_data = []
-                lunch_data[line.id] = {
+                lunch_data.append({
-                }
+                })
-    _order = 'date desc'
+    _order = 'date desc, id desc'
-        if self.env.user.share:
+        if self.env.user.share or self.env.context.get('force_website'):
-        if not self.template_id:
+        if not self.template_id or (not self.env.user.share and not self.env.context.get('force_website')):
-    def get_formview_id(self):
+    def get_formview_id(self, access_uid=None):
-    def get_formview_id(self):
+    def get_formview_id(self, access_uid=None):
-    def get_formview_id(self):
+    def get_formview_id(self, access_uid=None):
-        view_id = self.get_formview_id()
+        view_id = self.sudo().get_formview_id(access_uid=self.env.uid)
-            return cls._redirect_to_messaging()
+            record = record_sudo.sudo(uid)
-            _logger.error('ESC/POS Error: '+message)
+            _logger.error('ESC/POS Error: %s', message)
-            _logger.warning('ESC/POS Device Disconnected: '+message)
+            _logger.warning('ESC/POS Device Disconnected: %s', message)
-                print "No device found %s" %str(e)
+                print("No device found %s" % e)
-                print "Impossible to handle the device due to previous error %s" % str(e)
+                print("Impossible to handle the device due to previous error %s" % e)
-                print "The ticket does not seems to have been fully printed %s" % str(e)
+                print("The ticket does not seems to have been fully printed %s" % e)
-                print "Impossible to get the status of the printer %s" % str(e)
+                print("Impossible to get the status of the printer %s" % e)
-                _logger.error(errmsg);
+                self.set_status('error', e)
-                print 'WARNING: ESC/POS PRINTING: ignoring invalid value: '+utfstr(style[attr])+' for style: '+utfstr(attr)
+                print('WARNING: ESC/POS PRINTING: ignoring invalid value: %s for style %s' % (style[attr], utfstr(attr)))
-                print 'WARNING: ESC/POS PRINTING: ignoring invalid value: '+utfstr(style[attr])+' for style: '+utfstr(attr)
+                print('WARNING: ESC/POS PRINTING: ignoring invalid value: %s for style %s' % (style[attr], attr))
-            print  "WARNING: Image is wider than 512 and could be truncated at print time "
+            print("WARNING: Image is wider than 512 and could be truncated at print time ")
-        print 'print_b64_img'
+        print('print_b64_img')
-            print 'not in cache'
+            print('not in cache')
-            print 'convert image'
+            print('convert image')
-            print 'print image'
+            print('print image')
-        print 'raw image'
+        print('raw image')
-            print "Serial printer enabled"
+            print("Serial printer enabled")
-            print "Unable to open serial printer on: %s" % self.devfile
+            print("Unable to open serial printer on: %s" % self.devfile)
-            print "Could not open socket for %s" % self.host
+            print("Could not open socket for %s" % self.host)
-        print 'scan_item_success: ' + str(ean)
+        print('scan_item_success: %s', ean)
-        print 'scan_item_error_unrecognized: ' + str(ean)
+        print('scan_item_error_unrecognized: %s', ean)
-        print "help_needed"
+        print("help_needed")
-        print "help_canceled"
+        print("help_canceled")
-        print "payment_request: price:"+str(price)
+        print("payment_request: price:%s" % price)
-        print "payment_status"
+        print("payment_status")
-        print "payment_cancel"
+        print("payment_cancel")
-        print 'transaction_start'
+        print('transaction_start')
-        print 'transaction_end'
+        print('transaction_end')
-        print 'cashier_mode_activated'
+        print('cashier_mode_activated')
-        print 'cashier_mode_deactivated'
+        print('cashier_mode_deactivated')
-        print 'open_cashbox'
+        print('open_cashbox')
-        print 'print_receipt' + str(receipt)
+        print('print_receipt %s', receipt)
-        print 'is_scanner_connected?' 
+        print('is_scanner_connected?')
-        print 'scanner' 
+        print('scanner')
-        print 'print_pdf_invoice' + str(pdfinvoice)
+        print('print_pdf_invoice %s' % pdfinvoice)
-                    print k, v
+from __future__ import print_function
-        print "Available commands:\n"
+        print("Available commands:\n")
-        print "\nUse '%s <command> --help' for individual command help." % sys.argv[0].split(os.path.sep)[-1]
+            print("    %s%s" % (name, doc))
-    print >>sys.stderr, message
+    print(message, file=sys.stderr)
-    print "WARNING: " + message
+    print("WARNING:", message)
-            print 'readline or rlcompleter not available, autocomplete disabled.'
+            print('readline or rlcompleter not available, autocomplete disabled.')
-                print 'No environment set, use `%s shell -d dbname` to get one.' % sys.argv[0]
+                print('No environment set, use `%s shell -d dbname` to get one.' % sys.argv[0])
-                print '%s: %s' % (i, local_vars[i])
+                print('%s: %s' % (i, local_vars[i]))
-    print >>sys.stderr, message
+    print(message, file=sys.stderr)
-        print "WARNING: no translation function found for lang: '%s'" % (lang,)
+        print("WARNING: no translation function found for lang: '%s'" % (lang,))
-        print int_to_text(int(argv[1]), lang)
+from __future__ import print_function
-            print '###!!! Rounding error: got %s , expected %s' % (result, expected)
+            print('###!!! Rounding error: got %s , expected %s' % (result, expected))
-    print count, " round calls, ", errors, "errors, done in ", (stop-start), 'secs'
+    print(count, " round calls, ", errors, "errors, done in ", (stop-start), 'secs')
-                    print v, pv
+                    print(v, pv)
-        keys = tax_codes_iterator.next()
+        keys = next(tax_codes_iterator)
-        keys = taxes_iterator.next()
+        next(taxes_iterator)
-        keys = taxes_iterator.next()
+        keys = next(taxes_iterator)
-        keys = fiscal_pos_map_iterator.next()
+        keys = next(fiscal_pos_map_iterator)
-    fields = reader.next()
+    fields = next(reader)
-            fields = reader.next()
+            fields = next(reader)
-                return self.next()
+                return next(self)
-                return self.next()
+                return next(self)
-            return self.next()
+            return next(self)
-            ENOENT = 2
+    path = next(which_files(file, mode, path, pathext), None)
-
+    return path
-                    if _logger.isEnabledFor(logging.DEBUG):
+                    if start_time and _logger.isEnabledFor(logging.DEBUG):
-        if id is None:
+        if not id:
-        if id is None:
+        if not id:
-            if id is None and not working_intervals:  # no calendar -> consider working 8 hours
+            if not id and not working_intervals:  # no calendar -> consider working 8 hours
-            if id is None or working_intervals:  # no calendar -> no working hours, but day is considered as worked
+            if not id or working_intervals:  # no calendar -> no working hours, but day is considered as worked
-    to_refund = fields.Boolean(string="To Refund",
+    to_refund = fields.Boolean(string="To Refund (update SO/PO)",
-    to_refund = fields.Boolean(string="To Refund", help='Trigger a decrease of the delivered/received quantity in the associated Sale Order/Purchase Order')
+    to_refund = fields.Boolean(string="To Refund (update SO/PO)", help='Trigger a decrease of the delivered/received quantity in the associated Sale Order/Purchase Order')
-                        total += move.product_uom._compute_quantity(move.product_uom_qty, line.product_uom)
+                    if move.location_dest_id.usage == "supplier":
-                        total += move.product_uom_qty
+                        total += move.product_uom._compute_quantity(move.product_uom_qty, line.product_uom)
-        for move in self.move_ids.filtered(lambda x: x.state != 'cancel'):
+        for move in self.move_ids.filtered(lambda x: x.state != 'cancel' and not x.location_dest_id.usage == "supplier"):
-            #we don't want to propagate the link to the purchase order line except in case of move split
+        # we don't want to propagate the link to the purchase order line on the move copied,
-        po_vals = {
+        self.po_vals = {
-        self.po = self.PurchaseOrder.create(po_vals)
+
-            elif move.location_dest_id.usage == "internal" and move.to_refund_so:
+            elif move.location_dest_id.usage == "internal" and move.to_refund:
-        return_wiz.product_return_moves.to_refund_so = True # Refund these 2
+        return_wiz.product_return_moves.to_refund = True # Refund these 2
-            if request.website.company_id.vat_check_vies:
+            if request.website.company_id.sudo().vat_check_vies:
-    date_deadline = fields.Date('Deadline', index=True, required=True, default=fields.Date.today)
+    date_deadline = fields.Date('Due Date', index=True, required=True, default=fields.Date.today)
-        return super(CrmTeam, self.with_context(mail_create_nosubscribe=True)).create(values)
+        team = super(CrmTeam, self.with_context(mail_create_nosubscribe=True)).create(values)
-                        fn = getattr(claz, mv.func_name, None)
+                    for claz in reversed(mv.__self__.__class__.mro()):
-    ormcache = bound_method.clear_cache.im_self
+    model = bound_method.__self__
-            profile.dump_stats(self.fname or ("%s.cprof" % (f.func_name,)))
+            profile.dump_stats(self.fname or ("%s.cprof" % (f.__name__,)))
-    value = isinstance(node, types.DictionaryType) \
+    value = isinstance(node, dict) \
-    return isinstance(node, types.StringTypes)
+    return isinstance(node, basestring)
-        elif isinstance(xml_id, types.IntType):
+        elif isinstance(xml_id, int):
-            if isinstance(value, types.TupleType):
+            if isinstance(value, tuple):
-        if isinstance(value, types.BooleanType):
+        if isinstance(value, bool):
-        if isinstance(value, types.StringTypes):
+        if isinstance(value, str):
-        elif isinstance(value, types.IntType):
+        elif isinstance(value, int):
-            if isinstance(param, types.ListType):
+            if isinstance(param, list):
-            elif isinstance(param, types.DictionaryType): # supports XML syntax
+            elif isinstance(param, dict): # supports XML syntax
-            if isinstance(node, types.DictionaryType):
+            if isinstance(node, dict):
-            if isinstance(node, types.DictionaryType):
+            if isinstance(node, dict):
-            partner.issued_total = issued_total
+        domain = self.get_followup_lines_domain(today, overdue_only=True)
-    _order = 'sequence'
+    _order = 'sequence, id'
-
+    next_type_ids = fields.Many2many(
-                self.summary = self.activity_type_id.summary
+            self.summary = self.activity_type_id.summary
-            ('name', 'not like', '(RESCUE FOR')])
+            ('rescue', '=', False)])
-                '(RESCUE FOR' not in r.name)
+                not r.rescue)
-            session = pos_config.session_ids.filtered(lambda s: s.state == 'opened' and '(RESCUE FOR' not in s.name)
+            session = pos_config.session_ids.filtered(lambda s: s.state == 'opened' and not s.rescue)
-            ('name', 'like', '(RESCUE FOR %(session)s)' % {'session': closed_session.name}),
+            ('rescue', '=', True),
-            'name': '(RESCUE FOR %(session)s)' % {'session': closed_session.name},
+            'name': _('(RESCUE FOR %(session)s)') % {'session': closed_session.name},
-                ('name', 'not like', 'RESCUE FOR'),
+                ('rescue', '=', False)
-                ('name', 'not like', 'RESCUE FOR'),
+                ('rescue', '=', False)
-        number_draft = number_waiting = number_late = sum_draft = sum_waiting = sum_late = 0
+        number_draft = number_waiting = number_late = 0
-            query = """SELECT state, amount_total, currency_id AS currency FROM account_invoice WHERE journal_id = %s AND state NOT IN ('paid', 'cancel');"""
+            query = """SELECT state, amount_total, currency_id AS currency, type FROM account_invoice WHERE journal_id = %s AND state NOT IN ('paid', 'cancel');"""
-            query = """SELECT amount_total, currency_id AS currency FROM account_invoice WHERE journal_id = %s AND date < %s AND state = 'open';"""
+            query = """SELECT amount_total, currency_id AS currency, type FROM account_invoice WHERE journal_id = %s AND date < %s AND state = 'open';"""
-            number_waiting = 0
+                if result['type'] in ['in_refund', 'out_refund']:
-                    sum_draft += cur.compute(result.get('amount_total'), currency)
+                    sum_draft += cur.compute(result.get('amount_total'), currency) * factor
-            number_late = 0
+                    sum_waiting += cur.compute(result.get('amount_total'), currency) * factor
-                sum_late += cur.compute(result.get('amount_total'), currency)
+                sum_late += cur.compute(result.get('amount_total'), currency) * factor
-    res_name = fields.Char(compute='_compute_res_name', string='Resource Name', search='search_res_name')
+    res_name = fields.Char(compute='_compute_res_name', string='Resource Name', search='_search_res_name')
-        raise (_('Error!'), _('Not implemented.'))
+        raise NotImplementedError()
-            raise Exception, 'AccessDenied'
+            raise Exception('AccessDenied')
-        raise Exception, 'ReportNotFound'
+        raise Exception('ReportNotFound')
-
+    color = fields.Integer("Color Index", default=1)
-    color = fields.Integer('Color Index')
+    color = fields.Integer('Color Index', default=1)
-    color = fields.Integer("Color Index")
+    color = fields.Integer("Color Index", default=1)
-    color = fields.Integer(default=0)
+    color = fields.Integer("Color Index", default=1)
-                record[field] = count.get(record.id, 0)
+                record[field] = count.get(record.id, 0)
-            color = other_pick_type and other_pick_type.color or 0
+            color = other_pick_type and other_pick_type.color or 1
-    color = fields.Integer(string='Color Index', help="The color of the channel")
+    color = fields.Integer(string='Color Index', help="The color of the channel", default=1)
-        color = available_colors and available_colors[0] or 0
+        color = available_colors and available_colors[0] or 1
-        if vals.get('use_leads') or vals.get('alias_defaults'):
+        if 'use_leads' in vals or 'alias_defaults' in vals:
-        return ", ".join([v.name for v in self if v.attribute_id in variable_attributes])
+        return ", ".join([v.name for v in self.sorted(key=lambda r: r.name) if v.attribute_id in variable_attributes])
-                values.append({x_field: self.env['res.users'].browse(data_item.get('x_value')).name, y_field: data_item.get('y_value')})
+                values.append({x_field: self.env['res.users'].browse(data_item.get('x_value')).name or _('Not Defined'), y_field: data_item.get('y_value')})
-            'table': self._graph_sql_table(),
+            'table': graph_table,
-            'extra_conditions': self._extra_sql_conditions(),
+            'extra_conditions': extra_conditions
-        self._cr.execute(query, [self.id, start_date, end_date])
+        self._cr.execute(query, [self.id, start_date, end_date] + where_clause_params)
-    dashboard_graph_model = fields.Selection(selection_add=[('pipeline', 'Pipeline')])
+    dashboard_graph_model = fields.Selection(selection_add=[('crm.opportunity.report', 'Pipeline')])
-        for channel in self.filtered(lambda ch: ch.dashboard_graph_model == 'pipeline'):
+        for channel in self.filtered(lambda ch: ch.dashboard_graph_model == 'crm.opportunity.report'):
-            self.dashboard_graph_model = 'pipeline'
+            self.dashboard_graph_model = 'crm.opportunity.report'
-        if self.dashboard_graph_model == 'pipeline':
+        if self.dashboard_graph_model == 'crm.opportunity.report':
-        if not self.use_opportunities and self.dashboard_graph_model == 'pipeline':
+        if not self.use_opportunities and self.dashboard_graph_model == 'crm.opportunity.report':
-        if self.dashboard_graph_model == 'pipeline':
+        if self.dashboard_graph_model == 'crm.opportunity.report':
-        if self.dashboard_graph_model == 'pipeline' and self.dashboard_graph_group_pipeline == 'stage':
+        if self.dashboard_graph_model == 'crm.opportunity.report' and self.dashboard_graph_group_pipeline == 'stage':
-        if self.dashboard_graph_model == 'pipeline':
+        if self.dashboard_graph_model == 'crm.opportunity.report':
-        if self.dashboard_graph_model == 'pipeline' and self.dashboard_graph_group_pipeline == 'stage':
+        if self.dashboard_graph_model == 'crm.opportunity.report' and self.dashboard_graph_group_pipeline == 'stage':
-        if self.dashboard_graph_model == 'pipeline':
+        if self.dashboard_graph_model == 'crm.opportunity.report':
-        if self.dashboard_graph_model == 'pipeline':
+        if self.dashboard_graph_model == 'crm.opportunity.report':
-        ('invoices', 'Invoices'),
+        ('sale.report', 'Sales'),
-        if self.dashboard_graph_model == 'sales':
+        if self.dashboard_graph_model == 'sale.report':
-        elif self.dashboard_graph_model == 'invoices':
+        elif self.dashboard_graph_model == 'account.invoice.report':
-        if self.dashboard_graph_model == 'sales':
+        if self.dashboard_graph_model == 'sale.report':
-        elif self.dashboard_graph_model == 'invoices':
+        elif self.dashboard_graph_model == 'account.invoice.report':
-        if self.dashboard_graph_model == 'sales':
+        if self.dashboard_graph_model == 'sale.report':
-        elif self.dashboard_graph_model == 'invoices':
+        elif self.dashboard_graph_model == 'account.invoice.report':
-        if self.dashboard_graph_model == 'sales':
+        if self.dashboard_graph_model == 'sale.report':
-        elif self.dashboard_graph_model == 'invoices':
+        elif self.dashboard_graph_model == 'account.invoice.report':
-            # do not override dashboard_graph_model 'pipeline' if crm is installed
+            # do not override dashboard_graph_model 'crm.opportunity.report' if crm is installed
-                self.dashboard_graph_model = 'sales'
+                self.dashboard_graph_model = 'sale.report'
-            self.dashboard_graph_model = 'sales'
+            self.dashboard_graph_model = 'sale.report'
-
+    dashboard_graph_period_pipeline = fields.Selection([
-    ], string='Period', default='month', help="The time period this channel's dashboard graph will consider.")
+        ('week', 'Last Week'),
-        new_session.signal_workflow('open')
+        open_sessions = session.search(cr, uid, [('state', '=', 'opened'),
-    user_id = fields.Many2one('res.users', string='Project Manager', default=lambda self: self.env.user)
+    user_id = fields.Many2one('res.users', string='Project Manager', default=lambda self: self.env.user, track_visibility="onchange")
-        return super(Project, self).create(vals)
+        project = super(Project, self).create(vals)
-    def my_tasks(self, page=1, date_begin=None, date_end=None, sortby=None, filterby=None, **kw):
+    def my_tasks(self, page=1, date_begin=None, date_end=None, sortby=None, filterby=None, search=None, search_in='content', **kw):
-        'res.partner', 'Home Address')
+        'res.partner', 'Private Address', help='Enter here the private address of the employee, not the one linked to your company.')
-            "WHERE l.partner_id IN %s AND at.type IN ('receivable', 'payable') GROUP BY l.date, l.name, l.ref, l.date_maturity, l.partner_id, at.type, l.blocked, l.amount_currency, l.currency_id, l.move_id, m.name", (((fields.date.today(), ) + (tuple(partner_ids),))))
+            "WHERE l.partner_id IN %s AND at.type IN ('receivable', 'payable') AND NOT l.reconciled GROUP BY l.date, l.name, l.ref, l.date_maturity, l.partner_id, at.type, l.blocked, l.amount_currency, l.currency_id, l.move_id, m.name", (((fields.date.today(), ) + (tuple(partner_ids),))))
-        locale = self._context.get('lang', 'en_US')
+        locale = self._context.get('lang') or 'en_US'
-        day_of_week = int(format_datetime(today, 'e', locale=self._context.get('lang', 'en_US')))
+        day_of_week = int(format_datetime(today, 'e', locale=self._context.get('lang') or 'en_US'))
-                    label = str(start_week.day) + '-' +str(end_week.day)+ ' ' + format_date(end_week, 'MMM', locale=self._context.get('lang', 'en_US'))
+                    label = str(start_week.day) + '-' +str(end_week.day)+ ' ' + format_date(end_week, 'MMM', locale=self._context.get('lang') or 'en_US')
-                    label = format_date(start_week, 'd MMM', locale=self._context.get('lang', 'en_US'))+'-'+format_date(end_week, 'd MMM', locale=self._context.get('lang', 'en_US'))
+                    label = format_date(start_week, 'd MMM', locale=self._context.get('lang') or 'en_US')+'-'+format_date(end_week, 'd MMM', locale=self._context.get('lang') or 'en_US')
-            result = babel.dates.format_date(date=date, format='MMMM y', locale=self._context.get('lang', 'en_US'))
+            result = babel.dates.format_date(date=date, format='MMMM y', locale=self._context.get('lang') or 'en_US')
-            result = babel.dates.format_date(date=date, format='EEEE', locale=self._context.get('lang', 'en_US'))
+            result = babel.dates.format_date(date=date, format='EEEE', locale=self._context.get('lang') or 'en_US')
-            query_args = {'name': name, 'limit': limit, 'lang': self._context.get('lang', 'en_US')}
+            query_args = {'name': name, 'limit': limit, 'lang': self._context.get('lang') or 'en_US'}
-        locale = self._context.get('lang', 'en_US')
+        locale = self._context.get('lang') or 'en_US'
-                    locale = self._context.get('lang', 'en_US')
+                    locale = self._context.get('lang') or 'en_US'
-             'of the mailings.')
+    unique_ab_testing = fields.Boolean(string='Allow A/B Testing', default=True,
-            custom = json.loads(post.pop('custom', False) or post.pop('cm', False) or '{}')
+            custom = json.loads(urllib.unquote_plus(post.pop('custom', False) or post.pop('cm', False) or '{}'))
-        locale = self._context.get('lang', 'en_US')
+        locale = self._context.get('lang') or 'en_US'
-        day_of_week = int(format_datetime(today, 'e', locale=self._context.get('lang', 'en_US')))
+        day_of_week = int(format_datetime(today, 'e', locale=self._context.get('lang') or 'en_US'))
-                    label = str(start_week.day) + '-' +str(end_week.day)+ ' ' + format_date(end_week, 'MMM', locale=self._context.get('lang', 'en_US'))
+                    label = str(start_week.day) + '-' +str(end_week.day)+ ' ' + format_date(end_week, 'MMM', locale=self._context.get('lang') or 'en_US')
-                    label = format_date(start_week, 'd MMM', locale=self._context.get('lang', 'en_US'))+'-'+format_date(end_week, 'd MMM', locale=self._context.get('lang', 'en_US'))
+                    label = format_date(start_week, 'd MMM', locale=self._context.get('lang') or 'en_US')+'-'+format_date(end_week, 'd MMM', locale=self._context.get('lang') or 'en_US')
-            result = babel.dates.format_date(date=date, format='MMMM y', locale=self._context.get('lang', 'en_US'))
+            result = babel.dates.format_date(date=date, format='MMMM y', locale=self._context.get('lang') or 'en_US')
-            result = babel.dates.format_date(date=date, format='EEEE', locale=self._context.get('lang', 'en_US'))
+            result = babel.dates.format_date(date=date, format='EEEE', locale=self._context.get('lang') or 'en_US')
-            query_args = {'name': name, 'limit': limit, 'lang': self._context.get('lang', 'en_US')}
+            query_args = {'name': name, 'limit': limit, 'lang': self._context.get('lang') or 'en_US'}
-                    locale = self._context.get('lang', 'en_US')
+                    locale = self._context.get('lang') or 'en_US'
-    @api.multi
+        self.merge_followers()
-        new_blog_post = request.env['blog.post'].with_context(mail_create_nosubscribe=True).copy(int(blog_post_id), {})
+        new_blog_post = request.env['blog.post'].with_context(mail_create_nosubscribe=True).browse(int(blog_post_id)).copy()
-            self.state = 'confirmed'
+                self.env['lunch.cashmove'].create(values)
-                    'position': line.currency_id.position,
+                    'currency_id': line.currency_id.id,
-        })] if self.user_has_groups('event.group_email_scheduling') else []
+        })]
-            counter += 1
+            # To ensure that the used partners are accessible by the user
-                'location_id': move.location_dest_id.id,
+            new_move_vals = self._prepare_move_copy_values(move, new_date)
-            new_move.action_confirm()
+            }
-                    destinations = [product_to_location[product] for product in package.get_content().mapped('product_id')]
+                    destinations = set([product_to_location[product] for product in package.get_content().mapped('product_id')])
-                               for a in mail.attachment_ids.sudo().read(['datas_fname', 'datas'])]
+                attachments = [(a['datas_fname'], base64.b64decode(a['datas']), a['mimetype'])
-            for (fname, fcontent) in attachments:
+            for (fname, fcontent, mime) in attachments:
-                part = MIMEBase('application', "octet-stream")
+                if mime and '/' in mime:
-            "tzOffset": datetime.datetime.now(pytz.timezone(self._context.get('tz', 'UTC'))).utcoffset().total_seconds() / 60,
+            "tzOffset": self._context.get('tz') and datetime.datetime.now(pytz.timezone(self._context['tz'])).utcoffset().total_seconds() / 60 or False,
-            employees.write({'parent_id': manager_id})
+            # set the employees's parent to the new manager
-                    if order.client_order_ref and order.client_order_ref not in invoices[group_key].name.split(', '):
+                    if order.client_order_ref and order.client_order_ref not in invoices[group_key].name.split(', ') and order.client_order_ref != invoices[group_key].name:
-
+from odoo import fields
-
+        FROMPRODUCT = object()
-          {'amount_paid': 0.9,
+          {'amount_paid': untax + atax,
-           'amount_total': 0.9,
+           'amount_tax': atax,
-              'tax_ids': []}]],
+              'tax_ids': [(6, 0, self.carotte.taxes_id.ids)]}]],
-              'amount': 0.9,
+              'amount': untax + atax,
-          {'amount_paid': 1.2,
+          {'amount_paid': untax + atax,
-           'amount_total': 1.1,
+           'amount_tax': atax,
-              'tax_ids': []}]],
+              'tax_ids': [(6, 0, self.courgette.taxes_id.ids)]}]],
-              'amount': 1.2,
+              'amount': untax + atax,
-          {'amount_paid': 1.28,
+          {'amount_paid': untax + atax,
-           'amount_total': 1.28,
+           'amount_tax': atax,
-              'amount': 1.28,
+              'amount': untax + atax,
-
+# -*- coding: utf-8 -*-
-                    raise UserError(_("You cannot confirm all orders of this session, because they don't have the 'paid' status"))
+                    raise UserError(
-        elif 'opt_out' in self.env[self.mailing_model]._fields:
+        elif 'opt_out' in self.env[self.mailing_model]._fields and not self.mailing_domain:
-            suppliers = procurement.product_id.seller_ids.filtered(lambda r: not r.product_id or r.product_id == procurement.product_id)
+            suppliers = procurement.product_id.seller_ids\
-                    return strat.fixed_location_id.id
+                    return strat.fixed_location_id
-            (product, self.location_dest_id.get_putaway_strategy(product) or self.location_dest_id.id) for product in all_products)
+            (product, self.location_dest_id.get_putaway_strategy(product).id or self.location_dest_id.id) for product in all_products)
-                    }
+                    values = holiday._prepare_create_by_category(employee)
-        so_lines = self.mapped('so_line')
+        so_lines = self.sudo().mapped('so_line')
-        so_lines.with_context(force_so_lines=so_lines).sudo()._compute_analytic()
+        so_lines.with_context(force_so_lines=so_lines)._compute_analytic()
-
+                meeting_values = holiday._prepare_holidays_meeting_values()
-    def set_to_close(self):
+    def _get_disposal_moves(self):
-    def _create_service_task(self):
+    def _prepare_service_task_values(self):
-        task = self.env['project.task'].create({
+        return {
-        })
+        }
-                    reconcile_pool.unlink(cr, uid, [line.reconcile_id.id])
+                    reconcile_pool.unlink(cr, uid, [line.reconcile_id.id], context=context)
-                move_pool.unlink(cr, uid, [voucher.move_id.id])
+                move_pool.button_cancel(cr, uid, [voucher.move_id.id], context=context)
-        self.write(cr, uid, ids, res)
+        self.write(cr, uid, ids, res, context=context)
-            reference = init_ref + '-' + str(ref_suffix)
+            reference = init_ref + 'x' + str(ref_suffix)
-            if transaction.state != 'cancel':
+            # Ugly hack for SIPS: SIPS does not allow to reuse a payment reference, even if the
-                pu = self.env['account.tax']._fix_tax_included_price(order_line._get_display_price(product), product.taxes_id, order_line.tax_id)
+                pu = self.env['account.tax']._fix_tax_included_price(pu, product.taxes_id, order_line.tax_id)
-            else:
+            elif module != 'studio_customization':
-        return result
+        return len(self) - len_graph
-        mod_path = get_module_path(module)
+        mod_path = get_module_path(module, downloaded=True)
-        IrAttachment, parameter_attachments = self.env['ir.attachment'], self.env['ir.attachment']
+        IrAttachment = self.env['ir.attachment']
-                    cid_mapping[cid] = name
+                cid = info and info.get('cid')
-                'datas_fname': cid or name,
+                'datas_fname': name,
-        m2m_attachment_ids += [(4, attach.id) for attach in parameter_attachments]
+            new_attachment = IrAttachment.create(data_attach)
-                    attachment = parameter_attachments.filtered(lambda attachment: attachment.datas_fname == cid)
+                    attachment = cid_mapping.get(cid)
-                        attachment = parameter_attachments.filtered(lambda attachment: attachment.datas_fname == fname)
+                        attachment = fname_mapping.get(node.get('data-filename'), '')
-                        node.set('src', '/web/image/%s' % attachment.ids[0])
+                        node.set('src', '/web/image/%s' % attachment.id)
-            self._compute_value(record)
+            self.compute_value(record)
-                if pack_lot_names:
+                if pack_lot_names and lots_necessary:
-                elif pack_operation.product_id.tracking == 'none':
+                elif pack_operation.product_id.tracking == 'none' or not lots_necessary:
-            for line in order.lines.filtered(lambda l: l.product_id.type in ['product', 'consu']):
+            for line in order.lines.filtered(lambda l: l.product_id.type in ['product', 'consu'] and l.qty != 0):
-        if not any([(x.product_id.tracking != 'none') for x in picking.pack_operation_ids]):
+        wrong_lots = self.set_pack_operation_lot(picking)
-
+        has_wrong_lots = False
-                            else:
+                            else: # serial numbers
-                else:
+                        else:
-                                qty = pack_lot_names.count(lot_name)
+                                # if a lot nr is set through the frontend it will refer to the full quantity
-        amount = reduce(lambda x, y: x + y[1], result, 0.0)
+        amount = sum(amt for _, amt in result)
-            to_create_variants = filter(lambda rec_set: set(rec_set.ids) not in existing_variants, variant_matrix)
+            # iterator of n-uple of product.attribute.value *ids*
-                'total': reduce(lambda x, y: y['rating_count'] + x, data, 0),
+                'avg': sum(float(key * values[key]) for key in values) / rating_number if rating_number > 0 else 0,
-            total = reduce(lambda x, y: y['rating_count'] + x, rating_stats, 0)
+            total = sum(st['rating_count'] for st in rating_stats)
-                field_groups = reduce(add, map(ref, field_group_xmlids))
+                field_groups = Groups.concat(*map(ref, field_group_xmlids))
-            if reduce(lambda x, y: x and y in self, deps, True):
+            if all(dep in self for dep in deps):
-            reduce(cmp, pvs)
+
-                              'modules': reduce(lambda s, m: s + "#\t* %s\n" % m, modules, ""),
+                              'modules': ''.join("#\t* %s\n" % m for m in modules),
-            views._check_xml()
+            for view in views:
-                ", ".join(map(str, fields)),
+                _("Fields:") + " " + ", ".join(map(str, fields)),
-            line_invoice_status = [line.invoice_status for line in order.order_line]
+            # Ignore the status of the deposit product
-
+                order = self.sudo().browse(self.id)
-                    order_line._get_display_price(order_line.product_id),
+                    order_line._get_display_price(product),
-                pos_qty = any([x.qty >= 0 for x in order.lines])
+                pos_qty = any([x.qty > 0 for x in order.lines])
-                continue
+                if not i:
-
+    partner_id = fields.Many2one('res.partner', string='Responsible', related='user_id.partner_id', readonly=True)
-import unittest
+
-        self.phantom_js('/web/tests?mod=web',"","", login='admin')
+        self.phantom_js('/web/tests?mod=web', "", "", login='admin')
-    def get_move_lines_for_reconciliation_widget(self, excluded_ids=None, str=False, offset=0, limit=None):
+    def get_move_lines_for_reconciliation_widget(self, partner_id=None, excluded_ids=None, str=False, offset=0, limit=None):
-        aml_recs = self.get_move_lines_for_reconciliation(excluded_ids=excluded_ids, str=str, offset=offset, limit=limit)
+        aml_recs = self.get_move_lines_for_reconciliation(partner_id=partner_id, excluded_ids=excluded_ids, str=str, offset=offset, limit=limit)
-    def get_move_lines_for_reconciliation(self, excluded_ids=None, str=False, offset=0, limit=None, additional_domain=None, overlook_partner=False):
+    def get_move_lines_for_reconciliation(self, partner_id=None, excluded_ids=None, str=False, offset=0, limit=None, additional_domain=None, overlook_partner=False):
-        if self.partner_id.id or overlook_partner:
+        if partner_id or overlook_partner:
-            domain = expression.AND([domain, [('partner_id', '=', self.partner_id.id)]])
+        if partner_id and not overlook_partner:
-        domain = expression.AND([domain, generic_domain])
+        if str:
-        return self.env['account.move.line'].search(domain, offset=offset, limit=limit, order="date_maturity asc, id asc")
+        return self.env['account.move.line'].search(domain, offset=offset, limit=limit, order="date_maturity desc, id desc")
-                    ORDER BY temp_field_order, date_maturity asc, aml.id asc"
+                    ORDER BY temp_field_order, date_maturity desc, aml.id desc"
-                ORDER BY date_maturity asc, aml.id asc LIMIT 1"
+                ORDER BY date_maturity desc, aml.id desc LIMIT 1"
-                ORDER BY a.date asc
+                ORDER BY a.date desc
-            :param excluded_ids: list of ids of move lines that should not be fetched
+    def domain_move_lines_for_reconciliation(self, str):
-                '&', ('name', '!=', '/'), ('name', 'ilike', str)
+        if not str:
-        return domain
+            str_domain = expression.OR([str_domain, amount_domain])
-        return expression.AND([generic_domain, domain])
+        if excluded_ids:
-        lines = self.search(domain, offset=offset, limit=limit, order="date_maturity asc, id asc")
+        lines = self.search(domain, offset=offset, limit=limit, order="date_maturity desc, id desc")
-                'journal_name': line.journal_id.name,
+                'journal_id': [line.journal_id.id, line.journal_id.display_name],
-                total_amount_currency_str = formatLang(self.env, total_amount, currency_obj=line_currency)
+                target_currency.compute(total_amount, line_currency)
-                self.process_reconciliation(datum['mv_line_ids'], datum['new_mv_line_dicts'])
+                self.browse(datum['mv_line_ids']).process_reconciliation(datum['new_mv_line_dicts'])
-    'depends': ['web', 'web_kanban'],
+    'depends': ['web'],
-    'depends': ['base', 'web_kanban'],
+    'depends': ['base', 'web'],
-    'depends': ['base', 'mail', 'web_calendar'],
+    'depends': ['base', 'mail'],
-        fields2 = fields and fields[:] or None
+        if not fields:
-            Used by web_calendar.js : Many2ManyAttendee
+            Used by base_calendar.js : Many2ManyAttendee
-    def sync_data(self, arch, fields, model, **kw):
+    def sync_data(self, model, **kw):
-        'web_kanban',
+        'web',
-        'web_kanban',
+        'web',
-    def get_diagram_info(self, req, id, model, node, connector,
+    def get_diagram_info(self, id, model, node, connector,
-        connector_fields_string = kw.get('connector_fields_string',[])
+        visible_node_fields = kw.get('visible_node_fields', [])
-        shape = kw.get('shape','')
+        bgcolor = kw.get('bgcolor', '')
-            y_max = (y and max(y)) or 120
+        y = map(lambda t: t['y'], filter(lambda x: x['y'] if x['x'] == 20 else None, nodes.values()))
-                    name=name,
+                    display_name=name,
-    'depends': ['web_kanban'],
+    'depends': ['web'],
-            for additional_field in ('date_start', 'date_delay', 'date_stop', 'color', 'all_day', 'attendee'):
+            for additional_field in ('date_start', 'date_delay', 'date_stop', 'color', 'all_day'):
-                    fields[node.get(additional_field)] = {}
+                    fields[node.get(additional_field).split('.', 1)[0]] = {}
-        """ Returns the fields_views of given views, and optionally filters and fields.
+        """ Returns the fields_views of given views, along with the fields of
-        :return: dictionary with fields_views, filters and fields
+        :return: dictionary with fields_views, fields and optionally filters
-        group.add_option("--load", dest="server_wide_modules", help="Comma-separated list of server-wide modules.", my_default='web,web_kanban')
+        group.add_option("--load", dest="server_wide_modules", help="Comma-separated list of server-wide modules.", my_default='web')
-            self.options['server_wide_modules'] = 'web,web_kanban'
+            self.options['server_wide_modules'] = 'web'
-        record.date = date(2012, 05, 01)
+        record.date = date(2012, 5, 1)
-        record.date = datetime(2012, 05, 01, 10, 45, 00)
+        record.date = datetime(2012, 5, 1, 10, 45, 00)
-                    os.chmod(self.rcfile, 0600)
+                    os.chmod(self.rcfile, 0o600)
-                    os.makedirs(add_dir, 0700)
+                    os.makedirs(add_dir, 0o700)
-                os.makedirs(d, 0500)
+                os.makedirs(d, 0o500)
-            os.makedirs(d, 0700)
+            os.makedirs(d, 0o700)
-            items = sorted(values.items(), key=lambda (x, y): x.lower())
+            items = sorted(values.items(), key=lambda pair: pair[0].lower())
-        for app, gs in sorted(by_app.iteritems(), key=lambda (a, _): a.sequence or 0):
+        for app, gs in sorted(by_app.iteritems(), key=lambda it: it[0].sequence or 0):
-        if not attrs.has_key('href'): return None
+        if 'href' not in attrs: return None
-                        if (a.has_key('title') and attrs.has_key('title') and
+            if 'href' in a and a['href'] == attrs['href']:
-                if attrs.has_key('title'):
+                if 'title' in attrs:
-                if attrs.has_key('href') and not (SKIP_INTERNAL_LINKS and attrs['href'].startswith('#')):
+                if 'href' in attrs and not (SKIP_INTERNAL_LINKS and attrs['href'].startswith('#')):
-            if attrs.has_key('src'):
+            if 'src' in attrs:
-                        if link.has_key('title'): self.out(" ("+link['title']+")")
+                        if 'title' in link: self.out(" ("+link['title']+")")
-    if not _translate_funcs.has_key(lang):
+    if lang not in _translate_funcs:
-    if not _translate_funcs.has_key(lang):
+    if lang not in _translate_funcs:
-                    self.misc[sec]= {}
+                self.misc.setdefault(sec, {})
-        for header in [h for h in headers if msg.has_key(h)]:
+        for header in [h for h in headers if h in msg]:
-                if (account.company_id.id <> vals['company_id']) and move_lines:
+                if (account.company_id.id != vals['company_id']) and move_lines:
-                        self.o("][" + `a['count']` + "]")
+                        self.o("][%r]" % a['count'])
-                self.o("]["+`attrs['count']`+"]")
+                self.o("][%r]" % attrs['count'])
-                    self.o(`li['num']`+". ")
+                    self.o("%r. " % li['num'])
-                        self.out("   ["+`link['count']`+"]: " + urlparse.urljoin(self.baseurl, link['href']))
+                        self.out("   ["+repr(link['count'])+"]: " + urlparse.urljoin(self.baseurl, link['href']))
-        if not ((project.rating_status<>'no') and project.website_published) and not user.sudo(user).has_group('project.group_project_manager'):
+        if not ((project.rating_status!='no') and project.website_published) and not user.sudo(user).has_group('project.group_project_manager'):
-    partner_id = fields.Many2one('res.partner', string='Partner', readonly=True)
+    partner_id = fields.Many2one('res.partner', string='Customer', readonly=True)
-        if not subtype_ids or any(subtype.parent_id.model == 'project.task' for subtype in self.env['mail.message.subtype'].browse(subtype_ids)):
+        if not subtype_ids or any(subtype.parent_id.res_model == 'project.task' for subtype in self.env['mail.message.subtype'].browse(subtype_ids)):
-    user_id = fields.Many2one('res.users', string='Salesman', help="Person who uses the cash register. It can be a reliever, a student or an interim employee.", default=lambda self: self.env.uid)
+    user_id = fields.Many2one(
-    location_id = fields.Many2one('stock.location', related='session_id.config_id.stock_location_id', string="Location", store=True)
+    location_id = fields.Many2one(
-    fiscal_position_id = fields.Many2one('account.fiscal.position', string='Fiscal Position', default=lambda self: self._default_session().config_id.default_fiscal_position_id)
+    fiscal_position_id = fields.Many2one(
-            domain = [('so_line', 'in', self.ids), ('amount', '<=', 0.0)]
+            expense_type_id = self.env.ref('account.data_account_type_expenses', raise_if_not_found=False)
-            domain = [('so_line', 'in', self.ids), '|', ('amount', '<=', 0.0), ('is_timesheet', '=', True)]
+            expense_type_id = self.env.ref('account.data_account_type_expenses', raise_if_not_found=False)
-        except ldap.LDAPError, e:
+        except ldap.LDAPError as e:
-        except ldap.LDAPError, e:
+        except ldap.LDAPError as e:
-            except Exception, e:
+            except Exception as e:
-        except AccessDenied, access_denied_exception:
+        except AccessDenied as access_denied_exception:
-            except (SignupError, AssertionError), e:
+            except (SignupError, AssertionError) as e:
-            except Exception, e:
+            except Exception as e:
-        except Exception, e:
+        except Exception as e:
-        except Exception, e:
+        except Exception as e:
-        except Exception, e:
+        except Exception as e:
-        except Exception, error:
+        except Exception as error:
-                            except ValueError, e:
+                            except ValueError as e:
-                            except Exception, e:
+                            except Exception as e:
-        except ValueError, error:
+        except ValueError as error:
-        except Exception, e:
+        except Exception as e:
-                    except Exception, e:
+                    except Exception as e:
-            except Exception, e:
+            except Exception as e:
-            except Exception, err:
+            except Exception as err:
-            except (ValueError, SyntaxError), e:
+            except (ValueError, SyntaxError) as e:
-            except KeyError, e:
+            except KeyError as e:
-        except urllib2.HTTPError, error:
+        except urllib2.HTTPError as error:
-        except urllib2.HTTPError, error:
+        except urllib2.HTTPError as error:
-        except urllib2.HTTPError, e:
+        except urllib2.HTTPError as e:
-        except Exception, e:
+        except Exception as e:
-            except Exception, e:
+            except Exception as e:
-            except urllib2.HTTPError, e:
+            except urllib2.HTTPError as e:
-                        except Exception, e:
+                        except Exception as e:
-                except Exception, exc:
+                except Exception as exc:
-        except Exception, e:
+        except Exception as e:
-        except Exception, e:
+        except Exception as e:
-        except Exception, e:
+        except Exception as e:
-        except Exception, e:
+        except Exception as e:
-        except Exception, e:
+        except Exception as e:
-        except Exception, e:
+        except Exception as e:
-        except Exception, e:
+        except Exception as e:
-        except Exception, e:
+        except Exception as e:
-        except Exception, e:
+        except Exception as e:
-        except Exception, e:
+        except Exception as e:
-        except Exception, e:
+        except Exception as e:
-                    except IOError, e:
+                    except IOError as e:
-            except Exception, e:
+            except Exception as e:
-        except ValueError, e:
+        except ValueError as e:
-        except Exception, e:
+        except Exception as e:
-        except Exception, e:
+        except Exception as e:
-            except Exception, e:
+            except Exception as e:
-        except ValidationError, e:
+        except ValidationError as e:
-        except ValidationError, e:
+        except ValidationError as e:
-            except Exception, e:
+            except Exception as e:
-        except HTTPError, e:
+        except HTTPError as e:
-        except HTTPError, e:
+        except HTTPError as e:
-        except URLError, e:
+        except URLError as e:
-        except Exception, e:
+        except Exception as e:
-        except Exception, e:
+        except Exception as e:
-        except psycopg2.ProgrammingError, e:
+        except psycopg2.ProgrammingError as e:
-            except psycopg2.OperationalError, e:
+            except psycopg2.OperationalError as e:
-                except ValueError, e:
+                except ValueError as e:
-        except werkzeug.exceptions.NotFound, e:
+        except werkzeug.exceptions.NotFound as e:
-        except Exception, e:
+        except Exception as e:
-        except AssetError, e:
+        except AssetError as e:
-        except AssetError, e:
+        except AssetError as e:
-        except QWebException, e:
+        except QWebException as e:
-        except Exception, e:
+        except Exception as e:
-        except QWebException, e:
+        except QWebException as e:
-        except Exception, e:
+        except Exception as e:
-            except QWebException, e:
+            except QWebException as e:
-            except Exception, e:
+            except Exception as e:
-            except QWebException, e:
+            except QWebException as e:
-            except Exception, e:
+            except Exception as e:
-        except Exception, e:
+        except Exception as e:
-            except Exception, ex:
+            except Exception as ex:
-        except Exception, e:
+        except Exception as e:
-        except DatabaseExists, e:
+        except DatabaseExists as e:
-        except Exception, e:
+        except Exception as e:
-    except odoo.exceptions.DeferredException, e:
+    except odoo.exceptions.DeferredException as e:
-    except Exception, e:
+    except Exception as e:
-        except Exception, e:
+        except Exception as e:
-        except werkzeug.exceptions.HTTPException, e:
+        except werkzeug.exceptions.HTTPException as e:
-            except(Exception), e:
+            except(Exception) as e:
-                except werkzeug.exceptions.HTTPException, e:
+                except werkzeug.exceptions.HTTPException as e:
-        except werkzeug.exceptions.HTTPException, e:
+        except werkzeug.exceptions.HTTPException as e:
-            except Exception, e:
+            except Exception as e:
-                except ValidationError, e:
+                except ValidationError as e:
-                except Exception, e:
+                except Exception as e:
-    except Exception, e:
+    except Exception as e:
-    except Exception, e:
+    except Exception as e:
-        except platypus.doctemplate.LayoutError, e:
+        except platypus.doctemplate.LayoutError as e:
-    except Exception, exc:
+    except Exception as exc:
-                        except Exception, e:
+                        except Exception as e:
-                        except Exception, e:
+                        except Exception as e:
-            except Exception, e:
+            except Exception as e:
-            except Exception, e:
+            except Exception as e:
-    except Exception, e:
+    except Exception as e:
-        except Exception, e:
+        except Exception as e:
-        except Exception, e:
+        except Exception as e:
-            except IntegrityError, inst:
+            except IntegrityError as inst:
-    except Exception, exception:
+    except Exception as exception:
-            except Exception, exception:
+            except Exception as exception:
-        except socket.error, e:
+        except socket.error as e:
-        except IOError, e:
+        except IOError as e:
-        except OSError, e:
+        except OSError as e:
-            except OSError, e:
+            except OSError as e:
-                except OSError, e:
+                except OSError as e:
-        except select.error, e:
+        except select.error as e:
-            except Exception, e:
+            except Exception as e:
-        except select.error, e:
+        except select.error as e:
-        except IOError, e:
+        except IOError as e:
-        except socket.error, e:
+        except socket.error as e:
-    except Exception, e:
+    except Exception as e:
-            except select.error, e:
+            except select.error as e:
-                except Exception, e:
+                except Exception as e:
-    except etree.ParserError, e:
+    except etree.ParserError as e:
-    except Exception, e:
+    except Exception as e:
-    except Exception, e:
+    except Exception as e:
-            except Exception, e:
+            except Exception as e:
-            except AttributeError, exc:
+            except AttributeError as exc:
-    except etree.DocumentInvalid, xml_errors:
+    except etree.DocumentInvalid as xml_errors:
-                    except Exception, e:
+                    except Exception as e:
-                                except Exception, e:
+                                except Exception as e:
-                                except Exception, e:
+                                except Exception as e:
-        except AssertionError, e:
+        except AssertionError as e:
-        except Exception, e:
+        except Exception as e:
-            except Exception, e:
+            except Exception as e:
-                         u"or a field of the same name in an o2m.",
+            dict(message=u"The value for the field 'value' already exists "
-                         u"or a field of the same name in an o2m.",
+            dict(message=u"The value for the field 'value' already exists "
-    if not m or field_name not in fields:
+def convert_pgerror_not_null(model, fields, info, e):
-        message = _(u"Missing required value for the field '%s' (%s)") % (field['string'], field_name)
+
-    if not m or field_name not in fields:
+def convert_pgerror_unique(model, fields, info, e):
-                    u"of the same name in an o2m.") % (message, field['string'])
+
-        'field': field_name,
+        # no field, unclear which one we should pick and they could be in any order
-    '23505': convert_pgerror_23505,
+    '23502': convert_pgerror_not_null,
-                    taxes = line.tax_id.compute_all(price, line.order_id.currency_id, line.product_uom_qty, product=line.product_id, partner=line.order_id.partner_id)
+                    taxes = line.tax_id.compute_all(price, line.order_id.currency_id, line.product_uom_qty, product=line.product_id, partner=order.partner_shipping_id)
-                                         product=line.product_id, partner=line.order_partner_id)['taxes'][0]['amount']
+                                         product=line.product_id, partner=self.partner_shipping_id)['taxes'][0]['amount']
-                                                partner=line.order_partner_id)['taxes'][0]['amount']
+                                                partner=self.partner_shipping_id)['taxes'][0]['amount']
-            taxes = line.tax_id.compute_all(price, line.order_id.currency_id, line.product_uom_qty, product=line.product_id, partner=line.order_id.partner_id)
+            taxes = line.tax_id.compute_all(price, line.order_id.currency_id, line.product_uom_qty, product=line.product_id, partner=line.order_id.partner_shipping_id)
-            line.tax_id = fpos.map_tax(taxes, line.product_id, line.order_id.partner_id) if fpos else taxes
+            line.tax_id = fpos.map_tax(taxes, line.product_id, line.order_id.partner_shipping_id) if fpos else taxes
-        tax_lines = filter(lambda l: l.manual, invoice.tax_line_ids)
+        tax_lines = invoice.tax_line_ids
-                refund.compute_taxes()
+        # DO NOT FORWARDPORT
-            company_id and [('company_id', '=', company_id)] or [],
+        domain = [('company_id', '=', company_id)] if company_id else []
-                    wizard_user._send_email()
+                    wizard_user.with_context(active_test=True)._send_email()
-        return self.env['ir.values'].set_default(
+        if not self.user_has_groups('website.group_website_designer'):
-        return self.env['ir.values'].set_default(
+        if not self.user_has_groups('website.group_website_designer'):
-        return self.env['ir.values'].set_default(
+        if not self.user_has_groups('website.group_website_designer'):
-            domain += ['|', ('reconciled', '=', False), '|', ('matched_debit_ids.create_date', '>', context['reconcile_date']), ('matched_credit_ids.create_date', '>', context['reconcile_date'])]
+            domain += ['|', ('reconciled', '=', False), '|', ('matched_debit_ids.max_date', '>', context['reconcile_date']), ('matched_credit_ids.max_date', '>', context['reconcile_date'])]
-                if partial_line.create_date[:10] <= date_from:
+                if partial_line.max_date <= date_from:
-                if partial_line.create_date[:10] <= date_from:
+                if partial_line.max_date <= date_from:
-                    if partial_line.create_date[:10] <= date_from:
+                    if partial_line.max_date <= date_from:
-                    if partial_line.create_date[:10] <= date_from:
+                    if partial_line.max_date <= date_from:
-                    wizard_user._send_email()
+                    wizard_user.with_context(active_test=True)._send_email()
-            }
+            move_line = expense._prepare_move_line_value()
-        etree.SubElement(customer, "email").text = partner.email
+        etree.SubElement(customer, "email").text = partner.email or ''
-                        group_domains.setdefault(group, []).append(dom)
+                if rule.groups & user.groups_id:
-                if not line.tax_exigible:
+                if not float_is_zero(amount, precision_rounding=currency_id.rounding) and not line.tax_exigible:
-                self.process_reconciliation(datum['mv_line_ids'], datum['new_mv_line_dicts'])
+                self.env['account.move.line'].browse(datum['mv_line_ids']).process_reconciliation(datum['new_mv_line_dicts'])
-        date = self._context.get('date') or fields.Datetime.now()
+        date = self._context.get('date') or fields.Date.today()
-        model = self.env['res.currency.rate']
+        model = self.env['ir.property']
-        self.assertEqual(columns_data['name'], {
+        self.assertEqual(columns_data['value_datetime'], {
-            'column_name': u'name',
+            'column_name': u'value_datetime',
-            'is_nullable': u'NO',
+            'is_nullable': u'YES',
-            'table_name': u'res_currency_rate',
+            'table_name': u'ir_property',
-                if not line.currency_id or line.currency_id.id != line.account_id.currency_id.id:
+            account_currency = line.account_id.currency_id
-                           default=lambda self: fields.Date.today() + ' 00:00:00')
+    name = fields.Date(string='Date', required=True, index=True,
-            rate = currency_rate.create({'name':'2000-01-01',
+        def try_roundtrip(value, expected, date):
-        try_roundtrip(-10000.999999, -10000.999999)
+        try_roundtrip(2.6748955, 2.674896, '2000-01-01')
-            xml = ElementTree.parse(fp).getroot()
+            try:
-            supplier = self._make_po_select_supplier(suppliers)
+            supplier = procurement._make_po_select_supplier(suppliers)
-            supplier = suppliers[0]
+            supplier = self._make_po_select_supplier(suppliers)
-                                      'Message: %s') % (str(process.returncode), err))
+                    if process.returncode == -11:
-    tax_cash_basis_journal_id = fields.Many2one('account.journal', string="Tax Cash Basis Journal")
+    tax_cash_basis_journal_id = fields.Many2one('account.journal', string="Cash Basis Journal")
-    bank_statements_source = fields.Selection([('no_feeds', 'No Feeds'),('manual', 'Record Manually')], string='Bank Feeds', default='no_feeds')
+    bank_statements_source = fields.Selection([('undefined', 'Undefined Yet'),('manual', 'Record Manually')], string='Bank Feeds', default='undefined')
-            ctx.update({'default_journal_id': self.id})
+            ctx.update({'default_journal_id': self.id, 'view_no_maturity': True})
-    'depends': ['account'],
+    'depends': ['account_accountant'],
-        journals = self.env['account.journal'].search([('type', '=', 'bank'), ('use_in_payment', '=', True), ('company_id', '=', company_id)])
+        journals = self.env['account.journal'].search([('type', '=', 'bank'), ('company_id', '=', company_id)])
-            waiting = self.filtered(lambda move: move.get_ancestors())
+            waiting = self.filtered(lambda move: move.procure_method == 'make_to_order' or move.get_ancestors())
-                if move.find_move_ancestors():
+                if move.procure_method == 'make_to_order' or move.find_move_ancestors():
-        self.assertEquals(picking_out.state, "assigned")
+        self.assertEquals(picking_out.state, "assigned")
-            delivery_partner_id = self.partner_shipping_id.id or self.partner_id.address_get(['delivery'])['delivery']
+            delivery_partner_id = self.get_delivery_partner_id()
-URL_REGEX = r'(\bhref=[\'"]([^\'"]+)[\'"])'
+from openerp.addons.link_tracker.models.link_tracker import URL_REGEX
-    total_attendance = fields.Integer(string='Total Attendance', compute='_compute_total')
+    total_attendance = fields.Float(string='Total Attendance', compute='_compute_total')
-            fiscal_position = self.env['account.fiscal.position'].get_fiscal_position(self.partner_id.id, delivery_id=addr['delivery'])
+            delivery_partner_id = self.partner_shipping_id.id or self.partner_id.address_get(['delivery'])['delivery']
-        new = self.create(vals)
+        # To avoid to create a translation in the lang of the user, copy_translation will do it
-        opportunities = self.search([('type', '=', 'opportunity'), ('user_id', '=', self._uid)])
+        opportunities = self.search([('type', '=', 'opportunity'), ('user_id', '=', self._uid), ('activity_date_deadline', '!=', False)])
-            "_auto_join off: ('bank_ids.name', 'like', '..') should produce 3 queries (1 in res_partner_bank, 2 on res_partner)")
+        self.assertEqual(len(self.query_list), 2,
-        sql_query = self.query_list[2].get_sql()
+        sql_query = self.query_list[1].get_sql()
-            "_auto_join off: ('child_ids.bank_ids.id', 'in', [..]) should produce 5 queries (1 in res_partner_bank, 4 on res_partner)")
+        self.assertEqual(len(self.query_list), 3,
-        self.assertEqual(len(self.query_list), 5,
+        self.assertEqual(len(self.query_list), 4,
-                leaf.leaf = ('id', 'in', table_ids)
+                leaf.leaf = (path[0], 'in', right_ids)
-                    push(create_substitution_leaf(leaf, ('id', 'in', _rec_convert(ids2)), model))
+                    if comodel == model:
-                            push(create_substitution_leaf(leaf, ('id', m2m_op, select_from_where(cr, rel_id1, rel_table, rel_id2, res_ids, operator) or [0]), model))
+                            subop = 'not inselect' if operator in NEGATIVE_TERM_OPERATORS else 'inselect'
-               }
+        res = {'journal_id': self.company_id.currency_exchange_journal_id.id}
-            items is matched with the other lines to balance the full reconciliation.
+        """
-            move = rec.env['account.move'].create(move_vals)
+
-            })
+            aml_model = rec.env['account.move.line']
-                })
+                partial_rec = rec.env['account.partial.reconcile'].create(
-            if not self.company_id.income_currency_exchange_account_id.id:
+            if not rec.company_id.income_currency_exchange_account_id.id:
-            if not self.company_id.expense_currency_exchange_account_id.id:
+            if not rec.company_id.expense_currency_exchange_account_id.id:
-from odoo.exceptions import ValidationError
+from odoo.exceptions import UserError, ValidationError
-                        raise UserError(_('Cannot rename field to %s, because that field already exists!') % vals['name'])
+
-                        raise ValueError('Invalid character in column name')
+
-                ) % ("\n".join(themes_list)))
+        # the modules that are installed/to install/to upgrade
-        if price != 0 and new_list_price != 0:
+        if new_list_price != 0:
-            for move_lot in self.move_id.move_lot_ids.filtered(lambda r: not r.lot_produced_id and r.lot_id):
+            for move_lot in self.move_id.active_move_lot_ids.filtered(lambda r: not r.lot_produced_id and r.lot_id):
-            aml = ac_move.line_ids.filtered(lambda x: x.account_id.reconcile)
+            aml = ac_move.line_ids.filtered(lambda x: x.account_id.reconcile or x.account_id.internal_type == 'liquidity')
-            #reconcile together the reconciliable aml and their newly created counterpart
+            #reconcile together the reconciliable and the liquidity aml and their newly created counterpart
-        if not all_accounts[0].reconcile:
+        if not (all_accounts[0].reconcile or all_accounts[0].internal_type == 'liquidity'):
-            pdt_post[post] = urllib.unquote_plus(pdt_post[post]).decode('utf8')
+
-        return self.value_to_html(record[field_name], options)
+        return super(MonetaryConverter, self).record_to_html(record, field_name, options)
-        for move in self.filtered(lambda move: move.location_id.usage == 'supplier' and move.product_id.cost_method == 'average'):
+        for move in self.filtered(lambda move: move.location_id.usage in ('supplier', 'production') and move.product_id.cost_method == 'average'):
-            product.bom_count = mapped_data.get(product.id, 0)
+            if product.product_tmpl_id.product_variant_count == 1:
-                    self.cr.execute('''SELECT MIN(COALESCE(date_maturity,date)) FROM account_move_line WHERE reconcile_partial_id = %s''', (partner_info[2],))
+                    # in case of partial reconciliation, we want to keep the remaining amount in the
-                    'date': move.date,
+                    'date': fields.date.context_today(self, cr, uid, context=context),
-                    'date': move.date,
+                    'date': fields.date.context_today(self, cr, uid, context=context),
-            ids_set = {d[field] for d in data}
+            ids_set = {d[field] for d in data if d[field]}
-        picking_obj.action_confirm(cr, uid, [picking_id], context=context)
+        picking_obj.action_assign(cr, uid, [picking_id], context=context)
-                move_obj.force_assign(cr, uid, move_list, context=context)
+                move_obj.action_assign(cr, uid, move_list, context=context)
-            for move_lot in self.move_id.move_lot_ids.filtered(lambda r: not r.lot_produced_id):
+            for move_lot in self.move_id.move_lot_ids.filtered(lambda r: not r.lot_produced_id and r.lot_id):
-        if self.order_id.pricelist_id.discount_policy == 'without_discount':
+        if self.order_id.pricelist_id.discount_policy == 'with_discount':
-
+            recompute = False
-            record.cost_count = Cost.search_count([('vehicle_id', '=', self.id), ('parent_id', '=', False)])
+            record.odometer_count = Odometer.search_count([('vehicle_id', '=', record.id)])
-                limit=1)
+            company_id = self.sudo(user_id).company_id.id
-        orders._create_picking()
+        if orders:
-        
+
-        self.pool.get('account.move').assert_balanced(cr, uid, [move_id], context=context)
+            self.recompute(cr, uid, context=context)
-        if self.event_type_id:
+        if self.event_type_id and self.website_menu:
-            self.done = len(self.mail_registration_ids) == len(self.event_id.registration_ids) and all(filter(lambda line: line.mail_sent, self.mail_registration_ids))
+            self.done = len(self.mail_registration_ids) == len(self.event_id.registration_ids) and all(mail.mail_sent for mail in self.mail_registration_ids)
-            if self.event_type_id.use_reply_to:
+            if self.event_type_id.use_hashtag:
-            self.done = len(self.mail_registration_ids) == len(self.event_id.registration_ids) and all(filter(lambda line: line.mail_sent, self.mail_registration_ids))
+            self.done = len(self.mail_registration_ids) == len(self.event_id.registration_ids) and all(line.mail_sent for line in self.mail_registration_ids)
-        action['view_id'] = False
+        if action_name in ['action_bank_statement_tree', 'action_view_bank_statement_tree']:
-        pos_sessions = request.env['pos.session'].search([('state', '=', 'opened'), ('user_id', '=', request.session.uid)])
+        pos_sessions = request.env['pos.session'].search([
-            pos_config.current_session_state = session.state
+            session = pos_config.session_ids.filtered(lambda r: r.user_id.id == self.env.uid and \
-            pos_config.pos_session_username = pos_config.session_ids.filtered(lambda s: s.state == 'opened').user_id.name
+            session = pos_config.session_ids.filtered(lambda s: s.state == 'opened' and '(RESCUE FOR' not in s.name)
-            'rescue': True,    # avoid conflict with live sessions
+            'name': '(RESCUE FOR %(session)s)' % {'session': closed_session.name},
-        if self.search_count([('state', 'not in', ('closed', 'closing_control')), ('user_id', '=', self.user_id.id)]) > 1:
+        if self.search_count([
-        if self.search_count([('state', '!=', 'closed'), ('config_id', '=', self.config_id.id)]) > 1:
+        if self.search_count([
-from odoo.tools import float_compare, test_reports
+from odoo import fields, tools, report as odoo_report
-        joining the parameters "mail.catchall.alias" and
+        joining the parameters "mail.bounce.alias" and
-        If "mail.catchall.alias" is not set it defaults to "postmaster-odoo".
+        If "mail.bounce.alias" is not set it defaults to "postmaster-odoo".
-        self.image = self.user_id.image
+        if self.user_id:
-    # resource
+    # resource and user
-    identification_id = fields.Char(string='Identification No', groups="hr.group_hr_user")
+    # private partner
-    job_id = fields.Many2one('hr.job', string='Job Title')
+    birthday = fields.Date('Date of Birth', groups="hr.group_hr_user")
-
+    bank_account_id = fields.Many2one(
-    image = fields.Binary("Photo", default=_default_image, attachment=True,
+    image = fields.Binary(
-    image_medium = fields.Binary("Medium-sized photo", attachment=True,
+    image_medium = fields.Binary(
-    image_small = fields.Binary("Small-sized photo", attachment=True,
+    image_small = fields.Binary(
-    paperformat_id = fields.Many2one('report.paperformat', 'Paper format', default=lambda self: self.env.ref('report.paperformat_euro'))
+    paperformat_id = fields.Many2one('report.paperformat', 'Paper format', default=lambda self: self.env.ref('report.paperformat_euro', raise_if_not_found=False))
-        :param bool use_new_cursor: if set, use a dedicated cursor and auto-commit after processing each procurement.
+        :param bool use_new_cursor: if set, use dedicated cursors and auto-commit after processing
-            cr = openerp.registry(cr.dbname).cursor()
+            if use_new_cursor:
-            view.with_context(context, lang=None).write({'arch': xml_content})
+            view.with_context(context, lang=None).write({'arch': xml_content, 'arch_fs': False})
-    paperformat_id = fields.Many2one('report.paperformat', 'Paper format')
+    paperformat_id = fields.Many2one('report.paperformat', 'Paper format', default=lambda self: self.env.ref('report.paperformat_euro'))
-        if warehouse.buy_pull_id:
+        if name and warehouse.buy_pull_id:
-            if session_id:
+            session = self.env['pos.session'].browse(session_id).exists() if session_id else None
-                session = self.env['pos.session'].browse(session_id)
+# -*- coding: utf-8 -*-
-                if not (field.store or field.column and field.column._fnct_inv):
+                elif not (field.store or field.column and field.column._fnct_inv):
-            })
+            if not expense.sheet_id.id in move_group_by_sheet:
-            move.post()
+        for move in move_group_by_sheet.values():
-            result['name'] = product_obj.display_name
+            result['name'] = product_obj.with_context(lang=partner.lang).display_name
-    quantity = fields.Float(digits=(16, 2),
+    quantity = fields.Float(digits=dp.get_precision('Product Unit of Measure'),
-            # Get ids from triplets : https://www.odoo.com/documentation/master/reference/orm.html#openerp.models.Model.write
+            # Get ids from triplets : https://www.odoo.com/documentation/10.0/reference/orm.html#odoo.models.Model.write
-Re-implement openerp's file import system:
+Re-implement Odoo's file import system:
-from openerp import api, models
+from odoo import api, models
-        #repeat yearly but for openerp it's monthly, take same information as monthly but interval is 12 times
+        #repeat yearly but for odoo it's monthly, take same information as monthly but interval is 12 times
-        """ This route/function is called when we want to synchronize openERP calendar with Google Calendar
+        """ This route/function is called when we want to synchronize Odoo calendar with Google Calendar
-            The dictionary may contains an url, to allow OpenERP Client to redirect user on this URL for authorization for example
+            The dictionary may contains an url, to allow Odoo Client to redirect user on this URL for authorization for example
-            # Checking that user have already accepted OpenERP to access his calendar !
+            # Checking that user have already accepted Odoo to access his calendar !
-        """ This route/function is called when we want to remove all the references between one calendar OpenERP and one Google Calendar """
+        """ This route/function is called when we want to remove all the references between one calendar Odoo and one Google Calendar """
-            # Checking that user have already accepted OpenERP to access his calendar !
+            # Checking that user have already accepted Odoo to access his calendar !
-from openerp.exceptions import AccessError
+from odoo.exceptions import AccessError
-from openerp.tools import float_compare
+from odoo.tools import float_compare
-This module allows openerp to print with ESC/POS compatible printers and
+This module allows Odoo to print with ESC/POS compatible printers and
-This module overrides openerp web interface to display a simple
+This module overrides Odoo web interface to display a simple
-regular openerp interface anymore. 
+regular Odoo interface anymore.
-and should not be installed on regular openerp servers.
+and should not be installed on regular Odoo servers.
-from openerp import models, api, _
+from odoo import models, api, _
-accounting feature of Openerp.
+accounting feature of Odoo.
-       model. It is used by OpenERP's mail gateway when processing incoming emails
+    """A Mail Alias is a mapping of an email address with a given Odoo Document
-       created, it becomes immediately usable and OpenERP will accept email for it.
+       created, it becomes immediately usable and Odoo will accept email for it.
-        versions of OpenERP.
+        versions of Odoo.
-        Send a message to OpenERP's publisher warranty server to check the
+        Send a message to Odoo's publisher warranty server to check the
-    Receive the email via the stdin and send it to the OpenERP Server
+    Receive the email via the stdin and send it to the Odoo Server
-    payment_tx_id = fields.Many2one('payment.transaction', string='Transaction', copy=False)
+    payment_tx_id = fields.Many2one('payment.transaction', string='Last Transaction', copy=False)
-        if journal and journal.company_id == self.env.user.company_id:
+        if journal and journal.sudo().company_id == self.env.user.company_id:
-        IrSequence = self.env['ir.sequence']
+        IrSequence = self.env['ir.sequence'].sudo()
-            'context': context,
+        'data/sale_stock_data.xml',
-            'statement_id': self.statement_id.id,
+            'statement_line_id': self.id,
-        })]
+        })] if self.user_has_groups('event.group_email_scheduling') else []
-                        imd_name VARCHAR(128)
+                        imd_name VARCHAR(128),
-                       SET res_id = imd.res_id
+                       SET res_id = imd.res_id,
-                           WHERE %s AND ti.value IS NOT NULL AND ti.value != ''
+                           WHERE %s
-                move = move_group_by_sheet[expense.sheet_id.id]
+            move = self.env['account.move'].create({
-        res['domain'] = [('id', 'in', self.mapped('account_move_id').ids)]
+        #DO NOT FORWARD-PORT
-                'amount_currency': company_currency != current_currency and - sign * line.amount or 0.0,
+                'amount_currency': company_currency != current_currency and - 1.0 * line.amount or 0.0,
-                'amount_currency': company_currency != current_currency and sign * line.amount or 0.0,
+                'amount_currency': company_currency != current_currency and line.amount or 0.0,
-            workorder.production_messages = "<br/>".join(messages)
+            workorder.production_messages = "<br/>".join(messages) or False
-        return views.filtered(lambda v: not v.groups_id or len(user_groups.intersection(v.groups_id))
+        return views.filtered(lambda v: not v.groups_id or len(user_groups.intersection(v.groups_id)))
-    _description = "Lines of Point of Sale"
+    _description = "Lines of Point of Sale Orders"
-    'depends': ['hr_payroll', 'account', 'hr_expense'],
+    'depends': ['hr_payroll', 'account'],
-    identification_id = fields.Char(string='Identification No')
+    birthday = fields.Date('Date of Birth', groups="hr.group_hr_user")
-    ])
+    ], groups="hr.group_hr_user")
-    ], string='Marital Status')
+    ], string='Marital Status', groups="hr.group_hr_user")
-        domain="[('partner_id', '=', address_home_id)]", help='Employee bank salary account')
+        domain="[('partner_id', '=', address_home_id)]", help='Employee bank salary account',
-    passport_id = fields.Char('Passport No')
+    passport_id = fields.Char('Passport No', groups="hr.group_hr_user")
-    vehicle_distance = fields.Integer(string='Home-Work Dist.', help="In kilometers")
+    medic_exam = fields.Date(string='Medical Examination Date', groups="hr.group_hr_user")
-            resource = employee.resource_id
+            resource = employee.resource_id.sudo()
-        self.user_id.company_id.write({'fiscalyear_lock_date': self.yesterday.strftime(DEFAULT_SERVER_DATE_FORMAT)})
+        self.yesterday_str = self.yesterday.strftime(DEFAULT_SERVER_DATE_FORMAT)
-    @api.depends('state', 'order_line.qty_invoiced', 'order_line.product_qty')
+    @api.depends('state', 'order_line.qty_invoiced', 'order_line.qty_received', 'order_line.product_qty')
-            if any(float_compare(line.qty_invoiced, line.product_qty, precision_digits=precision) == -1 for line in order.order_line):
+            if any(float_compare(line.qty_invoiced, line.product_qty if line.product_id.purchase_method == 'purchase' else line.qty_received, precision_digits=precision) == -1 for line in order.order_line):
-            elif all(float_compare(line.qty_invoiced, line.product_qty, precision_digits=precision) >= 0 for line in order.order_line):
+            elif all(float_compare(line.qty_invoiced, line.product_qty if line.product_id.purchase_method == 'purchase' else line.qty_received, precision_digits=precision) >= 0 for line in order.order_line):
-            'price_unit': product.price,
+            'price_unit': pu,
-                values['price_unit'] = order_line._get_display_price(order_line.product_id)
+                values['price_unit'] = self.env['account.tax']._fix_tax_included_price(
-                    'check_in': fields.Datetime.to_string(fields.Datetime.context_timestamp(self, fields.Datetime.from_string(self.check_in))),
+                result.append((attendance.id, _("%(empl_name)s from %(check_in)s") % {
-                    'check_out': fields.Datetime.to_string(fields.Datetime.context_timestamp(self, fields.Datetime.from_string(self.check_out))),
+                result.append((attendance.id, _("%(empl_name)s from %(check_in)s to %(check_out)s") % {
-        if self.dashboard_graph_model in ['sales', 'invoices']:
+        if self.dashboard_graph_model == 'sales':
-            composer.with_context(active_ids=res_ids).send_mail(auto_commit=True)
+            extra_context = self._get_mass_mailing_context()
-from odoo import api, fields, models
+from odoo import api, fields, models, tools
-                res[res_id].update({
+                mail_values = res[res_id]
-                    })],
+                    'statistics_ids': [(0, 0, stat_vals)],
-        return request.render('auth_signup.reset_password', qcontext)
+        response = request.render('auth_signup.reset_password', qcontext)
-        return request.render('web.webclient_bootstrap', qcontext=context)
+        response = request.render('web.webclient_bootstrap', qcontext=context)
-        return request.render('web.login', values)
+        response = request.render('web.login', values)
-        return request.render("website_portal.details", values)
+        response = request.render("website_portal.details", values)
-    @api.constrains('lot_id')
+    @api.constrains('lot_id', 'quantity_done')
-                rules = Push.search(domain + [('route_id', '=', False)], order='sequence')
+                rules = Push.search(domain + [('route_id', '=', False)], order='sequence', limit=1)
-        default=lambda self: [(0, 0, {'name': 'x_name', 'field_description': 'Name', 'ttype': 'char'})])
+                               default=_default_field_id)
-    qty_received = fields.Float(compute='_compute_qty_received', string="Received Qty", store=True)
+    qty_invoiced = fields.Float(compute='_compute_qty_invoiced', string="Billed Qty", digits=dp.get_precision('Product Unit of Measure'), store=True)
-            })
+            if not expense.sheet_id.id in move_group_by_sheet:
-            move.post()
+        for move in move_group_by_sheet.values():
-            'name': vals['name'],
+            'name': refund and vals['name'] + _(': Refund') or vals['name'],
-            .action_move_create()
+        expense_line_ids = self.mapped('expense_line_ids')\
-        if self.payment_mode=='own_account':
+        if self.payment_mode == 'own_account' and expense_line_ids:
-                values[field_name] = value
+                if value:
-
+    unreserve_visible = fields.Boolean(
-        buy_route = self.env.ref('purchase.route_warehouse0_buy')
+        buy_route = self.env.ref('purchase.route_warehouse0_buy', raise_if_not_found=False)
-                    ORDER BY v.user_id, u.company_id"""
+                    ORDER BY v.user_id, v.company_id, v.id"""
-            name = self.product_id.name
+            name = self.product_id.name_get()[0][1]
-    _order = 'sequence'
+    _order = 'sequence, id'
-    _order = 'sequence'
+    feedback = fields.Html('Feedback')
-    def action_done(self):
+    def action_done(self, feedback=False):
-    date_action_next = fields.Datetime(string='Next Action', readonly=True)
+class CompanyDependentAttribute(models.Model):
-        record._cache.update(record._convert_to_cache(new_vals))
+            # put the values of pure new-style fields into cache, and inverse them
-# by Marcos Organizador de Negocios - Eneldo Serrata - www.marcos.org.do
+# Author: Gustavo Valverde <gvalverde@iterativo.do> iterativo | Consultores
-    'version': '1.0',
+    'version': '2.0',
-    'depends': ['account', 'base_iban'],
+
-        'data/account_chart_template.xml',
+        # Basic accounting data
-        'data/l10n_do_base_data.xml',
+        'data/account.tax.template.xml',
-        'data/account.fiscal.position.tax.template.csv',
+        'data/fiscal_position_template.xml',
-    'demo': [],
+        ],
-        # remaining records as done (to avoid recursive processing)
+        # filter out the records on which self has already been done
-        records -= action_done.setdefault(self, records.browse())
+        records_done = action_done.get(self, records.browse())
-        action_done[self] |= records
+
-            lead.sudo().convert_opportunity(lead.partner_id.id)
+            lead.sudo().convert_opportunity(lead.partner_id.id)  # sudo required to convert partner data
-        self.sudo().message_unsubscribe(partner_ids=partner_ids.ids)
+        self.message_unsubscribe(partner_ids=partner_ids.ids)
-
+from odoo.exceptions import AccessError
-    def test_00_partner_assign(self):
+    def test_partner_assign(self):
-        '''
+
-            'quotations': quotations,
+            'quotations': quotations.sudo(),
-            'orders': orders,
+            'orders': orders.sudo(),
-            days = (fields.Date.from_string(Order.validity_date) - fields.Date.from_string(fields.Date.today())).days + 1
+        if order_sudo.validity_date:
-            pdf = request.env['report'].sudo().with_context(set_viewport_size=True).get_pdf([Order.id], 'website_quote.report_quote')
+            pdf = request.env['report'].sudo().with_context(set_viewport_size=True).get_pdf([order_sudo.id], 'website_quote.report_quote')
-        transaction_id = request.session.get('quote_%s_transaction_id' % Order.id)
+        transaction_id = request.session.get('quote_%s_transaction_id' % order_sudo.id)
-            Transaction = request.env['payment.transaction'].sudo().search([('reference', '=', Order.name)])
+            Transaction = request.env['payment.transaction'].sudo().search([('reference', '=', order_sudo.name)])
-            'quotation': Order,
+            'quotation': order_sudo,
-            'order_valid': (not Order.validity_date) or (now <= Order.validity_date),
+            'option': bool(filter(lambda x: not x.line_id, order_sudo.options)),
-            'breadcrumb': request.env.user.partner_id == Order.partner_id,
+            'breadcrumb': request.env.user.partner_id == order_sudo.partner_id,
-            'need_payment': Order.invoice_status == 'to invoice' and Transaction.state in ['draft', 'cancel', 'error'],
+            'need_payment': order_sudo.invoice_status == 'to invoice' and Transaction.state in ['draft', 'cancel', 'error'],
-            values['acquirers'] = list(request.env['payment.acquirer'].sudo().search([('website_published', '=', True), ('company_id', '=', Order.company_id.id)]))
+        if order_sudo.require_payment or values['need_payment']:
-                    Order.pricelist_id.currency_id.id,
+                    order_sudo.amount_total,
-                        'partner_id': Order.partner_id.id,
+                        'partner_id': order_sudo.partner_id.id,
-        values.update(get_records_pager(history, Order))
+        values.update(get_records_pager(history, order_sudo))
-        response = super(WebsiteAccount, self).account(**kw)
+    def _prepare_portal_layout_values(self):
-        return response
+        values.update({
-        response = super(website_account, self).account(**kw)
+    def _prepare_portal_layout_values(self):
-        response.qcontext.update({
+        values.update({
-        return response
+        return values
-        response.qcontext.update({
+    def _prepare_portal_layout_values(self):
-        return response
+        return values
-        response = super(WebsiteAccount, self).account(**kw)
+    def _prepare_portal_layout_values(self):
-        response.qcontext.update({
+        values.update({
-        return response
+        return values
-        order = request.website.sale_get_order(force_create=1)
+        order = request.website.sale_get_order()
-            raise UserError(_("Cannot unactivate a language that is currently used by users."))
+        if vals.get('active') == False:
-            if float_compare(self.product_id.virtual_available, product_qty, precision_digits=precision) == -1:
+            if float_compare(product.virtual_available, product_qty, precision_digits=precision) == -1:
-                            (self.product_uom_qty, self.product_uom.name, self.product_id.virtual_available, self.product_id.uom_id.name, self.product_id.qty_available, self.product_id.uom_id.name)
+                        'message' : message
-
+            _message_post_helper(res_model='sale.order', res_id=Order.id, message=body, token=token, token_field="access_token", message_type='notification', subtype="mail.mt_note", partner_ids=Order.user_id.sudo().partner_id.ids)
-                _message_post_helper(res_model='sale.order', res_id=Order.id, message=body, token=token, token_field="access_token", message_type='notification', subtype="mail.mt_note", partner_ids=Order.user_id.partner_id.ids)
+        # Log only once a day
-from odoo import fields, models
+from odoo import fields, models, tools
-        return res
+from odoo import models, tools
-                message_dict['author_id'] = author_id
+                message_dict['author_id'] = author_ids[0]
-        if alias and alias.alias_contact == 'followers' and (thread_id or alias.alias_parent_thread_id):
+        if alias:
-            else:
+            elif alias.alias_parent_thread_id:
-                self._routing_create_bounce_email(email_from, _generic_bounce_body_html, message)
+            elif model and hasattr(record_set, '_alias_check_contact'):
-    _inherits = {'mail.alias': 'alias_id'}
+    _inherit = ['mail.thread', 'mail.alias.mixin']
-        help="The email address associated with this group. New emails received will automatically create new topics.")
+    def get_alias_model_name(self, vals):
-    @api.one
+    @api.multi
-                raise UserError(_("You have already set a registration for this event as 'Attended'. Please reset it to draft if you want to cancel this event."))
+        if any('done' in event.mapped('registration_ids.state') for event in self):
-        return request.render('web.webclient_bootstrap', qcontext=context)
+        try:
-        for menu in action_menus.sudo():
+        for menu in action_menus:
-                    partner_list.append({'id': partner.id, 'email': partner.email})
+                partner_list.append({'id': partner.id, 'email': partner.email})
-    'depends': ['base_geolocalize', 'crm', 'account', 'portal',
+    'depends': ['base_geolocalize', 'crm', 'account',
-        'website', 'portal'
+        'website', 'auth_signup'
-        default=_default_order_mail_template, domain="[('model', '=', 'sale.order')]", 
+        default=_default_order_mail_template, domain="[('model', '=', 'sale.order')]",
-    is_portal = fields.Boolean('Portal', help="If checked, this group is usable as a portal.")
+        'data/website_portal_data.xml',
-        template = self.env.ref('portal.mail_template_data_portal_welcome')
+        template = self.env.ref('website_portal.mail_template_data_portal_welcome')
-from . import test_portal
+import wizard
-import test_load_process
+# -*- coding: utf-8 -*-
-                    lang = babel.code.LOCALE_ALIASES[code]
+                    lang = babel.core.LOCALE_ALIASES[code]
-        'data/ir_sequence_data.xml',
+        'data/ir_sequence_data.xml',
-                self.tax_id = self.repair_id.partner_id.property_account_position_id.map_tax(self.product_id.taxes_id, self.product_id, self.repair_id.partner_id).ids
+            self.onchange_product_id()
-        'res.partner', 'Partner',
+        'res.partner', 'Customer',
-        'stock.production.lot', 'Repaired Lot',
+        'stock.production.lot', 'Lot/Serial',
-        'mrp.repair.line', 'repair_id', 'Operation Lines',
+        'mrp.repair.line', 'repair_id', 'Parts',
-        'mrp.repair.fee', 'repair_id', 'Fees',
+        'mrp.repair.fee', 'repair_id', 'Operations',
-    lot_id = fields.Many2one('stock.production.lot', 'Lot')
+    lot_id = fields.Many2one('stock.production.lot', 'Lot/Serial')
-    @api.depends('operations.price_subtotal', 'fees_lines.price_subtotal', 'pricelist_id.currency_id')
+    @api.depends('operations.price_subtotal', 'invoice_method', 'fees_lines.price_subtotal', 'pricelist_id.currency_id')
-            if operation.to_invoice and operation.tax_id:
+            if operation.tax_id:
-            if fee.to_invoice and fee.tax_id:
+            if fee.tax_id:
-                for fee in repair.fees_lines.filtered(lambda fee: fee.to_invoice):
+                for operation in repair.operations:
-    @api.depends('to_invoice', 'price_unit', 'repair_id', 'product_uom_qty', 'product_id')
+    @api.depends('price_unit', 'repair_id', 'product_uom_qty', 'product_id', 'repair_id.invoice_method')
-            self.price_subtotal = taxes['total_excluded']
+        taxes = self.tax_id.compute_all(self.price_unit, self.repair_id.pricelist_id.currency_id, self.product_uom_qty, self.product_id, self.repair_id.partner_id)
-            self.Location_dest_id = False
+            self.location_dest_id = False
-            self.to_invoice = self.repair_id.guarantee_limit and datetime.strptime(self.repair_id.guarantee_limit, '%Y-%m-%d') < datetime.now()
+            self.price_unit = 0.0
-            if price is False:
+        if self.type != 'remove':
-                    'title': _('No valid pricelist line found !'),
+                    'title': _('No Pricelist!'),
-                        _("Couldn't find a pricelist line matching this product and quantity.\nYou have to change either the product, the quantity or the pricelist.")}
+                        _('You have to select a pricelist in the Repair form !\n Please set one before choosing a product.')}
-            return {'warning': warning}
+                price = pricelist.get_product_price(self.product_id, self.product_uom_qty, partner)
-    @api.depends('to_invoice', 'price_unit', 'repair_id', 'product_uom_qty', 'product_id')
+    @api.depends('price_unit', 'repair_id', 'product_uom_qty', 'product_id')
-            self.price_subtotal = taxes['total_excluded']
+        taxes = self.tax_id.compute_all(self.price_unit, self.repair_id.pricelist_id.currency_id, self.product_uom_qty, self.product_id, self.repair_id.partner_id)
-        if not self.product_id or not self.product_uom_qty:
+        if not self.product_id:
-            'to_invoice': True,
+import logging
-            raise ValidationError(_("Invalid field %s.%s") % (model, field_name))
+            _logger.warning("Invalid field %s.%s", model, field_name)
-        with self.assertRaises(ValidationError):
+        # create valid but unusable defaults, a ValidationError should not be thrown
-        with self.assertRaises(ValidationError):
+
-                    qty += inv_line.uom_id._compute_quantity(inv_line.quantity, line.product_uom)
+                if inv_line.invoice_id.state not in ['cancel']:
-                raise Warning(_('You cannot validate an invoice with a negative total amount. You should create a refund instead.'))
+                raise Warning(_('You cannot validate an invoice with a negative total amount. You should create a credit note instead.'))
-            raise UserError(_("You cannot validate an invoice with a negative total amount. You should create a refund instead."))
+            raise UserError(_("You cannot validate an invoice with a negative total amount. You should create a credit note instead."))
-    default_generate_lead_from_alias = fields.Boolean()
+    # TDE TODO: as it is not linked to ir.values anymore, it should be renamed, but not in stable
-            lang = babel.core.LOCALE_ALIASES.get(lang, lang).replace('-', '_')
+        if "lang" not in httprequest.session.context:
-        for mail in self:
+        for mail_id in self.ids:
-    @api.depends('implemented_partner_ids')
+    @api.depends('implemented_partner_ids', 'implemented_partner_ids.website_published', 'implemented_partner_ids.active')
-        self.implemented_count = len(self.implemented_partner_ids.filtered(lambda x: x.website_published))
+        self.implemented_count = len(self.implemented_partner_ids.filtered('website_published'))
-            cls.pool.model_cache[cls._model_cache_key] = cls
+        cls.pool.model_cache[cls._model_cache_key] = cls
-        partner_id = self.employee_id.address_home_id.id
+        partner_id = self.employee_id.address_home_id.commercial_partner_id.id
-    model = fields.Many2one('ir.model', required=True, index=True)
+    model = fields.Many2one('ir.model', required=True, ondelete="cascade", index=True)
-            account_move[-1]['tax_ids'] = expense.tax_ids.ids
+            account_move[-1]['tax_ids'] = [(6, 0, expense.tax_ids.ids)]
-        partner_id = self.employee_id.address_home_id.commercial_partner_id.id
+        partner_id = self.employee_id.address_home_id.id
-from odoo.exceptions import UserError, RedirectWarning, ValidationError
+from odoo.exceptions import UserError, RedirectWarning, ValidationError, Warning
-            locs = request.website.with_context(use_public_user=True).enumerate_pages()
+            locs = request.website.sudo(user=request.website.user_id.id).enumerate_pages()
-        views = views.filtered(lambda v: user_groups.issuperset(v.groups_id))
+        views = views.filtered(lambda v: not v.groups_id or len(user_groups.intersection(v.groups_id)))
-                         (inv.type in ['in_refund', 'in_invoice']) and 'action_invoice_tree2'
+                xml_id = inv.type == 'out_invoice' and 'action_invoice_out_refund' or \
-        The PosBox software installed on this posbox is <b>version 15</b>,
+        If you need to display the current customer basket on another device, you can do it <a href='/point_of_sale/display'>here</a>.
-    'depends': ['stock_account', 'barcodes'],
+    'depends': ['stock_account', 'barcodes', 'web_editor'],
-        'views/point_of_sale.xml',
+import web_editor
-        account = self.env.ref('l10n_mx.1_cuenta118_01')
+        account = acc_template_ref.get(self.env.ref('l10n_mx.cuenta118_01').id)
-            'default_debit_account_id': account.id,
+            'default_credit_account_id': account,
-    commercial_partner_id = fields.Many2one('res.partner', string='Commercial Entity',
+    commercial_partner_id = fields.Many2one('res.partner', string='Commercial Entity', compute_sudo=True,
-    location pseudo uri (example: hdfs://hadoppserver)
+    location pseudo uri (example: hdfs://hadoopserver)
-            while cat:
+            while cat and cat.id:
-                                    }) for msg in discussion.important_messages])
+                         [(5,)] + [(4, msg.id) for msg in discussion.important_messages])
-        fnames = set(fnames or value.fields_view_get()['fields'])
+        fnames = set(fnames or ())
-from odoo.exceptions import AccessError
+from odoo.exceptions import AccessError, ValidationError
-        self.author_partner = author.partner_id
+        self.author_partner = self.author.partner_id
-                                    }) for msg in discussion.important_messages])
+                         [(5,)] + [(4, msg.id) for msg in discussion.important_messages])
-        fnames = set(fnames or value.fields_view_get()['fields'])
+        fnames = set(fnames or ())
-                if inv_line.invoice_id.state not in ['cancel']:
+                if inv_line.invoice_id.state not in ['cancel'] and inv_line.invoice_id.type == 'in_invoice':
-
+    def _check_duplicate_supplier_reference(self):
-                result_data.append(meeting.get_search_fields(order_fields, r_date=r_date))
+                result_data.append(meeting.get_search_fields(order_fields, r_date=r_start_date))
-        domain_matching = ['&', ('reconciled', '=', False), '|', ('payment_id','=',False), ('statement_id', '<>', False)]
+        domain_matching = [('reconciled', '=', False)]
-                      u'\N{NO-BREAK SPACE}{symbol}'.format(
+            converted, u'<span class="oe_currency_value">\u20110.12</span>'
-            value = self[field.name]
+            value = getattr(self, field.name, False)
-        ], string="Pricelists", default_model='pos.config.settings')
+        ], string="Multiple Prices per Products", default_model='pos.config.settings')
-        return self.pool['res.lang'].format(cr, uid, [lang_code], '%d', value, grouping=True)
+        return self.pool['res.lang'].format(cr, uid, [lang_code], '%d', value, grouping=True).replace(r'-', u'\u2011')
-        formatted = lang.format(cr, uid, [lang_code], fmt.format(precision=precision), value, grouping=True)
+        formatted = lang.format(cr, uid, [lang_code], fmt.format(precision=precision), value, grouping=True).replace(r'-', u'\u2011')
-            grouping=True, monetary=True).replace(r' ', u'\N{NO-BREAK SPACE}')
+            grouping=True, monetary=True).replace(r' ', u'\N{NO-BREAK SPACE}').replace(r'-', u'\u2011')
-        ).replace(r' ', u'\N{NO-BREAK SPACE}')
+        ).replace(r' ', u'\N{NO-BREAK SPACE}').replace(r'-', u'\u2011')
-        self.assertEqual(value, "42.0")
+        value = converter(-42.0)
-        obj = self.create(self.Model, value=0.12)
+        obj = self.create(self.Model, value=-0.12)
-                      '<span class="oe_currency_value">0.12</span>'
+                      u'<span class="oe_currency_value">\u20110.12</span>'
-                    Route.search([('supplied_wh_id', '=', warehouse.id), ('supplier_wh_id', 'in', to_remove.ids)]).unlink()
+                    Route.search([('supplied_wh_id', '=', warehouse.id), ('supplier_wh_id', 'in', to_remove.ids)]).write({'active': False})
-                reception_route.push_ids.unlink()
+                reception_route.pull_ids.write({'active': False})
-                self.env['stock.location.path'].create(push_vals)
+                existing_push = self.env['stock.location.path'].search([
-                self.env['procurement.rule'].create(pull_vals)
+                existing_pull = self.env['procurement.rule'].search([
-                delivery_route.pull_ids.unlink()
+                delivery_route.pull_ids.write({'active': False})
-                self.env['procurement.rule'].create(pull_vals)
+                existing_pull = self.env['procurement.rule'].search([
-                ('location_src_id', '=', self.lot_stock_id.id)]).unlink()
+                ('location_src_id', '=', self.lot_stock_id.id)]).write({'active': False})
-from odoo import api, fields, models
+from odoo import fields, models
-        return self.env['ir.values'].set_default('product.category', 'property_valuation', data)
+    def _get_move_values(self, qty, location_id, location_dest_id):
-                vals['product_uom_qty'] = abs(diff)
+                vals = self._get_move_values(abs(diff), line.product_id.property_stock_inventory.id, line.location_id.id)
-                vals['product_uom_qty'] = diff
+                vals = self._get_move_values(abs(diff), line.location_id.id, line.product_id.property_stock_inventory.id)
-        ('model_id_field_id_uniq', 'unique (model_name, field_name)', _("You cannot have two fields with the same name on the same object!")),
+        ('model_id_field_id_uniq', 'unique (model_name, field_name)', "You cannot have two fields with the same name on the same object!"),
-    _sql_constraints = [('uniq_name', 'unique(name)', _("The name of this POS Session must be unique !"))]
+    _sql_constraints = [('uniq_name', 'unique(name)', "The name of this POS Session must be unique !")]
-        ('barcode_uniq', 'unique(barcode)', _("A barcode can only be assigned to one product !")),
+        ('barcode_uniq', 'unique(barcode)', "A barcode can only be assigned to one product !"),
-        ('rounding_gt_zero', 'CHECK (rounding>0)', _('The rounding precision must be greater than 0!'))
+        ('factor_gt_zero', 'CHECK (factor!=0)', 'The conversion ratio for a unit of measure cannot be 0!'),
-                'name': usb.util.get_string(printer, 256, printer.iManufacturer) + " " + usb.util.get_string(printer, 256, printer.iProduct)
+                'name': description
-            taxes = self.env['account.tax'].compute_all(self.price_unit, self.repair_id.pricelist_id.currency_id, self.product_uom_qty, self.product_id, self.repair_id.partner_id)
+            taxes = self.tax_id.compute_all(self.price_unit, self.repair_id.pricelist_id.currency_id, self.product_uom_qty, self.product_id, self.repair_id.partner_id)
-            taxes = self.env['account.tax'].compute_all(self.price_unit, self.repair_id.pricelist_id.currency_id, self.product_uom_qty, self.product_id, self.repair_id.partner_id)
+            taxes = self.tax_id.compute_all(self.price_unit, self.repair_id.pricelist_id.currency_id, self.product_uom_qty, self.product_id, self.repair_id.partner_id)
-                qty += self.env['product.uom']._compute_qty_obj(move.product_uom, move.product_uom_qty, self.product_uom)
+                if not move.origin_returned_move_id:
-                        ids2 = [right]
+                        if isinstance(right, collections.Iterable):
-                            ids1 = recs.mapped(field.inverse_name).ids
+                            ids1 = recs.mapped(field.inverse_name)
-                    if comodel._fields[field.inverse_name].store:
+                    if comodel._fields[field.inverse_name].store and not (is_integer_m2o and domain):
-                        ids1 = recs.mapped(field.inverse_name).ids
+                        comodel_domain = [(field.inverse_name, '!=', False)]
-    maintenance_duration = fields.Float(help="Maintenance Duration in minutes and seconds.")
+    maintenance_duration = fields.Float(help="Maintenance Duration in hours.")
-
+            except Exception as exc:
-    priority = fields.Selection(crm_stage.AVAILABLE_PRIORITIES, string='Rating', index=True, default=crm_stage.AVAILABLE_PRIORITIES[0][0])
+    priority = fields.Selection(crm_stage.AVAILABLE_PRIORITIES, string='Priority', index=True, default=crm_stage.AVAILABLE_PRIORITIES[0][0])
-                            new_move_lot.write({'quantity':movelots.quantity_done, 'lot_produced_id': self.lot_id.id})
+                            default = {'quantity': movelots.quantity_done, 'lot_produced_id': self.lot_id.id}
-        default_model="account.config.settings", company_dependent=True, oldname="default_sale_tax")
+        company_dependent=True, oldname="default_sale_tax")
-        default_model="account.config.settings", company_dependent=True, oldname="default_purchase_tax")
+        company_dependent=True, oldname="default_purchase_tax")
-    default_external_email_server = fields.Boolean("External Email Servers", default_model='base.config.settings')
+    default_user_rights = fields.Boolean("Default Access Rights")
-    default_custom_report_footer = fields.Boolean("Custom Report Footer", default_model='base.config.settings')
+    default_custom_report_footer = fields.Boolean("Custom Report Footer")
-    default_generate_lead_from_alias = fields.Boolean(default_model='sale.config.settings')
+    default_generate_lead_from_alias = fields.Boolean()
-    default_use_sale_note = fields.Boolean(default_model='sale.config.settings')
+    default_use_sale_note = fields.Boolean()
-        return super(Lang, self).write(vals)
+        return res
-from odoo.exceptions import AccessError, MissingError
+from odoo.exceptions import AccessError, MissingError, ValidationError
-
+    def test_defaults(self):
-        self.assertEqual(d[0][2], 'conditional value', "Can't retrieve the created default value. (6)")
+        ir_values.set_default('res.partner', 'ref', 'X11')
-        ir_values.set_default('unexisting_model', 'my_test_field', 'specific value', for_all_users=False, condition=False)
+        # Retrieve them: ds is a list of triplets (id, name, value)
-        # Retrieve it and check it is the one for the current user.
+        ds = ir_values.get_defaults('res.partner.title')
-        self.assertEqual(d[0][2], 'specific value', "Can't retrieve the created default value.")
+        ds = ir_values.get_defaults('res.partner.title', condition="name=Miss")
-        # Create some action bindings for a non-existing model.
+        ds = ir_values.get_defaults('res.partner.title', condition="name=Mister")
-        ir_values.set_action('Side Wizard', action_slot='client_action_multi', model='unexisting_model', action='ir.actions.act_window,%d' % act_id_3, res_id=False)
+        ir_values = self.env['ir.values']
-        ir_values.set_action('Nice Report', action_slot='client_print_multi', model='unexisting_model', action='ir.actions.report.xml,%d' % report_id, res_id=False)
+        ir_values.set_action('Nice Report', action_slot='client_print_multi', model='res.partner', action='ir.actions.report.xml,%d' % report_id, res_id=False)
-        ir_values.set_action('OnDblClick Action New', action_slot='tree_but_open', model='unexisting_model', action='ir.actions.act_window,%d' % act_id_1, res_id=False)
+        ir_values.set_action('OnDblClick Action New', action_slot='tree_but_open', model='res.partner', action='ir.actions.act_window,%d' % act_id_1, res_id=False)
-        actions = ir_values.get_actions(action_slot='tree_but_open', model='unexisting_model', res_id=False)
+        actions = ir_values.get_actions(action_slot='tree_but_open', model='res.partner', res_id=False)
-        #first action
+        # first action
-        #second action - this ones comes last because it was re-created with a different name
+        # second action - this ones comes last because it was re-created with a different name
-        actions = ir_values.get_actions(action_slot='client_action_multi', model='unexisting_model', res_id=False)
+        actions = ir_values.get_actions(action_slot='client_action_multi', model='res.partner', res_id=False)
-        actions = ir_values.get_actions(action_slot='client_print_multi', model='unexisting_model', res_id=False)
+        actions = ir_values.get_actions(action_slot='client_print_multi', model='res.partner', res_id=False)
-        dest_model = request.env[model.model]
+        dest_model = request.env[model.sudo().model]
-            order.sudo().write(data['record'])
+            order.write(data['record'])
-            order.write(data['record'])
+            order.sudo().write(data['record'])
-            ('location_src_id.usage', '=', 'transit')]).write({'location_id': new_location})
+            ('location_src_id.usage', '=', 'transit')]).write({'location_id': new_location.id})
-    picking_type_entire_packs = fields.Boolean(related='picking_type_id.show_entire_packs')
+        ('internal', 'Internal')], related='picking_type_id.code',
-        help='This area is automatically filled by the user who validate the leave')
+    manager_id = fields.Many2one('hr.employee', related='employee_id.parent_id', string='Manager', readonly=True, store=True)
-    manager_id2 = fields.Many2one('hr.employee', string='Second Approval', readonly=True, copy=False,
+    first_approver_id = fields.Many2one('hr.employee', string='First Approval', readonly=True, copy=False,
-                'manager_id2': False,
+                'first_approver_id': False,
-        manager = self.env['hr.employee'].search([('user_id', '=', self.env.uid)], limit=1)
+        current_employee = self.env['hr.employee'].search([('user_id', '=', self.env.uid)], limit=1)
-                return holiday.write({'state': 'validate1', 'manager_id': manager.id if manager else False})
+                return holiday.write({'state': 'validate1', 'first_approver_id': current_employee.id})
-        manager = self.env['hr.employee'].search([('user_id', '=', self.env.uid)], limit=1)
+        current_employee = self.env['hr.employee'].search([('user_id', '=', self.env.uid)], limit=1)
-                holiday.write({'manager_id2': manager.id})
+                holiday.write({'second_approver_id': current_employee.id})
-                holiday.write({'manager_id': manager.id})
+                holiday.write({'first_approver_id': current_employee.id})
-        manager = self.env['hr.employee'].search([('user_id', '=', self.env.uid)], limit=1)
+        current_employee = self.env['hr.employee'].search([('user_id', '=', self.env.uid)], limit=1)
-                holiday.write({'state': 'refuse', 'manager_id': manager.id})
+                holiday.write({'state': 'refuse', 'first_approver_id': current_employee.id})
-                holiday.write({'state': 'refuse', 'manager_id2': manager.id})
+                holiday.write({'state': 'refuse', 'second_approver_id': current_employee.id})
-    query = """ SELECT con.conname, c2.relname, a2.attnum, con.confdeltype as deltype
+    query = """ SELECT con.conname, c2.relname, a2.attname, con.confdeltype as deltype
-        aml_to_cancel = self.env['account.move']
+        aml_to_cancel = self.env['account.move.line']
-                        payment_to_cancel |= line.payment_id
+            for line in st_line.journal_entry_ids:
-            moves_to_cancel = set([x.move_id for x in aml_to_cancel])
+            moves_to_cancel = aml_to_cancel.mapped('move_id')
-        function = "if (arguments[1] === false || arguments[1] === undefined) {" + company_currency_format + " }" + function
+                function = "if (arguments[1] === false || arguments[1] === undefined) {" + company_currency_format + " }" + function
-            vals['name'] = self.env['ir.sequence'].next_by_code('sale.order') or 'New'
+        if vals.get('name', _('New')) == _('New'):
-        'data/l10n_chart_china_standard_business_chart_data.xml',
+        'data/l10n_cn_standard_chart_data.xml',
-                done += moves.create(template)
+            for val in line._prepare_stock_moves(picking):
-from odoo.tools import email_split
+from odoo.tools import email_split, float_is_zero
-        res = self.mapped('expense_line_ids').action_move_create()
+        res = self.mapped('expense_line_ids')\
-                    request.context = context
+        request.session['form_builder_model_model'] = model_record.model
-        request.session['form_builder_id']    = id_record
+        request.session['form_builder_id'] = id_record
-    website_form_enable_metadata = fields.Boolean('Write metadata',help="Enable writing metadata on form submit.")
+
-            fields_get.pop(val,None)
+            fields_get.pop(val, None)
-                    elif not locations[loc] or locations[loc][-1][2] < start_date:
+                    elif not locations[loc] or locations[loc][-1][2] <= start_date:
-            'location_src_id': new_location,
+            'location_src_id': new_location.id,
-                context = {'ir_sequence_date', statement.date}
+                context = {'ir_sequence_date': statement.date}
-                    st_number = statement.journal_id.sequence_id.with_context(context).next_by_id()
+                    st_number = statement.journal_id.sequence_id.with_context(**context).next_by_id()
-                    st_number = SequenceObj.with_context(context).next_by_code('account.bank.statement')
+                    st_number = SequenceObj.with_context(**context).next_by_code('account.bank.statement')
-    product_uom_qty = fields.Float('Quantity', digits=dp.get_precision('Product Unit of Measure'), required=True)
+    product_uom_qty = fields.Float('Quantity', digits=dp.get_precision('Product Unit of Measure'), required=True, default=1.0)
-            fiscal_position = p.property_account_position_id.id
+            addr = p.address_get(['delivery'])
-from odoo import api, fields, models, _
+from odoo import api, fields, models, tools, _
-            start_dt = end_dt.replace(hour=0, minute=0, second=0)
+            start_dt = end_dt.replace(hour=0, minute=0, second=0, microsecond=0)
-            start_dt = datetime.datetime.now().replace(hour=0, minute=0, second=0)
+            start_dt = datetime.datetime.now().replace(hour=0, minute=0, second=0, microsecond=0)
-            work_limits.append((start_dt.replace(hour=0, minute=0, second=0), start_dt))
+            work_limits.append((start_dt.replace(hour=0, minute=0, second=0, microsecond=0), start_dt))
-            end_dt = start_dt.replace(hour=23, minute=59, second=59)
+            end_dt = start_dt.replace(hour=23, minute=59, second=59, microsecond=999999)
-            work_limits.append((end_dt, end_dt.replace(hour=23, minute=59, second=59)))
+            work_limits.append((end_dt, end_dt.replace(hour=23, minute=59, second=59, microsecond=999999)))
-        work_dt = start_dt.replace(hour=0, minute=0, second=0)
+        work_dt = start_dt.replace(hour=0, minute=0, second=0, microsecond=0)
-                                    start_dt.replace(hour=default_interval[1], minute=0, second=0))
+                working_interval = (start_dt.replace(hour=default_interval[0], minute=0, second=0, microsecond=0),
-            dt_t = work_dt.replace(hour=0, minute=0, second=0) + timedelta(seconds=(calendar_working_day.hour_to * 3600))
+            dt_f = work_dt.replace(hour=0, minute=0, second=0, microsecond=0) + timedelta(seconds=(calendar_working_day.hour_from * 3600))
-                               until=(end_dt + timedelta(days=1)).replace(hour=0, minute=0, second=0),
+                               until=(end_dt + timedelta(days=1)).replace(hour=0, minute=0, second=0, microsecond=0),
-            day_start_dt = day.replace(hour=0, minute=0, second=0)
+            day_start_dt = day.replace(hour=0, minute=0, second=0, microsecond=0)
-            day_end_dt = day.replace(hour=23, minute=59, second=59)
+            day_end_dt = day.replace(hour=23, minute=59, second=59, microsecond=999999)
-        current_datetime = day_date.replace(hour=0, minute=0, second=0)
+        current_datetime = day_date.replace(hour=0, minute=0, second=0, microsecond=0)
-            day_dt=dt_from.replace(minute=0, second=0),
+            day_dt=dt_from.replace(minute=0, second=0, microsecond=0),
-        extra_attrib = {}
+            attrib = el.attrib
-            # `extra_attrib` dict.
+            # `attrib` dict.
-                    extra_attrib['xmlns'] = ns_definition
+                    attrib['xmlns'] = ns_definition
-                    extra_attrib['xmlns:%s' % ns_prefix] = ns_definition
+                    attrib['xmlns:%s' % ns_prefix] = ns_definition
-        tag = u'<%s%s' % (el_tag, u''.join([u' %s="%s"' % (name, escape(unicodifier(value))) for name, value in chain(el.attrib.iteritems(), extra_attrib.iteritems())]))
+        tag = u'<%s%s' % (el_tag, u''.join([u' %s="%s"' % (name, escape(unicodifier(value))) for name, value in attrib.iteritems()]))
-        pairs (name, expression AST). """
+        pairs (name, expression AST).
-from odoo import api, models
+from odoo import api, models, _
-                if main_pricelist.company_id == company or (main_pricelist.company_id.id is False and nb_companies == 1):
+                existing_pricelist = ProductPricelist.search(
-                        'name': company.name,
+                        'name': _("Default %(currency)s pricelist for %(company)s") %  params,
-                    raise UserError(_("No Expense account found for the product %s (or for it's category), please configure one.") % (expense.product_id.name))
+                    raise UserError(_("No Expense account found for the product %s (or for its category), please configure one.") % (expense.product_id.name))
-            intervals = Calendar._schedule_days(self.purchase_calendar_id.id, 1, new_date, compute_leaves=True)
+            intervals = self.purchase_calendar_id._schedule_days(1, new_date, compute_leaves=True)
-# Copyright (C) 2007-2014 Jeff Wang(<http://jeff@osbzr.com>).
+# Copyright (C) 2008-2008 å¯æºåé« lvxin@gmail.com   <basic chart data>
-    'version': '1.8',
+    'name': 'ä¼è®¡ç§ç®è¡¨ - ä¸­å½ä¼ä¸ä¼è®¡åå',
-    'website': 'http://openerp-china.org',
+    'author': ['lvxin@gmail.co', 'oldrev@gmail.co', 'ccdos@intoerp.com', 'jeff@osbzr.com', 'jeffery9@gmail.com'],
-    ç§ç®ç±»å\ä¼è®¡ç§ç®è¡¨æ¨¡æ¿\å¢å¼ç¨\è¾å©æ ¸ç®ç±»å«\ç®¡çä¼è®¡å­è¯ç°¿\è´¢å¡ä¼è®¡å­è¯ç°¿
+* Chart of Accounts
-    æ·»å ä¸­æçä»½æ°æ®
+* Account templates
-    å¢å å°ä¼ä¸ä¼è®¡ç§ç®è¡¨
+* Tax templates
-        'data/l10n_cn_standard_chart_data.xml',
+        'data/l10n_chart_china_standard_business_chart_data.xml',
-            analytic_timesheet_toremove += sheet.timesheet_ids
+            analytic_timesheet_toremove += sheet.timesheet_ids.filtered(lambda t: not t.task_id)
-           by the ``encryption`` parameter.
+        """Returns a new SMTP connection to the given SMTP server.
-                                    smtp_debug=server.smtp_debug)
+                smtp = self.connect(mail_server_id=server.id)
-            if encryption is None and tools.config.get('smtp_ssl'):
+            smtp_encryption = encryption
-        help="Forces all moves for this account to have this secondary currency.")
+        help="Forces all moves for this account to have this account currency.")
-                    raise ValidationError(_('The selected account of your Journal Entry force to provide a secondary currency. You should  either remove the secondary currency on the account or match the currency of your journal with your account currency.'))
+                if not line.currency_id or line.currency_id.id != line.account_id.currency_id.id:
-            new_proc = self.env["procurement.order"].create(vals)
+            new_proc = self.env["procurement.order"].with_context(procurement_autorun_defer=True).create(vals)
-            new_proc = self.env["procurement.order"].create(vals)
+            new_proc = self.env["procurement.order"].with_context(procurement_autorun_defer=True).create(vals)
-    return "<%.15f.%s-openerp-%s@%s>" % (time.time(), rndstr, res_id, socket.gethostname())
+    return "<%s.%.15f-openerp-%s@%s>" % (rndstr, time.time(), res_id, socket.gethostname())
-            if not consteq(token, right_token):
+            if not consteq(str(token), right_token):
-        token = (self.env.cr.dbname, self.id, int(res_id), email)
+        token = (self.env.cr.dbname, self.id, int(res_id), tools.ustr(email))
-                        res = IrMailServer.send_email(msg, mail_server_id=mail.mail_server_id.id)
+                        res = IrMailServer.send_email(
-                related_attachment = [attach for attach in attachments if len(attach) == 2 and attach[2] == cid]
+                related_attachment = [attach for attach in attachments if attach[2] and attach[2].get('cid') == cid]
-                    node.set('data-filename', related_attachment[0])
+                    node.set('data-filename', related_attachment[0][0])
-                    price, rule_id = pricelist_item.base_pricelist_id.with_context(uom=uom.id).price_rule_get(product_id, qty, partner)[pricelist_item.base_pricelist_id.id]
+                    price, rule_id = pricelist_item.base_pricelist_id.with_context(uom=uom.id).price_rule_get(product.id, qty, partner)[pricelist_item.base_pricelist_id.id]
-        if encryption == 'starttls':
+        if smtp_encryption == 'starttls':
-            ids = self.search(filters).ids
+            # TODO: make limit configurable
-        IrMailServer = self.env['ir.mail_server']
+        for server_id, batch_ids in self._split_by_server():
-        for mail in self:
+    @api.multi
-    def connect(self, host, port, user=None, password=None, encryption=False, smtp_debug=False):
+    def connect(self, host=None, port=None, user=None, password=None, encryption=None,
-           :param host: host or IP of SMTP server to connect to
+
-            connection = smtplib.SMTP_SSL(host, port)
+        mail_server = smtp_encryption = None
-            connection = smtplib.SMTP(host, port)
+            # we were passed individual smtp parameters or nothing and there is no default server
-        if user:
+        if smtp_user:
-            connection.login(user, password)
+            smtp_user = ustr(smtp_user).encode('utf-8')
-                   smtp_user=None, smtp_password=None, smtp_encryption=None, smtp_debug=False):
+                   smtp_user=None, smtp_password=None, smtp_encryption=None, smtp_debug=False,
-            smtp = None
+            smtp = smtp_session
-                smtp = self.connect(smtp_server, smtp_port, smtp_user, smtp_password, smtp_encryption or False, smtp_debug)
+                smtp = smtp or self.connect(
-                if smtp is not None:
+                # do not quit() a pre-established smtp_session
-        'font-size', 'font-family', 'background-color', 'color', 'text-align',
+        'font-size', 'font-family', 'font-weight', 'background-color', 'color', 'text-align',
-        'border', 'border-color', 'border-radius', 'height', 'margin', 'padding', 'width', 'max-width', 'min-width',
+        'border', 'border-color', 'border-radius', 'border-style', 'height',
-        """ Get recurrent dates based on Rule string and all event where recurrent_id is child """
+    def _get_recurrent_dates_by_event(self):
-            startdate = datetime.now()
+        event_date = pytz.UTC.localize(fields.Datetime.from_string(reference_date))  # Add "+hh:mm" timezone
-        # Convert the start date to saved timezone (or context tz) as it'll
+        # Convert the event date to saved timezone (or context tz) as it'll
-        rset1 = rrule.rrulestr(str(self.rrule), dtstart=startdate, forceset=True)
+        event_date = event_date.astimezone(timezone)  # transform "+hh:mm" timezone
-            rdates = meeting._get_recurrent_date_by_event()
+            rdates = meeting._get_recurrent_dates_by_event()
-            for r_date in rdates:
+            for r_start_date, r_stop_date in rdates:
-                            ok = r_date.strftime('%Y-%m-%d') == arg[2]
+                            ok = r_date.strftime(dformat) == arg[2]
-                            ok = r_date.strftime('%Y-%m-%d') > arg[2]
+                            ok = r_date.strftime(dformat) > arg[2]
-                            ok = r_date.strftime('%Y-%m-%d') < arg[2]
+                            ok = r_date.strftime(dformat) < arg[2]
-                            ok = r_date.strftime('%Y-%m-%d') >= arg[2]
+                            ok = r_date.strftime(dformat) >= arg[2]
-                            ok = r_date.strftime('%Y-%m-%d') <= arg[2]
+                            ok = r_date.strftime(dformat) <= arg[2]
-        token = (self.env.cr.dbname, self.id, res_id, email)
+        token = (self.env.cr.dbname, self.id, int(res_id), email)
-        if produce_move.product_id.tracking != 'none':
+        if produce_move and produce_move.product_id.tracking != 'none':
-            if field.type == 'selection':
+        fields = self.env['ir.model.fields'].search([('name', 'in', fields or []), ('model_id.model', '=', self._name)])
-            elif field.type == 'many2one':
+            elif field.ttype == 'many2one':
-            elif field.type == 'many2many':
+            elif field.ttype == 'many2many':
-            body.append("%s: %s" % (field.string, value or ''))
+            body.append("%s: %s" % (field.field_description, value or ''))
-                order_to_invoice_count=0, order_carts_abandonned_count=0,
+                order_to_invoice_count=0, order_carts_abandoned_count=0,
-            order_carts_abandonned_count=request.env['sale.order'].search_count(sale_order_domain + [
+            order_carts_abandoned_count=request.env['sale.order'].search_count(sale_order_domain + [
-version_info = (11, 0, 0, ALPHA, 1, '')
+version_info = (10, 'saas~15', 0, FINAL, 0, '')
-        Model = request.env[self.model]
+    def generate(self, uid, query=None, args=None):
-        View = request.env['ir.ui.view']
+    def generate(self, uid, query=None, args={}):
-                    for value_dict in converter.generate(query=query, args=val):
+                    for value_dict in converter.generate(uid=self.env.uid, query=query, args=val):
-from odoo import models, fields, api
+from odoo import models, fields, api, _
-                record.currency_id.name in ['EUR', 'CHF']
+                record.l10n_ch_currency_name in ['EUR', 'CHF']
-            the ISR if the invoice is compatible.
+       This function is needed on the model, as it must be called in the report
-        return invoice_report
+            self.l10n_ch_isr_sent = True
-            next_action = next_action.get('next_report_to_generate', None)
+        self.assertFalse(self.print_isr(invoice), 'No ISR should be generated for this invoice')
-        self.assertTrue(isr_found, 'An ISR should have been generated')
+        self.assertTrue(self.print_isr(invoice), 'An ISR should have been generated')
-                subtype_id=self.env.ref('mail.mt_note').id)
+            if backorder.group_id: # origin from a sale
-            '&', ('res_model', '=', res_model), ('res_id', 'in', res_ids),
+            '&', ('res_model_id', '=', res_model_id), ('res_id', 'in', res_ids),
-                rec.exchange_move_id.reverse_moves()
+                # reverse the exchange rate entry after de-referencing it to avoid looping
-            locs = request.website.sudo(user=request.website.user_id.id).enumerate_pages()
+            locs = request.website.with_context(use_public_user=True).enumerate_pages()
-        return self._prepare_report_view_action('report.layout_'+self.external_report_layout)
+        return self._prepare_report_view_action('report.external_layout_' + self.external_report_layout)
-                ('sale_order_id.state', '!=', 'cancel')
+                # that part perform a search on sale.order in order to comply with access rights as tx do not have any
-            )
+            total_sold=sum(price_line['price_subtotal'] for price_line in report_price_lines)
-            line.qty_delivered_updateable = False
+                super(SaleOrderLine, line)._compute_qty_delivered_updateable()
-        default='total',
+        ('subtotal', 'Tax-Excluded Prices'),
-            return request.redirect("/shop/cart?code_not_available=1")
+        if not pricelist or (pricelist and not request.website.is_pricelist_available(pricelist.id)):
-        return request.redirect("/shop/cart")
+        return request.redirect(redirect)
-            model.field_id._prepare_update()
+                # prevent screwing up fields that depend on these models' fields
-        activity.post_assignation_message()
+        self.env[activity.res_model].browse(activity.res_id).message_subscribe(partner_ids=[activity.user_id.partner_id.id])
-            self.post_assignation_message()
+            for activity in self:
-        model = self.env[action.model_id.model]
+        model_name = action.model_id.sudo().model
-        if self._context.get('active_model') == action.model_id.model and self._context.get('active_id'):
+        if self._context.get('active_model') == model_name and self._context.get('active_id'):
-        if self._context.get('active_model') == action.model_id.model and self._context.get('active_ids'):
+        if self._context.get('active_model') == model_name and self._context.get('active_ids'):
-    _description = 'Partner'
+    _description = 'Contact'
-        self.paypal_validate_data(**post)
+        try:
-from datetime import datetime, timedelta
+from datetime import datetime, timedelta, time
-from odoo import http
+from odoo import fields, http, _
-from odoo.tools import DEFAULT_SERVER_DATE_FORMAT
+
-        date_to = datetime.strptime(date_to, DEFAULT_SERVER_DATE_FORMAT)
+        date_date_from = fields.Date.from_string(date_from)
-        product_lines = request.env['sale.order.line'].read_group(
+        # Product-based computation
-            fields=['product_id', 'product_uom_qty', 'price_total'],
+                ('team_id.team_type', '=', 'website'),
-        for product_line in product_lines:
+        for product_line in report_product_lines:
-            best_sellers.append({
+            sales_values['best_sellers'].append({
-                'sales': product_line['price_total'],
+                'sales': product_line['price_subtotal'],
-            ('state', 'in', ['sent', 'sale', 'done']),
+            ('team_id.team_type', '=', 'website'),
-        }
+        sales_values['graph'] += [{
-            groupby='date_order:day')
+        daily_sales = request.env['sale.report'].read_group(
-        daily_sales_dict = {p['date_order:day']: p['amount_total'] for p in daily_sales}
+        daily_sales_dict = {p['date:day']: p['price_subtotal'] for p in daily_sales}
-            '0': d.strftime(DEFAULT_SERVER_DATE_FORMAT) if not previous else (d + timedelta(days=days_between)).strftime(DEFAULT_SERVER_DATE_FORMAT),
+            '0': fields.Date.to_string(d) if not previous else fields.Date.to_string(d + timedelta(days=days_between)),
-        'views/backend.xml',
+        'views/product_views.xml',
-        'views/sale_order.xml',
+        'views/payment_views.xml',
-import operator
+
-from odoo.tools import DEFAULT_SERVER_DATETIME_FORMAT, DEFAULT_SERVER_DATE_FORMAT
+from odoo.http import request
-            'groups': {'system': request.env['res.users'].has_group('base.group_system')},
+        has_group_system = request.env['res.users'].has_group('base.group_system')
-                }
+                'apps_data': apps_data,
-
+        'data/web_planner_data.xml',
-    'sequence': 135,
+    'sequence': 166,
- - Minimal chart of account tested in production eviroments.
+ - Minimal chart of account tested in production environments.
-# Author: Nicolas Bessi. Copyright Camptocamp SA
+# Main contributor: Nicolas Bessi. Camptocamp SA
- 'description':  """
+    'description': """
- }
+This module defines a chart of account for Switzerland (Swiss PME/KMU 2015), taxes and enables the generation of ISR when you print an invoice or send it by mail.
-        readonly=True, states={'draft': [('readonly', False)]})
+        readonly=True, states={'draft': [('readonly', False)]}) #Default value computed in default_get for out_invoices
-from odoo.tools import float_compare, float_is_zero, float_repr, float_round
+from odoo.tools import float_compare, float_is_zero, float_repr, float_round, float_split_str
-    def new_page(self, name, template='website.default_page', ispage=True):
+    def new_page(self, name, template='website.default_page', ispage=True, namespace=None):
-        template_module, dummy = template.split('.')
+        if namespace:
-    datetime = fields.Datetime('Date', default=fields.Datetime.now())
+    datetime = fields.Datetime('Date', default=fields.Datetime.now)
-            return request.redirect('/page/' + page[8:], code=301)
+            return request.redirect('/page/%s?%s' % (page[8:], request.httprequest.query_string), code=301)
-                company.write(company._get_company_address_fields(partner))
+                company.update(company._get_company_address_fields(partner))
-        'data/email_template_data.xml',
+        'data/event_data.xml',
-    def _default_event_mail_ids(self):
+    def _get_default_event_type_mail_ids(self):
-    event_mail_ids = fields.One2many('event.mail', 'event_id', string='Mail Schedule', default=_default_event_mail_ids, copy=True)
+    event_mail_ids = fields.One2many('event.mail', 'event_id', string='Mail Schedule', copy=True)
-    auto_confirm = fields.Boolean(string='Autoconfirm Registrations', compute='_compute_auto_confirm')
+    auto_confirm = fields.Boolean(string='Autoconfirm Registrations')
-            self.reply_to = self.event_type_id.default_reply_to
+
-    default_auto_confirmation = fields.Boolean("Auto Confirmation", default_model='event.config.settings')
+class EventTypeMail(models.Model):
-        'mail.template', string='Email to Send',
+        'mail.template', string='Email Template',
-
+            'auto_confirm': True,
-        self.env['ir.values'].set_default('event.config.settings', 'default_auto_confirmation', True)
+            'auto_confirm': True,
-from odoo.exceptions import ValidationError
+from odoo.exceptions import ValidationError, UserError
-    _inherit = 'event.event'
+class EventType(models.Model):
-    def _default_tickets(self):
+    @api.model
-        return [{
+            return False
-        }]
+        })]
-        default=lambda self: self._default_tickets(), copy=True)
+class Event(models.Model):
-    event_id = fields.Many2one('event.event', string="Event", required=True, ondelete='cascade')
+    event_type_id = fields.Many2one('event.type', string='Event Category', ondelete='cascade')
-    twitter_hashtag = fields.Char('Twitter Hashtag', default=_default_hashtag)
+    @api.onchange('event_type_id')
-from odoo import fields, models
+from odoo import api, fields, models, _
-    event_id = fields.Many2one('event.event', required=True, ondelete='cascade')
+    event_type_id = fields.Many2one('event.type', 'Event Type', ondelete='cascade')
-        self.order_line._update_registrations(confirm=True)
+        self.order_line._update_registrations(confirm=False, cancel_to_draft=False)
-    def _update_registrations(self, confirm=True, registration_data=None):
+    def _update_registrations(self, confirm=True, cancel_to_draft=False, registration_data=None):
-            else:
+            if cancel_to_draft:
-                order.order_line._update_registrations(confirm=True)
+                order.order_line._update_registrations(confirm=False)
-    'summary': 'Schedule, Promote and Sell Events',
+    'summary': 'Publish Events and Manage Online Registrations on your Website',
-    'summary': "Sell Your Event's Tickets",
+    'summary': "Manage Events and Sell Tickets Online",
-            line._update_registrations(confirm=False, registration_data=kwargs.get('registration_data', []))
+            line._update_registrations(confirm=False, cancel_to_draft=True, registration_data=kwargs.get('registration_data', []))
-                                    " of the event on the website.", store=True)
+    website_menu = fields.Boolean(
-        """ Retuns a list of tuple ('Page name', 'relative page url') for the event """
+    def _get_menu_entries(self):
-            (_('Location'), 'website_event.template_location')
+        return [
-    def _set_show_menu(self):
+    def _set_website_menu(self):
-            if event.menu_id and not event.show_menu:
+            if event.menu_id and not event.website_menu:
-                event.menu_id = root_menu
+            elif event.website_menu:
-    def _get_show_menu(self):
+    def _compute_website_menu(self):
-            event.show_menu = bool(event.menu_id)
+            event.website_menu = bool(event.menu_id)
-    @http.route(['''/event/<model("event.event", "[('show_tracks','=',1)]"):event>/agenda'''], type='http', auth="public", website=True)
+    @http.route(['''/event/<model("event.event", "[('website_track','=',1)]"):event>/agenda'''], type='http', auth="public", website=True)
-        '''/event/<model("event.event", "[('show_tracks','=',1)]"):event>/track/tag/<model("event.track.tag"):tag>'''
+        '''/event/<model("event.event", "[('website_track','=',1)]"):event>/track''',
-    @http.route(['''/event/<model("event.event", "[('show_track_proposal','=',1)]"):event>/track_proposal'''], type='http', auth="public", website=True)
+    @http.route(['''/event/<model("event.event", "[('website_track_proposal','=',1)]"):event>/track_proposal'''], type='http', auth="public", website=True)
-    count_tracks = fields.Integer('Tracks', compute='_count_tracks')
+    sponsor_count = fields.Integer('Sponsors', compute='_compute_sponsor_count')
-    count_sponsor = fields.Integer('# Sponsors', compute='_count_sponsor')
+    tracks_tag_ids = fields.Many2many(
-        return result
+    def _compute_track_count(self):
-    def _set_show_menu(self):
+    def _compute_sponsor_count(self):
-        return super(Event, self)._set_show_menu()
+            event.sponsor_count = result.get(event.id, 0)
-        result = dict((data['event_id'][0], data['event_id_count']) for data in track_data)
+    def _compute_website_track(self):
-            event.count_tracks = result.get(event.id, 0)
+            existing_pages = event.menu_id.child_id.mapped('name')
-    def _get_tracks_tag_ids(self):
+    def _compute_website_track_proposal(self):
-            event.tracks_tag_ids = event.track_ids.mapped('tag_ids').ids
+            existing_pages = event.menu_id.child_id.mapped('name')
-    def _count_sponsor(self):
+    @api.depends('track_ids.tag_ids')
-            event.count_sponsor = len(event.sponsor_ids)
+            event.tracks_tag_ids = event.track_ids.mapped('tag_ids').ids
-    _inherit = ['mail.thread', 'website.seo.metadata', 'website.published.mixin']
+    _inherit = ['mail.thread', 'mail.activity.mixin', 'website.seo.metadata', 'website.published.mixin']
-    speaker_ids = fields.Many2many('res.partner', string='Speakers')
+    partner_id = fields.Many2one('res.partner', 'Speaker')
-        'Status', default='draft', required=True, copy=False, track_visibility='onchange')
+    stage_id = fields.Many2one(
-    image = fields.Binary('Image', related='speaker_ids.image_medium', store=True, attachment=True)
+    image = fields.Binary('Image', related='partner_id.image_medium', store=True, attachment=True)
-        res.message_post_with_view(
+        track = super(Track, self).create(vals)
-        return res
+            values={'track': track},
-            vals.update({'website_published': True})
+        if 'stage_id' in vals and 'kanban_state' not in vals:
-            self.message_subscribe([speaker['id'] for speaker in self.resolve_2many_commands('speaker_ids', vals['speaker_ids'], ['id'])])
+        if vals.get('partner_id'):
-            return super(Track, self).read_group(domain, fields, groupby, offset=offset, limit=limit, orderby=orderby)
+    def _read_group_stage_ids(self, stages, domain, order):
-    def open_track_speakers_list(self):
+    def _track_template(self, tracking):
-            'domain': [('id', 'in', [partner.id for partner in self.speaker_ids])],
+            'domain': [('id', 'in', self.mapped('partner_id').ids)],
-    _description = 'Event Type'
+    _description = 'Event Category'
-    name = fields.Char('Event Type', required=True, translate=True)
+    name = fields.Char('Event Category', required=True, translate=True)
-    active = fields.Boolean(default=True, track_visibility="onchange")
+    active = fields.Boolean(default=True)
-    auto_confirm = fields.Boolean(string='Confirmation not required', compute='_compute_auto_confirm')
+    auto_confirm = fields.Boolean(string='Autoconfirm Registrations', compute='_compute_auto_confirm')
-        readonly=False, states={'done': [('readonly', True)]})
+        'res.partner', string='Location',
-    @api.one
+    @api.constrains('seats_min', 'seats_max', 'seats_availability')
-        if self.seats_availability == 'limited' and self.seats_max and self.seats_available < 0:
+        if any(event.seats_availability == 'limited' and event.seats_max and event.seats_available < 0 for event in self):
-        if self.event_id.date_begin <= today:
+        if self.event_id.date_begin <= today and self.event_id.state == 'confirm':
-            raise UserError(_("You must wait for the starting day of the event to do this action."))
+            raise UserError(_("You must wait the event starting day before doing this action."))
-        """)
+    _mail_mass_mailing = _('Event Attendees')
-        string='When to Run ', default="before_event", required=True)
+        string='Trigger ', default="before_event", required=True)
-        })]
+    event_mail_ids = fields.One2many('event.mail', 'event_id', string='Mail Schedule', default=_default_event_mail_ids, copy=True)
-        return result
+    @api.onchange('event_type_id')
-        'data/website_event_data.xml',
+        'data/event_data.xml',
-        'views/website_event_views.xml',
+        'views/event_templates.xml',
-        'security/website_event_security.xml',
+        'security/event_security.xml',
-        'data/website_event_demo.xml'
+        'data/event_demo.xml'
-        'views/website_event_questions_templates.xml',
+        'views/event_views.xml',
-        'data/demo.xml',
+        'data/event_demo.xml',
-        'views/website_event_sale_templates.xml',
+        'views/event_templates.xml',
-        'views/website_event_track_views.xml',
+        'security/event_track_security.xml',
-import website_event_track
+import event_track
-
+    @api.multi
-
+            elif 'partner_email' in self._fields and record.partner_email:
-        activity.post_assignation_message()
+        self.env[activity.res_model].browse(activity.res_id).message_subscribe(partner_ids=[activity.user_id.partner_id.id])
-            self.post_assignation_message()
+            for activity in self:
-                        values['product_uos_qty'] = result['product_uos_qty']
+                    for field in ['product_uos_qty', 'th_weight']:
-    account_move_id = fields.Many2one('account.move', string='Journal Entry', copy=False)
+    account_move_id = fields.Many2one('account.move', string='Journal Entry', ondelete='restrict', copy=False)
-            raise UserError(_("The timesheet cannot be validated as it contains an attendance record with no Check Out)."))
+            raise UserError(_("The timesheet cannot be validated as it contains an attendance record with no Check Out."))
-        default='subtotal',
+        default='total',
-        return Report.sudo().render('account.report_invoice', {'docs': self.env['account.invoice'].browse(ids_to_print)})
+        return Report.sudo().render('account.report_invoice', {'docs': self.env['account.invoice'].sudo().browse(ids_to_print)})
-                new_list_price, currency_id = line.with_context(context_partner)._get_real_price_currency(line.product_id.id, list_price_dict, line.product_uom_qty, line.product_uom.id, line.order_id.pricelist_id.id)
+                new_list_price, currency_id = line.with_context(dict(context_partner, date=line.order_id.date_order))._get_real_price_currency(line.product_id.id, list_price_dict, line.product_uom_qty, line.product_uom.id, line.order_id.pricelist_id.id)
-            new_list_price, currency_id = self.with_context(context_partner)._get_real_price_currency(self.product_id.id, list_price_dict, self.product_uom_qty, self.product_uom.id, self.order_id.pricelist_id.id)
+            new_list_price, currency_id = self.with_context(dict(context_partner, date=self.order_id.date_order))._get_real_price_currency(self.product_id.id, list_price_dict, self.product_uom_qty, self.product_uom.id, self.order_id.pricelist_id.id)
-        self.total_qty = sum(self.mapped('line_ids').mapped('product_qty'))
+        """ For single product inventory, total quantity of the counted """
-        return (default_user or self.env['res.users']).groups_id
+        return (default_user or self.env['res.users']).sudo().groups_id
-                res[val.id]['invoice_state'] = invoice_state
+            res[val.id]['date_from'] = date_from
-                res[val.id]['expected_margin_rate'] = res[val.id]['sale_expected'] and res[val.id]['expected_margin'] * 100 / res[val.id]['sale_expected'] or 0.0
+            res[val.id]['total_margin'] = res[val.id]['turnover'] - res[val.id]['total_cost']
-        website = getattr(request, 'website', None)
+        website = getattr(request, 'website', None) if request else None
-            self.env['ir.qweb']._get_asset.clear_cache(self.env['ir.qweb'])
+        self.env['ir.qweb'].clear_caches()
-                    if not acquired:
+                    try:
-                _logger.warning('Skipping database %s as its base version is not %s.', db_name, BASE_VERSION)
+            with db.cursor() as cr:
-    def _check_recursion(self):
+    def _check_recursion_associate_member(self):
-    name = fields.Char(required=True, string="Label")
+    name = fields.Char(string="Label")
-            writeoff_line['name'] = _('Counterpart')
+            writeoff_line['name'] = self.writeoff_label
-                amount_unit = std_price_update.get(move.product_id.id) or move.product_id.standard_price
+                amount_unit = std_price_update.get((move.company_id.id, move.product_id.id)) or move.product_id.standard_price
-            std_price_update[move.product_id.id] = new_std_price
+            move.product_id.with_context(force_company=move.company_id.id).sudo().write({'standard_price': new_std_price})
-        return self.sudo().search([('model', '=', name)])
+        model_id = self._get_id(name) if name else False
-        return self.sudo().search([('model', '=', model_name), ('name', '=', name)])
+        field_id = self._get_id(model_name, name) if model_name and name else False
-            order = self.env['sale.order'].search([('project_id', '=', self.account_id.id), ('state', '=', 'sale')], limit=1)
+            order_in_sale = self.env['sale.order'].search([('project_id', '=', self.account_id.id), ('state', '=', 'sale')], limit=1)
-        if not unaffected_earnings_line and unaffected_earnings_results and unaffected_earnings_results[11] != '0,00' and unaffected_earnings_results[12] != '0,00':
+        if (not unaffected_earnings_line
-                        listrow[12] = '0.00'
+                        listrow[11] = str(listrow_amount).replace('.', ',')
-                        listrow[12] = str(listrow_amount)
+                        listrow[11] = '0,00'
-#-*- coding:utf-8 -*-
+# -*- coding:utf-8 -*-
-        #fill only if the contract as a working schedule linked
+        # fill only if the contract as a working schedule linked
-                 'contract_id': contract.id,
+                'name': _("Normal Working Days paid at 100%"),
-            res += [attendances] + leaves
+
-    working_hours = fields.Many2one('resource.calendar', string='Working Schedule')
+    resource_calendar_id = fields.Many2one(
-        for contract in self.env['hr.contract'].browse(contract_ids).filtered(lambda contract: contract.working_hours):
+        for contract in self.env['hr.contract'].browse(contract_ids).filtered(lambda contract: contract.resource_calendar_id):
-                working_hours_on_day = contract.working_hours.get_work_hours_count(day_from + timedelta(days=day), False, contract.employee_id.resource_id.id)
+                working_hours_on_day = contract.resource_calendar_id.get_work_hours_count(day_from + timedelta(days=day), False, contract.employee_id.resource_id.id)
-    'depends': ['hr', 'calendar', 'resource', 'product', 'report'],
+    'depends': ['hr', 'calendar', 'resource', 'report'],
-        states={'draft': [('readonly', False)], 'confirm': [('readonly', False)]})
+    number_of_days_temp = fields.Float(
-                    return uom_hour._compute_quantity(hours, uom_day)
+            return employee.get_work_days_count(from_dt, to_dt)
-                - 45 Hours/Week, 5 Days/Week: 1 Day = 9.0 Hours""")
+from odoo import fields, models
-    _inherits = {'resource.resource': 'resource_id'}
+    _inherit = ['resource.mixin']
-                    r = blocktime.workcenter_id.calendar_id.get_work_hours_count(d1, d2, blocktime.workcenter_id.resource_id.id)
+                if (blocktime.loss_type not in ('productive', 'performance')) and blocktime.workcenter_id.resource_calendar_id:
-    _inherit = ['mail.thread']
+    _order = 'name'
-    name_related = fields.Char(related='resource_id.name', string="Resource Name", readonly=True, store=True)
+    # resource
-                    'empl_name': self.employee_id.name_related,
+                    'empl_name': self.employee_id.name,
-                    'empl_name': self.employee_id.name_related,
+                    'empl_name': self.employee_id.name,
-                    'empl_name': attendance.employee_id.name_related,
+                    'empl_name': attendance.employee_id.name,
-                        'empl_name': attendance.employee_id.name_related,
+                        'empl_name': attendance.employee_id.name,
-                        'empl_name': attendance.employee_id.name_related,
+                        'empl_name': attendance.employee_id.name,
-                'calendar_id': leave.employee_id.resource_id.calendar_id.id
+                'calendar_id': leave.employee_id.resource_calendar_id.id
-from odoo import api, fields, models
+from odoo import fields, models
-            intervals = Calendar._schedule_days(self.purchase_calendar_id.id, 1, new_date, compute_leaves=True)
+            intervals = self.purchase_calendar_id._schedule_days(1, new_date, compute_leaves=True)
-                    group = Attendance.browse(interval[2]).group_id.id
+                    group = interval[2] and interval[2]['attendances'].group_id.id
-                group_to_find = res[0][2] and Attendance.browse(res[0][2]).group_id.id
+                group_to_find = res[0][2] and res[0][2]['attendances'].group_id.id
-                            group = re[2] and Attendance.browse(re[2]).group_id.id
+                            group = re[2] and re[2]['attendances'].group_id.id
-        att_group = res and res[0][2] and Attendance.browse(res[0][2]).group_id.id
+        att_group = False
-                    att_group = Attendance.browse(re[2]).group_id.id
+                    att_group = re[2]['attendances'].group_id.id
-                    att_group = Attendance.browse(re[2]).group_id.id
+                    att_group = re[2]['attendances'].group_id.id
-                working_hours_on_day = contract.working_hours.get_work_hours_count(day_from + timedelta(days=day), False)
+                working_hours_on_day = contract.working_hours.get_work_hours_count(day_from + timedelta(days=day), False, contract.employee_id.resource_id.id)
-                    r = blocktime.workcenter_id.calendar_id.get_work_hours_count(d1, d2, resource_id=blocktime.workcenter_id.resource_id.id)
+                    r = blocktime.workcenter_id.calendar_id.get_work_hours_count(d1, d2, blocktime.workcenter_id.resource_id.id)
-                        compute_leaves=True, resource_id=False)
+                        dt_create_date, dt_date_open, False, compute_leaves=True)
-                        compute_leaves=True, resource_id=False)
+                        dt_create_date, dt_date_closed, False, compute_leaves=True)
-import itertools
+import math
-    return (td.microseconds + (td.seconds + td.days * 24 * 3600) * 10**6) / 10.**6
+def float_to_time(float_hour):
-    def _interval_schedule_hours(self, intervals, hour, remove_at_end=True):
+    def _interval_schedule_hours(self, intervals, hour, backwards=False):
-        submitted accordingly.
+        to match the specified hours. This method can be applied backwards meaning
-        :param list intervals:  a list of tuples (beginning datetime, ending datetime)
+        :param list intervals:  a list of time intervals
-        is done, and results == intervals. """
+                                int or float
-                interval = (interval[0], interval[1] + relativedelta(seconds=seconds(limit - res)))
+            if res > limit and not backwards:
-                interval = (interval[0] + relativedelta(seconds=seconds(res - limit)), interval[1])
+                interval = (interval[0] + relativedelta(seconds=(res - limit).total_seconds()), interval[1])
-        """ Given a day datetime, return matching attendances """
+    def _get_day_attendances(self, day_date, start_time, end_time):
-        weekday = day_dt.weekday()
+        weekday = day_date.weekday()
-                not (att.date_to and fields.Date.from_string(att.date_to) < day_dt.date())):
+                not (att.date_from and fields.Date.from_string(att.date_from) > day_date) and
-        return list(weekdays)
+        return list(set(map(int, (self.attendance_ids.mapped('dayofweek')))))
-        :return date: next day of calendar, or just next day """
+        """ Get following date of day_date, based on resource.calendar. """
-        days = (weekdays[new_index] - day_date.weekday())
+        weekday = next((item for item in weekdays if item > day_date.weekday()), weekdays[0])
-        :return date: previous day of calendar, or just previous day """
+        """ Get previous date of day_date, based on resource.calendar. """
-        days = (weekdays[new_index] - day_date.weekday())
+        weekday = next((item for item in weekdays if item < day_date.weekday()), weekdays[0])
-                             start_datetime=None, end_datetime=None):
+    def _get_leave_intervals(self, resource_id=None, start_datetime=None, end_datetime=None):
-        the start datetime or the end datetime.
+        and on a start and end datetime.
-        """
+        Leaves are encoded from a given timezone given by their tz field. COnverting
-        return leaves
+        if resource_id:
-        :param boolean compute_leaves: if set and if leaves is None, compute the
+    def _get_day_work_intervals(self, day_date, start_time=None, end_time=None, compute_leaves=False, resource_id=None):
-                                specific leaves are computed.
+                                computing the work intervals. Leaves notably are
-                                of work intervals """
+        :return list intervals: list of time intervals in UTC """
-        work_dt = start_dt.replace(hour=0, minute=0, second=0)
+        if not start_time:
-            dt_t = work_dt.replace(hour=0, minute=0, second=0) + timedelta(seconds=(calendar_working_day.hour_to * 3600))
+        working_intervals = [att_interval for att_interval in self._iter_day_attendance_intervals(day_date, start_time, end_time)]
-            working_intervals += self._interval_remove_leaves(working_interval, work_limits)
+        # filter according to leaves
-            leaves = self._get_leave_intervals(resource_id=resource_id)
+        :return list intervals: list of time intervals in UTC """
-            return working_intervals
+        if not start_time:
-    def get_work_hours_count(self, start_dt, end_dt, compute_leaves=False, resource_id=None):
+    def _iter_work_intervals(self, start_dt, end_dt, resource_id, compute_leaves=True):
-        res = timedelta()
+            end_dt = datetime.datetime.combine(start_dt.date(), datetime.time.max)
-                day_end_dt = end_dt
+            start_time = day.date() == start_dt.date() and start_dt.time() or datetime.time.min
-                compute_leaves=compute_leaves, resource_id=resource_id)
+                day.date(),
-        return seconds(res) / 3600.0
+        return res.total_seconds() / 3600.0
-                        compute_leaves=False, resource_id=None):
+    def _schedule_hours(self, hours, day_dt, compute_leaves=False, resource_id=None):
-        scheduling days before a deadline.
+        scheduling days before a deadline. For compute_leaves, resource_id:
-        """
+        :return list intervals: list of time intervals in naive UTC """
-        iterations = 0
+        remaining_hours, iterations = abs(hours * 1.0), 0
-                call_args['end_dt'] = current_datetime
+                call_args['end_time'] = current_datetime.time()
-                call_args['start_dt'] = current_datetime
+                call_args['start_time'] = current_datetime.time()
-            working_intervals = self._get_day_work_intervals(**call_args)
+            working_intervals = self._get_day_work_intervals(current_datetime.date(), **call_args)
-                    new_working_intervals.reverse()
+                new_working_intervals = self._interval_schedule_hours(working_intervals, remaining_hours, backwards=backwards)
-                    intervals = intervals + new_working_intervals
+                remaining_hours -= res.total_seconds() / 3600.0
-    def plan_hours(self, hours, day_dt=None, compute_leaves=False, resource_id=None):
+    def plan_hours(self, hours, day_dt, compute_leaves=False, resource_id=None):
-                       resource_id=None):
+    def _schedule_days(self, days, day_dt, compute_leaves=False, resource_id=None):
-        scheduling days before a deadline.
+        scheduling days before a deadline. For compute_leaves, resource_id:
-                                             working intervals of the scheduling.
+        :param date day_dt: reference datetime to compute working days. If days is > 0
-            day_date = datetime.datetime.now()
+        :return list intervals: list of time intervals in naive UTC """
-        current_datetime = day_date.replace(hour=0, minute=0, second=0)
+        planned_days, iterations = 0, 0
-        while planned_days < days and iterations < 100:
+        while planned_days < abs(days) and iterations < 100:
-                current_datetime,
+                current_datetime.date(),
-    def plan_days(self, days, day_date=None, compute_leaves=False, resource_id=None):
+    def plan_days(self, days, day_dt, compute_leaves=False, resource_id=None):
-        res = self._schedule_days(days, day_date, compute_leaves, resource_id)
+        res = self._schedule_days(days, day_dt, compute_leaves, resource_id)
-
+    tz = fields.Selection(
-from datetime import datetime, timedelta, date
+from datetime import datetime, timedelta, date, time
-from odoo.addons.resource.models.resource import seconds
+from odoo.addons.resource.models.resource import to_naive_utc, to_naive_user_tz
-        result = self.env['resource.calendar']._interval_schedule_hours(cleaned_intervals, 5.5, remove_at_end=False)
+        result = self.env['resource.calendar']._interval_schedule_hours(cleaned_intervals, 5.5, backwards=True)
-        self.assertEqual(result[0][:2], (Datetime.from_string('2013-02-04 17:00:00'), Datetime.from_string('2013-02-04 21:00:00')))
+        self.assertEqual(result[1][:2], (Datetime.from_string('2013-02-04 17:00:00'), Datetime.from_string('2013-02-04 21:00:00')))
-        self.assertEqual(result[1][:2], (Datetime.from_string('2013-02-04 12:30:00'), Datetime.from_string('2013-02-04 14:00:00')))
+        self.assertEqual(result[0][:2], (Datetime.from_string('2013-02-04 12:30:00'), Datetime.from_string('2013-02-04 14:00:00')))
-        intervals = self.calendar._get_day_work_intervals(start_dt=Datetime.from_string('2013-02-12 09:08:07'))
+        intervals = self.calendar._get_day_work_intervals(Date.from_string('2013-02-12'), start_time=time(9, 8, 7))
-        intervals = self.calendar._get_day_work_intervals(start_dt=Datetime.from_string('2013-02-19 10:30:00'))
+        intervals = self.calendar._get_day_work_intervals(Date.from_string('2013-02-19'), start_time=time(10, 30, 0))
-        intervals = self.calendar._get_day_work_intervals(start_dt=Datetime.from_string('2013-02-15 10:11:12'))
+        intervals = self.calendar._get_day_work_intervals(Date.from_string('2013-02-15'), start_time=time(10, 11, 12))
-        intervals = self.calendar._get_day_work_intervals(start_dt=Datetime.from_string('2013-02-12 07:00:00'), compute_leaves=True)
+        intervals = self.calendar._get_day_work_intervals(Date.from_string('2013-02-12'), start_time=time(7, 0, 0), compute_leaves=True)
-                                                               compute_leaves=True)
+        intervals = self.calendar._get_day_work_intervals(Date.from_string('2013-02-19'),
-            Datetime.from_string('2013-02-26 07:00:00'),
+            Date.from_string('2013-02-26'),
-        intervals = self.calendar._get_day_work_intervals(start_dt=self.date2)
+        intervals = self.calendar._get_day_work_intervals(self.date2.date(), start_time=self.date2.time())
-        intervals = self.calendar._get_day_work_intervals(start_dt=self.date2)
+        intervals = self.calendar._get_day_work_intervals(self.date2.date(), start_time=self.date2.time())
-        intervals = self.calendar._get_day_work_intervals(start_dt=self.date2)
+        intervals = self.calendar._get_day_work_intervals(self.date2.date(), start_time=self.date2.time())
-        intervals = self.calendar._get_day_work_intervals(start_dt=self.date2)
+        intervals = self.calendar._get_day_work_intervals(self.date2.date(), start_time=self.date2.time())
-        wh = self.calendar.get_work_hours_count(Datetime.from_string('2013-02-19 10:30:00'), Datetime.from_string('2013-02-19 18:00:00'))
+        wh = self.calendar.get_work_hours_count(Datetime.from_string('2013-02-19 10:30:00'), Datetime.from_string('2013-02-19 18:00:00'), self.resource1_id, compute_leaves=False)
-            compute_leaves=False, resource_id=self.resource1_id)
+            self.resource1_id,
-            compute_leaves=True, resource_id=self.resource1_id)
+            self.resource1_id,
-        self.assertEqual(seconds(td) / 3600.0, 40.0)
+        self.assertEqual(td.total_seconds() / 3600.0, 40.0)
-        self.assertEqual(seconds(td) / 3600.0, 40.0)
+        self.assertEqual(td.total_seconds() / 3600.0, 40.0)
-        self.assertEqual(seconds(td) / 3600.0, 40.0)
+        self.assertEqual(td.total_seconds() / 3600.0, 40.0)
-        res = self.calendar.plan_days(5, day_date=Datetime.from_string('2013-02-12 09:08:07') )
+        res = self.calendar.plan_days(5, Datetime.from_string('2013-02-12 09:08:07') )
-        res = self.calendar.plan_days(-2, day_date=Datetime.from_string('2013-02-12 09:08:07') )
+        res = self.calendar.plan_days(-2, Datetime.from_string('2013-02-12 09:08:07') )
-            5, day_date=Datetime.from_string('2013-02-12 09:08:07'),
+            5, Datetime.from_string('2013-02-12 09:08:07'),
-            list(r._iter_work_days(WAR_START, WAR_END))
+            list(r.calendar_id._iter_work_days(WAR_START, WAR_END, r.id))
-        self.assertEqual(days, list(r2._iter_work_days(WAR_START, WAR_END)))
+        self.assertEqual(days, list(r1.calendar_id._iter_work_days(WAR_START, WAR_END, r1.id)))
-        self.assertEqual(weekdays, list(r1._iter_work_days(WAR_START, WAR_END)))
+        self.assertEqual(weekdays, list(r1.calendar_id._iter_work_days(WAR_START, WAR_END, r1.id)))
-            list(r2._iter_work_days(WAR_START, WAR_END))
+            list(r2.calendar_id._iter_work_days(WAR_START, WAR_END, r2.id))
-            list(r._iter_work_days(WAR_START, WAR_END))
+            list(r.calendar_id._iter_work_days(WAR_START, WAR_END, r.id))
-        self.assertFalse(r._is_work_day(date(1932, 12, 6)))  # personal leave
+        self.assertTrue(r.calendar_id._is_work_day(date(1932, 11, 8), r.id))
-        Overlapping intervals are merged into a single one.
+    def _merge_kw(self, kw, kw_ext):
-        :return list cleaned: list of sorted intervals without overlap """
+        :return list cleaned: sorted intervals merged without overlap """
-                working_interval = [current_interval[0], current_interval[1]]
+                working_interval = self._interval_new(*current_interval)
-                working_interval = [current_interval[0], current_interval[1]]
+                cleaned.append(working_interval)
-                working_interval[1] = current_interval[1]
+                working_interval = self._interval_or(working_interval, current_interval)
-            cleaned.append(tuple(working_interval))
+            cleaned.append(working_interval)
-            leave_intervals = []
+        """ Remove leave intervals from a base interval
-        current_interval = [interval[0], interval[1]]
+        leave_intervals = self._interval_merge(leave_intervals)
-                current_interval = [leave[1], interval[1]]
+                intervals.append(self._interval_exclude_right(current_interval, leave))
-                current_interval[0] = leave[1]
+                current_interval = self._interval_exclude_left(interval, leave)
-            intervals.append((current_interval[0], current_interval[1]))
+            intervals.append(current_interval)
-        """ Get previous date of day_date, based on work.calendar. If no
+        """ Get previous date of day_date, based on resource.calendar. If no
-            leaves.append((date_from, date_to))
+            leaves.append(self._interval_new(date_from, date_to, {'leaves': leave}))
-            work_limits.append((start_dt.replace(hour=0, minute=0, second=0), start_dt))
+            work_limits.append(self._interval_new(start_dt.replace(hour=0, minute=0, second=0), start_dt))
-            work_limits.append((end_dt, end_dt.replace(hour=23, minute=59, second=59)))
+            work_limits.append(self._interval_new(end_dt, end_dt.replace(hour=23, minute=59, second=59)))
-            working_interval = (
+            working_interval = self._interval_new(
-                calendar_working_day.id
+                {'attendances': calendar_working_day}
-        return intervals
+        if leaves:
-        )
+        self.calendar = self.env['resource.calendar'].create({
-        ).id
+        self.leave1 = self.env['resource.calendar.leaves'].create({
-        ).id
+        self.leave2 = self.env['resource.calendar.leaves'].create({
-        ).id
+        self.leave3 = self.env['resource.calendar.leaves'].create({
-        super(TestResourceCommon, self).setUp()
+        super(TestIntervals, self).setUp()
-            (
+            self.calendar._interval_new(
-            ), (
+            ), self.calendar._interval_new(
-            ), (
+            ), self.calendar._interval_new(
-            ), (
+            ), self.calendar._interval_new(
-            ), (
+            ), self.calendar._interval_new(
-            ), (
+            ), self.calendar._interval_new(
-        cleaned_intervals = self.env['resource.calendar']._interval_clean(self.intervals)
+    def test_interval_merge(self):
-        self.assertEqual(cleaned_intervals[0], (Datetime.from_string('2013-02-03 08:00:00'), Datetime.from_string('2013-02-03 10:00:00')))
+        self.assertEqual(cleaned_intervals[0][:2], (Datetime.from_string('2013-02-03 08:00:00'), Datetime.from_string('2013-02-03 10:00:00')))
-        self.assertEqual(cleaned_intervals[1], (Datetime.from_string('2013-02-04 08:00:00'), Datetime.from_string('2013-02-04 14:00:00')))
+        self.assertEqual(cleaned_intervals[1][:2], (Datetime.from_string('2013-02-04 08:00:00'), Datetime.from_string('2013-02-04 14:00:00')))
-        self.assertEqual(cleaned_intervals[2], (Datetime.from_string('2013-02-04 17:00:00'), Datetime.from_string('2013-02-04 21:00:00')))
+        self.assertEqual(cleaned_intervals[2][:2], (Datetime.from_string('2013-02-04 17:00:00'), Datetime.from_string('2013-02-04 21:00:00')))
-        working_interval = (Datetime.from_string('2013-02-04 08:00:00'), Datetime.from_string('2013-02-04 18:00:00'))
+        working_interval = self.calendar._interval_new(Datetime.from_string('2013-02-04 08:00:00'), Datetime.from_string('2013-02-04 18:00:00'))
-        self.assertEqual(result[0], (Datetime.from_string('2013-02-04 14:00:00'), Datetime.from_string('2013-02-04 17:00:00')))
+        self.assertEqual(result[0][:2], (Datetime.from_string('2013-02-04 14:00:00'), Datetime.from_string('2013-02-04 17:00:00')))
-        cleaned_intervals = self.env['resource.calendar']._interval_clean(self.intervals)
+        cleaned_intervals = self.env['resource.calendar']._interval_merge(self.intervals)
-        self.assertEqual(result[0], (Datetime.from_string('2013-02-03 08:00:00'), Datetime.from_string('2013-02-03 10:00:00')))
+        self.assertEqual(result[0][:2], (Datetime.from_string('2013-02-03 08:00:00'), Datetime.from_string('2013-02-03 10:00:00')))
-        self.assertEqual(result[1], (Datetime.from_string('2013-02-04 08:00:00'), Datetime.from_string('2013-02-04 11:30:00')))
+        self.assertEqual(result[1][:2], (Datetime.from_string('2013-02-04 08:00:00'), Datetime.from_string('2013-02-04 11:30:00')))
-        cleaned_intervals = self.env['resource.calendar']._interval_clean(self.intervals)
+        cleaned_intervals = self.env['resource.calendar']._interval_merge(self.intervals)
-        self.assertEqual(result[0], (Datetime.from_string('2013-02-04 17:00:00'), Datetime.from_string('2013-02-04 21:00:00')))
+        self.assertEqual(result[0][:2], (Datetime.from_string('2013-02-04 17:00:00'), Datetime.from_string('2013-02-04 21:00:00')))
-        self.assertEqual(result[1], (Datetime.from_string('2013-02-04 12:30:00'), Datetime.from_string('2013-02-04 14:00:00')))
+        self.assertEqual(result[1][:2], (Datetime.from_string('2013-02-04 12:30:00'), Datetime.from_string('2013-02-04 14:00:00')))
-        self.assertEqual(intervals[0], (Datetime.from_string('2013-02-12 09:08:07'), Datetime.from_string('2013-02-12 16:00:00')))
+        self.assertEqual(intervals[0][:2], (Datetime.from_string('2013-02-12 09:08:07'), Datetime.from_string('2013-02-12 16:00:00')))
-        self.assertEqual(intervals[0], (Datetime.from_string('2013-02-19 10:30:00'), Datetime.from_string('2013-02-19 16:00:00')))
+        self.assertEqual(intervals[0][:2], (Datetime.from_string('2013-02-19 10:30:00'), Datetime.from_string('2013-02-19 16:00:00')))
-        self.assertEqual(intervals[1], (Datetime.from_string('2013-02-15 16:00:00'), Datetime.from_string('2013-02-15 23:00:00')))
+        self.assertEqual(intervals[0][:2], (Datetime.from_string('2013-02-15 10:11:12'), Datetime.from_string('2013-02-15 13:00:00')))
-        self.assertEqual(intervals[0], (Datetime.from_string('2013-02-12 08:00:00'), Datetime.from_string('2013-02-12 16:00:00')))
+        self.assertEqual(intervals[0][:2], (Datetime.from_string('2013-02-12 08:00:00'), Datetime.from_string('2013-02-12 16:00:00')))
-        # Test: day0 with leaves: 2 intervals because of leave between 9 ans 12, ending at 15:45:30
+        # Test: day0 with leaves: 2 intervals because of leave between 9 and 12, ending at 15:45:30
-        self.assertEqual(intervals[1], (Datetime.from_string('2013-02-19 12:00:00'), Datetime.from_string('2013-02-19 15:45:30')))
+        self.assertEqual(intervals[0][:2], (Datetime.from_string('2013-02-19 08:15:00'), Datetime.from_string('2013-02-19 09:00:00')))
-        self.assertEqual(len(intervals), 0, 'resource_calendar: wrong working interval/day computing')
+        self.assertEqual(len(intervals), 0)
-        self.assertEqual(intervals, [(Datetime.from_string('2013-02-15 10:11:12'), Datetime.from_string('2013-02-15 13:00:00'))])
+        self.assertEqual(len(intervals), 1)
-        self.assertEqual(intervals, [(Datetime.from_string('2013-02-15 10:11:12'), Datetime.from_string('2013-02-15 13:00:00'))])
+        self.assertEqual(len(intervals), 1)
-        self.assertEqual(intervals, [(Datetime.from_string('2013-02-15 10:11:12'), Datetime.from_string('2013-02-15 13:00:00'))])
+        self.assertEqual(len(intervals), 1)
-        self.assertEqual(intervals[1], (Datetime.from_string('2013-02-15 16:00:00'), Datetime.from_string('2013-02-15 23:00:00')))
+        self.assertEqual(intervals[0][:2], (Datetime.from_string('2013-02-15 10:11:12'), Datetime.from_string('2013-02-15 13:00:00')))
-        self.assertEqual(wh, 5.5, 'resource_calendar: wrong working interval / day time computing')
+        self.assertEqual(wh, 5.5)
-        self.assertEqual(res[-1], (Datetime.from_string('2013-02-12 08:00:00'), Datetime.from_string('2013-02-12 09:00:00')))
+        self.assertEqual(res[-1][:2], (Datetime.from_string('2013-02-12 08:00:00'), Datetime.from_string('2013-02-12 09:00:00')))
-        self.assertEqual(res[-6], (Datetime.from_string('2013-02-01 08:00:00'), Datetime.from_string('2013-02-01 13:00:00')))
+        self.assertEqual(res[-2][:2], (Datetime.from_string('2013-02-08 16:00:00'), Datetime.from_string('2013-02-08 23:00:00')))
-        self.assertEqual(res[-7], (Datetime.from_string('2013-01-29 09:00:00'), Datetime.from_string('2013-01-29 16:00:00')))
+        self.assertEqual(res[-7][:2], (Datetime.from_string('2013-01-29 09:00:00'), Datetime.from_string('2013-01-29 16:00:00')))
-        self.assertEqual(res[6], (Datetime.from_string('2013-02-26 08:00:00'), Datetime.from_string('2013-02-26 09:00:00')))
+        self.assertEqual(res[0][:2], (Datetime.from_string('2013-02-12 09:00:00'), Datetime.from_string('2013-02-12 16:00:00')))
-        self.assertEqual(res[8], (Datetime.from_string('2013-03-01 16:00:00'), Datetime.from_string('2013-03-01 22:30:00')))
+        self.assertEqual(res[0][:2], (Datetime.from_string('2013-02-12 09:00:00'), Datetime.from_string('2013-02-12 16:00:00')))
-        #leave_intervals = self._interval_clean(leave_intervals) NOT NECESSARY TO CLEAN HERE AS IT WOULD REMOVE GROUP INFO
+        #leave_intervals = self._interval_merge(leave_intervals) NOT NECESSARY TO CLEAN HERE AS IT WOULD REMOVE GROUP INFO
-            return action.trg_date_calendar_id.schedule_days_get_date(
+            return action.trg_date_calendar_id.plan_days(
-            )[0]
+            )
-                hours = resource.calendar_id.get_working_hours(from_dt, to_dt, resource_id=resource.id, compute_leaves=True)
+                hours = resource.calendar_id.get_work_hours_count(from_dt, to_dt, resource_id=resource.id, compute_leaves=True)
-                working_hours_on_day = contract.working_hours.working_hours_on_day(day_from + timedelta(days=day))
+                working_hours_on_day = contract.working_hours.get_work_hours_count(day_from + timedelta(days=day), False)
-                    r = blocktime.workcenter_id.calendar_id.get_working_hours(d1, d2, resource_id=blocktime.workcenter_id.resource_id.id)
+                    r = blocktime.workcenter_id.calendar_id.get_work_hours_count(d1, d2, resource_id=blocktime.workcenter_id.resource_id.id)
-                    issue.working_hours_open = issue.project_id.resource_calendar_id.get_working_hours(
+                    issue.working_hours_open = issue.project_id.resource_calendar_id.get_work_hours_count(
-                    issue.working_hours_close = issue.project_id.resource_calendar_id.get_working_hours(
+                    issue.working_hours_close = issue.project_id.resource_calendar_id.get_work_hours_count(
-    def interval_clean(self, intervals):
+    def _interval_clean(self, intervals):
-    def interval_remove_leaves(self, interval, leave_intervals):
+    def _interval_remove_leaves(self, interval, leave_intervals):
-        leave_intervals = self.interval_clean(leave_intervals)
+        leave_intervals = self._interval_clean(leave_intervals)
-    def interval_schedule_hours(self, intervals, hour, remove_at_end=True):
+    @api.model
-    def get_attendances_for_weekday(self, day_dt):
+    def _get_day_attendances(self, day_dt):
-    def get_weekdays(self):
+    def _get_weekdays(self):
-    def get_next_day(self, day_date):
+    def _get_next_work_day(self, day_date):
-        weekdays = self.get_weekdays()
+        weekdays = self._get_weekdays()
-        """ Get previous date of day_date, based on resource.calendar. If no
+    def _get_previous_work_day(self, day_date):
-        weekdays = self.get_weekdays()
+        weekdays = self._get_weekdays()
-                            start_datetime=None, end_datetime=None):
+    def _get_leave_intervals(self, resource_id=None,
-                                     leaves=None, compute_leaves=False, resource_id=None):
+    def _get_day_work_intervals(self, start_dt=None, end_dt=None,
-        assert start_dt.date() == end_dt.date(), 'get_working_intervals_of_day is restricted to one day'
+        assert start_dt.date() == end_dt.date(), '_get_day_work_intervals is restricted to one day'
-        for calendar_working_day in self.get_attendances_for_weekday(start_dt):
+        for calendar_working_day in self._get_day_attendances(start_dt):
-            working_intervals += self.interval_remove_leaves(working_interval, work_limits)
+            working_intervals += self._interval_remove_leaves(working_interval, work_limits)
-            leaves = self.get_leave_intervals(resource_id=resource_id)
+            leaves = self._get_leave_intervals(resource_id=resource_id)
-            work_intervals = self.interval_remove_leaves(interval, leaves)
+            work_intervals = self._interval_remove_leaves(interval, leaves)
-        return seconds(res) / 3600.0
+    # --------------------------------------------------
-        hours = 0.0
+    def get_work_hours_count(self, start_dt, end_dt, compute_leaves=False, resource_id=None):
-                               byweekday=self.get_weekdays()):
+                               byweekday=self._get_weekdays()):
-            hours += self.get_working_hours_of_date(
+            intervals = self._get_day_work_intervals(
-        return hours
+            for interval in intervals:
-    # Hours scheduling
+    # Scheduling API
-            working_intervals = self.get_working_intervals_of_day(**call_args)
+            working_intervals = self._get_day_work_intervals(**call_args)
-                new_working_intervals = self.interval_schedule_hours(working_intervals, remaining_hours, not backwards)
+                new_working_intervals = self._interval_schedule_hours(working_intervals, remaining_hours, not backwards)
-                current_datetime = datetime.datetime.combine(self.get_previous_day(current_datetime), datetime.time(23, 59, 59))
+                current_datetime = datetime.datetime.combine(self._get_previous_work_day(current_datetime), datetime.time(23, 59, 59))
-                current_datetime = datetime.datetime.combine(self.get_next_day(current_datetime), datetime.time())
+                current_datetime = datetime.datetime.combine(self._get_next_work_day(current_datetime), datetime.time())
-        an hours scheduling. """
+    def plan_hours(self, hours, day_dt=None, compute_leaves=False, resource_id=None):
-            working_intervals = self.get_working_intervals_of_day(
+            working_intervals = self._get_day_work_intervals(
-                current_datetime = self.get_previous_day(current_datetime)
+                current_datetime = self._get_previous_work_day(current_datetime)
-                current_datetime = self.get_next_day(current_datetime)
+                current_datetime = self._get_next_work_day(current_datetime)
-        a days scheduling. """
+    def plan_days(self, days, day_date=None, compute_leaves=False, resource_id=None):
-        working_intervals = self.calendar_id.get_working_intervals_of_day
+        working_intervals = self.calendar_id._get_day_work_intervals
-from odoo.tools import float_compare
+from odoo.addons.resource.models.resource import seconds
-        cleaned_intervals = self.env['resource.calendar'].interval_clean(self.intervals)
+        cleaned_intervals = self.env['resource.calendar']._interval_clean(self.intervals)
-        result = self.env['resource.calendar'].interval_remove_leaves(working_interval, self.intervals)
+        result = self.env['resource.calendar']._interval_remove_leaves(working_interval, self.intervals)
-        result = self.env['resource.calendar'].interval_schedule_hours(cleaned_intervals, 5.5)
+        cleaned_intervals = self.env['resource.calendar']._interval_clean(self.intervals)
-        cleaned_intervals = self.env['resource.calendar'].interval_clean(self.intervals)
+        cleaned_intervals = self.env['resource.calendar']._interval_clean(self.intervals)
-        result = self.env['resource.calendar'].interval_schedule_hours(cleaned_intervals, 5.5, remove_at_end=False)
+        result = self.env['resource.calendar']._interval_schedule_hours(cleaned_intervals, 5.5, remove_at_end=False)
-        weekdays = self.calendar.get_weekdays()
+        weekdays = self.calendar._get_weekdays()
-        date = self.calendar.get_next_day(day_date=Date.from_string('2013-02-12'))
+        date = self.calendar._get_next_work_day(day_date=Date.from_string('2013-02-12'))
-        date = self.calendar.get_next_day(day_date=Date.from_string('2013-02-15'))
+        date = self.calendar._get_next_work_day(day_date=Date.from_string('2013-02-15'))
-        date = self.calendar.get_next_day(day_date=Date.from_string('2013-02-15') + relativedelta(days=1))
+        date = self.calendar._get_next_work_day(day_date=Date.from_string('2013-02-15') + relativedelta(days=1))
-        date = self.calendar.get_next_day(day_date=Date.from_string('2013-02-12') + relativedelta(days=-1))
+        date = self.calendar._get_next_work_day(day_date=Date.from_string('2013-02-12') + relativedelta(days=-1))
-        date = self.calendar.get_previous_day(day_date=Date.from_string('2013-02-12'))
+        date = self.calendar._get_previous_work_day(day_date=Date.from_string('2013-02-12'))
-        date = self.calendar.get_previous_day(day_date=Date.from_string('2013-02-15'))
+        date = self.calendar._get_previous_work_day(day_date=Date.from_string('2013-02-15'))
-        date = self.calendar.get_previous_day(day_date=Date.from_string('2013-02-15') + relativedelta(days=1))
+        date = self.calendar._get_previous_work_day(day_date=Date.from_string('2013-02-15') + relativedelta(days=1))
-        date = self.calendar.get_previous_day(day_date=Date.from_string('2013-02-12') + relativedelta(days=-1))
+        date = self.calendar._get_previous_work_day(day_date=Date.from_string('2013-02-12') + relativedelta(days=-1))
-        intervals = self.calendar.get_working_intervals_of_day(start_dt=Datetime.from_string('2013-02-12 09:08:07'))
+        intervals = self.calendar._get_day_work_intervals(start_dt=Datetime.from_string('2013-02-12 09:08:07'))
-        intervals = self.calendar.get_working_intervals_of_day(start_dt=Datetime.from_string('2013-02-19 10:30:00'))
+        intervals = self.calendar._get_day_work_intervals(start_dt=Datetime.from_string('2013-02-19 10:30:00'))
-        intervals = self.calendar.get_working_intervals_of_day(start_dt=Datetime.from_string('2013-02-15 10:11:12'))
+        intervals = self.calendar._get_day_work_intervals(start_dt=Datetime.from_string('2013-02-15 10:11:12'))
-        intervals = self.calendar.get_working_intervals_of_day(start_dt=Datetime.from_string('2013-02-12 07:00:00'), compute_leaves=True)
+        intervals = self.calendar._get_day_work_intervals(start_dt=Datetime.from_string('2013-02-12 07:00:00'), compute_leaves=True)
-        intervals = self.calendar.get_working_intervals_of_day(start_dt=Datetime.from_string('2013-02-19 08:15:00'),
+        intervals = self.calendar._get_day_work_intervals(start_dt=Datetime.from_string('2013-02-19 08:15:00'),
-        intervals = self.calendar.get_working_intervals_of_day(
+        intervals = self.calendar._get_day_work_intervals(
-        intervals = self.calendar.get_working_intervals_of_day(start_dt=self.date2)
+        intervals = self.calendar._get_day_work_intervals(start_dt=self.date2)
-        intervals = self.calendar.get_working_intervals_of_day(start_dt=self.date2)
+        intervals = self.calendar._get_day_work_intervals(start_dt=self.date2)
-        intervals = self.calendar.get_working_intervals_of_day(start_dt=self.date2)
+        intervals = self.calendar._get_day_work_intervals(start_dt=self.date2)
-        intervals = self.calendar.get_working_intervals_of_day(start_dt=self.date2)
+        intervals = self.calendar._get_day_work_intervals(start_dt=self.date2)
-        wh = self.calendar.get_working_hours_of_date(start_dt=Datetime.from_string('2013-02-19 10:30:00'))
+        wh = self.calendar.get_work_hours_count(Datetime.from_string('2013-02-19 10:30:00'), Datetime.from_string('2013-02-19 18:00:00'))
-        res = self.calendar.get_working_hours(
+        res = self.calendar.get_work_hours_count(
-        res = self.calendar.get_working_hours(
+        res = self.calendar.get_work_hours_count(
-        res = self.calendar.schedule_hours(-40, day_dt=Datetime.from_string('2013-02-12 09:00:00'))
+        res = self.calendar._schedule_hours(-40, day_dt=Datetime.from_string('2013-02-12 09:00:00'))
-        res = self.calendar.schedule_hours(40, day_dt=Datetime.from_string('2013-02-12 09:00:00'))
+        res = self.calendar._schedule_hours(40, day_dt=Datetime.from_string('2013-02-12 09:00:00'))
-        res = self.calendar.schedule_hours(
+        res = self.calendar._schedule_hours(
-        res = self.calendar.schedule_days_get_date(5, day_date=Datetime.from_string('2013-02-12 09:08:07') )
+        res = self.calendar.plan_days(5, day_date=Datetime.from_string('2013-02-12 09:08:07') )
-        res = self.calendar.schedule_days_get_date(-2, day_date=Datetime.from_string('2013-02-12 09:08:07') )
+        res = self.calendar.plan_days(-2, day_date=Datetime.from_string('2013-02-12 09:08:07') )
-        res = self.calendar.schedule_days_get_date(
+        res = self.calendar.plan_days(
-                            start_datetime=None, end_datetime=None):
+    def _get_leave_intervals(self, resource_id=None,
-    def interval_remove_leaves(self, interval, leave_intervals):
+    def _interval_remove_leaves(self, interval, leave_intervals):
-        #leave_intervals = self.interval_clean(leave_intervals) NOT NECESSARY TO CLEAN HERE AS IT WOULD REMOVE GROUP INFO
+        #leave_intervals = self._interval_clean(leave_intervals) NOT NECESSARY TO CLEAN HERE AS IT WOULD REMOVE GROUP INFO
-    resource_calendar_id = fields.Many2one('resource.calendar', string='Working Time',
+    resource_calendar_id = fields.Many2one(
-
+
-                    compute_leaves=True, resource_id=False, default_interval=(8, 16))
+                if issue.project_id.resource_calendar_id:
-                    compute_leaves=True, resource_id=False, default_interval=(8, 16))
+                if issue.project_id.resource_calendar_id:
-            return default_weekdays if default_weekdays is not None else [0, 1, 2, 3, 4]
+    def get_weekdays(self):
-                                     default_interval=None):
+                                     leaves=None, compute_leaves=False, resource_id=None):
-
+        self.ensure_one()
-                                  default_interval=None):
+                                  leaves=None, compute_leaves=False, resource_id=None):
-            default_interval)
+            compute_leaves, resource_id)
-                          resource_id=None, default_interval=None):
+                          resource_id=None):
-                default_interval=default_interval)
+                compute_leaves=compute_leaves, resource_id=resource_id)
-                        default_interval=None):
+                        compute_leaves=False, resource_id=None):
-                                       is returned when id is None.
+        self.ensure_one()
-        call_args = dict(compute_leaves=compute_leaves, resource_id=resource_id, default_interval=default_interval)
+        call_args = dict(compute_leaves=compute_leaves, resource_id=resource_id)
-            elif working_intervals:
+            if working_intervals:
-                                default_interval=None):
+                                compute_leaves=False, resource_id=None):
-        res = self._schedule_hours(hours, day_dt, compute_leaves, resource_id, default_interval)
+        res = self._schedule_hours(hours, day_dt, compute_leaves, resource_id)
-                       default_interval=None):
+                       compute_leaves=False, resource_id=None):
-        return self._schedule_hours(hours, day_dt, compute_leaves, resource_id, default_interval)
+        return self._schedule_hours(hours, day_dt, compute_leaves, resource_id)
-                       resource_id=None, default_interval=None):
+                       resource_id=None):
-                default_interval=default_interval)
+                compute_leaves=compute_leaves, resource_id=resource_id)
-                               resource_id=None, default_interval=None):
+    def schedule_days_get_date(self, days, day_date=None, compute_leaves=False, resource_id=None):
-        res = self._schedule_days(days, day_date, compute_leaves, resource_id, default_interval)
+        res = self._schedule_days(days, day_date, compute_leaves, resource_id)
-                      resource_id=None, default_interval=None):
+    def schedule_days(self, days, day_date=None, compute_leaves=False, resource_id=None):
-        return self._schedule_days(days, day_date, compute_leaves, resource_id, default_interval)
+        return self._schedule_days(days, day_date, compute_leaves, resource_id)
-            default_interval=(8, 16)
+            compute_leaves=True, resource_id=resource
-            default_interval=(8, 16))
+        )
-        if not fields or 'calendar_id' in fields and not res.get('calendar_id') and res.get('company_id'):
+        if not res.get('calendar_id') and res.get('company_id'):
-        ], string='Resource Type', required=True, default='user')
+        ('material', 'Material')], string='Resource Type',
-    calendar_id = fields.Many2one("resource.calendar", string='Working Time', help="Define the schedule of resource")
+    calendar_id = fields.Many2one(
-        # this is probably a problem of osv_memory as it's not compatible with normal OSV's
+        # add_payment expect a journal key
-    def fields_view_get(self, view_id=None, view_type=False, toolbar=False, submenu=False):
+    def fields_view_get(self, view_id=None, view_type='form', toolbar=False, submenu=False):
-            proc_obj.message_post(cr, uid, procs, body=_('Manufacturing order cancelled.'), context=context)
+            for proc in procs:
-                new_list_price, currency_id = line.with_context(context_partner)._get_real_price_currency(line.product_id.id, list_price, line.product_uom_qty, line.product_uom.id, line.order_id.pricelist_id.id)
+                list_price_dict = line.order_id.pricelist_id.with_context(pricelist_context).price_rule_get(line.product_id.id, line.product_uom_qty or 1.0, line.order_id.partner_id)
-                if line.order_id.pricelist_id.discount_policy == 'without_discount' and list_price[line.order_id.pricelist_id.id][0] != 0 and new_list_price != 0:
+                if line.order_id.pricelist_id.discount_policy == 'without_discount' and list_price != 0 and new_list_price != 0:
-                    discount = (new_list_price - line.price_unit) / new_list_price * 100
+                    discount = (new_list_price - list_price) / new_list_price * 100
-            new_list_price, currency_id = self.with_context(context_partner)._get_real_price_currency(self.product_id.id, list_price, self.product_uom_qty, self.product_uom.id, self.order_id.pricelist_id.id)
+            list_price_dict = self.order_id.pricelist_id.with_context(pricelist_context).price_rule_get(self.product_id.id, self.product_uom_qty or 1.0, self.order_id.partner_id)
-            if self.order_id.pricelist_id.discount_policy == 'without_discount' and list_price[self.order_id.pricelist_id.id][0] != 0 and new_list_price != 0:
+            if self.order_id.pricelist_id.discount_policy == 'without_discount' and list_price != 0 and new_list_price != 0:
-                discount = (new_list_price - self.price_unit) / new_list_price * 100
+                discount = (new_list_price - list_price) / new_list_price * 100
-                order_line.write({'qty': -order_line.qty})
+    def _default_session(self):
-                    MessageModel.browse(thread_id).message_update(message_dict)
+                    thread = MessageModel.browse(thread_id)
-                    thread_id = MessageModel.message_new(message_dict, custom_values)
+                    thread = MessageModel.message_new(message_dict, custom_values)
-                Model = self.env['mail.thread'].with_context(thread_model=model)
+                thread = self.env['mail.thread']
-            new_msg = Model.browse(thread_id).message_post(subtype=subtype, partner_ids=partner_ids, **message_dict)
+            new_msg = thread.message_post(subtype=subtype, partner_ids=partner_ids, **message_dict)
-        return res.id
+        return RecordModel.create(data)
-        task = self.browse(res)
+        task = super(Task, self).message_new(msg, custom_values=defaults)
-        return res
+        return task
-        issue = self.browse(res_id)
+        issue = super(ProjectIssue, self.with_context(create_context)).message_new(msg, custom_values=defaults)
-        return res_id
+        return issue
-def _message_post_helper(res_model='', res_id=None, message='', token='', token_field='token', sha_in='', sha_time=None, nosubscribe=True, **kw):
+def _message_post_helper(res_model='', res_id=None, message='', token='', token_field='token', nosubscribe=True, **kw):
-        If a token or a shasign is specified, all logged in users will be able to write a message regardless
+        If a token is specified, all logged in users will be able to write a message regardless
-        Return the sha signature and the time of generation in a tuple"""
+        Return the sha signature and the time of generation in a tuple
-        If a token or a shasign is specified, all logged in users will be able to write a message regardless
+        If a token is specified, all logged in users will be able to write a message regardless
-        :param str sha_time: timestamp of sha signature generation (signatures are valid for 24h)
+        :param string sha_in: Deprecated, use `token` and `token_field` instead
-            ('state', 'in', ['open', 'paid', 'cancelled'])
+            ('state', 'in', ['open', 'paid', 'cancel'])
-                    pages=range(1, pages + 1),
+                    pages=pages_with_website,
-
+    module_website_sale_comparison = fields.Boolean("Product Comparator", help='Installs *e-Commerce Comparator*')
-            pricelist = request.env['product.pricelist'].browse(pricelist_context['pricelist'])
+
-
+        if event.state == 'done':
-
+                if reporthtml[0] is not False:
-                except UserError as e:
+                except ValidationError as e:
-            results = conn.search_st(conf['ldap_base'], ldap.SCOPE_SUBTREE, filter, retrieve_attributes, timeout=60)
+            results = conn.search_st(conf['ldap_base'].encode('utf-8'), ldap.SCOPE_SUBTREE, filter, retrieve_attributes, timeout=60)
-            self.tax_id = partner.property_account_position_id.map_tax(self.product_id.taxes_id).ids
+            self.tax_id = partner.property_account_position_id.map_tax(self.product_id.taxes_id, self.product_id, partner).ids
-            self.tax_id = partner.property_account_position_id.map_tax(self.product_id.taxes_id).ids
+            self.tax_id = partner.property_account_position_id.map_tax(self.product_id.taxes_id, self.product_id, partner).ids
-            'name': {'label': _('Name'), 'order': 'name'},
+            'name': {'label': _('Reference'), 'order': 'name'},
-            'name': {'label': _('Name'), 'order': 'name'},
+            'name': {'label': _('Reference'), 'order': 'name'},
-            'name': {'label': _('Name'), 'order': 'name desc'},
+            'name': {'label': _('Reference'), 'order': 'name desc'},
-            'name': {'label': _('Name'), 'order': 'name'},
+            'name': {'label': _('Title'), 'order': 'name'},
-            'name': {'label': _('Name'), 'order': 'name'},
+            'name': {'label': _('Title'), 'order': 'name'},
-            strftime_pattern = (u"%s %s" % (lang.date_format, lang.time_format))
+            if options and options.get('time_only'):
-from odoo import api, exceptions, models, fields
+from odoo import api, fields, exceptions, models
-    def my_issues(self, page=1, date_begin=None, date_end=None, sortby=None, filterby=None, **kw):
+    def my_issues(self, page=1, date_begin=None, date_end=None, sortby=None, filterby=None, search=None, search_in='content', **kw):
-            'url': '/blog/%s/post/%s' % (self.blog_id.id, self.id),
+            'url': self.url,
-from odoo.addons.website_portal.controllers.main import website_account
+from odoo.addons.website_portal.controllers.main import website_account, get_records_pager
-        return request.render("website_portal_sale.orders_followup", {
+        history = request.session.get('my_orders_history', [])
-        })
+        }
-from odoo.addons.website_portal.controllers.main import website_account
+from odoo.addons.website_portal.controllers.main import website_account, get_records_pager
-        return request.render("website_project.my_project", {'project': project})
+        vals = {'project': project, }
-        return request.render("website_project.my_task", {'task': task, 'user': request.env.user})
+        vals = {'task': task, 'user': request.env.user}
-from odoo import api, exceptions, models
+from odoo import api, exceptions, models, fields
-                    'url': '/my/task/%s' % self.id,
+                    'url': self.website_url,
-from odoo.addons.website_portal.controllers.main import website_account
+from odoo.addons.website_portal.controllers.main import website_account, get_records_pager
-        return request.render("website_project_issue.my_issues_issue", {'issue': issue})
+        vals = {'issue': issue}
-from odoo import api, exceptions, models, _
+from odoo import api, exceptions, models, fields
-                    'url': '/my/issues/%s' % self.id,
+                    'url': self.website_url,
-                arch_fs = arch_fs and resolve_external_ids(arch_fs, view.xml_id)
+                if fullpath:
-                amount_unit = move.product_id.standard_price
+                amount_unit = std_price_update.get(move.product_id.id) or move.product_id.standard_price
-                tools.drop_not_null(self._cr, self._table, row['attname'])
+                tools.drop_not_null(cr, self._table, row['attname'])
-                tools.drop_not_null(self._table, row['attname'])
+                tools.drop_not_null(self._cr, self._table, row['attname'])
-</div><blockquote>%s</blockquote>""" % (message.get('to'), message_dict.get('body')),
+</div><blockquote>%s</blockquote>""" % (message.get('to'), message_dict.get('body'))
-    rating_last_value = fields.Float('Rating Last Value', related='rating_ids.rating', store=True)
+    rating_last_value = fields.Float('Rating Last Value', compute='_compute_rating_last_value', compute_sudo=True, store=True)
-import report
+import sale_margin      # noqa
-				env['sale.report'].init()
+    def recreate_view(dbname):
-	cr.after("commit", partial(recreate_view, cr.dbname))
+    cr.after("commit", partial(recreate_view, cr.dbname))
-        ''' Adapt standard price on outgoing moves if the product cost_method is 'real', so that a
+        ''' Adapt standard price on outgoing moves, so that a
-        to_update_moves = self.filtered(lambda move: move.product_id.cost_method == 'real' and move.location_dest_id.usage != 'internal')
+        to_update_moves = self.filtered(lambda move: move.location_dest_id.usage != 'internal')
-        for move in self:
+        """ Store the average price of the move on the move and product form (costing method 'real')"""
-            if value['refund_account_id'] or value['account_id']:
+            if value['refund_account_id'] or value['account_id'] or value['cash_basis_account']:
-        'account.account',
+        'account.account.template',
-            'cash_basis_account': self.cash_basis_account,
+
-        if column['typname'] == self.column_type[0]:
+        if column['udt_name'] == self.column_type[0]:
-        if column['typname'] in self.column_cast_from:
+        if column['udt_name'] in self.column_cast_from:
-            if column['attnotnull']:
+            if column['is_nullable'] == 'NO':
-        has_notnull = column and column['attnotnull']
+        has_notnull = column and column['is_nullable'] == 'NO'
-            (self.size is None or column['size'] < self.size)
+            column and column['udt_name'] == 'varchar' and column['character_maximum_length'] and
-    query = "SELECT 1 FROM pg_class WHERE relkind IN ('r','v') AND relname=%s"
+    query = "SELECT 1 FROM information_schema.tables WHERE table_name=%s"
-    return cr.fetchone()[0] if cr.rowcount else None
+    """ Return the kind of a table: ``'r'`` (regular table), ``'v'`` (view),
-        `typname` (data type name), `size` (varchar size).
+        a dict with the data from the table ``information_schema.columns``.
-                WHERE c.relname=%s AND c.oid=a.attrelid AND a.atttypid=t.oid """
+    query = 'SELECT * FROM information_schema.columns WHERE table_name=%s'
-    return {row['attname']: row for row in cr.dictfetchall()}
+    return {row['column_name']: row for row in cr.dictfetchall()}
-                WHERE c.relname=%s AND a.attname=%s AND c.oid=a.attrelid """
+    query = """ SELECT 1 FROM information_schema.columns
-            raise ValueError(_('There is no reference available for %s') % (self.comodel_name,))
+        comodel = model.env[self.comodel_name]
-                model.pool.post_init(model._m2o_fix_foreign_key, model._table, self.name, comodel, self.ondelete)
+        # ir_actions is inherited, so foreign key doesn't work on it
-                raise UserError(_('Many2many comodel does not exist: %r') % (self.comodel_name,))
+        # Do not reflect relations for custom fields, as they do not belong to a
-            _schema.debug("Create table '%s': m2m relation between '%s' and '%s'", rel, model._table, comodel._table)
+            query = """
-
+_CONFDELTYPES = {
-                       table_kind, ustr, OrderedSet
+                       html_sanitize, human_size, pg_varchar, ustr, OrderedSet
-    # Read from/write to database
+    # Update database schema
-        ``True`` if the schema was altered and the field must be recomputed.
+    def update_db(self, model, columns):
-        pass
+        if not self.column_type:
-    def check_schema(self, model):
+    def update_db(self, model, columns):
-    def check_schema(self, model):
+    def update_db(self, model, columns):
-        if not table_exists(cr, rel):
+        if not sql.table_exists(cr, rel):
-            if table_kind(cr, comodel._table) != 'v':
+            if sql.table_kind(cr, comodel._table) != 'v':
-            if table_kind(cr, model._table) != 'v':
+            if sql.table_kind(cr, model._table) != 'v':
-            column_data = tools.table_columns(cr, self._table)
+            # update the database schema for fields
-                    continue
+            def recompute(field):
-                        self.pool.post_init(recompute, field)
+                    continue            # don't update custom fields
-                            tools.set_not_null(cr, self._table, name)
+                new = field.update_db(self, columns)
-            self._cr.execute('CREATE UNIQUE INDEX act_window_view_unique_mode_per_action ON ir_act_window_view (act_window_id, view_mode)')
+        tools.create_unique_index(self._cr, 'act_window_view_unique_mode_per_action',
-            self._cr.commit()
+        tools.create_index(self._cr, 'ir_attachment_res_idx',
-from odoo import api, fields, models, _
+from odoo import api, fields, models, tools, _
-                                (lower(name), model_id, COALESCE(user_id,-1), COALESCE(action_id,-1))""")
+        tools.create_unique_index(self._cr, 'ir_filters_name_model_uid_unique_action_index',
-                self._cr.execute('DROP TABLE %s CASCADE' % table)
+            kind = tools.table_kind(self._cr, table)
-                self._cr.execute('ALTER table "%s" DROP column "%s" cascade' % (model._table, field.name))
+            if tools.column_exists(self._cr, model._table, field.name) and \
-            if self._cr.fetchone():
+            if tools.table_exists(self._cr, name):
-            self._cr.execute('DROP TABLE %s CASCADE' % table,)
+            self._cr.execute('DROP TABLE "%s" CASCADE' % table,)
-            self._cr.execute('CREATE INDEX ir_model_data_model_res_id_index ON ir_model_data (model, res_id)')
+        tools.create_unique_index(self._cr, 'ir_model_data_module_name_uniq_index',
-            cr.commit()
+        tools.create_index(self._cr, 'ir_translation_src_md5', self._table, ['md5(src)'])
-            self._cr.execute("CREATE INDEX ir_ui_view_custom_user_id_ref_id ON ir_ui_view_custom (user_id, ref_id)")
+        tools.create_index(self._cr, 'ir_ui_view_custom_user_id_ref_id',
-            self._cr.execute('CREATE INDEX ir_ui_view_model_type_inherit_id ON ir_ui_view (model, inherit_id)')
+        tools.create_index(self._cr, 'ir_ui_view_model_type_inherit_id',
-            self._cr.execute("CREATE INDEX ir_values_key_model_key2_res_id_user_id_idx ON ir_values (key, model, key2, res_id, user_id)")
+        tools.create_index(self._cr, 'ir_values_key_model_key2_res_id_user_id_idx',
-                       html_sanitize, human_size, pg_varchar, ustr, OrderedSet
+                       html_sanitize, human_size, pg_varchar, table_exists, \
-        if not cr.dictfetchall():
+        if not table_exists(cr, rel):
-            if not cr.fetchall():
+            if table_kind(cr, comodel._table) != 'v':
-            if not cr.fetchall():
+            if table_kind(cr, model._table) != 'v':
-        return bool(self.env.cr.fetchone())
+        return tools.table_kind(self.env.cr, self._table) == 'r'
-        self._cr.execute("ALTER TABLE %s DROP CONSTRAINT %s" % (source_table, constraint_name))
+                tools.drop_not_null(self._table, row['attname'])
-                    self._drop_constraint(source_table, cons['constraint_name'])
+                    tools.drop_constraint(self._cr, source_table, cons['constraint_name'])
-                    self._drop_constraint(source_table, cons['constraint_name'])
+                    tools.drop_constraint(self._cr, source_table, cons['constraint_name'])
-        create = not self._table_exist()
+        must_create_table = not tools.table_exists(cr, self._table)
-                self._create_table()
+            if must_create_table:
-                if not self._parent_columns_exist():
+                if not tools.column_exists(cr, self._table, 'parent_left'):
-            column_data = self._select_column_data()
+            column_data = tools.table_columns(cr, self._table)
-                            _schema.debug("Table '%s': renamed column '%s' to '%s'", self._table, field.oldname, name)
+                            tools.rename_column(cr, self._table, field.oldname, name)
-                                              self._table, name, f_pg_size or 'unlimited', field.size or 'unlimited')
+                                tools.convert_column(cr, self._table, name, column_type[1])
-                                                      self._table, name, c[0], c[1])
+                                        tools.convert_column(cr, self._table, name, column_type[1])
-                                        if not cr.fetchone()[0]:
+                                        if not tools.column_exists(cr, self._table, newname):
-                                                    self._table, name, f_pg_type, field.type, newname)
+                                        tools.drop_not_null(cr, self._table, name)
-                                    _schema.warning(msg, self._table, name, self._table, name)
+                                tools.set_not_null(cr, self._table, name)
-                                              self._table, name)
+                                tools.drop_not_null(cr, self._table, name)
-                                cr.execute('CREATE INDEX "%s_%s_index" ON "%s" ("%s")' % (self._table, name, self._table, name))
+                            has_index = tools.index_exists(cr, indexname)
-                                _schema.debug(msg, self._table, name, field.type)
+                            if has_index and not field.index:
-                                      self._table, name, field.column_type[1])
+                        tools.create_column(cr, self._table, name, field.column_type[1], field.string)
-                            cr.execute('CREATE INDEX "%s_%s_index" ON "%s" ("%s")' % (self._table, name, self._table, name))
+                            indexname = '%s_%s_index' % (self._table, name)
-            create = not bool(cr.fetchone())
+                            tools.set_not_null(cr, self._table, name)
-        if create:
+        if must_create_table:
-        self._cr.execute('ALTER TABLE "%s" ADD COLUMN "parent_right" INTEGER' % (self._table,))
+        tools.create_column(self._cr, self._table, 'parent_left', 'INTEGER')
-            if not cr.rowcount:
+            has_definition = tools.constraint_definition(cr, conname)
-            elif cons_text(definition) != cons_text(cr.fetchone()[0]):
+                tools.add_constraint(cr, self._table, conname, definition)
-                add(conname, definition)
+                tools.drop_constraint(cr, self._table, conname)
-    return len(cr.fetchall()) > 0
+    return odoo.tools.table_exists(cr, 'ir_module_module')
-                        lazy_property, topological_sort, OrderedSet)
+                        lazy_property, table_exists, topological_sort, OrderedSet)
-                   if not model._abstract and not model._table_exist()]
+                   if not model._abstract and not table_exists(cr, model._table)]
-                if not model._abstract and not model._table_exist():
+                if not model._abstract and not table_exists(cr, model._table):
-            if cr.fetchone():
+            if odoo.tools.table_exists(cr, 'ir_module_module'):
-                                                  self._table, name)
+                                    with cr.savepoint():
-                                              self._table, name)
+                                with cr.savepoint():
-                              self._table, name, definition)
+                with cr.savepoint():
-                              self._table, name, definition)
+                with cr.savepoint():
-                    cr.commit()
+            cr.commit()
-        if field_data['serialization_field_id']:
+        if field_data.get('serialization_field_id'):
-            model_class._build_model(self, cr)
+        # load custom models (except when loading 'base')
-            IMR._reflect_relation(model, rel, self._module)
+            model.pool.post_init(IMR._reflect_relation, model, rel, self._module)
-
+            - reflect models, fields, relations and constraints,
-                model._m2o_add_foreign_key_unchecked(rel, id2, comodel, 'cascade', self._module)
+                model.pool.post_init(model._m2o_add_foreign_key_unchecked, rel, id2, comodel, 'cascade', self._module)
-                model._m2o_add_foreign_key_unchecked(rel, id1, model, 'cascade', self._module)
+                model.pool.post_init(model._m2o_add_foreign_key_unchecked, rel, id1, model, 'cascade', self._module)
-        _schema.debug("Table '%s': added foreign key '%s' with definition=REFERENCES \"%s\" ON DELETE %s", *fk_def[:-1])
+        cr = self._cr
-                                    self._m2o_fix_foreign_key(self._table, name, comodel, field.ondelete)
+                                    self.pool.post_init(self._m2o_fix_foreign_key, self._table, name, comodel, field.ondelete)
-                                self._m2o_add_foreign_key_checked(name, comodel, field.ondelete)
+                                self.pool.post_init(self._m2o_add_foreign_key_checked, name, comodel, field.ondelete)
-
+        foreign_key_re = re.compile(r'\s*foreign\s+key\b.*', re.I)
-        for (key, definition, _) in self._sql_constraints:
+        def process(key, definition):
-            or update the database tables supporting the models.
+            ``_auto_init`` and ``init`` on each model to create or update the
-        self._context['todo'].append((10, record.modified, [set(params) - {'model', 'state'}]))
+        self.pool.post_init(record.modified, set(params) - {'model', 'state'})
-            self._context['todo'].append((20, record.modified, [list(params)]))
+            self.pool.post_init(record.modified, list(params))
-            self._context['todo'].append((20, record.modified, [diff]))
+            self.pool.post_init(record.modified, diff)
-        assert 'todo' in self._context, "Context not passed correctly to method _auto_init()."
+        """ Initialize the database schema of ``self``:
-                        stored_fields.append(field)
+                        self.pool.post_init(recompute, field)
-                            stored_fields.append(field)
+                            self.pool.post_init(recompute, field)
-
+from functools import partial
-            func(*args)
+        while self._post_init_queue:
-        vals = super(IrModelFields, self)._reflect_values(field, existing)
+    def _reflect_field_params(self, field):
-        vals['serialization_field_id'] = None
+        params['serialization_field_id'] = None
-            vals['serialization_field_id'] = serialization_record.id
+            serialization_record = self._reflect_field(serialization_field)
-        return vals
+        return params
-        # pure-SQL ir.model.field creations (e.g. in _field_create) generate
+        # pure-SQL ir.model.field creations (e.g. in _reflect) generate
-        params = {
+    def _reflect_model_params(self, model):
-        """ Return the values corresponding to the given ``field``. """
+    @tools.ormcache('model_name')
-        existing_data = existing.get(field.name)
+    def _reflect_field(self, field):
-        if existing_data is None:
+        if field_data is None:
-            query_insert(cr, self._table, vals)
+            query_insert(cr, self._table, params)
-            self._context['todo'].append((20, record.modified, [list(vals)]))
+            self._context['todo'].append((20, record.modified, [list(params)]))
-            existing[field.name] = dict(vals, id=record.id)
+            # update fields_data (for recursive calls)
-        diff = {key for key, val in vals.items() if existing_data[key] != val}
+        diff = {key for key, val in params.items() if field_data[key] != val}
-            query_update(cr, self._table, vals, ['model', 'name'])
+            query_update(cr, self._table, params, ['model', 'name'])
-            existing_data.update(vals)
+            # update fields_data (for recursive calls)
-            return self.browse(existing_data['id'])
+            return self.browse(field_data['id'])
-            model._save_relation_table(rel, self._module)
+            IMR = model.env['ir.model.relation']
-    def _field_create(self):
+    def _reflect(self):
-
+        self.env['ir.model']._reflect_model(self)
-        self._field_create()
+        self._reflect()
-            self._save_constraint("%s_%s_fkey" % (table1, column), 'f', False, module)
+            conname = "%s_%s_fkey" % (table1, column)
-        def unify_cons_text(txt):
+        def cons_text(txt):
-        def drop(name, definition, old_definition):
+        def drop(name, definition):
-                              self._table, name, old_definition, definition)
+                _schema.debug("Table '%s': dropped constraint '%s'. Reason: its definition changed to '%s'",
-            if not existing:
+            cr.execute("SELECT pg_get_constraintdef(oid) FROM pg_constraint WHERE conname=%s", (conname,))
-                drop(conname, definition, existing['definition'] or '')
+            elif cons_text(definition) != cons_text(cr.fetchone()[0]):
-
+import tests
-        self._context['todo'].append((10, record.modified, [['name', 'info', 'transient']]))
+        self._context['todo'].append((10, record.modified, [set(params) - {'model', 'state'}]))
-        if not all(existing_data[key] == val for key, val in vals.iteritems()):
+        diff = {key for key, val in vals.items() if existing_data[key] != val}
-            self._context['todo'].append((20, record.modified, [modified]))
+            self._context['todo'].append((20, record.modified, [diff]))
-
+from functools import partial
-        run('git','checkout','9.0')
+        # setup 10.0 branch
-
+        if not self.currency_field:
-            order.write({'partner_shipping_id': checkout['shipping_id']})
+            'partner_shipping_id': checkout.get('shipping_id') or partner_id,
-            moves_to_unbind |= st_line.journal_entry_ids
+            moves_to_unbind = st_line.journal_entry_ids
-                move.line_ids.filtered(lambda x:x.statement_id == st_line.statement_id).write({'statement_id': False})
+            if moves_to_unbind:
-            new_partners.setdefault(partner_id, None)
+        to_add_users = self.env['res.users'].sudo().browse([values[name] for name in user_field_lst if values.get(name)])
-        user_pids = [user_pid for user_pid in user_pids if user_pid != self.env.user.partner_id.id]
+        user_pids = [user.partner_id.id for user in to_add_users if user != self.env.user and user.notification_type == 'email']
-                                           notify_email="none",
+            'notification_type': 'inbox',
-            ('id', 'in', partners_sudo.ids),
+            ('id', 'in', (partners_sudo - notif_users.mapped('partner_id')).ids),
-            ('notify_email', '!=', 'none')])._notify(self, force_send=force_send, send_after_commit=send_after_commit, user_signature=user_signature)
+        ])._notify(self, force_send=force_send, send_after_commit=send_after_commit, user_signature=user_signature)
-             "- All Messages: for every notification you receive in your Inbox")
+                'is_read': True,  # handle by email discards Inbox notification
-        type(self).SELF_WRITEABLE_FIELDS.extend(['notify_email'])
+        type(self).SELF_WRITEABLE_FIELDS.extend(['notification_type'])
-        type(self).SELF_READABLE_FIELDS.extend(['notify_email'])
+        type(self).SELF_READABLE_FIELDS.extend(['notification_type'])
-            'notify_email': 'always',
+            'notification_type': 'email',
-            'notify_email': 'always',
+            'notification_type': 'email',
-            'notify_email': 'always',
+            'notification_type': 'email',
-            'notify_email': 'always'})
+            'email': 'valid.lelitre@agrolait.com'})
-            'notify_email': 'always'})
+            'email': 'valid.other@gmail.com'})
-        self.user_admin.write({'notify_email': 'always'})
+
-        # notification emails: followers + recipients - notify_email=none (partner_2) - author (user_employee)
+        # notification emails: followers + recipients - author (user_employee)
-        self.user_employee.write({'notify_email': 'none'})
+        self.user_employee.write({'notification_type': 'inbox'})
-            'notify_email': 'none',
+            'notification_type': 'inbox',
-            'notify_email': 'none',
+            'notification_type': 'inbox',
-            'notify_email': 'none',
+            'notification_type': 'inbox',
-            'notify_email': 'always',
+            'notification_type': 'email',
-            'notify_email': 'none',
+            'notification_type': 'inbox',
-            'notify_email': 'always',
+            'notification_type': 'email',
-            'notify_email': 'always',
+            'notification_type': 'email',
-            'notify_email': 'none',
+            'notification_type': 'inbox',
-            'notify_email': 'none',
+            'notification_type': 'inbox',
-            'notify_email': 'none',
+            'notification_type': 'inbox',
-            'notify_email': 'none',
+            'notification_type': 'inbox',
-            'notify_email': 'none',
+            'notification_type': 'inbox',
-        """
+        """ Compute recipients to notify based on specified recipients and document
-        # website modules like forum / blog / ...
+        # have a sudoed copy to manipulate partners (public can go here with website modules like forum / blog / ... )
-        channels = self.env['mail.channel'] | self.channel_ids
+        self.ensure_one()
-            partners = self_sudo.partner_ids
+            channels_sudo |= followers.mapped('channel_id')
-            partners = partners - self_sudo.author_id
+            partners_sudo = partners_sudo - self_sudo.author_id
-            'needaction_partner_ids': [(6, 0, partners.ids)]
+            'channel_ids': [(6, 0, channels_sudo.ids)],
-        channels._notify(self)
+        # those methods are called as SUPERUSER because portal users posting messages
-    def _notify_by_email(self, message, force_send=False, send_after_commit=True, user_signature=True):
+    def test_post_portal(self):
-from odoo.addons.mail.tests.common import TestMail
+from odoo.addons.mail.tests.common import BaseFunctionalTest
-class TestCrm(TestMail):
+class TestCrm(BaseFunctionalTest):
-        self.sales_team_1.message_subscribe(channel_ids=[self.group_pigs.id], subtype_ids=[subtype.id])
+        self.sales_team_1.message_subscribe(channel_ids=[self.channel_listen.id], subtype_ids=[subtype.id])
-        self.assertIn(self.group_pigs, lead.message_channel_ids)
+        self.assertIn(self.channel_listen, lead.message_channel_ids)
-        self.assertIn(self.group_pigs, msg.channel_ids)
+        self.assertIn(self.channel_listen, msg.channel_ids)
-class TestMail(common.SavepointCase):
+class BaseFunctionalTest(common.SavepointCase):
-                           model=None, target_model='mail.channel', target_field='name'):
+                           model=None, target_model='mail.test', target_field='name'):
-        TestMailGroup = cls.env['mail.channel'].with_context({
+        TestModel = cls.env['mail.test'].with_context({
-        cls.group_pigs = TestMailGroup.create({
+        cls.test_pigs = TestModel.create({
-            'name': 'Jobs',
+            'alias_contact': 'followers',
-        ).with_context({'mail_create_nosubscribe': False})
+            'alias_contact': 'everyone'
-            ('res_id', 'in', (cls.group_pigs | cls.group_public).ids)]).unlink()
+            ('res_model', '=', 'mail.test'),
-            'default_res_id': self.group_pigs.id
+            'default_res_model': 'mail.test',
-        self.assertEqual(self.group_pigs.message_partner_ids,
+        self.assertEqual(self.test_pigs.message_partner_ids,
-        self.assertEqual(self.group_pigs.message_follower_ids.mapped('channel_id'),
+        self.assertEqual(self.test_pigs.message_follower_ids.mapped('channel_id'),
-        self.assertEqual(self._mails[0].get('subject'), 'Invitation to follow Discussion channel: Pigs',
+        self.assertEqual(self._mails[0].get('subject'), 'Invitation to follow %s: Pigs' % self.env['mail.test']._description,
-        self.assertEqual(self._mails[1].get('subject'), 'Invitation to follow Discussion channel: Pigs',
+        self.assertEqual(self._mails[1].get('subject'), 'Invitation to follow %s: Pigs' % self.env['mail.test']._description,
-        self.assertIn('%s invited you to follow Discussion channel document: Pigs' % self.user_employee.name,
+        self.assertIn('%s invited you to follow %s document: Pigs' % (self.user_employee.name, self.env['mail.test']._description),
-        self.assertIn('%s invited you to follow Discussion channel document: Pigs' % self.user_employee.name,
+        self.assertIn('%s invited you to follow %s document: Pigs' % (self.user_employee.name, self.env['mail.test']._description),
-        cls.group_private = cls.env['mail.channel'].with_context({
+        # cls.registry('mail.channel')._revert_method('message_get_recipient_values')
-        }).create({
+        })
-        ).with_context({'mail_create_nosubscribe': False})
+            'public': 'private'})
-        alias = self.env['mail.alias'].with_context(alias_model_name='mail.channel').create({'alias_name': 'b4r+_#_R3wl$$'})
+        alias = self.env['mail.alias'].with_context(alias_model_name='mail.test').create({'alias_name': 'b4r+_#_R3wl$$'})
-        na_emp2_base = self.group_pigs.sudo().message_needaction_counter
+        na_emp1_base = self.test_pigs.sudo(self.user_employee).message_needaction_counter
-        self.group_pigs.message_post(body='Test', message_type='comment', subtype='mail.mt_comment', partner_ids=[self.user_employee.partner_id.id])
+        self.test_pigs.message_post(body='Test', message_type='comment', subtype='mail.mt_comment', partner_ids=[self.user_employee.partner_id.id])
-        na_emp2_new = self.group_pigs.sudo().message_needaction_counter
+        na_emp1_new = self.test_pigs.sudo(self.user_employee).message_needaction_counter
-        self.group_pigs.sudo(self.user_employee).with_context({'mail_create_nosubscribe': True}).message_post(
+        original = self.test_pigs.message_follower_ids
-        self.assertEqual(self.group_pigs.message_follower_ids.mapped('channel_id'), original.mapped('channel_id'))
+        self.assertEqual(self.test_pigs.message_follower_ids.mapped('partner_id'), original.mapped('partner_id'))
-    # TODO : the author of a message post on mail.channel should not be added as follower
+    # TODO : the author of a message post on mail.test should not be added as follower
-    #     self.group_pigs.sudo(self.user_employee).message_post(
+    #     original = self.test_pigs.message_follower_ids
-    #     self.assertEqual(self.group_pigs.message_follower_ids.mapped('channel_id'), original.mapped('channel_id'))
+    #     self.assertEqual(self.test_pigs.message_follower_ids.mapped('partner_id'), original.mapped('partner_id') | self.user_employee.partner_id)
-        self.group_pigs.sudo(self.user_employee).with_context({'mail_create_nosubscribe': True}).message_post(
+        original = self.test_pigs.message_follower_ids
-        self.assertEqual(self.group_pigs.message_follower_ids.mapped('channel_id'), original.mapped('channel_id'))
+        self.assertEqual(self.test_pigs.message_follower_ids.mapped('partner_id'), original.mapped('partner_id'))
-        self.group_pigs.sudo(self.user_employee).with_context({'mail_create_nosubscribe': True, 'mail_post_autofollow': True}).message_post(
+        original = self.test_pigs.message_follower_ids
-        self.assertEqual(self.group_pigs.message_follower_ids.mapped('channel_id'), original.mapped('channel_id'))
+        self.assertEqual(self.test_pigs.message_follower_ids.mapped('partner_id'), original.mapped('partner_id') | self.partner_1 | self.partner_2)
-        self.group_pigs.sudo(self.user_employee).with_context({'mail_create_nosubscribe': True, 'mail_post_autofollow': True, 'mail_post_autofollow_partner_ids': [self.partner_2.id]}).message_post(
+        original = self.test_pigs.message_follower_ids
-        self.assertEqual(self.group_pigs.message_follower_ids.mapped('channel_id'), original.mapped('channel_id'))
+        self.assertEqual(self.test_pigs.message_follower_ids.mapped('partner_id'), original.mapped('partner_id') | self.partner_2)
-        self.group_pigs.message_subscribe_users(user_ids=[self.env.user.id])
+        self.test_pigs.message_subscribe_users(user_ids=[self.env.user.id])
-        msg = self.group_pigs.sudo(self.user_employee).message_post(
+        msg = self.test_pigs.sudo(self.user_employee).message_post(
-        self.assertEqual(set(msg.attachment_ids.mapped('res_id')), set([self.group_pigs.id]),
+        self.assertEqual(set(msg.attachment_ids.mapped('res_model')), set(['mail.test']),
-                         set(['%s %s <%s@%s>' % (self.env.user.company_id.name, self.group_pigs.name, self.group_pigs.alias_name, _domain)]),
+                         set(['%s %s <%s@%s>' % (self.env.user.company_id.name, self.test_pigs.name, self.test_pigs.alias_name, _domain)]),
-        parent_msg = self.group_pigs.sudo(self.user_employee).message_post(
+        parent_msg = self.test_pigs.sudo(self.user_employee).message_post(
-        msg = self.group_pigs.sudo(self.user_employee).message_post(
+        msg = self.test_pigs.sudo(self.user_employee).message_post(
-        new_msg = self.group_pigs.sudo(self.user_employee).message_post(
+        self.assertTrue(all('openerp-%d-mail.test' % self.test_pigs.id in m['references'] for m in self._mails))
-        msg = self.group_pigs.sudo(self.user_employee).message_post(
+        self.test_pigs.message_subscribe_users([self.user_admin.id])
-        self.assertEqual(self.group_pigs.message_ids, msg)
+        self.assertEqual(self.test_pigs.message_ids, msg)
-        reply = self.group_pigs.message_ids - msg
+        reply = self.test_pigs.message_ids - msg
-            'default_res_id': self.group_pigs.id,
+            'default_model': 'mail.test',
-        self.assertEqual(composer.record_name, self.group_pigs.name)
+        self.assertEqual(composer.model, 'mail.test')
-        message = self.group_pigs.message_ids[0]
+        message = self.test_pigs.message_ids[0]
-            'default_res_id': self.group_pigs.id,
+            'default_res_id': self.test_pigs.id,
-        self.assertEqual(composer.res_id, self.group_pigs.id)
+        self.assertEqual(composer.model, 'mail.test')
-        self.assertEqual(composer.subject, 'Re: %s' % self.group_pigs.name)
+        self.assertEqual(composer.subject, 'Re: %s' % self.test_pigs.name)
-            'default_model': 'mail.channel',
+            'default_model': 'mail.test',
-            'active_ids': [self.group_pigs.id, self.group_public.id]
+            'active_ids': [self.test_pigs.id, self.test_public.id]
-            'active_ids': [self.group_pigs.id, self.group_public.id]
+            'active_ids': [self.test_pigs.id, self.test_public.id]
-        self.assertEqual(message1.body, '<p>%s</p>' % self.group_pigs.description)
+        # check message on test_pigs
-        self.assertEqual(message1.body, '<p>%s</p>' % self.group_public.description)
+        # check message on test_public
-        # message1 = group_pigs.message_ids[0]
+        # message1 = test_pigs.message_ids[0]
-        # self.assertEqual(set(group_pigs.message_follower_ids.ids), set([self.partner_admin_id, p_b.id, p_c.id, p_d.id]),
+        # Test: mail.test followers: author not added as follower in mass mail mode
-            'default_model': 'mail.channel',
+            'default_model': 'mail.test',
-            'active_domain': [('name', 'in', ['%s' % self.group_pigs.name, '%s' % self.group_public.name])],
+            'active_ids': [self.test_pigs.id],
-        self.assertEqual(self.group_public.message_ids[0].subject, 'From Composer Test')
+        self.assertEqual(self.test_pigs.message_ids[0].subject, 'From Composer Test')
-            'default_model': 'mail.channel',
+            'default_model': 'mail.test',
-            'active_domain': [('name', 'in', ['%s' % self.group_pigs.name, '%s' % self.group_public.name])],
+            'active_ids': [self.test_pigs.id],
-        self.assertFalse(self.group_public.message_ids.ids)
+        self.assertEqual(self.test_pigs.message_ids[0].subject, 'From Composer Test')
-        self.mt_mg_def = Subtype.create({'name': 'mt_mg_def', 'default': True, 'res_model': 'mail.channel'})
+        self.mt_mg_def = Subtype.create({'name': 'mt_mg_def', 'default': True, 'res_model': 'mail.test'})
-        self.mt_mg_nodef = Subtype.create({'name': 'mt_mg_nodef', 'default': False, 'res_model': 'mail.channel'})
+        self.mt_mg_nodef = Subtype.create({'name': 'mt_mg_nodef', 'default': False, 'res_model': 'mail.test'})
-        self.default_group_subtypes = Subtype.search([('default', '=', True), '|', ('res_model', '=', 'mail.channel'), ('res_model', '=', False)])
+        self.default_group_subtypes = Subtype.search([('default', '=', True), '|', ('res_model', '=', 'mail.test'), ('res_model', '=', False)])
-        groups = self.group_pigs | self.group_public
+        groups = self.test_pigs | self.test_public
-            'mail.channel', groups.ids,
+            'mail.test', groups.ids,
-        mail_channel_model_id = self.env['ir.model']._get('mail.channel').id
+        mail_channel_model_id = self.env['ir.model']._get('mail.test').id
-        self.env['mail.followers'].create({'partner_id': self.user_employee.partner_id.id, 'res_model_id': mail_channel_model_id, 'res_id': self.group_pigs.id})
+        mail_channel_model_id = self.env['ir.model']._get('mail.test').id
-            'mail.channel', groups.ids,
+            'mail.test', groups.ids,
-        self.assertEqual(set(specific[self.group_public.id][0][2]['subtype_ids'][0][2]), set([self.mt_mg_nodef.id]))
+        self.assertEqual(specific.keys(), [self.test_public.id])
-        self.assertTrue(self.group_pigs.sudo(self.user_employee).message_is_follower)
+        qty_followed_before = len(self.test_pigs.sudo(self.user_employee).search([('message_is_follower', '=', True)]))
-        self.assertEqual(self.group_pigs.message_follower_ids.mapped('channel_id'), self.env['mail.channel'])
+        self.test_pigs.message_subscribe_users(user_ids=[self.user_employee.id])
-            ('res_id', '=', self.group_pigs.id),
+            ('res_model', '=', 'mail.test'),
-        self.group_pigs.message_subscribe_users(user_ids=[self.user_employee.id])
+        mt_mg_def_int = self.env['mail.message.subtype'].create({'name': 'mt_mg_def', 'default': True, 'res_model': 'mail.test', 'internal': True})
-            ('res_id', '=', self.group_pigs.id),
+            ('res_model', '=', 'mail.test'),
-        self.group_pigs.message_subscribe_users(user_ids=[self.user_portal.id])
+        self.test_pigs.message_subscribe_users(user_ids=[self.user_portal.id])
-            ('res_id', '=', self.group_pigs.id),
+            ('res_model', '=', 'mail.test'),
-        self.assertEqual(self.group_pigs.message_follower_ids.mapped('channel_id'), self.env['mail.channel'])
+        self.test_pigs.sudo(self.user_employee).message_subscribe_users(subtype_ids=[self.mt_mg_nodef.id])
-            ('res_id', '=', self.group_pigs.id),
+            ('res_model', '=', 'mail.test'),
-        self.assertEqual(self.group_pigs.message_follower_ids.mapped('channel_id'), self.env['mail.channel'])
+        self.test_pigs.sudo(self.user_employee).message_subscribe_users(subtype_ids=[self.mt_mg_nodef.id])
-            ('res_id', '=', self.group_pigs.id),
+            ('res_model', '=', 'mail.test'),
-        self.assertEqual(self.group_pigs.message_follower_ids.mapped('channel_id'), self.env['mail.channel'])
+        self.test_pigs.sudo(self.user_employee).message_subscribe_users(subtype_ids=[self.mt_mg_nodef.id, self.mt_al_nodef.id])
-            ('res_id', '=', self.group_pigs.id),
+            ('res_model', '=', 'mail.test'),
-        test_channel = self.env['mail.channel'].create({
+        test_record = self.env['mail.channel'].create({
-                'res_id': test_channel.id,
+                'res_model_id': self.env['ir.model']._get('mail.test').id,
-                'channel_id': self.group_pigs.id,
+                'channel_id': test_channel.id,
-        self.mail_channel_model = self.env['ir.model']._get('mail.channel')
+        mail_test_model = self.env['ir.model']._get('mail.test')
-            'alias_model_id': self.mail_channel_model.id,
+            'alias_model_id': mail_test_model.id,
-            'alias_model_id': self.mail_test_model.id,
+            'alias_model_id': mail_channel_model.id,
-            'res_id': self.group_public.id,
+            'model': 'mail.test',
-            'message_id': '<123456-openerp-%s-mail.channel@%s>' % (self.group_public.id, socket.gethostname()),
+            'message_id': '<123456-openerp-%s-mail.test@%s>' % (self.test_public.id, socket.gethostname()),
-        self.assertEqual(len(new_groups), 1, 'message_process: a new mail.channel should have been created')
+        self.assertEqual(len(new_groups), 1, 'message_process: a new mail.test should have been created')
-        self.assertEqual(len(new_groups), 1, 'message_process: a new mail.channel should have been created')
+        self.assertEqual(len(new_groups), 1, 'message_process: a new mail.test should have been created')
-        # TODO : the author of a message post on mail.channel should not be added as follower
+        # TODO : the author of a message post on mail.test should not be added as follower
-            'alias_parent_thread_id': self.group_pigs.id})
+            'alias_parent_model_id': self.env['ir.model']._get('mail.test').id,
-        self.assertEqual(len(new_groups), 1, 'message_process: a new mail.channel should have been created')
+        self.assertEqual(len(new_groups), 1, 'message_process: a new mail.test should have been created')
-        self.group_pigs.message_subscribe(partner_ids=[self.partner_1.id])
+            'alias_parent_model_id': self.env['ir.model']._get('mail.test').id,
-        self.assertEqual(len(new_groups), 1, 'message_process: a new mail.channel should have been created')
+        self.assertEqual(len(new_groups), 1, 'message_process: a new mail.test should have been created')
-        self.alias.write({'alias_force_thread_id': self.group_public.id})
+        self.alias.write({'alias_force_thread_id': self.test_public.id})
-        self.group_public.message_subscribe(partner_ids=[self.partner_1.id])
+        self.test_public.message_subscribe(partner_ids=[self.partner_1.id])
-        self.assertEqual(len(self.group_public.message_ids), 2, 'message_process: group should contain one new message')
+        self.assertEqual(len(self.test_public.message_ids), 2, 'message_process: group should contain one new message')
-        # TODO : the author of a message post on mail.channel should not be added as follower
+        # TODO : the author of a message post on mail.test should not be added as follower
-        # self.assertEqual(self.group_public.message_partner_ids, self.partner_1 | self.partner_2,
+        # self.assertEqual(self.test_public.message_partner_ids, self.partner_1 | self.partner_2,
-        # self.assertEqual(self.group_public.message_channel_ids, self.env['mail.channel'],
+        # self.assertEqual(self.test_public.message_channel_ids, self.env['mail.test'],
-        self.assertEqual(len(self.group_public.message_ids), 2, 'message_process: group should contain one new message')
+        self.assertEqual(len(self.test_public.message_ids), 2, 'message_process: group should contain one new message')
-        self.assertEqual(len(self.group_public.message_ids), 2, 'message_process: group should contain one new message')
+        self.assertEqual(len(self.test_public.message_ids), 2, 'message_process: group should contain one new message')
-        self.assertEqual(len(self.group_public.message_ids), 2, 'message_process: group should contain one new message')
+        self.assertEqual(len(self.test_public.message_ids), 2, 'message_process: group should contain one new message')
-    @mute_logger('odoo.addons.mail.models.mail_thread', 'odoo.models')
+    # @mute_logger('odoo.addons.mail.models.mail_thread', 'odoo.models')
-            target_model='mail.test')
+            target_model='mail.channel')
-        self.assertEqual(len(self.group_public.message_ids), 1, 'message_process: group should not contain new message')
+        self.assertEqual(len(self.test_public.message_ids), 1, 'message_process: group should not contain new message')
-        self.assertEqual(len(self.group_public.message_ids), 2, 'message_process: group should contain one new message')
+        self.assertEqual(len(self.test_public.message_ids), 2, 'message_process: group should contain one new message')
-                          extra='In-Reply-To: <12321321-openerp-%d-mail.channel@%s>' % (self.group_public.id, socket.gethostname()),
+                          extra='In-Reply-To: <12321321-openerp-%d-mail.test@%s>' % (self.test_public.id, socket.gethostname()),
-            extra='In-Reply-To: <12321321-openerp-%d-mail.channel@%s>' % (self.group_public.id, socket.gethostname()))
+            extra='In-Reply-To: <12321321-openerp-%d-mail.test@%s>' % (self.test_public.id, socket.gethostname()))
-                          extra='In-Reply-To: <12321321-openerp-%d-mail.channel@neighbor.com>' % self.group_public.id)
+                          extra='In-Reply-To: <12321321-openerp-%d-mail.test@neighbor.com>' % self.test_public.id)
-        self.assertEqual(len(self.group_public.message_ids[0].child_ids), 0)
+        self.assertEqual(len(self.test_public.message_ids), 1)
-        self.alias.write({'alias_force_thread_id': self.group_public.id,})
+        self.alias.write({'alias_force_thread_id': self.test_public.id,})
-        self.assertEqual(len(self.group_public.message_ids), 2, 'message_process: message with already existing message_id should not have been duplicated')
+        self.assertEqual(len(self.test_public.message_ids), 2, 'message_process: message with already existing message_id should not have been duplicated')
-        self.group_public.message_unsubscribe([from_1.id])
+        self.assertEqual(self.test_public.message_ids[0].author_id, from_1, 'message_process: email_from -> author_id wrong')
-        self.group_public.message_unsubscribe([from_2.partner_id.id])
+        self.assertEqual(self.test_public.message_ids[0].author_id, from_2.partner_id, 'message_process: email_from -> author_id wrong')
-        self.group_public.message_subscribe([from_3.id])
+        self.test_public.message_subscribe([from_3.id])
-        self.assertEqual(self.group_public.message_ids[0].author_id, from_3, 'message_process: email_from -> author_id wrong')
+        self.assertEqual(self.test_public.message_ids[0].author_id, from_3, 'message_process: email_from -> author_id wrong')
-            MAIL_TEMPLATE, to='noone@example.com', subject='Spammy', extra='', model='mail.channel',
+            MAIL_TEMPLATE, to='noone@example.com', subject='Spammy', extra='', model='mail.test',
-                         'message_process: erroneous email but with a fallback model should have created a new mail.channel')
+                         'message_process: erroneous email but with a fallback model should have created a new mail.test')
-        self.assertEqual(len(frog_groups), 1, 'message_process: a new mail.channel should have been created')
+        self.assertEqual(len(frog_groups), 1, 'message_process: a new mail.test should have been created')
-            'thread_model': 'mail.channel'
+            'thread_model': 'mail.test'
-                         'message_post: private discussion: wrong author through mailgatewya based on email')
+                         'message_post: private discussion: wrong author through mailgateway based on email')
-        msg = self.group_pigs.sudo(self.user_employee).message_post(no_auto_thread=True, subtype='mail.mt_comment')
+        msg = self.test_pigs.sudo(self.user_employee).message_post(no_auto_thread=True, subtype='mail.mt_comment')
-        channel = self.env['mail.channel'].search([('name', "=", msg_fw.subject)])
+        channel = self.env['mail.test'].search([('name', "=", msg_fw.subject)])
-        self.assertEqual(msg_fw.model, 'mail.channel')
+        self.assertEqual(msg_fw.model, 'mail.test')
-        channel = self.env['mail.channel'].search([('name', "=", msg_fw.subject)])
+        channel = self.env['mail.test'].search([('name', "=", msg_fw.subject)])
-        self.assertEqual(msg_fw.model, 'mail.channel')
+        self.assertEqual(msg_fw.model, 'mail.test')
-        self.assertTrue(msg_fw.res_id == self.group_public.id)
+        self.assertTrue(msg_fw.res_id == self.test_public.id)
-            'res_id': self.group_pigs.id
+            'model': 'mail.test',
-        self.assertIn('-openerp-%d-mail.channel' % self.group_pigs.id, msg.message_id, 'mail_message: message_id for a void message should be a "private" one')
+        self.assertIn('-openerp-%d-mail.test' % self.test_pigs.id, msg.message_id, 'mail_message: message_id for a void message should be a "private" one')
-            'res_id': self.group_pigs.id
+            'model': 'mail.test',
-        self.assertEqual(msg.reply_to, '%s %s <%s@%s>' % (self.env.user.company_id.name, self.group_pigs.name, self.group_pigs.alias_name, alias_domain))
+        self.assertIn('-openerp-%d-mail.test' % self.test_pigs.id, msg.message_id, 'mail_message: message_id for a void message should be a "private" one')
-            'res_id': self.group_pigs.id
+            'model': 'mail.test',
-        self.assertEqual(msg.reply_to, '%s %s <%s@%s>' % (self.env.user.company_id.name, self.group_pigs.name, self.group_pigs.alias_name, alias_domain))
+        self.assertIn('-openerp-%d-mail.test' % self.test_pigs.id, msg.message_id, 'mail_message: message_id for a void message should be a "private" one')
-            'res_id': self.group_pigs.id,
+            'model': 'mail.test',
-        self.assertNotIn('-%d-' % self.group_pigs.id, msg.message_id)
+        self.assertNotIn('mail.test', msg.message_id)
-        msg = self.group_pigs.message_post(body='My Body', subject='1')
+        msg = self.test_pigs.message_post(body='My Body', subject='1')
-        self.assertEqual(len(self.group_pigs.message_ids), msg_cnt + 1)
+        msg_cnt = len(self.test_pigs.message_ids)
-    _inherit = ['mail.thread']
+    # _mail_flat_thread = False
-        'mail.alias', 'Alias')
+        'mail.alias', 'Alias',
-            'model_id': self.env['ir.model']._get('mail.channel').id,
+            'model_id': self.env['ir.model']._get('mail.test').id,
-            'default_res_id': self.group_pigs.id,
+            'default_model': 'mail.test',
-        values = composer.onchange_template_id(self.email_template.id, 'comment', 'mail.channel', self.group_pigs.id)['value']
+        values = composer.onchange_template_id(self.email_template.id, 'comment', 'mail.test', self.test_pigs.id)['value']
-        self.assertEqual(values['body'], '<p>%s</p>' % self.group_pigs.description)
+        self.assertEqual(values['subject'], self.test_pigs.name)
-        self.group_pigs.with_context(use_template=False).message_post_with_template(self.email_template.id, composition_mode='comment')
+        self.test_pigs.with_context(use_template=False).message_post_with_template(self.email_template.id, composition_mode='comment')
-        message = self.group_pigs.message_ids[0]
+        message = self.test_pigs.message_ids[0]
-        self.assertEqual(message.body, '<p>%s</p>' % self.group_pigs.description)
+        self.assertEqual(message.subject, self.test_pigs.name)
-        self.assertEqual(set(message.attachment_ids.mapped('res_id')), set([self.group_pigs.id]))
+        self.assertEqual(set(message.attachment_ids.mapped('res_model')), set(['mail.test']))
-            'default_res_id': self.group_pigs.id,
+            'default_model': 'mail.test',
-            'active_ids': [self.group_pigs.id, self.group_public.id]
+            'active_ids': [self.test_pigs.id, self.test_public.id]
-        values = composer.onchange_template_id(self.email_template.id, 'mass_mail', 'mail.channel', self.group_pigs.id)['value']
+        values = composer.onchange_template_id(self.email_template.id, 'mass_mail', 'mail.test', self.test_pigs.id)['value']
-        message_2 = self.group_public.message_ids[0]
+        message_1 = self.test_pigs.message_ids[0]
-        self.assertIn(self.group_public.description, message_2.body, 'mail.message body on Bird incorrect')
+        self.assertEqual(message_1.subject, self.test_pigs.name, 'mail.message subject on Pigs incorrect')
-        mail_id = self.email_template.send_mail(self.group_pigs.id)
+        mail_id = self.email_template.send_mail(self.test_pigs.id)
-        self.assertEqual(mail.subject, self.group_pigs.name)
+        self.assertEqual(mail.subject, self.test_pigs.name)
-            'active_ids': [self.group_pigs.id, self.group_public.id]
+            'default_model': 'mail.test',
-        }).with_context({'default_model': 'mail.channel'}).save_as_template()
+        }).with_context({'default_model': 'mail.test'}).save_as_template()
-        last_template = self.env['mail.template'].search([('model', '=', 'mail.channel'), ('subject', '=', 'Forget me subject')], limit=1)
+        last_template = self.env['mail.template'].search([('model', '=', 'mail.test'), ('subject', '=', 'Forget me subject')], limit=1)
-        mail_in_2_days_id = self.email_template_in_2_days.send_mail(self.group_pigs.id)
+        mail_now_id = self.email_template.send_mail(self.test_pigs.id)
-        last_msg = self.group_pigs.message_ids[-1]
+        test_channel.sudo(self.user_employee).write({'name': 'my_name'})
-        self.assertEqual(last_msg.tracking_value_ids.old_value_char, 'Pigs')
+        self.assertEqual(last_msg.tracking_value_ids.old_value_char, 'Test')
-        last_msg = self.group_pigs.message_ids[0]
+        test_channel.sudo(self.user_employee).write({'name': 'supername', 'public': 'private'})
-        last_msg = self.group_pigs.message_ids[0]
+        test_channel.sudo(self.user_employee).write({'public': 'public', 'group_public_id': group_system.id})
-        port_msg = self.group_pigs.message_post(body='Message')
+        test_channel = self.env['mail.channel'].create({
-        self.group_pigs.sudo(self.user_portal).message_post(body='I love Pigs', message_type='comment', subtype='mail.mt_comment')
+        test_channel.sudo(self.user_portal).message_post(body='I love Pigs', message_type='comment', subtype='mail.mt_comment')
-            'default_res_id': self.group_pigs.id
+            'default_res_id': test_channel.id
-        group_pigs = self.group_pigs
+        test_record = self.env['mail.test'].create({'name': 'Pigs'})
-            'default_res_id': group_pigs.id}).create({
+            'default_res_model': 'mail.test',
-        self.assertEqual(group_pigs.message_partner_ids, partner_carine)
+        self.assertIn(partner_carine, test_record.message_partner_ids)
-                sent_email.get('subject'), 'Invitation to follow Discussion channel: Pigs',
+                sent_email.get('subject'), 'Invitation to follow %s: Pigs' % self.env['mail.test']._description,
-                'Administrator invited you to follow Discussion channel document: Pigs', sent_email.get('body'),
+                'Administrator invited you to follow %s document: Pigs' % self.env['mail.test']._description, sent_email.get('body'),
-        google_maps_api_key = self.env['ir.config_parameter'].get_param('google_maps_api_key', default='')
+        if not self.user_has_groups('website.group_website_designer'):
-        self.env['ir.config_parameter'].set_param('google_maps_api_key', (self.google_maps_api_key or '').strip())
+        if not self.user_has_groups('website.group_website_designer'):
-            day = fields.Date.to_string(datetime_day)
+
-            ], limit=1).holiday_status_id.name
+                ('date_from', '<=', date_from),
-                            }
+                working_intervals_on_day = contract.working_hours.get_working_intervals_of_day(start_dt=day_from + timedelta(days=day))
-                        attendances['number_of_hours'] += working_hours_on_day
+                        leaves[holiday.holiday_status_id.name] = {
-            res += [attendances] + leaves
+            for data in [attendances] + leaves:
-                if child_task.stage_id and not child_task.stage_id.fold:
+                if child_task.stage_id and child_task.stage_id.fold:
-                    task.children_hours += child_task.effective_hours + child_task.children_hours
+                    children_hours += child_task.effective_hours + child_task.children_hours
-                    task.children_hours += max(child_task.planned_hours, child_task.effective_hours + child_task.children_hours)
+                    children_hours += max(child_task.planned_hours, child_task.effective_hours + child_task.children_hours)
-    @api.depends('timesheet_ids.unit_amount', 'planned_hours', 'child_ids.stage_id',
+    @api.depends('stage_id', 'timesheet_ids.unit_amount', 'planned_hours', 'child_ids.stage_id',
-from werkzeug import url_encode
+from werkzeug import url_encode, unescape
-            vals['url'] = long_url
+            vals['url'] = unescape(long_url)
-        partner = self.create({self._rec_name: name or email, 'email': email or False})
+        partner = self.create({self._rec_name: name or email, 'email': email or self.env.context.get('default_email', False)})
-        partner_ids = message_dict.pop('partner_ids', [])
+        original_partner_ids = message_dict.pop('partner_ids', [])
-            if partner_ids:
+            # replies to internal message are considered as notes, but parent message
-                new_msg.write({'partner_ids': partner_ids})
+                new_msg.write({'partner_ids': original_partner_ids})
-        self.assertEqual(reply.needaction_partner_ids, self.env['res.partner'])
+        self.assertEqual(reply.needaction_partner_ids, self.user_employee.partner_id)
-        product_ids = self.product_variant_ids.ids
+        product_ids = self.with_context(active_test=False).product_variant_ids.ids
-            localdict['categories'].dict[category.code] = category.code in localdict['categories'].dict and localdict['categories'].dict[category.code] + amount or amount
+            if category.code in localdict['categories'].dict:
-        payment = self.env['account.payment'].create({
+    def get_payment_vals(self):
-        })
+        }
-            record.rating_count = result[record.id]
+            record.rating_count = result.get(record.id)
-            for partner_id in ids
+            partner_id.id: Claim.search_count(cr,uid, ['|', ('partner_id', 'in', partner_id.child_ids.ids), ('partner_id', '=', partner_id.id)], context=context)
-                company.fax = partner.fax
+                company.write(company._get_company_address_fields(partner))
-                if float_compare(diff_quantity, 0.0, precision_rounding=line.product_uom.rounding) > 0:
+                if float_compare(procurement_qty, 0.0, precision_rounding=procurement.product_uom.rounding) > 0 and float_compare(diff_quantity, 0.0, precision_rounding=line.product_uom.rounding) > 0:
-    @api.model
+    @api.multi
-        product_currency = (product.company_id and product.company_id.currency_id) or self.pool['res.users'].browse(cr, uid, uid).company_id.currency_id
+        product_currency = product_currency or (product.company_id and product.company_id.currency_id) or self.pool['res.users'].browse(cr, uid, uid).company_id.currency_id
-            if self.state not in ['confirm', 'validate', 'validate1']:
+            if holiday.state not in ['confirm', 'validate', 'validate1']:
-            if (not products) or (len(templates) > limit):
+            if (not products) or (limit and (len(templates) > limit)):
-        track_visibility='onchange',
+        track_visibility='onchange', ondelete='restrict',
-    route_id = fields.Many2one('stock.location.route', string='Route', domain=[('sale_selectable', '=', True)])
+    route_id = fields.Many2one('stock.location.route', string='Route', domain=[('sale_selectable', '=', True)], ondelete='restrict')
-    route_id = fields.Many2one('stock.location.route', 'Route', help="If route_id is False, the rule is global")
+    route_id = fields.Many2one('stock.location.route', 'Route', required=True, ondelete='cascade')
-    route_id = fields.Many2one('stock.location.route', 'Route')
+    route_id = fields.Many2one('stock.location.route', 'Route', required=True, ondelete='cascade')
-    push_rule_id = fields.Many2one('stock.location.path', 'Push Rule', help='The push rule that created this stock move')
+    rule_id = fields.Many2one('procurement.rule', 'Procurement Rule', ondelete='restrict', help='The procurement rule that created this stock move')
-                
+
-        
+
-    delivery_route_id = fields.Many2one('stock.location.route', 'Delivery Route')
+    crossdock_route_id = fields.Many2one('stock.location.route', 'Crossdock Route', ondelete='restrict')
-        ('direct', 'Partial'), ('one', 'All at once')], 'Delivery Type',
+        ('direct', 'Partial'), ('one', 'All at once')], 'Shipping Policy',
-             "a Manufacturing Order for that product using a BoM of the same picking type. That allows "
+        'stock.picking.type', 'Operation Type', domain=[('code', '=', 'mrp_operation')],
-        'stock.picking.type', 'Picking Type',
+        'stock.picking.type', 'Operation Type',
-        only_create = False  # Check picking type in theory
+        only_create = False  # Check operation type in theory
-        'stock.picking.type', 'Manufacturing Picking Type',
+        'stock.picking.type', 'Manufacturing Operation Type',
-    picking_type_id = fields.Many2one('stock.picking.type', string='Picking Type')
+    picking_type_id = fields.Many2one('stock.picking.type', string='Operation Type')
-    picking_type_id = fields.Many2one('stock.picking.type', related='session_id.config_id.picking_type_id', string="Picking Type")
+    picking_type_id = fields.Many2one('stock.picking.type', related='session_id.config_id.picking_type_id', string="Operation Type")
-        help="This will determine picking type of incoming shipment")
+        help="This will determine operation type of incoming shipment")
-        #override the context to get rid of the default filtering on picking type
+        #override the context to get rid of the default filtering on operation type
-    picking_type_id = fields.Many2one('stock.picking.type', 'Picking Type', required=True, default=_get_picking_in)
+    picking_type_id = fields.Many2one('stock.picking.type', 'Operation Type', required=True, default=_get_picking_in)
-        'stock.picking.type', 'Picking Type',
+        'stock.picking.type', 'Operation Type',
-        help="Picking Type determines the way the picking should be shown in the view, reports, ...")
+        help="Operation Type determines the way the picking should be shown in the view, reports, ...")
-        picking types of the warehouses, so they won't appear in the dashboard.
+        operation types of the warehouses, so they won't appear in the dashboard.
-        help="This is the picking type that will be put on the stock moves")
+        'stock.picking.type', 'Operation Type', required=True,
-    picking_type_id = fields.Many2one('stock.picking.type', 'Picking Type')
+    picking_type_id = fields.Many2one('stock.picking.type', 'Operation Type')
-    _description = "The picking type determines the picking view"
+    _description = "The operation type determines the picking view"
-    name = fields.Char('Picking Type Name', required=True, translate=True)
+    name = fields.Char('Operation Types Name', required=True, translate=True)
-        help="This is the default source location when you create a picking manually with this picking type. It is possible however to change it or that the routes put another location. If it is empty, it will check for the supplier location on the partner. ")
+        help="This is the default source location when you create a picking manually with this operation type. It is possible however to change it or that the routes put another location. If it is empty, it will check for the supplier location on the partner. ")
-        help="This is the default destination location when you create a picking manually with this picking type. It is possible however to change it or that the routes put another location. If it is empty, it will check for the customer location on the partner. ")
+        help="This is the default destination location when you create a picking manually with this operation type. It is possible however to change it or that the routes put another location. If it is empty, it will check for the customer location on the partner. ")
-    return_picking_type_id = fields.Many2one('stock.picking.type', 'Picking Type for Returns')
+    return_picking_type_id = fields.Many2one('stock.picking.type', 'Operation Type for Returns')
-        help="If this is checked, you will be able to choose the Lots/Serial Numbers. You can also decide to not put lots in this picking type.  This means it will create stock with no lot or not put a restriction on the lot taken. ")
+        help="If this is checked, you will be able to choose the Lots/Serial Numbers. You can also decide to not put lots in this operation type.  This means it will create stock with no lot or not put a restriction on the lot taken. ")
-        'stock.picking.type', 'Picking Type',
+        'stock.picking.type', 'Operation Type',
-        # create sequences and picking types
+        # create sequences and operation types
-        # choose the next available color for the picking types of this warehouse
+        # choose the next available color for the operation types of this warehouse
-        # change the default source and destination location and (de)activate picking types
+        # change the default source and destination location and (de)activate operation types
-        # Change basic picking type not to get lots
+        # Change basic operation type not to get lots
-This module adds a pre-configured Drop Shipping picking type
+This module adds a pre-configured Drop Shipping operation type
-    @api.onchange('employee_id', 'date_from')
+    @api.onchange('employee_id', 'date_from', 'date_to')
-                               until=(end_dt + timedelta(days=1)).replace(hour=0, minute=0, second=0),
+        for day in rrule.rrule(rrule.DAILY,
-                diff_quantity -= min(procurement_qty, diff_quantity)
+                if float_compare(diff_quantity, 0.0, precision_rounding=line.product_uom.rounding) > 0:
-    last_login = fields.Datetime(related='user_id.login_date', string='Latest Connection', readonly=True)
+            'maintenance_team_id': self.maintenance_team_id.id,
-        'name': lambda obj, cr, uid, context: obj.pool.get('ir.sequence').next_by_code(cr, uid, 'pos.order.line', context=context),
+    sequence_line_id = fields.Many2one('ir.sequence', string='Order Line IDs Sequence', readonly=True,
-        IrSequence.create(val)
+        values['sequence_line_id'] = IrSequence.create(val).id
-        for pos_config in self.filtered(lambda pos_config: pos_config.sequence_id):
+        for pos_config in self.filtered(lambda pos_config: pos_config.sequence_id or pos_config.sequence_line_id):
-        process_line = partial(self.env['pos.order.line']._order_line_fields)
+        process_line = partial(self.env['pos.order.line']._order_line_fields, session_id=ui_order['pos_session_id'])
-    def _order_line_fields(self, line):
+    def _order_line_fields(self, line, session_id=None):
-    name = fields.Char(string='Line No', required=True, copy=False, default=lambda self: self.env['ir.sequence'].next_by_code('pos.order.line'))
+    name = fields.Char(string='Line No', required=True, copy=False)
-    @api.depends('invoice_line_ids.price_subtotal', 'tax_line_ids.amount', 'currency_id', 'company_id', 'date_invoice')
+    @api.depends('invoice_line_ids.price_subtotal', 'tax_line_ids.amount', 'currency_id', 'company_id', 'date_invoice', 'type')
-            return ir_model_data._update(model, template_xmlid.module, vals, xml_id=new_xml_id, store=True, noupdate=True, mode='init', res_id=False)
+        new_xml_id = str(company.id)+'_'+template_xmlid.name
-        'data/account_chart_template_data.yml',
+        'data/account_chart_template_data.yml',
-        pricelist.currency_id = base_company.currency_id
+        pricelist = self.pricelist_model.search([('name', '=', 'Public Pricelist')])[0]
-        return ir_model_data._update(model, template_xmlid.module, vals, xml_id=new_xml_id, store=True, noupdate=True, mode='init', res_id=False)
+        if template_xmlid:
-        pricelist = self.pricelist_model.search([('name', '=', 'Public Pricelist')])[0]
+        pricelist = self.pricelist_model.search([('name', '=', 'Public Pricelist')])[0].copy()
-                with db_registry.cursor() as cr:
+                with api.Environment.manage(), db_registry.cursor() as cr:
-# Copyright (C) 2016 ONESTEiN BV (<http://www.onestein.eu>).
+# Copyright (C) 2016 Onestein (<http://www.onestein.eu>).
-# Copyright (C) 2016 ONESTEiN BV (<http://www.onestein.eu>).
+# Copyright (C) 2016 Onestein (<http://www.onestein.eu>).
-    'author': 'ONESTEiN BV',
+    'author': 'Onestein',
-                partner = company.partner_id.browse(address_data['contact'])
+                partner = company.partner_id.browse(address_data['contact']).sudo()
-        """
+    ## The get_assets_editor_resources route is in charge of transmitting the resources the assets
-        return views.read(['name', 'id', 'key', 'xml_id', 'arch', 'active', 'inherit_id'])
+        views = views.read(['name', 'id', 'key', 'xml_id', 'arch', 'active', 'inherit_id'])
-    def customize_template_get(self, key, full=False, bundles=False):
+    @http.route('/web_editor/get_assets_editor_resources', type='json', auth='user', website=True)
-        return request.env["ir.ui.view"].customize_template_get(key, full=full, bundles=bundles)
+        views = request.env["ir.ui.view"].get_related_views(key, bundles=bundles)
-    def customize_template_get(self, key, full=False, bundles=False):
+    def get_related_views(self, key, bundles=False):
-        return views.read(['name', 'id', 'key', 'xml_id', 'arch', 'active', 'inherit_id'])
+        user_groups = set(self.env.user.groups_id)
-                return self._ir_attach['datas'].decode('base64')
+                return self._ir_attach['datas'].decode('base64').decode('utf-8')
-                    self.preprocess_css(debug=debug)
+                is_css_preprocessed, old_attachments = self.is_css_preprocessed()
-                        self.stylesheets.append(StylesheetAsset(self, inline=self.css_message(msg)))
+                        response.append(JavascriptAsset(self, inline=self.dialog_message(msg)).to_html())
-                else:
+                css_attachments = self.css() or []
-                        response.append(style.to_html())
+                    response.append(JavascriptAsset(self, inline=self.dialog_message(msg)).to_html())
-    def get_attachments(self, type):
+    def get_attachments(self, type, ignore_version=False):
-        url_pattern = '/web/content/%-{0}/{1}{2}.{3}'.format(self.version, self.name, '.%' if type == 'css' else '', type)
+        version = "%" if ignore_version else self.version
-                return
+                return self.get_attachments('css', ignore_version=True)
-        message = message.replace('\n', '\\A ').replace('"', '\\"')
+    def dialog_message(self, message):
-        """ % message
+            (function (message) {
-        return preprocessed
+        return preprocessed, attachments
-    def preprocess_css(self, debug=False):
+    def preprocess_css(self, debug=False, old_attachments=None):
-        "data/account_chart_template_data.yml",
+        "data/account_chart_template_data.yml",
-                               """, (uid,))
+                    company = int(kw['company']) if kw and kw.get('company') else False
-        return journal.currency_id or journal.company_id.currency_id
+        return journal.currency_id or journal.company_id.currency_id or self.env.user.company_id.currency_id
-        """ Prepare the dict of values to create the move line from a statement line.
+        """ Prepare the dict of values to balance the move.
-                amount_currency = self.amount_currency * ratio
+        st_line_currency_rate = self.currency_id and (self.amount_currency / self.amount) or False
-            # This leaves out the amount already reconciled and avoids rounding errors from currency conversion
+            # Balance the move
-                order_data = self.env['report.pos.order'].read_group(
+                # locale en_GB is used to be able to obtain the datetime from the string returned by read_group
-                        # for example 2016-12-31 -> week number 53 from read_group, while both isocalendar() and strftime('%W') return 52.
+import hashlib
-from odoo.tools import float_round, image_resize_images
+from odoo.tools import consteq, float_round, image_resize_images, ustr
-            self.env['my.model'].payment_validated(self)""", oldname="s2s_cb_eval", groups="base.group_system")
+    callback_model_id = fields.Many2one('ir.model', 'Callback Document Model', groups="base.group_system")
-                    safe_eval(self.callback_eval, {'self': self})
+                if init_state != 'authorized':
-                    safe_eval(self.callback_eval, {'self': self})
+                self.execute_callback()
-                safe_eval(self.callback_eval, {'self': self})
+            self.execute_callback()
-                safe_eval(self.callback_eval, {'self': self})
+            self.execute_callback()
-                safe_eval(self.callback_eval, {'self': self})
+            self.execute_callback()
-                'callback_eval': "self.sale_order_id._confirm_online_quote(self)"
+                'callback_model_id': request.env['ir.model'].sudo().search([('model', '=', Order._name)], limit=1).id,
-    module_web_clearbit = fields.Boolean("Clearbit")
+    module_web_clearbit = fields.Boolean("Company Research")
-    module_sale_coupon = fields.Boolean("Manage coupons and promotional offers")
+    module_sale_coupon = fields.Boolean("Discount Programs")
-            return "AND state = 'paid'"
+            return "AND state in ('open', 'paid')"
-                        prod_re[prod] = re_ind
+                        prod_re[prod.id] = re_ind
-        payment_currency = self.currency_id or self.journal_id.currency_id or self.journal_id.company_id.currency_id
+        payment_currency = self.currency_id or self.journal_id.currency_id or self.journal_id.company_id.currency_id or self.env.user.company_id.currency_id
-            'name': _('Choose Your Report Layout'),
+            'name': _('Choose Your Document Layout'),
-                'name': _('Choose Your Report Layout'),
+                'name': _('Choose Your Document Layout'),
-    ], string='Report Template')
+    ], string='Document Template')
-                pricelist = self.env['product.pricelist'].name_search(pricelist_id_or_name, operator='=', limit=1)
+                pricelist_name_search = self.env['product.pricelist'].name_search(pricelist_id_or_name, operator='=', limit=1)
-            users = self._get_challenger_users(vals.get('user_domain'))
+            users = self._get_challenger_users(ustr(vals.get('user_domain')))
-            users = self._get_challenger_users(vals.get('user_domain'))
+            users = self._get_challenger_users(ustr(vals.get('user_domain')))
-    _description = "Point of Sale"
+    _description = "Point of Sale Orders"
-            finish_moves.action_cancel()
+            raw_moves = production.move_raw_ids.filtered(lambda x: x.state not in ('done', 'cancel'))
-            procurements = ProcurementOrder.search([('move_dest_id', 'in', finish_moves.ids)])
+            procurements = ProcurementOrder.search([('move_dest_id', 'in', (finish_moves | raw_moves).ids)])
-        default='code', required=True,  # set default to write ?
+        default='object_write', required=True,
-            self.filter_pre_id = self.filter_pre_domain = self.trg_date_id = self.trg_date_range = self.trg_date_range_type = False
+            self.filter_pre_domain = self.trg_date_id = self.trg_date_range = self.trg_date_range_type = False
-        self.filter_domain = self.filter_id.domain
+            self.filter_pre_domain = False
-        elif self.filter_pre_domain and records:
+        if self.filter_pre_domain and records:
-        elif self.filter_domain and records:
+        if self.filter_domain and records:
-                    context['lang'] = self.env['res.users'].browse(user_id).lang
+        request._cr = None
-            move_line = self.env['account.move.line'].with_context(ctx).create(voucher.first_move_line_get(move.id, company_currency, current_currency))
+            move_line = self.env['account.move.line'].with_context(ctx).create(voucher.with_context(ctx).first_move_line_get(move.id, company_currency, current_currency))
-                d.update(data_dict[d['id']])
+        self._read_group_resolve_many2one_fields(fetched_data, annotated_groupbys)
-        counts = dict((data['team_id'][0], data['team_id_count']) for data in leads_data)
+        counts = {datum['team_id'][0]: datum['team_id_count'] for datum in leads_data}
-        opportunity_data = self.env['crm.opportunity.report'].read_group([
+        opportunity_data = self.env['crm.lead'].read_group([
-        amounts = dict((data['team_id'][0], data['expected_revenue']) for data in opportunity_data)
+        ], ['planned_revenue', 'probability', 'team_id'], ['team_id'])
-    order_line = fields.One2many('sale.order.line', 'order_id', string='Order Lines', states={'cancel': [('readonly', True)], 'done': [('readonly', True)]}, copy=True)
+    order_line = fields.One2many('sale.order.line', 'order_id', string='Order Lines', states={'cancel': [('readonly', True)], 'done': [('readonly', True)]}, copy=True, auto_join=True)
-            self.browse(rec['team_id'][0]).quotations_count += 1
+        non_website_teams = self.filtered(lambda team: team.team_type != 'website')
-        amounts = self.env['sale.report'].read_group([
+        sale_order_data = self.env['sale.order'].read_group([
-            self.browse(rec['team_id'][0]).sales_to_invoice_count += 1
+            ('order_line.qty_to_invoice', '>', 0),
-            team.invoiced = sum(invoices.mapped('amount_untaxed_signed'))
+        invoice_data = self.env['account.invoice'].read_group([
-                        team.pending_payment_transactions_amount += line_currency.compute(line['amount'], self.env.user.company_id.currency_id)
+            payment_data = self.env['payment.transaction'].read_group([
-    sale_order_id = fields.Many2one('sale.order', string='Sales Order')
+    sale_order_id = fields.Many2one('sale.order', string='Sales Order', auto_join=True)
-        string='Number of transactions to capture', readonly=True)
+        string='Number of Abandoned Carts', readonly=True)
-        string='Amount of transactions to capture', readonly=True)
+        string='Amount of Abandoned Carts', readonly=True)
-            team.abandoned_carts_amount = amounts.get(team.id, 0)
+        if website_teams:
-            if not line.reconciled:
+            if not line.full_reconcile_id:
-        move_lines.with_context(skip_full_reconcile_check='amount_currency_excluded', manual_full_reconcile_currency=currency).reconcile()
+        #So we force the reconciliation in company currency only at first
-        #So we force the reconciliation in company currency only at first, then in second pass the amounts in secondary currency.
+        #So we force the reconciliation in company currency only at first,
-        writeoff = move_lines.with_context(context).reconcile(self.writeoff_acc_id, self.journal_id)
+        writeoff = move_lines_filtered.with_context(context).reconcile(self.writeoff_acc_id, self.journal_id)
-        (move_lines + writeoff).compute_full_after_batch_reconcile()
+        if not isinstance(writeoff, bool):
-        domain += ['|', ('website_id', '=', website_id), ('website_id', '=', False)]
+        website = request.env['website'].get_current_website()
-        self.env['ir.values'].set_default('event.config.settings', 'auto_confirmation', False)
+        self.env['ir.values'].set_default('event.config.settings', 'default_auto_confirmation', False)
-        self.env['ir.values'].set_default('event.config.settings', 'auto_confirmation', True)
+        self.env['ir.values'].set_default('event.config.settings', 'default_auto_confirmation', True)
-        self.auto_confirm = self.env['ir.values'].get_default('event.config.settings', 'auto_confirmation')
+        self.auto_confirm = self.env['ir.values'].get_default('event.config.settings', 'default_auto_confirmation')
-            else:
+            elif move.product_id.uom_id and move.product_uom:
-        return babel.dates.format_date(date, format=pattern, locale=locale)
+        return tools.format_date(env, date, date_format=pattern)
-        return date.strftime(pattern)
+        return date
-from odoo.tools import html_escape as escape, posix_to_ldml, safe_eval, float_utils
+from odoo.tools import html_escape as escape, posix_to_ldml, safe_eval, float_utils, format_date
-        return babel.dates.format_date(value, format=pattern, locale=locale)
+        return format_date(self.env, value, date_format=(options or {}).get('format'))
-        'Quantity Available', compute="_qty_available", store=True,
+        'Quantity Available', compute="_qty_available",
-            total_residual_company_signed = self._compute_total_invoices_amount()
+            total_residual_company_signed = sum(invoice.residual_company_signed for invoice in self.invoice_ids)
-            if line_currency != company_currency and target_currency != company_currency:
+            if line_currency != company_currency and target_currency == line_currency:
-            if line_currency != target_currency and target_currency != company_currency:
+                currency = company_currency
-                actual_credit = line_currency.with_context(ctx).compute(actual_credit, target_currency)
+                total_amount = currency.with_context(ctx).compute(total_amount, target_currency)
-            raise UserError(_("Invoice must be in draft or Pro-forma state in order to validate it."))
+        if to_open_invoices.filtered(lambda inv: inv.state != 'draft'):
-            raise UserError(_("Invoice must be in draft, Pro-forma or open state in order to be cancelled."))
+        if self.filtered(lambda inv: inv.state not in ['draft', 'open']):
-                if result.get('state') in ['draft', 'proforma', 'proforma2']:
+                if result.get('state') == 'draft':
-                    raise UserError(_('Cannot refund draft/proforma/cancelled invoice.'))
+                if inv.state in ['draft', 'cancel']:
-                raise UserError(_("Selected invoice(s) cannot be confirmed as they are not in 'Draft' or 'Pro-Forma' state."))
+            if record.state != 'draft':
-            if istate in ('draft', 'proforma'):
+            if istate == 'draft':
-                            elif  (mstate == 'draft' or mstate == 'proforma') and s != 0 and s != 1:
+                            elif mstate == 'draft' and s != 0 and s != 1:
-        ctx.update({
+        ctx = {
-        })
+            'custom_layout': "sale.mail_template_data_notification_email_sale_order",
-        default=lambda self: getattr(self.env.ref('stock.warehouse0', raise_if_not_found=False) or self.env['stock.warehouse'], 'lot_stock_id').id)
+        default=_default_location_id)
-                                load_openerp_module, runs_post_install
+from odoo.modules.module import adapt_version, initialize_sys_path, load_openerp_module
-        # STEP 9: Run the post-install tests
+        # STEP 9: save installed/updated modules for post-install tests
-            _logger.log(25, "All post-tested in %.2fs, %s queries", time.time() - t0, odoo.sql_db.sql_counter - t0_sql)
+        self.updated_modules = []       # installed/updated modules
-    test_file = config['test_file']
+
-            if test_file:
+            if config['test_file']:
-        self.registry.enter_test_mode()
+        if self.registry_test_mode:
-            SELECT min(%(table)s.id) AS id, count(%(table)s.id) AS %(count_field)s %(extra_fields)s
+            SELECT min("%(table)s".id) AS id, count("%(table)s".id) AS "%(count_field)s" %(extra_fields)s
-        context['no_round_hours'] = True
+        context = dict(context, no_round_hours=True)
-        'name': fields.char('Level Name'),
+        'name': fields.char('Level Name', translate=True),
-            return self.parent_id._get_full_name(level - 1) + MENU_ITEM_SEPARATOR + self.name
+            return self.parent_id._get_full_name(level - 1) + MENU_ITEM_SEPARATOR + (self.name or "")
-                SUM(price_unit_on_quant * quantity) / SUM(quantity) as price_unit_on_quant,
+                COALESCE(SUM(price_unit_on_quant * quantity) / NULLIF(SUM(quantity), 0), 0) as price_unit_on_quant,
-    @api.multi
+    @api.depends('state', 'product_uom_qty', 'reserved_availability')
-                move.quantity_available = move.reserved_availability
+                move.quantity_available = move.product_id.uom_id._compute_quantity(move.reserved_availability, move.product_uom)
-        'Quantity Available', compute="_qty_available",
+        'Quantity Available', compute="_qty_available", store=True,
-    module_purchase_requisition = fields.Boolean("Calls for Tenders")
+    module_purchase_requisition = fields.Boolean("Purchase Agreements")
-    'name': 'Purchase Requisitions',
+    'name': 'Purchase Agreements',
-This module allows you to manage your Purchase Requisition.
+This module allows you to manage your Purchase Agreements.
-keep track and order all your purchase orders.
+Manage calls for tenders and blanket orders. Calls for tenders are used to get
-        ], string="Pricelists")
+        ], default='percentage', string="Pricelists")
-    sale_pricelist_setting_split_1 = fields.Boolean(default=0, string="Multiple Prices per Products")
+    sale_pricelist_setting_split_1 = fields.Boolean(default=0, string="Multiple Prices per Product")
-        generate_alias_name = self.env['ir.values'].get_default('sales.config.settings', 'generate_sales_team_alias')
+        generate_alias_name = self.env['ir.values'].get_default('sale.config.settings', 'generate_sales_team_alias')
-            'generate_sales_team_alias': self.env['ir.values'].get_default('sales.config.settings', 'generate_sales_team_alias')
+            'generate_sales_team_alias': self.env['ir.values'].get_default('sale.config.settings', 'generate_sales_team_alias')
-        IrValues.set_default('sales.config.settings', 'generate_sales_team_alias', self.generate_sales_team_alias)
+        IrValues.set_default('sale.config.settings', 'generate_sales_team_alias', self.generate_sales_team_alias)
-        sale_pricelist_setting = self.env['ir.values'].get_default('sales.config.settings', 'sale_pricelist_setting')
+        sale_pricelist_setting = self.env['ir.values'].get_default('sale.config.settings', 'sale_pricelist_setting')
-        return self.env['ir.values'].sudo().set_default('sales.config.settings', 'sale_pricelist_setting', self.sale_pricelist_setting)
+        return self.env['ir.values'].sudo().set_default('sale.config.settings', 'sale_pricelist_setting', self.sale_pricelist_setting)
-    def _get_purchase_order_date(self, schedule_date):
+    def _get_purchase_order_date(self, partner, schedule_date):
-        return schedule_date - relativedelta(days=seller_delay)
+
-        purchase_date = self._get_purchase_order_date(schedule_date)
+        purchase_date = self._get_purchase_order_date(partner, schedule_date)
-    def _get_date_planned(self, start_date):
+    def _get_date_planned(self, product_qty, start_date):
-            days += self.product_id._select_seller().delay or 0.0
+            days += self.product_id._select_seller(
-            'date_planned': date or self._get_date_planned(datetime.today()),
+            'date_planned': date or self._get_date_planned(product_qty, datetime.today()),
-    def _get_purchase_order_date(self, schedule_date):
+    def _get_purchase_order_date(self, partner, schedule_date):
-        return super(ProcurementOrder, self)._get_purchase_order_date(schedule_date)
+        return super(ProcurementOrder, self)._get_purchase_order_date(partner, schedule_date)
-            if all([True if not answer.strip() else False for answer in answer_candidates.values()]):
+            if all([True if not answer.strip() else False for answer in answer_candidates.values()]) and answer_candidates:
-        return "%s-%s-%s-%s-%s-%s" % (
+        return "%s-%s-%s-%s-%s-%s-%s" % (
-    is_done = fields.Boolean(compute='_compute_is_done', inverse='_set_is_done', string='Done', oldname='processed_boolean')
+    is_done = fields.Boolean(compute='_compute_is_done', string='Done', readonly=False, oldname='processed_boolean')
-        # TDE FIXME: whuuuut ???
+    @api.onchange('is_done')
-            pack.qty_done = 1.0
+            pack.is_done = True
-            pack.qty_done = 1.0
+            pack.is_done = True
-
+        for product in products:
-    menu_id = fields.Many2one('ir.ui.menu', string='Parent Menu', required=True)
+    menu_id = fields.Many2one('ir.ui.menu', string='Parent Menu', required=True, ondelete='cascade')
-    @api.depends('period', 'maintenance_open_count', 'maintenance_ids.request_date')
+    @api.depends('period', 'maintenance_ids.request_date', 'maintenance_ids.close_date')
-                equipment.next_action_date = next_date and (next_date + timedelta(days=equipment.period)).strftime(DEFAULT_SERVER_DATE_FORMAT)
+        date_now = fields.Date.context_today(self)
-
+        """
-
+    request_date = fields.Date('Request Date', track_visibility='onchange', default=fields.Date.context_today,
-    close_date = fields.Date('Close Date')
+    close_date = fields.Date('Close Date', help="Date the maintenance was finished. ")
-    schedule_date = fields.Datetime('Scheduled Date')
+    schedule_date = fields.Datetime('Scheduled Date', help="Date the maintenance team plans the maintenance.  It should not differ much from the Request Date. ")
-
+from dateutil import relativedelta
-    def test_equipment_request_category(self):
+    def test_10_equipment_request_category(self):
-                amount = tax.compute_all(line.price_reduce + base_tax, quantity=line.product_uom_qty)['taxes'][0]['amount']
+                amount = tax.compute_all(line.price_reduce + base_tax, quantity=line.product_uom_qty,
-                    base_tax += tax.compute_all(line.price_reduce + base_tax, quantity=1)['taxes'][0]['amount']
+                    base_tax += tax.compute_all(line.price_reduce + base_tax, quantity=1, product=line.product_id,
-    name = fields.Char(required=True)
+    name = fields.Char(required=True, translate=True)
-        if not action_ref:
+        if not action_ref or len(self.report_name.split('.')) < 2:
-        if type in ('in_invoice', 'in_refund'):
+        if type in ('in_invoice', 'out_refund'):
-    def _fetch_data(self, base_url, data, content_type=False):
+    def _fetch_data(self, base_url, data, content_type=False, extra_params=False):
-                base_url = base_url + '?%s' % urlencode(data)
+                sep = '?' if not extra_params else '&'
-                values['index_content'] = self._fetch_data(google_values['exportLinks']['text/csv'], {})['values']
+            if 'exportLinks' in google_values:
-                return 'presentation'
+            slide_type = 'presentation'
-        bom_delivered = {}
+        # In the case of a kit, we need to check if all components are shipped. Since the BOM might
-            return 0.0
+            bom_delivered = all([move.state == 'done' for move in self.move_ids])
-        bom_delivered = {}
+        # In the case of a kit, we need to check if all components are shipped. Since the BOM might
-            return 0.0
+            bom_delivered = all([move.state == 'done' for move in self.procurement_ids.mapped('move_ids')])
-    invoice_ids = fields.Many2many('account.invoice', compute="_compute_invoice", string='Bills', copy=False)
+    invoice_count = fields.Integer(compute="_compute_invoice", string='# of Bills', copy=False, default=0, store=True)
-    picking_ids = fields.Many2many('stock.picking', compute='_compute_picking', string='Receptions', copy=False)
+    picking_count = fields.Integer(compute='_compute_picking', string='Receptions', default=0, store=True)
-    @api.depends('order_line.invoice_lines.invoice_id.state')
+    @api.depends('order_line.invoice_lines.invoice_id')
-    @api.depends('order_line.move_ids')
+    @api.depends('order_line.move_ids.returned_move_ids',
-                domain=['|', '&', ('res_model', '=', product._name), ('res_id', '=', product_id), '&', ('res_model', '=', template._name), ('res_id', '=', template.id)],
+                domain=['|', '&', ('res_model', '=', product._name), ('res_id', '=', product_id), '&', ('res_model', '=', template._name), '&', ('res_id', '=', template.id), ('product_downloadable', '=', True)],
-            domain=[('invoice_id.state', '=', 'paid'), ('invoice_id.partner_id', '=', partner.id), ('product_id.product_tmpl_id.type', '=', 'digital')],
+            domain=[('invoice_id.state', '=', 'paid'), ('invoice_id.partner_id', '=', partner.id)],
-                if '.'.join(base_version.split('.')[:2]) != server_version:
+                base_version = cr.fetchone()
-            """, (self.env.uid, 'server', self._cr.dbname, __name__, level, message, "action", action.id, action.name))
+            with self.pool.cursor() as cr:
-    '==': py_operator.eq,
+    '=': py_operator.eq,
-        if value == 0.0 and operator in ('==', '>=', '<='):
+        if value == 0.0 and operator in ('=', '>=', '<='):
-            pterm_list = pterm.with_context(currency_id=self.currency_id.id).compute(value=1, date_ref=date_invoice)[0]
+            pterm_list = pterm.with_context(currency_id=self.company_id.currency_id.id).compute(value=1, date_ref=date_invoice)[0]
-                totlines = inv.with_context(ctx).payment_term_id.with_context(currency_id=inv.currency_id.id).compute(total, date_invoice)[0]
+                totlines = inv.with_context(ctx).payment_term_id.with_context(currency_id=company_currency.id).compute(total, date_invoice)[0]
-                    'move_dest_id': production.move_prod_id.id,
+        # release connection
-            qty = self.pool.get('product.product')._product_available(cr, uid, [product_id], context=dict(context or {}, location=location_id))
+            qty = self.pool.get('product.product')._product_available(cr, uid, [product_id], context=dict(context or {}, location=location_id, compute_child=False))
-            order_line.order_id.write({'order_line': [(2, order_line.id, False)]})
+            order_line.unlink()
-            order_line.order_id.write({'order_line': [(1, order_line.id, values)]})
+            order_line.write(values)
-    @route(['/report/barcode', '/report/barcode/<type>/<path:value>'], type='http', auth="user")
+    @route(['/report/barcode', '/report/barcode/<type>/<path:value>'], type='http', auth="public")
-            message = (tx.state == 'done' and 'Your payment was successful! It may take some time to be validated on our end.') or 'OOps! There was a problem with your payment.'
+            if tx.state == 'done':
-                })
+            if values['activity_date_deadline']:
-            'all': {'label': _('All'), 'domain': []},
+            'all': {'label': _('Active'), 'domain': []},
-            'lost': {'label': _('Lost'), 'domain': [('active', '=', False)]},
+            'won': {'label': _('Won'), 'domain': [('stage_id.probability', '=', 100), ('stage_id.on_change', '=', True)]},
-    def portal_my_lead(self, lead=None, **kw):
+    @http.route(['''/my/lead/<model('crm.lead', "[('type','=', 'lead')]"):lead>'''], type='http', auth="user", website=True)
-    def portal_my_opportunity(self, lead=None, **kw):
+    @http.route(['''/my/opportunity/<model('crm.lead', "[('type','=', 'opportunity')]"):opp>'''], type='http', auth="user", website=True)
-                'user_activity': lead.activity_ids.filtered(lambda activity: activity.user_id == request.env.user)[:1],
+                'opportunity': opp,
-        for menu in action_menus:
+        for menu in action_menus.sudo():
-    _geoip_resolver = None
+    _geoip_resolver = None  # backwards-compatibility
-                cls._geoip_resolver = False
+        # Lazy init of GeoIP resolver
-                record = cls._geoip_resolver.record_by_addr(request.httprequest.remote_addr) or {}
+            if odoo._geoip_resolver and request.httprequest.remote_addr:
-            self._action_unfollow(partner)
+        for p in partner:
-                bounced_mail_id, bounced_model, bounced_thread_id = bounce_match.group(1), bounce_match.group(2), int(bounce_match.group(3))
+                bounced_mail_id, bounced_model, bounced_thread_id = bounce_match.group(1), bounce_match.group(2), bounce_match.group(3)
-                partner, partner_address = self.env['res.partner'], False
+                partners, partner_address = self.env['res.partner'], False
-                        partner.message_receive_bounce(partner_address, partner, mail_id=bounced_mail_id)
+                        partners = partners.sudo().search([('email', 'like', partner_address)])
-                if partner and mail_message:
+                if partners and mail_message:
-                        ('res_partner_id', '=', partner.id)])
+                        ('res_partner_id', 'in', partners.ids)])
-                    self.env[bounced_model].browse(bounced_thread_id).message_receive_bounce(partner_address, partner, mail_id=bounced_mail_id)
+                    self.env[bounced_model].browse(int(bounced_thread_id)).message_receive_bounce(partner_address, partners, mail_id=bounced_mail_id)
-                             email_from, email_to, message_id, bounced_mail_id, bounced_model, bounced_thread_id, partner_address, partner.id)
+                             email_from, email_to, message_id, bounced_mail_id, bounced_model, bounced_thread_id, partner_address, partners)
-    name = fields.Char(required=True)
+    name = fields.Char(required=True, translate=True)
-                forced_qty = (move.state == 'assigned') and move.product_qty - sum([x.qty for x in move_quants]) or 0
+                forced_qty = 0.0
-            if operation.pack_lot_ids and float_compare(sum(lot_quantities.values()), operation.product_qty, precision_rounding=operation.product_uom_id.rounding) != 0.0:
+
-        help="Create journal entries from payslips")
+    module_hr_timesheet = fields.Boolean(string='Timesheets')
-    _inherit = 'account.config.settings'
+class HrPayrollConfigSettings(models.TransientModel):
-        self._context['todo'].append((10, model.modified, [list(params)]))
+        self._context['todo'].append((10, model.modified, [['name', 'info', 'transient']]))
-            order_line.unlink()
+            order_line.order_id.write({'order_line': [(2, order_line.id, False)]})
-            order_line.write(values)
+            order_line.order_id.write({'order_line': [(1, order_line.id, values)]})
-        fetch_res = self._fetch_data('https://www.googleapis.com/drive/v2/files/%s' % document_id, {'projection': 'BASIC', 'key': key}, "json")
+
-            if move.product_id.type == 'consu':
+            # if the move is preceeded, restrict the choice of quants in the ones moved previously in original move
-        self.mapped('reserved_quant_ids').sudo().write({'reservation_id': False})
+        self.mapped('reserved_quant_ids').sudo().write({'reservation_id': False})
-                values['category_id'] = EnglishUoMCateg.name_create('Unsorted/Imported Units').id
+                values['category_id'] = EnglishUoMCateg.name_create('Unsorted/Imported Units')[0]
-                continue
+        bom_id = self.env['mrp.bom']._bom_find(product_id=self.product_id.id, properties=self.property_ids.ids)
-        recs.recompute()
+        if recs.env.recompute and context.get('recompute', True):
-from odoo import api, fields, models
+from odoo import api, fields, models, _
-                move.write({'line_ids': lines})
+                move.with_context(dont_create_taxes=True).write({'line_ids': lines})
-        d = os.path.join(self['data_dir'], 'addons', release.series)
+        add_dir = os.path.join(self['data_dir'], 'addons')
-        d = os.path.join(self['data_dir'], 'addons', release.series)
+        add_dir = os.path.join(self['data_dir'], 'addons')
-        d = os.path.join(self['data_dir'], 'addons', release.series)
+        add_dir = os.path.join(self['data_dir'], 'addons')
-from odoo.tools import float_compare
+from odoo.tools import float_compare, float_round
-                move.quantity_done += self.qty_producing * move.unit_factor
+                rounding = move.product_uom.rounding
-from odoo.tools import float_compare
+from odoo.tools import float_compare, float_round
-            if float_compare(move.quantity_done, 0.0, precision_rounding=rounding) <= 0:
+            move.quantity_done = float_round(move.quantity_done, precision_rounding=rounding, rounding_method ='UP')
-from odoo.tools import float_compare
+from odoo.tools import float_compare, float_round
-                move.quantity_done_store += quantity * move.unit_factor
+                rounding = move.product_uom.rounding
-                move.quantity_done_store += quantity
+                move.quantity_done_store += float_round(quantity, precision_rounding=rounding)
-                move.quantity_done_store += quantity * move.unit_factor
+                # byproducts handling
-    _inherit = 'base.config.settings'
+    _name = 'attendance.config.settings'
-            return cn[0] in string.ascii_lowercase and cn[1] in string.ascii_lowercase
+            return len(cn) == 2 and cn[0] in string.ascii_lowercase and cn[1] in string.ascii_lowercase
-        return "%s-%s-%s-%s-%s" % (
+        return "%s-%s-%s-%s-%s-%s" % (
-        if len(msg) != self.device.write(self.out_ep, msg, self.interface):
+        if len(msg) != self.device.write(self.out_ep, msg, self.interface, timeout=5000):
-    if dd not in ad_paths:
+    if os.access(dd, os.R_OK) and dd not in ad_paths:
-                "%s: directory is not writable" % d
+            try:
-    group_product_variant = fields.Boolean("Attributes and Variants", implied_group='product.group_sale_pricelist')
+    group_product_variant = fields.Boolean("Attributes and Variants", implied_group='product.group_product_variant')
-    if dd not in ad_paths:
+    if os.access(dd, os.R_OK) and dd not in ad_paths:
-                "%s: directory is not writable" % d
+            try:
-    if dd not in ad_paths:
+    if os.access(dd, os.R_OK) and dd not in ad_paths:
-                "%s: directory is not writable" % d
+            try:
-                Partner.browse(partner_id).sudo().update(checkout)
+                Partner.browse(partner_id).sudo().write(checkout)
-
+        if mode == ('edit', 'billing') and order.partner_id.type == 'contact':
-                        mode = ('edit', 'billing')
+                    mode = ('edit', 'billing')
-        res.append(('bba', 'BBA Structured Communication'))
+        res[[i for i,x in enumerate(res) if x[0] == 'none'][0]] = \
-    'category': 'Localization/Account Charts',
+    'category': 'Localization',
-            employee.manual_attendance = employee.user_id.has_group('hr.group_hr_attendance') if employee.user_id else False
+            employee.manual_attendance = employee.user_id.has_group('hr_attendance.group_hr_attendance') if employee.user_id else False
-        manual_attendance_group = self.env.ref('hr.group_hr_attendance')
+        manual_attendance_group = self.env.ref('hr_attendance.group_hr_attendance')
-
+
-            elif any(move.partially_available for move in filtered_moves):
+            # We sort our moves by importance of state: "confirmed" should be first, then we'll have
-                self.state = ordered_moves[0].state
+                self.state = moves_todo[-1].state
-                    push(create_substitution_leaf(leaf, ('id', o2m_op, select_distinct_from_where_not_null(cr, column._fields_id, comodel._table)), model))
+                    # determine ids from column._fields_id
-                name = name + ('  (%g remaining out of %g)' % (record.virtual_remaining_leaves or 0.0, record.max_leaves or 0.0))
+                name = "%(name)s (%(count)s)" % {
-        reference = "PAYMENT-%s-%s" % (self.id, datetime.datetime.now().strftime('%y%m%d_%H%M%S'))
+        reference = "P-%s-%s" % (self.id, datetime.datetime.now().strftime('%y%m%d_%H%M%S'))
-        help='Twitter API key you can get it from https://apps.twitter.com/app/new')
+        help='Twitter API key you can get it from https://apps.twitter.com/')
-        help='Twitter API secret you can get it from https://apps.twitter.com/app/new')
+        help='Twitter API secret you can get it from https://apps.twitter.com/')
-        res['domain'] = [('ref', 'in', refs)]
+        res['domain'] = [('id', 'in', self.mapped('account_move_id').ids)]
-        'mass_mailing_id': fields.many2one('mail.mass_mailing', 'Mailing', required=True),
+        'mass_mailing_id': fields.many2one(
-        'data/l10n_eu_service.service_tax_rate.csv'
+        'data/l10n_eu_service.service_tax_rate.csv',
-                suggestions.append((user.partner_id.id, user.name, user.email)) 
+            hr_suggestions = [{'id': user.partner_id.id, 'name': user.name, 'email': user.email}
-    def onchange_product_or_uom(self):
+    @api.onchange('product_id')
-        if self.product_id and (not self.product_uom_id or self.product_id.uom_id.category_id != self.product_uom_id.category_id):
+        if self.product_id:
-    @api.multi
+        self.ensure_one()
-        action = self.env.ref('project.open_view_project_all')
+        action = self.env.ref('project.open_view_project_all').read()[0]
-        return result
+        action['views'] = [(form_view_id, 'form')]
-                    })
+            reversed_move = ac_move._reverse_move(date=date,
-    evented = True
+def is_server_running_with_gevent():
-            if record.res_id:
+            if record.model and record.res_id:
-        index=True, ondelete='cascade',
+        index=True, required=True, ondelete='cascade',
-            default_template_id=template.id,
+            default_template_id=template and template.id or False,
-                    base_tax += amount
+                    base_tax += tax.compute_all(line.price_reduce + base_tax, quantity=1)['taxes'][0]['amount']
-                    company_id = wizard_user.partner_id.company_id.id
+                    if wizard_user.partner_id.company_id:
-                partner.write({'last_website_so_id': sale_order_id})
+                partner.write({'last_website_so_id': sale_order.id})
-                    queries = [("update %(table)s set %(field)s = %%(value)s where id = %%(id)s" % {
+                    queries = [("update \"%(table)s\" set \"%(field)s\" = %%(value)s where id = %%(id)s" % {
-                    'res_model': 'mail.channel',
+                    'res_model_id': res_model_id,
-        if self._module == self._context.get('module'):
+        if model._module == self._context.get('module'):
-            sql = "select id, %s from %s" % (field_name, table_name)
+            sql = "select id, \"%s\" from \"%s\"" % (field_name, table_name)
-                sql = "update %(table)s set %(field)s = %%(anonymized_value)s where id = %%(id)s" % {
+                sql = "update \"%(table)s\" set \"%(field)s\" = %%(anonymized_value)s where id = %%(id)s" % {
-                elif uom:
+                if uom:
-                context=dict(self.env.context, default_vehicle_id=self.id),
+                context=dict(self.env.context, default_vehicle_id=self.id, group_by=False),
-        ], "Shipping Management", default='direct', default_model="sale.order")
+        ], "Shipping Management", default='direct', default_model="sale.order", required=True)
-            res['domain'] = {'payment_token_id': [('partner_id', '=', self.partner_id.id), ('acquirer_id.auto_confirm', '!=', 'authorize')]}
+            partners = self.partner_id | self.partner_id.commercial_partner_id | self.partner_id.commercial_partner_id.child_ids
-        self.payment_transaction_id = tx
+        self.payment_transaction_id = tx
-    _order = 'partner_id'
+    _order = 'partner_id, id desc'
-                if order.state not in ('paid', 'invoiced'):
+            for order in session.order_ids.filtered(lambda o: o.state not in ['done', 'invoiced']):
-                order.filtered(lambda o: o.state == 'paid').action_pos_order_done()
+                order.action_pos_order_done()
-    partner_lang = fields.Selection(_lang_get, 'Language', default='en_US')
+    partner_lang = fields.Selection(_lang_get, 'Language', default=lambda self: self.env.lang)
-                order.action_pos_order_done()
+                order.filtered(lambda o: o.state == 'paid').action_pos_order_done()
-            return [_('Pipeline'), _('Expected Revenue')]
+            return ['', _('Expected Revenue')] # no more title
-            return [_('Sales'), _('Untaxed Amount')]
+            return ['', _('Untaxed Amount')] # no more title
-            return [_('Sales'), _('Untaxed Total')]
+            return ['', _('Untaxed Total')] # no more title
-            return [_('Invoices'), _('Untaxed Total')]
+            return ['', _('Untaxed Total')]
-        }
+
-        if action and action['res_model'] == 'board.board' and action['views'][0][1] == 'form':
+        if action and action['res_model'] == 'board.board' and action['views'][0][1] == 'form' and action_id:
-        }
+
-        if action and action['res_model'] == 'board.board' and action['views'][0][1] == 'form':
+        if action and action['res_model'] == 'board.board' and action['views'][0][1] == 'form' and action_id:
-    default_use_sale_note = fields.Boolean(default_model='sale.config.settings')
+    default_use_sale_note = fields.Boolean(string='Default Terms & Conditions', default_model='sale.config.settings')
-    group_sale_layout = fields.Boolean("Sales Reports Layout", implied_group='sale.group_sale_layout')
+    group_sale_layout = fields.Boolean("Sections on Sales Orders", implied_group='sale.group_sale_layout')
-    module_sale_stock = fields.Boolean("Inventory")
+    module_sale_stock = fields.Boolean("Inventory Management")
-    module_web_clearbit = fields.Boolean("Clearbit")
+    module_web_clearbit = fields.Boolean("Customer Autocomplete")
-    module_sale_coupon = fields.Boolean("Manage coupons and promotional offers")
+    module_sale_coupon = fields.Boolean("Coupons & Promotions")
-
+        'security/ir.model.access.csv',
-            res['res_model_id'] = self.env['ir.model'].sudo().search([('model', '=', res['res_model'])]).id
+            res['res_model_id'] = self.env['ir.model']._get(res['res_model']).id
-        model_record = request.env['ir.model'].search([('model', '=', model_name), ('website_form_access', '=', True)])
+        model_record = request.env['ir.model'].sudo().search([('model', '=', model_name), ('website_form_access', '=', True)])
-        fields = self.env['ir.model.fields'].search([('model', '=', model_name)])
+        fields = self.env['ir.model.fields'].sudo().search([('model', '=', model_name)])
-        fields = self.env['ir.model.fields'].search([('model', '=', model_name)])
+        fields = self.env['ir.model.fields'].sudo().search([('model', '=', model_name)])
-                value = '%s,%d' % (field_id.relation, value)
+                value = '%s,%d' % (field_id.sudo().relation, value)
-        model_name = env['ir.model'].browse(report['model_id'][0]).model
+        model_name = env['ir.model'].sudo().browse(report['model_id'][0]).model
-                        env['ir.model.fields'].browse(field_child[0]).name
+                        env['ir.model.fields'].sudo().browse(field_child[0]).name
-                ttype = env['ir.model.fields'].browse(field_id).ttype
+                ttype = env['ir.model.fields'].sudo().browse(field_id).ttype
-                ttype = env['ir.model.fields'].browse(field_id).ttype
+                ttype = env['ir.model.fields'].sudo().browse(field_id).ttype
-            domain += [('tag_ids', 'in', tag_id)]
+            domain += [('website_tag_ids', 'in', tag_id)]
-        seller_delay = int(self.product_id._select_seller().delay)
+        seller_delay = int(self.product_id._select_seller(quantity=self.product_qty, uom_id=self.product_uom).delay)
-    ttype = fields.Selection(selection='_get_field_types', string='Field Type', required=True)
+    ttype = fields.Selection(selection=FIELD_TYPES, string='Field Type', required=True)
-        """ Return a field instance corresponding to parameters ``field_data``. """
+    def _reflect_values(self, field, existing):
-        # FIXME: ignore field_data['serialization_field_id']
+        return attrs
-        """ Determine field parameter attributes. """
+    def _get_attrs(self, model, name):
-                attrs['inverse'] = self._inverse_sparse
+        return attrs
-        """ Reflect the models and its fields in the models 'ir.model' and
+        """ Reflect the model and its fields in the models 'ir.model' and
-        cr = self._cr
+        # reflect the model in 'ir.model'
-        # create/update the entries in 'ir.model.fields' and 'ir.model.data'
+        # reflect the fields in 'ir.model.fields'
-        Fields = self.env['ir.model.fields']
+        existing = {row['name']: row for row in cr.dictfetchall()}
-                self._context['todo'].append((20, Fields.browse(field_id).modified, [names]))
+        reflect = self.env['ir.model.fields']._reflect
-            fields['.id'] = fields.pop('id', {'string': 'ID'})
+            fields['.id'] = fields.get('id', {'string': 'ID'})
-            moves_to_do = order.move_raw_ids
+            moves_to_do = order.move_raw_ids.filtered(lambda x: x.state not in ('done', 'cancel'))
-            moves_to_finish = order.move_finished_ids
+            moves_to_finish = order.move_finished_ids.filtered(lambda x: x.state not in ('done','cancel'))
-        self.assertEqual(production.move_raw_ids[0].location_id.id, self.warehouse_1.wh_input_stock_loc_id.id, 'Raw moves start location should have altered.')
+        self.assertEqual(production.move_raw_ids[0].location_id.id, self.warehouse_1.wh_input_stock_loc_id.id, 'Raw moves start location should have altered.')
-        response = tx._create_stripe_charge(tokenid=post['tokenid'])
+        response = tx._create_stripe_charge(tokenid=post['tokenid'], email=post['email'])
-    def _create_stripe_charge(self, acquirer_ref=None, tokenid=None):
+    def _create_stripe_charge(self, acquirer_ref=None, tokenid=None, email=None):
-        self.account_depreciation_id = self.account_asset_id
+        if self.type == "purchase":
-            self.account_id = self.asset_category_id.account_depreciation_id.id
+            self.account_id = self.asset_category_id.account_asset_id.id
-        supplier_taxes_id = set(ir_values.get_default('product.template', 'supplier_taxes_id', company_id=company_id))
+        supplier_taxes_id = set(ir_values.get_default('product.template', 'supplier_taxes_id', company_id=company_id) or [])
-        taxes_id = set(self.env['ir.values'].get_default('product.template', 'taxes_id', company_id=company_id))
+        taxes_id = set(self.env['ir.values'].get_default('product.template', 'taxes_id', company_id=company_id) or [])
-    image.paste(color)
+    image.paste(color, box=(0, 0) + original.size)
-        invoice_line_tax_ids = self.purchase_id.fiscal_position_id.map_tax(taxes)
+        invoice_line_tax_ids = line.order_id.fiscal_position_id.map_tax(taxes)
-            'origin': self.purchase_id.origin,
+            'name': line.order_id.name+': '+line.name,
-        account = invoice_line.get_invoice_line_account('in_invoice', line.product_id, self.purchase_id.fiscal_position_id, self.env.user.company_id)
+        account = invoice_line.get_invoice_line_account('in_invoice', line.product_id, line.order_id.fiscal_position_id, self.env.user.company_id)
-    code = fields.Char('Internal Reference', compute='_compute_product_code')
+    code = fields.Char('Reference', compute='_compute_product_code')
-        'website',
+        'website', 'portal'
-                         [(5,)] + [(4, msg.id) for msg in discussion.important_messages])
+                         [(5,)] + [(1, msg.id, {
-            fnames = [name for name in fnames if name != self.inverse_name]
+        fnames = set(fnames or value.fields_view_get()['fields'])
-        vals.update(self._get_dates(vals.get('product_id')))
+        dates = self._get_dates(vals.get('product_id'))
-            self.account_id = self.asset_category_id.account_depreciation_id.id
+            #DO NOT FORWARDPORT
-        return fields.date.context_today(self)
+        return fields.Date.context_today(self)
-        return fields.date.context_today(self)
+        return fields.Date.context_today(self)
-        if 'module' in context:
+
-                if float_compare(procurement_qty, 0.0, precision_rounding=procurement.product_uom.rounding) > 0:
+                if float_compare(procurement_qty, 0.0, precision_rounding=procurement.product_uom.rounding) > 0 and float_compare(diff_quantity, 0.0, precision_rounding=line.product_uom.rounding) > 0:
-            'format_date': lambda date, format=False, context=self._context: format_dae(self.env, date, format),
+            'format_date': lambda date, format=False, context=self._context: format_date(self.env, date, format),
-                    date(c.date_closed) as date_closed,
+                    c.date_closed as date_closed,
-    'demo': ['data/resource_demo.xml'],
+import res_company
-    company_id = fields.Many2one('res.company', string='Company',
+    company_id = fields.Many2one(
-    manager = fields.Many2one('res.users', string='Workgroup Manager', default=lambda self: self.env.uid)
+        'resource.calendar.attendance', 'calendar_id', 'Working Time',
-        'resource.calendar.leaves', 'calendar_id', string='Leaves')
+        'resource.calendar.leaves', 'calendar_id', 'Leaves')
-    active = fields.Boolean(track_visibility='onchange', default=True,
+    active = fields.Boolean(
-    time_efficiency = fields.Float(string='Efficiency Factor', required=True, default=100,
+    time_efficiency = fields.Float(
-    resource_id = fields.Many2one("resource.resource", string='Resource',
+    name = fields.Char('Reason')
-        self.calendar_id = self.resource_id.calendar_id
+        if self.resource_id:
-            'name': "NoCalendar"
+            'name': "NoCalendar",
-            'working_hours': self.ref('resource.timesheet_group1')
+            'working_hours': self.ref('resource.resource_calendar_std')
-            'working_hours': self.ref('resource.timesheet_group1'),
+            'working_hours': self.ref('resource.resource_calendar_std'),
-        self.ResourceLeaves = self.env['resource.calendar.leaves']
+        self.env.user.tz = 'UTC'
-        self.calendar = self.ResourceCalendar.with_context(context).create(
+        self.calendar = self.env['resource.calendar'].create(
-        self.resource1_id = self.Resource.with_context(context).create(
+
-        self.leave1_id = self.ResourceLeaves.with_context(context).create(
+
-                'date_to': self.leave1_end,
+                'date_from': Datetime.from_string('2013-02-19 09:00:00'),
-        self.leave2_id = self.ResourceLeaves.with_context(context).create(
+        # Leave2: 22/02/2013, from 9 to 15, is a day 4
-                'date_to': self.leave2_end,
+                'date_from': Datetime.from_string('2013-02-22 09:00:00'),
-        self.leave3_id = self.ResourceLeaves.with_context(context).create(
+        # Leave3: 25/02/2013 (day0) -> 01/03/2013 (day4)
-                'date_to': self.leave3_end,
+                'date_from': Datetime.from_string('2013-02-25 13:00:00'),
-from odoo.fields import Datetime
+from odoo.fields import Date, Datetime
-class TestResource(TestResourceCommon):
+class TestIntervals(TestResourceCommon):
-        intervals = [
+    def setUp(self):
-        self.assertEqual(len(cleaned_intervals), 3, 'resource_calendar: wrong interval cleaning')
+    def test_interval_clean(self):
-        self.assertEqual(cleaned_intervals[1][1], Datetime.from_string('2013-02-04 14:00:00'), 'resource_calendar: wrong interval cleaning')
+        self.assertEqual(cleaned_intervals[0], (Datetime.from_string('2013-02-03 08:00:00'), Datetime.from_string('2013-02-03 10:00:00')))
-        self.assertEqual(cleaned_intervals[2][1], Datetime.from_string('2013-02-04 21:00:00'), 'resource_calendar: wrong interval cleaning')
+        self.assertEqual(cleaned_intervals[2], (Datetime.from_string('2013-02-04 17:00:00'), Datetime.from_string('2013-02-04 21:00:00')))
-        # Test: disjoint removal
+    def test_interval_remove(self):
-        self.assertEqual(len(result), 1, 'resource_calendar: wrong leave removal from interval')
+        result = self.env['resource.calendar'].interval_remove_leaves(working_interval, self.intervals)
-        self.assertEqual(result[0][1], Datetime.from_string('2013-02-03 10:00:00'), 'resource_calendar: wrong leave removal from interval')
+        self.assertEqual(result[0], (Datetime.from_string('2013-02-04 14:00:00'), Datetime.from_string('2013-02-04 17:00:00')))
-        self.assertEqual(result[1][1], Datetime.from_string('2013-02-04 11:30:00'), 'resource_calendar: wrong leave removal from interval')
+        self.assertEqual(result[1], (Datetime.from_string('2013-02-04 08:00:00'), Datetime.from_string('2013-02-04 11:30:00')))
-        # Test: schedule hours on intervals, backwards
+    def test_interval_schedule_hours_backwards(self):
-        self.assertEqual(result[0][1], Datetime.from_string('2013-02-04 21:00:00'), 'resource_calendar: wrong leave removal from interval')
+        result = self.env['resource.calendar'].interval_schedule_hours(cleaned_intervals, 5.5, remove_at_end=False)
-        self.assertEqual(result[1][1], Datetime.from_string('2013-02-04 14:00:00'), 'resource_calendar: wrong leave removal from interval')
+        self.assertEqual(result[1], (Datetime.from_string('2013-02-04 12:30:00'), Datetime.from_string('2013-02-04 14:00:00')))
-        """ Testing basic method of resource.calendar """
+class TestCalendarBasics(TestResourceCommon):
-        # --------------------------------------------------
+    def test_calendar_weekdays(self):
-        self.assertEqual(date, self.date2.date(), 'resource_calendar: wrong next day computing')
+        date = self.calendar.get_next_day(day_date=Date.from_string('2013-02-12'))
-        self.assertEqual(date, self.date1.date() + relativedelta(days=7), 'resource_calendar: wrong next day computing')
+        date = self.calendar.get_next_day(day_date=Date.from_string('2013-02-15'))
-        self.assertEqual(date, self.date1.date() + relativedelta(days=7), 'resource_calendar: wrong next day computing')
+        date = self.calendar.get_next_day(day_date=Date.from_string('2013-02-15') + relativedelta(days=1))
-        # --------------------------------------------------
+        date = self.calendar.get_next_day(day_date=Date.from_string('2013-02-12') + relativedelta(days=-1))
-        self.assertEqual(date, self.date2.date() + relativedelta(days=-7), 'resource_calendar: wrong previous day computing')
+        date = self.calendar.get_previous_day(day_date=Date.from_string('2013-02-12'))
-        self.assertEqual(date, self.date1.date(), 'resource_calendar: wrong previous day computing')
+        date = self.calendar.get_previous_day(day_date=Date.from_string('2013-02-15'))
-        self.assertEqual(date, self.date2.date(), 'resource_calendar: wrong previous day computing')
+        date = self.calendar.get_previous_day(day_date=Date.from_string('2013-02-15') + relativedelta(days=1))
-        """ Testing working intervals computing method of resource.calendar """
+        date = self.calendar.get_previous_day(day_date=Date.from_string('2013-02-12') + relativedelta(days=-1))
-        self.assertEqual(intervals[0][1], Datetime.from_string('2013-02-12 16:00:00'), 'resource_calendar: wrong working intervals')
+        intervals = self.calendar.get_working_intervals_of_day(start_dt=Datetime.from_string('2013-02-12 09:08:07'))
-        self.assertEqual(intervals[1][1], Datetime.from_string('2013-02-15 23:00:00'), 'resource_calendar: wrong working intervals')
+        intervals = self.calendar.get_working_intervals_of_day(start_dt=Datetime.from_string('2013-02-15 10:11:12'))
-        self.assertEqual(intervals[0][1], Datetime.from_string('2013-02-12 16:00:00'), 'resource_calendar: wrong working intervals')
+        intervals = self.calendar.get_working_intervals_of_day(start_dt=Datetime.from_string('2013-02-12 07:00:00'), compute_leaves=True)
-                                                               end_dt=self.date1.replace(hour=15, minute=45, second=30) + relativedelta(days=7),
+        intervals = self.calendar.get_working_intervals_of_day(start_dt=Datetime.from_string('2013-02-19 08:15:00'),
-        self.assertEqual(intervals[1][1], Datetime.from_string('2013-02-19 15:45:30'), 'resource_calendar: wrong working intervals')
+        self.assertEqual(len(intervals), 2)
-    def test_21_calendar_working_intervals_limited_attendances(self):
+    def test_calendar_working_day_intervals_limited_attendances(self):
-        self.env['resource.calendar.attendance'].browse(self.att3_id).write({
+        attendance = self.env['resource.calendar.attendance'].search(
-        self.env['resource.calendar.attendance'].browse(self.att3_id).write({
+        attendance.write({
-        self.env['resource.calendar.attendance'].browse(self.att3_id).write({
+        attendance.write({
-        self.env['resource.calendar.attendance'].browse(self.att3_id).write({
+        attendance.write({
-
+    def test_calendar_working_hours_of_date(self):
-        wh = self.calendar.get_working_hours_of_date(start_dt=self.date1.replace(hour=10, minute=30, second=0))
+        wh = self.calendar.get_working_hours_of_date(start_dt=Datetime.from_string('2013-02-19 10:30:00'))
-        # --------------------------------------------------
+class ResourceWorkingHours(TestResourceCommon):
-            self.date2.replace(hour=23, minute=0) + relativedelta(days=7),
+            Datetime.from_string('2013-02-12 06:00:00'),
-        self.assertEqual(res, 40.0, 'resource_calendar: wrong _interval_hours_get compatibility computation')
+        self.assertEqual(res, 40.0)
-            self.date2.replace(hour=23, minute=0) + relativedelta(days=7),
+            Datetime.from_string('2013-02-12 06:00:00'),
-        self.assertEqual(res, 40.0, 'resource_calendar: wrong get_working_hours computation')
+        self.assertEqual(res, 40.0)
-            self.date2.replace(hour=23, minute=0) + relativedelta(days=7),
+            Datetime.from_string('2013-02-12 06:00:00'),
-        self.assertEqual(res, 33.0, 'resource_calendar: wrong _interval_hours_get compatibility computation')
+        self.assertEqual(res, 33.0)
-            self.date2.replace(hour=23, minute=0) + relativedelta(days=7),
+            Datetime.from_string('2013-02-12 06:00:00'),
-        # --------------------------------------------------
+        self.assertEqual(res, 33.0)
-            self.date2.replace(hour=23, minute=0),
+        res = self.env['resource.calendar'].with_context(tz='UTC').get_working_hours(
-        self.assertEqual(res, 6, 'resource_calendar: wrong get_working_hours computation')
+        self.assertEqual(res, 32.0)
-        """ Testing calendar days scheduling """
+    def test_calendar_hours_scheduling_forward_leaves_resource(self):
-        # --------------------------------------------------
+        td = timedelta()
-        res = self.calendar.schedule_days_get_date(5, day_date=self.date1)
+    def test_calendar_days_scheduling(self):
-        res = self.calendar.schedule_days_get_date(-2, day_date=self.date1)
+        res = self.calendar.schedule_days_get_date(-2, day_date=Datetime.from_string('2013-02-12 09:08:07') )
-            5, day_date=self.date1,
+            5, day_date=Datetime.from_string('2013-02-12 09:08:07'),
-
+    def test_calendar_days_scheduling_without_calendar(self):
-        res = self.ResourceCalendar.with_context(self.context).schedule_days_get_date(5, day_date=self.date1, default_interval=(8, 16))
+        res = self.env['resource.calendar'].with_context(tz='UTC').schedule_days_get_date(5, day_date=Datetime.from_string('2013-02-12 09:08:07'), default_interval=(8, 16))
-        self.assertGreaterEqual(len(work_intreval), 5, 'Wrong Schedule Calculated')
+WAR_START = date(1932, 11, 2)
-        self.assertTrue(resource_id, 'Unable to Duplicate Resource')
+class TestWorkDays(TestResourceCommon):
-class TestWorkDays(TransactionCase):
+
-            'name': "Trivial Calendar",
+        self.calendar.write({
-        """
+        """ If a resource has no resource calendar, they don't work """
-            'calendar_id': self._calendar.id
+            'calendar_id': self.calendar.id
-            'calendar_id': self._calendar.id,
+            'calendar_id': self.calendar.id,
-            'calendar_id': self._calendar.id
+            'calendar_id': self.calendar.id
-            'calendar_id': self._calendar.id
+            'calendar_id': self.calendar.id
-            'calendar_id': self._calendar.id
+            'calendar_id': self.calendar.id
-            'calendar_id': self._calendar.id
+            'calendar_id': self.calendar.id
-            'calendar_id': self._calendar.id,
+            'calendar_id': self.calendar.id,
-            'calendar_id': self._calendar.id
+            'calendar_id': self.calendar.id
-            'calendar_id': self._calendar.id,
+            'calendar_id': self.calendar.id,
-            'calendar_id': self._calendar.id,
+            'calendar_id': self.calendar.id,
-    resource_calendar_id = fields.Many2one('resource.calendar', string="Working Time", help="Used to compute open days")
+    price_reduce_taxinc = fields.Float(compute='_get_price_reduce_tax', string='Price Reduce Tax inc')
-                                res = self.update_from_google(parent_event, event.GG.event, "copy")
+                                res = recs.update_from_google(parent_event, event.GG.event, "copy")
-                            res = recs.update_from_google(parent_event, event.GG.event, "copy")
+                                recs.create_from_google(event, my_partner_id)
-                                res = self.update_from_google(parent_event, event.GG.event, "copy")
+                                res = recs.update_from_google(parent_event, event.GG.event, "copy")
-                            res = recs.update_from_google(parent_event, event.GG.event, "copy")
+                                recs.create_from_google(event, my_partner_id)
-            warehouses = self.env['stock.warehouse'].search([('company_id', '=', values['company_id'])], limit=1)
+            warehouses = self.env['stock.warehouse'].sudo().search([('company_id', '=', values['company_id'])], limit=1)
-                field = self.env['ir.model.fields'].sudo().search([('name', '=', record[0]), ('model', '=', record[1]), ('relation', '=', record[2])])
+                field = self.env['ir.model.fields'].search([('name', '=', record[0]), ('model', '=', record[1]), ('relation', '=', record[2])], limit=1)
-        for record in records:
+        records = self.env['ir.model.fields'].search([('ttype', '=', 'reference')])
-                records_ref.write(values)
+                records_ref.sudo().write(values)
-                for alias in dest_aliases.sudo():
+                for alias in dest_aliases:
-            model = self.env['ir.model'].browse(model_id).sudo().model
+            model = self.env['ir.model'].browse(model_id).model
-            field = self.env['ir.model.fields'].sudo().search([('name', '=', 'property_stock_journal'), ('model', '=', 'product.category'), ('relation', '=', 'account.journal')])
+            field = self.env['ir.model.fields'].search([('name', '=', 'property_stock_journal'), ('model', '=', 'product.category'), ('relation', '=', 'account.journal')], limit=1)
-                field = self.env['ir.model.fields'].sudo().search([('name', '=', record), ('model', '=', 'product.category'), ('relation', '=', 'account.account')])
+                field = self.env['ir.model.fields'].search([('name', '=', record), ('model', '=', 'product.category'), ('relation', '=', 'account.account')], limit=1)
-        fields = http.request.env['ir.model.fields'].sudo()
+        fields = http.request.env['ir.model.fields']
-        model_record = request.env['ir.model'].sudo().search([('model', '=', model_name), ('website_form_access', '=', True)])
+        model_record = request.env['ir.model'].search([('model', '=', model_name), ('website_form_access', '=', True)])
-        fields = self.env['ir.model.fields'].sudo().search([('model', '=', model_name)])
+        fields = self.env['ir.model.fields'].search([('model', '=', model_name)])
-        fields = self.env['ir.model.fields'].sudo().search([('model', '=', model_name)])
+        fields = self.env['ir.model.fields'].search([('model', '=', model_name)])
-        fields = self.env['ir.model.fields'].sudo().search([('model', '=', model_name)])
+        fields = self.env['ir.model.fields'].search([('model', '=', model_name)])
-        for menu in action_menus.sudo():
+        for menu in action_menus:
-EXCLUDED_FIELDS = set((
+EXCLUDED_FIELDS = set(('code',
-            fnames = self.env['ir.model.fields'].sudo().browse(res_ids).mapped('name')
+            fnames = self.env['ir.model.fields'].browse(res_ids).mapped('name')
-                value = '%s,%d' % (field_id.sudo().relation, value)
+                value = '%s,%d' % (field_id.relation, value)
-        model_name = env['ir.model'].browse(report['model_id'][0]).sudo().model
+        model_name = env['ir.model'].browse(report['model_id'][0]).model
-                        env['ir.model.fields'].sudo().browse(field_child[0]).name
+                        env['ir.model.fields'].browse(field_child[0]).name
-                ttype = env['ir.model.fields'].sudo().browse(field_id).ttype
+                ttype = env['ir.model.fields'].browse(field_id).ttype
-                ttype = env['ir.model.fields'].sudo().browse(field_id).ttype
+                ttype = env['ir.model.fields'].browse(field_id).ttype
-            picking.count_mo_late = count_mo_late
+        domains = {
-                    'account.move.line': (lambda self, cr, uid, ids, c={}: ids, ['reconcile_id','reconcile_partial_id'], 50)}),
+                    'account.move.line': (lambda self, cr, uid, ids, c={}: ids, ['reconcile_id','reconcile_partial_id'], 50),'account.move.reconcile': (_get_move_from_reconcile, None, 50)}),
-                    'account.move.line': (lambda self, cr, uid, ids, c={}: ids, ['reconcile_id','reconcile_partial_id'], 50),'account.move.reconcile': (_get_move_from_reconcile, None, 50)}),
+                    'account.move.line': (lambda self, cr, uid, ids, c={}: ids, ['reconcile_id','reconcile_partial_id'], 50)}),
-    account_depreciation_id = fields.Many2one('account.account', string='Depreciation Account', required=True, domain=[('internal_type','=','other'), ('deprecated', '=', False)])
+    account_income_recognition_id = fields.Many2one('account.account', string='Depreciation Entries: Expense Account', domain=[('internal_type','=','other'), ('deprecated', '=', False)], oldname='account_expense_depreciation_id',
-            debit_account = line.asset_id.category_id.account_asset_id.id
+            debit_account = line.asset_id.category_id.account_income_recognition_id.id or line.asset_id.category_id.account_asset_id.id
-        return self.env.cr.dictfetchall()
+        # This method is supposed to be used only in the context of channel creation or
-        return suggestions
+        try:
-        required=True, domain=["|", ("event_type_id", "!=", False), ("event_ok", "=", True)],
+        required=True, domain=[("event_ok", "=", True)],
-        view_obj = self.env['ir.ui.view']
+        view_obj = self.env['ir.ui.view'].with_context(context)
-        error = stderr.split('Load paths')[0].replace('  Use --trace for backtrace.', '')
+        error = misc.ustr(stderr).split('Load paths')[0].replace('  Use --trace for backtrace.', '')
-    full_reconcile_id = fields.Many2one('account.full.reconcile', string="Matching Number")
+    full_reconcile_id = fields.Many2one('account.full.reconcile', string="Matching Number", copy=False)
-    full_reconcile_id = fields.Many2one('account.full.reconcile', string="Full Reconcile")
+    full_reconcile_id = fields.Many2one('account.full.reconcile', string="Full Reconcile", copy=False)
-    full_reconcile_id = fields.Many2one('account.full.reconcile', string="Matching Number")
+    full_reconcile_id = fields.Many2one('account.full.reconcile', string="Matching Number", copy=False)
-    full_reconcile_id = fields.Many2one('account.full.reconcile', string="Full Reconcile")
+    full_reconcile_id = fields.Many2one('account.full.reconcile', string="Full Reconcile", copy=False)
-        return self.env['product.uom'].search([('category_id', '=', uom_categ_id), ('factor', '=', 1)], limit=1)
+        weight_uom_id = self.env.ref('product.product_uom_kgm', raise_if_not_found=False)
-            self.env['ir.property'].sudo().set_multi(
+            # keep the company of the current user before sudo
-        domain=[('deprecated', '=', False)], required=True)
+        domain=[('deprecated', '=', False)])
-                <field name='city_id' attrs="{'invisible': [('country_enforce_cities', '=', False)]}"/>
+                <field name='city' attrs="{'invisible': [('country_enforce_cities', '=', True), ('city_id', '!=', False)], 'readonly': [('type', '=', 'contact'), ('parent_id', '!=', False)]}"/>
-    address_format = fields.Text(
+    address_format = fields.Text(string="Layout in Reports",
-        comodel_name='ir.ui.view', string="Address View",
+        comodel_name='ir.ui.view', string="Input View",
-                }
+                values = self._prepare_sale_order_values(cr, uid, w, partner, context=context)
-import controllers
+import controllers
-        website_id = request.context.get('website_id') or request.registry['website'].search(cr, uid, [], limit=1)[0]
+        website_id = request.context.get('website_id') or request.env['website'].search([], limit=1).id
-    def _get_tax_vals(self, company):
+    def _get_tax_vals(self, company, tax_template_to_tax):
-            vals_tax['children_tax_ids'] = children_ids and [(6, 0, children_ids)] or []
+            vals_tax = tax._get_tax_vals(company, tax_template_to_tax)
-    def _get_tax_vals(self, company):
+    def _get_tax_vals(self, company, tax_template_to_tax):
-        res = super(AccountTaxTemplatePython, self)._get_tax_vals(company)
+        res = super(AccountTaxTemplatePython, self)._get_tax_vals(company, tax_template_to_tax)
-            my_qty = sbom.product_qty
+        result, result2 = bom.explode(self, 1)
-                price += sbom.product_id.uom_id._compute_price(sbom.product_id.standard_price, sbom.product_uom_id) * my_qty
+                price += sbom.product_id.uom_id._compute_price(sbom.product_id.standard_price, sbom.product_uom_id) * sbom_data['qty']
-            price = bom.product_uom_id._compute_price(price / bom.product_qty, bom.product_id.uom_id)
+            price = bom.product_uom_id._compute_price(price / bom.product_qty, self.uom_id)
-            :rtype: dict
+    def _prepare_reconcile_model_vals(self, company, account_reconcile_model, acc_template_ref, tax_template_ref):
-            vals = {
+        return {
-            res_ids = data.mapped('res_ids')
+            res_ids = data.mapped('res_id')
-                    super(calendar_event, self).write(cr, uid, [id], {'final_date': final_date}, context=context)
+            if any(field in values for field in ['recurrency', 'end_type', 'count', 'rrule_type', 'start', 'stop']):
-            res.append((leave.id, _("%s on %s : %.2f day(s)") % (leave.employee_id.name, leave.holiday_status_id.name, leave.number_of_days_temp)))
+            res.append((leave.id, _("%s on %s : %.2f day(s)") % (leave.employee_id.name or leave.category_id.name, leave.holiday_status_id.name, leave.number_of_days_temp)))
-            elif value <= 0 and operator == '>':
+            elif value < 0 and operator == '>':
-            elif value >= 0 and operator == '<':
+            elif value > 0 and operator == '<':
-                if not all(isinstance(x, int) for x in eval(lang.grouping)):
+                if not all(isinstance(x, int) for x in json.loads(lang.grouping)):
-from odoo import api, fields, models
+from odoo import fields, models
-        IrValues.set_default('event.config.settings', 'auto_confirmation', self.auto_confirmation)
+    module_event_sale = fields.Boolean("Tickets")
-            'auto_confirmation': 1
+            'default_auto_confirmation': 1
-                'auto_confirmation': 1
+                'default_auto_confirmation': 1
-    date_deadline = fields.Date('Due Date', index=True, required=True, default=fields.Date.today)
+    date_deadline = fields.Date('Deadline', index=True, required=True, default=fields.Date.today)
-    user_id = fields.Many2one('res.users', string='User', default=lambda self: self.env.user, required=True)
+    user_id = fields.Many2one('res.users', string='Cron User', default=lambda self: self.env.user, required=True)
-from openerp import tools, SUPERUSER_ID
+from openerp import api, tools, SUPERUSER_ID
-        self.invalidate_cache(cr, uid, context=context)
+    @api.multi
-        return res
+    @api.multi
-                'company_id': self._context.get('force_compay', self.env.user.company_id.id),
+                'company_id': self._context.get('force_company', self.env.user.company_id.id),
-            values['stage_id'] = self.stage_find(cr, uid, [], project_id, [('fold', '=', False)], context=context)
+            if project.exists():
-            values['partner_id'] = False
+    def action_cancel(self):
-            html_body = publish_template.with_context({'base_url': base_url}).render_template(publish_template.body_html, 'slide.slide', slide.id)
+            html_body = publish_template.with_context(base_url=base_url).render_template(publish_template.body_html, 'slide.slide', slide.id)
-        return self.channel_id.share_template_id.with_context({'email': email, 'base_url': base_url}).send_mail(self.id)
+        return self.channel_id.share_template_id.with_context(email=email, base_url=base_url).send_mail(self.id)
-        if entered_pin or self.env['res.users'].browse(SUPERUSER_ID).has_group('hr_attendance.group_hr_attendance_use_pin') and (self.user_id and self.user_id.id != self._uid or not self.user_id):
+        if not (entered_pin is None) or self.env['res.users'].browse(SUPERUSER_ID).has_group('hr_attendance.group_hr_attendance_use_pin') and (self.user_id and self.user_id.id != self._uid or not self.user_id):
-                if account_move_line in invoice.payment_move_line_ids:
+                if invoice.id == self.env.context.get('invoice_id') and account_move_line in invoice.payment_move_line_ids:
-        created_invoice = self.env['account.invoice'].browse(created_invoice)
+        # force company to ensure journals/accounts etc. are correct
-                amount_tax += line.price_tax
+                # FORWARDPORT UP TO 10.0
-                amount_tax += line.price_tax
+                # FORWARDPORT UP TO 10.0
-            return cls._redirect_to_messaging()
+        if uid is not None:
-            raise UserError(_('Invoice must be validated in order to set it to register payemnt.'))
+            raise UserError(_('Invoice must be validated in order to set it to register payment.'))
-            raise UserError(_('Invoice must be paid in order to set it to register payemnt.'))
+            raise UserError(_('Invoice must be paid in order to set it to register payment.'))
-            raise UserError(_("Invoice must be in draft,Pro-forma or open state in order to be cancelled."))
+            raise UserError(_("Invoice must be in draft, Pro-forma or open state in order to be cancelled."))
-            self.env[model].search_count([(field, 'in', aggr_ids)], limit=1)
+            self.env[model].search_count([(field, 'in', aggr_ids)])
-        request.context = dict(request.context, **context)
+        request.context = dict(request.context, **self.env.context)
-                if user_id == uid:
+                partner_id = self.pool['res.users'].browse(cr, uid, uid, context).partner_id.id
-            routes = product.route_ids + product.categ_id.route_ids
+            routes = product.route_ids + product.route_from_categ_ids
-        readonly=True, related='bom_id.routing_id', store=True,
+        readonly=True, compute='_compute_routing', store=True,
-
+
-        'product_id', 'invoice_id.partner_id', 'invoice_id.currency_id', 'invoice_id.company_id')
+        'product_id', 'invoice_id.partner_id', 'invoice_id.currency_id', 'invoice_id.company_id',
-            price_subtotal_signed = self.invoice_id.currency_id.compute(price_subtotal_signed, self.invoice_id.company_id.currency_id)
+            price_subtotal_signed = self.invoice_id.currency_id.with_context(date=self.invoice_id.date_invoice).compute(price_subtotal_signed, self.invoice_id.company_id.currency_id)
-                raise werkzeug.exceptions.BadRequest('Invalid CSRF Token')
+                raise werkzeug.exceptions.BadRequest('Session expired (invalid CSRF token)')
-            total_residual_company_signed = sum(invoice.residual_company_signed for invoice in self.invoice_ids)
+            total_residual_company_signed = self._compute_total_invoices_amount()
-            amount_wo = total_residual_company_signed - total_payment_company_signed
+            if self.invoice_ids[0].type in ['in_invoice', 'out_refund']:
-    timesheet_range = fields.Selection(related='company_id.timesheet_range', string="Timesheet range *")
+        'views/project_config_settings_views.xml',
-        help="This allows customers to give rating on provided services")
+    module_pad = fields.Boolean("Collaborative Pads")
-    module_project_forecast = fields.Boolean(string="Forecasts, planning and Gantt charts")
+    module_project_forecast = fields.Boolean(string="Forecasts")
-        help="This allows customers to give rating on issue")
+    module_project_issue_sheet = fields.Boolean(string="Timesheets on Issues")
-        # ----------------------------------------
+        # ---------------------------------------------------------------
-        if self.env['res.users'].browse(SUPERUSER_ID).has_group('hr_attendance.group_hr_attendance_use_pin') and (self.user_id and self.user_id.id != self._uid or not self.user_id):
+        if entered_pin or self.env['res.users'].browse(SUPERUSER_ID).has_group('hr_attendance.group_hr_attendance_use_pin') and (self.user_id and self.user_id.id != self._uid or not self.user_id):
-    module_mass_mailing_themes = fields.Boolean("Mass mailing themes")
+    group_mass_mailing_campaign = fields.Boolean(string="Mass Mailing Campaigns", implied_group='mass_mailing.group_mass_mailing_campaign', help="""This is useful if your marketing campaigns are composed of several emails""")
-        implied_group="website_mass_mailing.group_website_popup_on_exit")
+    group_website_popup_on_exit = fields.Boolean(string="Website Popup", implied_group="website_mass_mailing.group_website_popup_on_exit")
-        return super(account_payment, self.sudo()).create(vals)
+        return super(account_payment, self).create(vals)
-from odoo import api, exceptions, models
+from odoo import api, exceptions, fields, models
-    _inherit = 'account.abstract.payment'
+    _inherit = ['mail.thread', 'account.abstract.payment']
-            self.move_raw_ids.action_confirm()
+            production._adjust_procure_method()
-    cost = fields.Float('Unit Cost')
+    cost = fields.Float('Unit Cost', group_operator='avg')
-            _logger.exception("Fail to upload attachment %s" % ufile.filename)
+        args = []
-    res_model = fields.Char(string='Document Model', required=True, help="Model name of the rated object", index=True)
+    res_model_id = fields.Many2one('ir.model', 'Related Document Model', index=True, ondelete='cascade', help='Model of the followed resource')
-            rating = self.env['rating.rating'].create({'partner_id': partner.id, 'rated_partner_id': rated_partner.id, 'res_model': self._name, 'res_id': self.id})
+            record_model_id = self.env['ir.model'].sudo().search([('model', '=', self._name)], limit=1).id
-                'res_model': res_model,
+                'res_model_id': res_model_id,
-                    'res_model': res_model,
+                    'res_model_id': res_model_id,
-                'consumed': True
+                'consumed': True,
-from odoo import api, fields, models, tools
+from odoo import api, fields, models, tools, _
-    res_name = fields.Char(string='Resource Name', compute='_compute_res_name', store=True, help="The name of the rated resource.")
+    res_name = fields.Char(string='Resource name', compute='_compute_res_name', store=True, help="The name of the rated resource.")
-    rated_partner_id = fields.Many2one('res.partner', string="Rated Partner", help="Owner of the rated resource")
+    rated_partner_id = fields.Many2one('res.partner', string="Rated person", help="Owner of the rated resource")
-    feedback = fields.Text('Feedback reason', help="Reason of the rating")
+    rating_image = fields.Binary('Image', compute='_compute_rating_image')
-    rating_ids = fields.One2many('rating.rating', 'res_id', string='Rating', domain=lambda self: [('res_model', '=', self._name)])
+    rating_ids = fields.One2many('rating.rating', 'res_id', string='Rating', domain=lambda self: [('res_model', '=', self._name)], auto_join=True)
-    def rating_send_request(self, template, partner=None, rated_partner=None, reuse_rating=True, force_send=True):
+    def rating_send_request(self, template, lang=False, force_send=True):
-        partner = (partner or self.env['res.partner']).sudo()
+        lang = lang or 'en_US'
-            self.filtered(lambda x: x.project_id.rating_status == 'stage')._send_task_rating_mail()
+            self.filtered(lambda x: x.project_id.rating_status == 'stage')._send_task_rating_mail(force_send=True)
-    def _send_task_rating_mail(self):
+    def _send_task_rating_mail(self, force_send=False):
-                task.rating_send_request(rating_template, partner=task.partner_id, reuse_rating=False, force_send=force_send)
+                task.rating_send_request(rating_template, lang=task.partner_id.lang, force_send=force_send)
-        projects.with_context(force_send=False)._send_rating_mail()
+        projects._send_rating_mail()
-            self.filtered(lambda x: x.project_id.rating_status == 'stage')._send_issue_rating_mail()
+            self.filtered(lambda x: x.project_id.rating_status == 'stage')._send_issue_rating_mail(force_send=True)
-    def _send_issue_rating_mail(self):
+    def _send_issue_rating_mail(self, force_send=False):
-                issue.rating_send_request(rating_template, partner=issue.partner_id, reuse_rating=False)
+                issue.rating_send_request(rating_template, lang=issue.partner_id.lang, force_send=force_send)
-        if self.use_tasks: # add task domain, if neeeded
+        if self.use_tasks:  # add task domain, if needed
-        if self.use_issues: # add issue domain if needed
+        if self.use_issues:  # add issue domain if needed
-        'views/project_dashboard.xml',
+import test_backend_view
-                res[group] += tax.compute_all(line.price_reduce, quantity=line.product_uom_qty)['taxes'][0]['amount']
+                amount = tax.compute_all(line.price_reduce + base_tax, quantity=line.product_uom_qty)['taxes'][0]['amount']
-    @api.onchange('partner_id', 'type')
+    @api.onchange('partner_id', 'type', 'reference_type')
-    @api.multi
+        'data/mail_template_data.xml',
-        ], string='Request Type', required=True, readonly=True, index=True, default='remove',
+        ], string='Request Type', required=True, readonly=True, index=True, track_visibility='always', default='remove',
-            res.append((leave.id, _("%s on %s : %.2f day(s)") % (leave.employee_id.name, leave.holiday_status_id.name, leave.number_of_days_temp)))
+            if leave.type == 'remove':
-    open = fields.Boolean(string='Active', track_visibility='onchange', default=True)
+    open = fields.Boolean(string='Active', default=True)
-            }
+            vals = self._get_account_vals(company, account_template, code_acc, tax_template_ref)
-                blocktime.duration = round(diff.total_seconds() / 60.0, 2)
+                d1 = fields.Datetime.from_string(blocktime.date_start)
-    color = fields.Integer('Color Index')
+    color = fields.Integer('Color Index', default=10)
-    color = fields.Integer('Color Index')
+    color = fields.Integer('Color Index', default=10)
-    color = fields.Integer('Color Index')
+    color = fields.Integer('Color Index', default=10)
-    color = fields.Integer('Color Index')
+    color = fields.Integer('Color Index', default=10)
-    color = fields.Integer(string='Color Index')
+    color = fields.Integer(string='Color Index', default=10)
-    color = fields.Integer(string='Color Index')
+    color = fields.Integer(string='Color Index', default=10)
-    color = fields.Integer(string='Color Index')
+    color = fields.Integer(string='Color Index', default=10)
-    'name': 'Mass Mailing Campaigns',
+    'name': 'Email Marketing',
-        kanban_box = E.t(div, {'t-name': "kanban-box"})
+        content_div = E.div(field, {'class': "o_kanban_card_content"})
-                    _logger.warning('Invalid custom view(s) for model %s', model)
+                try:
-                else:
+                elif _logger.isEnabledFor(logging.INFO):    # more an info that a warning...
-    po_lead = fields.Float(related='company_id.po_lead', string="Purchase Lead Time")
+# -*- coding: utf-8 -*-
-class StockSettings(models.TransientModel):
+class StockConfigSettings(models.TransientModel):
-        ], "Packaging Methods",
+        (1, 'Immediately after sales order confirmation'),
-        ], "Packages",
+        help="Select or scan the packaging used to transfer products in operations. This allows to update or check the unit # transferred (which must be a multiple of the unit # per package). Packaging types are set on product detail form.")
-        ], "Routes",
+        help="Put products in packages and get shipping labels per package unit thanks to shipping connectors.")
-    module_quality = fields.Boolean(string="Quality", help="This module allows you to generate quality alerts and quality check")
+        help="Add and customize route operations to process product moves in your warehouse(s): e.g. unload > quality control > stock for incoming products, pick > pack > ship for outgoing products. \n You can also set putaway strategies on warehouse locations in order to send incoming products into specific child locations straight away (e.g. specific bins, racks).")
-        self.group_stock_multi_warehouses = self.warehouse_and_location_usage_level > 1
+    @api.onchange('group_stock_multi_warehouses')
-            self.warehouse_and_location_usage_level = 1
+        if self.group_stock_adv_location and not self.group_stock_multi_locations:
-        help="""Install the module that allows to affect landed costs on pickings, and split them onto the different products.""")
+    group_stock_inventory_valuation = fields.Boolean("Perpetual Valuation", implied_group='stock_account.group_inventory_valuation',
-        return self.env['ir.values'].set_default('product.category', 'property_valuation', data[self.group_stock_inventory_valuation])
+    @api.model
-            self.group_stock_inventory_valuation = 1
+    @api.multi
-            res.update(state='done', date_validate=data.get('payment_date', fields.Datetime.now()))
+            try:
-        self.assertEqual(tx.date_validate, '2013-11-18 03:21:19', 'paypal: wrong validation date')
+        self.assertEqual(tx.date_validate, '2013-11-18 11:21:19', 'paypal: wrong validation date')
-            res.update(state='done', date_validate=data.get('payment_date', fields.datetime.now()))
+            res.update(state='done', date_validate=data.get('payment_date', fields.Datetime.now()))
-        print(data['config_ids'])
+        print(data['config_ids'])
-# in odoo.cli.server was working.
+# Make sure the OpenERP server runs in UTC.
-del time
+os.environ['TZ'] = 'UTC' # Set the timezone
-            if data.get('vat', partner.vat) != partner.vat:
+            if (data.get('vat', partner.vat) or False) != partner.vat:
-        help='Work with product variant allows you to define some variant of the same products, an ease the product management in the ecommerce for example',
+    manufacturing_lead = fields.Float(related='company_id.manufacturing_lead', string="Manufacturing Lead Time")
-             'that will define the required raw materials.')
+    module_mrp_byproduct = fields.Boolean("By-Products")
-        'mail.alias', 'Alias', ondelete='cascade', required=True,
+        'mail.alias', 'Alias', ondelete='restrict', required=True,
-                        attendee_records.with_context(context_tmp).write({'oe_synchro_date': meeting.oe_update_date, 'google_internal_event_id': event.GG.event['id']})
+                        self.create_from_google(event, my_partner_id)
-                                                string='Employee PIN', help='Enable or disable employee PIN identification at check in', implied_group="hr_attendance.group_hr_attendance_use_pin")
+    group_attendance_use_pin = fields.Boolean(string='Employee PIN',
-                    sib = node.getnext()
+                elif pos == 'inside':
-                            self.raise_view_error(_("Invalid position attribute: '%s'") % pos, inherit_id)
+                        node.append(child)
-from odoo import fields, models
+from odoo import api, fields, models
-    ], string="Reprints")
+    group_multi_currency = fields.Boolean("Multi-Currencies", implied_group='base.group_multi_currency')
-    sale_id = fields.Many2one('sale.order', "Sales Order", compute='_compute_sale_id', search='_search_sale_id')
+    sale_id = fields.Many2one('sale.order', "Sales Order", compute='_compute_sale_id', store=True)
-    module_sale_contract = fields.Boolean("Manage subscriptions and recurring invoicing")
+    module_sale_contract = fields.Boolean("Subscriptions")
-            domain = [('company_id', '=', company_id), ('date_start', '<', now), ('date_stop', '>', now)]
+            domain = [('company_id', '=', company_id), ('date_start', '<=', now), ('date_stop', '>=', now)]
-        domain = [('company_id', '=', company_id), ('date_start', '<', now), ('date_stop', '>', now)]
+        domain = [('company_id', '=', company_id), ('date_start', '<=', now), ('date_stop', '>=', now)]
-version_info = (11, 0, 0, ALPHA, 1, '')
+version_info = (10, 'saas~14', 0, FINAL, 0, '')
-        migrations = openerp.modules.migration.MigrationManager(cr, graph)
+        migrations = odoo.modules.migration.MigrationManager(cr, graph)
-        'views/report_templates.xml',
+        'views/res_company_view.xml',
-    'qweb' : [
+    'qweb': [
-from odoo import fields, models
+from odoo import fields, models, _
-        help='Define your custom header & footer.', default_model='base.config.settings')
+    external_report_layout = fields.Selection(related="company_id.external_report_layout")
-        return self.company_id.edit_external_header()
+        return self._prepare_report_view_action('report.layout_'+self.external_report_layout)
-        return self.company_id.edit_external_footer()
+    def change_report_template(self):
-from odoo import api, fields, models, _
+from odoo import api, fields, models, SUPERUSER_ID, _
-            for node in root.xpath(match_klass.format('page')):
+            for node in root.xpath(match_klass.format('article')):
-    def get_action(self, docids, report_name, data=None):
+    def get_action(self, docids, report_name, data=None, config=True):
-            })
+    external_report_layout = fields.Selection([
-        return self._prepare_report_view_action('report.internal_layout')
+
-    rml_header1 = fields.Char(string='Company Tagline', help="Appears by default on the top right corner of your printed documents (report header).")
+    rml_header1 = fields.Text(string='Company Tagline', help="Appears by default on the top right corner of your printed documents (report header).")
-    ], "Report Footer", default=0, help="""Set to 'custom' this to define the report footer manually. Otherwise it will be filled in automatically.""")
+    rml_footer = fields.Text(string='Report Footer', translate=True, help="Footer text displayed at the bottom of all reports.")
-    logo = fields.Binary(related='partner_id.image', default=_get_logo)
+    logo = fields.Binary(related='partner_id.image', default=_get_logo, string="Company Logo")
-    user_type_id = fields.Many2one('account.account.type', string='Type', required=True, oldname="user_type", 
+    user_type_id = fields.Many2one('account.account.type', string='Type', required=True, oldname="user_type",
-    display_on_footer = fields.Boolean("Show in Invoices Footer", help="Display this bank account on the footer of printed documents like invoices and sales orders.")
+        'views/account_journal_views.xml',
-        journals = self.env['account.journal'].search([('type', '=', 'bank'), ('display_on_footer', '=', True), ('company_id', '=', company_id)])
+        journals = self.env['account.journal'].search([('type', '=', 'bank'), ('use_in_payment', '=', True), ('company_id', '=', company_id)])
-            elif self.partner_id.picking_warn not in ('no-message', 'block') and partner.parent_id.picking_warn == 'block':
+            elif self.partner_id.picking_warn not in ('no-message', 'block') and self.partner_id.parent_id.picking_warn == 'block':
-    use_opportunities = fields.Boolean('Pipeline', help="Check this box to manage opportunities in this sales channel.")
+    use_leads = fields.Boolean('Leads', help="Check this box to filter and qualify incoming requests as leads before converting them into opportunities and assigning them to a salesperson.")
-    use_quotations = fields.Boolean(string='Quotations', help="Check this box to manage quotations in this sales channel.")
+    use_quotations = fields.Boolean(string='Quotations', help="Check this box if you send quotations to your customers rather than confirming orders straight away. "
-    quotations_to_invoice_count = fields.Integer(
+    quotations_count = fields.Integer(
-    quotations_to_invoice_amount = fields.Integer(
+    quotations_amount = fields.Integer(
-            self.browse(rec['team_id'][0]).quotations_to_invoice_count += 1
+            self.browse(rec['team_id'][0]).quotations_amount += rec['price_total']
-            ('partner_id', '!=', self.env.ref('base.public_user').id),
+            ('partner_id', '!=', self.env.ref('base.public_partner').id),
-from odoo import fields, models, _
+from odoo import api, fields, models, _
-            if self.dashboard_graph_group == 'user':
+            if self.dashboard_graph_group_pos == 'pos':
-                    groupby=['date:' + self.dashboard_graph_group]
+                    groupby=['date:' + self.dashboard_graph_group_pos]
-                if self.dashboard_graph_group == 'day':
+                if self.dashboard_graph_group_pos == 'day':
-                if self.dashboard_graph_group == 'week':
+                elif self.dashboard_graph_group_pos == 'week':
-                if self.dashboard_graph_group == 'month':
+                        # also this week result is non-standard, so week numbers might be wrong here...
-            if team.dashboard_graph_group == 'user' or team.dashboard_graph_period == 'week' and team.dashboard_graph_group != 'day' or team.dashboard_graph_period == 'month' and team.dashboard_graph_group != 'day':
+            if team.dashboard_graph_group in (False, 'user') or team.dashboard_graph_period == 'week' and team.dashboard_graph_group != 'day' \
-import openerp
+from openerp.modules.module import get_resource_path
-        by 'pre' or 'post' and will be executed, respectively, before and after the module initialisation
+        Migrations files must be python files containing a `migrate(cr, installed_version)`
-                |-- 5.0.1.1                     # files in this folder will be executed only on a 5.0 server
+                |   |-- post-create_plop_records.py
-        the maintenance contract
+                `-- foo.py                              # not processed
-        self.migrations = {}
+        self.migrations = defaultdict(dict)
-        #"""
+        def get_scripts(path):
-            if not (hasattr(pkg, 'update') or pkg.state == 'to upgrade'):
+            if not (hasattr(pkg, 'update') or pkg.state == 'to upgrade' or
-            self.migrations[pkg.name]['maintenance'] = get_module_filetree('base', 'maintenance/migrations/' + pkg.name) or {}
+            self.migrations[pkg.name] = {
-        assert stage in ('pre', 'post')
+        assert stage in ('pre', 'post', 'end')
-        if not (hasattr(pkg, 'update') or pkg.state == 'to upgrade') or pkg.state == 'to install':
+        if not (hasattr(pkg, 'update') or state == 'to upgrade') or state == 'to install':
-                __get_dir(self.migrations[pkg.name]['maintenance'])
+                ver
-            """ return a list of tuple (module, file)
+            """ return a list of migration script files
-                if version in m[x]:
+                if version in m.get(x):
-        parsed_installed_version = parse_version(pkg.installed_version or '')
+        parsed_installed_version = parse_version(getattr(pkg, 'load_version', pkg.installed_version) or '')
-                self.sudo().action_confirm()
+            transaction._confirm_so()
-                                        help='Generate tax cash basis entrie when reconciliating entries')
+    tax_cash_basis_journal_id = fields.Many2one(
-    user_id = fields.Many2one('res.users', 'Me', default=lambda self: self.env.user)
+    user_id = fields.Many2one('res.users', 'Me', required=True, default=lambda self: self.env.user)
-
+
-    order_mail_template = fields.Many2one('mail.template', string='Order Confirmation Email', default=_default_order_mail_template, help="Email sent to customer at the end of the checkout process")
+    order_mail_template = fields.Many2one('mail.template', string='Order Confirmation Email',
-        arch = etree.tostring(doc)
+        if self._name == 'res.partner':
-        ('total', 'Show line subtotals with taxes included (B2C)')], "Tax Display",
+        ('subtotal', 'Tax-Included Prices'),
-                partner.street_number2 = ''
+                for field in street_fields:
-    is_default = fields.Boolean(string='Default filter')
+    is_default = fields.Boolean(string='Default Filter')
-    web_icon_data = fields.Binary(string='Web Icon Image', compute="_compute_web_icon", store=True, attachment=True)
+    web_icon_data = fields.Binary(string='Web Icon Image', attachment=True)
-
+        if 'web_icon' in values:
-        arch = super(FormatAddressMixin, self).fields_view_get_address(arch)
+    def _fields_view_get_address(self, arch):
-            </div>
+                <field name="country_enforce_cities" invisible="1"/>
-        holidays = self.env['hr.holidays'].search([
+        holidays = self.env['hr.holidays'].sudo().search([
-    model = fields.Char(related='model_id.model', readonly=True)
+    action_server_id = fields.Many2one(
-                             ('on_time', 'Based on Timed Condition')], string='When to Run', required=True)
+    trigger = fields.Selection([
-    filter_pre_id = fields.Many2one("ir.filters", string='Before Update Filter', ondelete='restrict', domain="[('model_id', '=', model_id.model)]",
+    filter_pre_id = fields.Many2one("ir.filters", string='Before Update Filter', ondelete='restrict',
-    filter_id = fields.Many2one("ir.filters", string='Filter', ondelete='restrict', domain="[('model_id', '=', model_id.model)]",
+    filter_id = fields.Many2one("ir.filters", string='Filter', ondelete='restrict',
-    CRITICAL_FIELDS = ['model_id', 'active', 'kind', 'on_change_fields']
+    CRITICAL_FIELDS = ['model_id', 'active', 'trigger', 'on_change_fields']
-        if self.kind in ['on_create', 'on_create_or_write', 'on_unlink']:
+    @api.onchange('trigger')
-        elif self.kind in ['on_write', 'on_create_or_write']:
+        elif self.trigger in ['on_write', 'on_create_or_write']:
-        elif self.kind == 'on_time':
+        elif self.trigger == 'on_time':
-        return cron and cron.toggle(model=self._name, domain=[('kind', '=', 'on_time')])
+        return cron and cron.toggle(model=self._name, domain=[('trigger', '=', 'on_time')])
-        """ Return the actions of the given kinds for records' model. The
+    def _get_actions(self, records, triggers):
-        domain = [('model', '=', records._name), ('kind', 'in', kinds)]
+        domain = [('model_name', '=', records._name), ('trigger', 'in', triggers)]
-        if self.server_action_ids:
+        if self.action_server_id:
-                self.server_action_ids.with_context(**ctx).run()
+                self.action_server_id.with_context(**ctx).run()
-                            result['warning'] = res['warning']
+                server_action = action_rule.action_server_id.with_context(active_model=self._name, onchange_self=self)
-            if action_rule.kind == 'on_create':
+            Model = self.env[action_rule.model_name]
-            elif action_rule.kind == 'on_create_or_write':
+            elif action_rule.trigger == 'on_create_or_write':
-            elif action_rule.kind == 'on_write':
+            elif action_rule.trigger == 'on_write':
-            elif action_rule.kind == 'on_unlink':
+            elif action_rule.trigger == 'on_unlink':
-            elif action_rule.kind == 'on_change':
+            elif action_rule.trigger == 'on_change':
-        for action in self.with_context(active_test=True).search([('kind', '=', 'on_time')]):
+        for action in self.with_context(active_test=True).search([('trigger', '=', 'on_time')]):
-            records = self.env[action.model].with_context(context).search(domain)
+            records = self.env[action.model_name].with_context(context).search(domain)
-    'depends': ['base', 'mail', 'base_automation', 'web_calendar'],
+    'depends': ['base', 'mail', 'web_calendar'],
-    'depends': ['base_automation', 'hr'],
+    'depends': ['hr'],
-        return super(BaseAutomation, self)._check_delay(action, record, record_dt)
+from datetime import date
-        return self.write({'state': 'close'})
+    @api.model
-        'views/base_action_rule_view.xml',
+        'data/base_automation_data.xml',
-        'data/base_action_rule_demo.xml',
+        'data/base_automation_demo.xml',
-import base_action_rule
+import base_automation
-    _description = 'Action Rules'
+class BaseAutomation(models.Model):
-        base_action_rule = super(BaseActionRule, self).create(vals)
+        base_automation = super(BaseAutomation, self).create(vals)
-        return base_action_rule
+        return base_automation
-        res = super(BaseActionRule, self).write(vals)
+        res = super(BaseAutomation, self).write(vals)
-        res = super(BaseActionRule, self).unlink()
+        res = super(BaseAutomation, self).unlink()
-        cron = self.env.ref('base_action_rule.ir_cron_data_bar_check', raise_if_not_found=False)
+        cron = self.env.ref('base_automation.ir_cron_data_base_automation_check', raise_if_not_found=False)
-                actions = self.env['base.action.rule']._get_actions(self, ['on_create', 'on_create_or_write'])
+                actions = self.env['base.automation']._get_actions(self, ['on_create', 'on_create_or_write'])
-                actions = self.env['base.action.rule']._get_actions(self, ['on_write', 'on_create_or_write'])
+                actions = self.env['base.automation']._get_actions(self, ['on_write', 'on_create_or_write'])
-                actions = self.env['base.action.rule']._get_actions(self, ['on_unlink'])
+                actions = self.env['base.automation']._get_actions(self, ['on_unlink'])
-                action_rule = self.env['base.action.rule'].browse(action_rule_id)
+            def base_automation_onchange(self):
-            return base_action_rule_onchange
+            return base_automation_onchange
-import test_base_action_rule
+import test_base_automation
-class base_action_rule_test(common.TransactionCase):
+class base_automation_test(common.TransactionCase):
-        super(base_action_rule_test, self).setUp()
+        super(base_automation_test, self).setUp()
-        return self.env['base.action.rule.lead.test'].create(vals)
+        return self.env['base.automation.lead.test'].create(vals)
-        line = self.env['base.action.rule.line.test'].create({'name': "Line"})
+        line = self.env['base.automation.line.test'].create({'name': "Line"})
-    _name = "base.action.rule.lead.test"
+    _name = "base.automation.lead.test"
-    line_ids = fields.One2many('base.action.rule.line.test', 'lead_id')
+    line_ids = fields.One2many('base.automation.line.test', 'lead_id')
-    _name = "base.action.rule.line.test"
+    _name = "base.automation.line.test"
-    lead_id = fields.Many2one('base.action.rule.lead.test', ondelete='cascade')
+    lead_id = fields.Many2one('base.automation.lead.test', ondelete='cascade')
-    'depends': ['base', 'mail', 'base_action_rule', 'web_calendar'],
+    'depends': ['base', 'mail', 'base_automation', 'web_calendar'],
-        'base_action_rule',
+        'base_automation',
-        'data/base_action_rule_demo.xml',
+        'data/base_automation_demo.xml',
-    'depends': ['base_action_rule', 'hr'],
+    'depends': ['base_automation', 'hr'],
-        'views/base_action_rule_views.xml',
+        'views/base_automation_views.xml',
-import base_action_rule
+import base_automation
-class BaseActionRule(models.Model):
+class BaseAutomation(models.Model):
-    _inherit = 'base.action.rule'
+    _inherit = 'base.automation'
-        return super(BaseActionRule, self)._check_delay(action, record, record_dt)
+        return super(BaseAutomation, self)._check_delay(action, record, record_dt)
-    write_date = fields.Datetime(index=True)  #not displayed in the view but it might be useful with base_action_rule module (and it needs to be defined first for that)
+    write_date = fields.Datetime(index=True)  #not displayed in the view but it might be useful with base_automation module (and it needs to be defined first for that)
-        # TODO remove 'check' argument from addons/base_action_rule/base_action_rule.py
+        # TODO remove 'check' argument from addons/base_automation/base_automation.py
-        cron = self.env.ref('base_action_rule.ir_cron_crm_action', raise_if_not_found=False)
+        cron = self.env.ref('base_action_rule.ir_cron_data_bar_check', raise_if_not_found=False)
-        ('ir_actions_server', 'Server Action')], string='Usage',
+        ('ir_actions_server', 'Server Action'),
-from odoo.tools.safe_eval import safe_eval
+from odoo.exceptions import UserError
-    _order = 'name'
+    _order = 'cron_name'
-    name = fields.Char(required=True)
+    ir_actions_server_id = fields.Many2one(
-            raise ValidationError(_('Invalid arguments'))
+    @api.model
-            self.sudo(user=cron.user_id.id)._callback(cron.model, cron.function, cron.args, cron.id)
+            self.sudo(user=cron.user_id.id).ir_actions_server_id.run()
-    def _handle_callback_exception(self, model_name, method_name, args, job_id, job_exception):
+    def _handle_callback_exception(self, cron_name, server_action_id, job_id, job_exception):
-        """
+        Simply logs the exception and rollback the transaction. """
-                          model_name, method_name, args, job_id)
+        _logger.exception("Call from cron %s for server action %d failed in Job %s",
-        """
+    def _callback(self, cron_name, server_action_id, job_id):
-                _logger.warning("Model %r does not exist.", model_name)
+
-            self._handle_callback_exception(model_name, method_name, args, job_id, e)
+            self._handle_callback_exception(cron_name, server_action_id, job_id, e)
-                        cron._callback(job['model'], job['function'], job['args'], job['id'])
+                        cron._callback(job['cron_name'], job['ir_actions_server_id'], job['id'])
-                    _logger.debug("Job `%s` already executed by another process/thread. skipping it", job['name'])
+                    _logger.debug("Job `%s` already executed by another process/thread. skipping it", job['cron_name'])
-                _logger.debug('Starting job `%s`.', job['name'])
+                _logger.debug('Starting job `%s`.', job['cron_name'])
-                    _logger.debug('Another process/thread is already busy executing job `%s`, skipping it.', job['name'])
+                    _logger.debug('Another process/thread is already busy executing job `%s`, skipping it.', job['cron_name'])
-            cron_ids[u] = Cron.create({'name': u, 'user_id': user_ids[u]}).id
+            cron_ids[u] = Cron.create({'name': u, 'model_id': self.env.ref('base.model_res_partner').id, 'user_id': user_ids[u]}).id
-    state = fields.Selection(selection_add=[('email', 'Send Email')])
+    state = fields.Selection(selection_add=[
-    def test_00_state_email(self):
+    def test_email_action(self):
-                                 "is given in the help tab.")
+    usage = fields.Selection([
-        ('object_write', 'Write on a Record'),
+        ('object_create', 'Create a new Record'),
-                                  string="Creation Policy", default='new', required=True)
+    # Create
-                                          "to the current record on which the server action runs.")
+    crud_model_name = fields.Char(related='crud_model_id.name', readonly=True)
-                                   help="Provide an expression that, applied on the current record, gives the field to update.")
+                                    help="Provide the field used to link the newly created record"
-        """ When changing the CRUD model, update its stored name also """
+        self.crud_model_name = self.crud_model_id.model
-        self.id_value = self.id_object.id if self.id_object else False
+    @api.onchange('model_id')
-        self.env[model].browse(ref_id).write(res)
+        self.env[action.model_id.model].browse(self._context.get('active_id')).write(res)
-            res = self.env[model].create(res)
+        res = self.env[action.crud_model_id.model].create(res)
-        if action.link_new_record and action.link_field_id:
+        if action.link_field_id:
-        condition or code server actions.
+        python formulas or code server actions.
-        allows easy overriding of the server actions.
+        """ Runs the server action. For each server action, the
-                                            " that can use the same values as for the condition field on the server action.\n"
+                                            " that can use the same values as for the code field on the server action.\n"
-    def test_40_crud_create(self):
+    def test_20_crud_create(self):
-            'link_new_record': True,
+            'crud_model_id': self.action.model_id.id,
-            'link_new_record': False,
+            'link_field_id': False,
-    def test_50_crud_write(self):
+    def test_30_crud_write(self):
-        # Do: create a new record in the same model and link it
+        # Do: update partner name
-        # Test: new partner created
+        # Test: partner updated
-    def test_60_multi(self):
+    def test_40_multi(self):
-            'use_create': 'copy_current',
+            'fields_lines': [(0, 0, {'col1': self.res_partner_name_field.id, 'value': 'RaoulettePoiluchette'}),
-        self.assertEqual(len(partner), 1, 'ir_actions_server: TODO')
+        partner = self.test_partner.search([('name', 'ilike', 'RaoulettePoiluchette')])
-
+    state = fields.Selection(selection_add=[('email', 'Send Email')])
-#  - records: Records on which the action is triggered if there is one, otherwise None
+#  - model: Odoo Model of the record on which the action is triggered; is a void recordset
-                                  "- 'Send Email': automatically send an email (available in email_template)")
+    state = fields.Selection([
-                                        help='More menu entry.', copy=False)
+    model_name = fields.Char(related='model_id.model', readonly=True, store=True)
-    'depends': ['sale', 'crm', 'web_kanban_gauge'],
+    'depends': ['sale', 'crm'],
-sales team, or an opportunity which still has status pending after 14 days might
+sales channel, or an opportunity which still has status pending after 14 days might
-        index=True, track_visibility='onchange', help='When sending mails, the default email address is taken from the sales team.')
+    team_id = fields.Many2one('crm.team', string='Sales Channel', oldname='section_id', default=lambda self: self.env['crm.team'].sudo()._get_default_team_id(user_id=self.env.uid),
-        # set up context used to find the lead's sales team which is needed
+        # set up context used to find the lead's sales channel which is needed
-            :param team : the id of the sales team. If not given, will be determined by `_merge_data`.
+            :param team : the id of the sales channel. If not given, will be determined by `_merge_data`.
-        # force value for saleperson and sales team
+        # force value for saleperson and sales channel
-        # check if the stage is in the stages of the sales team. If not, assign the stage with the lowest sequence
+        # check if the stage is in the stages of the sales channel. If not, assign the stage with the lowest sequence
-            :param team_id : identifier of the sales team to determine the stage
+            :param team_id : identifier of the sales channel to determine the stage
-    # Sales Team Dashboard
+    # Sales Channel Dashboard
-            context should not create a stage for the current sales team only
+            context should not create a stage for the current sales channel only
-from odoo import api, fields, models
+from dateutil.relativedelta import relativedelta
-    alias_id = fields.Many2one('mail.alias', string='Alias', ondelete="restrict", required=True, help="The email address associated with this team. New emails received will automatically create new leads assigned to the team.")
+    use_leads = fields.Boolean('Leads', help="The first contact you get with a potential customer is a lead you qualify before converting it into a real "
-    as a member of one of the sales team.
+    Looks like you are not a member of a sales channel. You should add yourself
-                action['help'] += "<p>As you don't belong to any sales team, Odoo opens the first one by default.</p>"
+                action['help'] += "<p>As you don't belong to any sales channel, Odoo opens the first one by default.</p>"
-        help="Odoo will generate an email alias based on the sales team name")
+    generate_sales_team_alias = fields.Boolean("Automatically generate an email alias at the sales channel creation",
-    team_id = fields.Many2one('crm.team', string='Sales Team', oldname='section_id')
+    team_id = fields.Many2one('crm.team', string='Sales Channel', oldname='section_id')
-    team_id = fields.Many2one('crm.team', 'Sales Team', readonly=True)
+    team_id = fields.Many2one('crm.team', 'Sales Channel', readonly=True)
-    team_id = fields.Many2one('crm.team', 'Sales Team', oldname='section_id', readonly=True)
+    team_id = fields.Many2one('crm.team', 'Sales Channel', oldname='section_id', readonly=True)
-            'name': 'Test Sales Team',
+            'name': 'Test Sales Channel',
-        # subscribe a partner and a channel to the sales team with new lead subtype
+        subscribed to the sales channel shoud be notified. """
-    team_id = fields.Many2one('crm.team', 'Sales Team', oldname='section_id', index=True)
+    team_id = fields.Many2one('crm.team', 'Sales Channel', oldname='section_id', index=True)
-    team_id = fields.Many2one('crm.team', 'Sales Team', index=True, oldname='section_id')
+    team_id = fields.Many2one('crm.team', 'Sales Channel', index=True, oldname='section_id')
-    team_id = fields.Many2one('crm.team', 'Sales Team', oldname='section_id', index=True)
+    team_id = fields.Many2one('crm.team', 'Sales Channel', oldname='section_id', index=True)
-                    raise UserError(_("You cannot confirm all orders of this session, because they have not the 'paid' status"))
+                    raise UserError(_("You cannot confirm all orders of this session, because they don't have the 'paid' status"))
-    cash_control = fields.Boolean(compute='_compute_cash_all',    string='Has Cash Control')
+    cash_control = fields.Boolean(compute='_compute_cash_all', string='Has Cash Control')
-    team_id = fields.Many2one('crm.team', string='Sales Team', default=_get_default_team, oldname='section_id')
+    team_id = fields.Many2one('crm.team', string='Sales Channel', default=_get_default_team, oldname='section_id')
-    team_id = fields.Many2one('crm.team', 'Sales Team', change_default=True, default=_get_default_team, oldname='section_id')
+    team_id = fields.Many2one('crm.team', 'Sales Channel', change_default=True, default=_get_default_team, oldname='section_id')
-from odoo import api, fields, models
+from odoo import api, fields, models, _
-        help="Check this box to manage invoices in this sales team.")
+    use_quotations = fields.Boolean(string='Quotations', help="Check this box to manage quotations in this sales channel.")
-                "team has invoiced this month. It is used to compute the progression ratio "
+                "channel has invoiced this month. It is used to compute the progression ratio "
-        string='Invoice Target',
+        string='Invoicing Target',
-        string="Currency", readonly=True, required=True)
+             "channel estimates to be able to invoice this month.")
-        amounts = self.env['sale.order'].read_group([
+    def _compute_sales_to_invoice(self):
-        ], ['amount_total', 'team_id'], ['team_id'])
+            ('qty_to_invoice', '>', 0),
-            self.browse(rec['team_id'][0]).sales_to_invoice_amount = rec['amount_total']
+            self.browse(rec['team_id'][0]).sales_to_invoice_count += 1
-    team_id = fields.Many2one('crm.team', string='Sales Team')
+    team_id = fields.Many2one('crm.team', string='Sales Channel')
-    team_id = fields.Many2one('crm.team', 'Sales Team', readonly=True, oldname='section_id')
+    team_id = fields.Many2one('crm.team', 'Sales Channel', readonly=True, oldname='section_id')
-        'views/crm_team_views.xml',
+import crm_team
-    'name': 'Sales Teams',
+    'name': 'Sales Channels',
-    'summary': 'Sales Team',
+    'summary': 'Sales Channels',
-Using this application you can manage Sales Team  with CRM and/or Sales 
+Using this application you can manage Sales Channels  with CRM and/or Sales
-    'depends': ['base','mail'],
+    'depends': ['base', 'mail'],
-from odoo import api, fields, models
+
-    _description = "Sales Team"
+    _description = "Sales Channel"
-    active = fields.Boolean(default=True, help="If the active field is set to false, it will allow you to hide the sales team without removing it.")
+    name = fields.Char('Sales Channel', required=True, translate=True)
-    member_ids = fields.One2many('res.users', 'sale_team_id', string='Team Members')
+    currency_id = fields.Many2one(
-    color = fields.Integer(string='Color Index', help="The color of the team")
+                           help="The email address put in the 'Reply-To' of all emails sent by Odoo about cases in this sales channel")
-        help='If set, sales team used notably for sales and assignations related to this partner')
+        'crm.team', 'Sales Channel',
-        help='Sales Team the user is member of. Used to compute the members of a sales team through the inverse one2many')
+        'crm.team', 'Sales Channel',
-        'crm.team', string='Default Sales Team',
+        'crm.team', string='Default Sales Channels',
-        help='Default sales team for new leads created through the Contact Us form.')
+        help='Default sales channel for new leads created through the Contact Us form.')
-        'crm.team', string='Default Sales Team', related='website_id.crm_default_team_id',
+        'crm.team', string='Default Sales Channel', related='website_id.crm_default_team_id',
-        help='Default sales team for new leads created through the Contact Us form.')
+        help='Default sales channel for new leads created through the Contact Us form.')
-    team_id = fields.Many2one('crm.team', 'Sales Team', oldname='section_id', readonly=True)
+    team_id = fields.Many2one('crm.team', 'Sales Channel', oldname='section_id', readonly=True)
-    team_id = fields.Many2one('crm.team', 'Sales Team', oldname='section_id', readonly=True)
+    team_id = fields.Many2one('crm.team', 'Sales Channel', oldname='section_id', readonly=True)
-from odoo import api, fields, models
+from datetime import datetime
-    website_ids = fields.One2many('website', 'salesteam_id', string='Websites', help="Websites using this sales team")
+    website_ids = fields.One2many('website', 'salesteam_id', string='Websites', help="Websites using this sales channel")
-    salesteam_id = fields.Many2one('crm.team', related='website_id.salesteam_id', string='Sales Team')
+    salesteam_id = fields.Many2one('crm.team', related='website_id.salesteam_id', string='Sales Channel', domain=[('team_type', '!=', 'pos')])
-    salesteam_id = fields.Many2one('crm.team', string='Sales Team')
+    salesteam_id = fields.Many2one('crm.team', string='Sales Channel')
-            if packop.result_package_id:
+            if packop.result_package_id and packop.result_package_id.packaging_id:
-        if self.carrier_id and self.carrier_id.delivery_type not in ['fixed', 'base_on_rule'] and self.carrier_id.integration_level == 'rate_and_ship':
+        if self.carrier_id and self.carrier_id.delivery_type not in ['fixed', 'base_on_rule'] and self.carrier_id.integration_level == 'rate_and_ship' and self.package_ids:
-
+        'wizard/choose_delivery_package_views.xml',
-            'view_id': self.env.ref('delivery.view_quant_package_form_save').id,
+            'res_model': 'choose.delivery.package',
-            'res_id': self.result_package_id.id,
+                'default_stock_quant_package_id': self.result_package_id.id,
-            },
+                }
-
+        view_id = self.env.ref('delivery.choose_delivery_package_view_form').id;
-            'view_id': self.env.ref('delivery.view_quant_package_form_save').id,
+            'res_model': 'choose.delivery.package',
-            },
+                'current_package_carrier_type': self.carrier_id.delivery_type if self.carrier_id.delivery_type not in ['base_on_rule', 'fixed'] else 'none',
-    def put_in_pack(self):
+    def _put_in_pack(self):
-        return res
+    def _get_new_picking_values(self):
-from odoo import models
+from odoo import models, fields
-        res.update({'move_type': self.picking_policy, 'partner_id': self.partner_shipping_id.id})
+        res.update({'move_type': self.picking_policy, 'partner_id': self.partner_shipping_id.id, 'sale_order_id': self.id})
-    product_tmpl_id = fields.Many2one('product.template', string='Product')
+    product_id = fields.Many2one('product.product', string='Product')
-             "the picking order and is mainly used if you use the EDI module.")
+        'product.packaging', string="Packaging", compute="_compute_packaging_ids", inverse="_set_packaging_ids",
-    ldaps = fields.One2many(related='company_id.ldaps', string="LDAP Parameters *")
+    ldaps = fields.One2many(related='company_id.ldaps', string="LDAP Parameters")
-    auth_signup_uninvited = fields.Boolean(string='Allow external users to sign up', help="If unchecked, only invited users may sign up.")
+    auth_signup_reset_password = fields.Boolean(string='Enable password reset from Login page')
-
+
-import res_config
+import res_config
-        implied_group='base.group_multi_company')
+    group_multi_company = fields.Boolean("Manage multiple companies", implied_group='base.group_multi_company')
-        help="""This installs the module google_docs.""")
+    default_user_rights = fields.Boolean("Default Access Rights", default_model='base.config.settings')
-        help="""This installs the module inter_company_rules.\n Configure company rules to automatically create SO/PO when one of your company sells/buys to another of your company.""")
+        string='Allow the users to synchronize their calendar  with Google Calendar')
-    google_cal_sync = fields.Boolean("Show Tutorial")
+        'views/base_config_settings_views.xml',
-    report_footer_default = fields.Html(related="company_id.report_footer_default")
+    paperformat_id = fields.Many2one(related="company_id.paperformat_id", string='Paper format')
-        user = self.env.user
+        eval_context = self._eval_context()
-                    group_domains[group].append(dom)
+        group_domains = []                      # list of domains
-        return domain
+        return expression.AND(global_domains + [expression.OR(group_domains)])
-            for d in self.env['ir.model.data'].search([('res_id', 'in', menu_ids), ('model', '=', 'ir.ui.menu')])
+            for d in self.env['ir.model.data'].sudo().search([('res_id', 'in', menu_ids), ('model', '=', 'ir.ui.menu')])
-                    subtype_id=self.env['ir.model.data'].sudo().xmlid_to_res_id('website_blog.mt_blog_blog_published'))
+                    subtype_id=self.env['ir.model.data'].xmlid_to_res_id('website_blog.mt_blog_blog_published'))
-            subtype_id=self.env['ir.model.data'].sudo().xmlid_to_res_id('website_event_track.mt_event_track'))
+            subtype_id=self.env['ir.model.data'].xmlid_to_res_id('website_event_track.mt_event_track'))
-                    subtype_id=self.env['ir.model.data'].sudo().xmlid_to_res_id('website_forum.mt_answer_new'))
+                    subtype_id=self.env['ir.model.data'].xmlid_to_res_id('website_forum.mt_answer_new'))
-                    subtype_id=self.env['ir.model.data'].sudo().xmlid_to_res_id('website_forum.mt_question_new'))
+                    subtype_id=self.env['ir.model.data'].xmlid_to_res_id('website_forum.mt_question_new'))
-                    subtype_id=self.env['ir.model.data'].sudo().xmlid_to_res_id('mail.mt_note'))
+                    subtype_id=self.env['ir.model.data'].xmlid_to_res_id('mail.mt_note'))
-        xid = self.search([('module', '=', module), ('name', '=', name)])
+        xid = self.sudo().search([('module', '=', module), ('name', '=', name)])
-                    xid = self.search([
+                    xid = self.sudo().search([
-        for data in self.env['ir.model.data'].search_read(domain, ['res_id'], order='id desc'):
+        for data in self.env['ir.model.data'].sudo().search_read(domain, ['res_id'], order='id desc'):
-        data = self.env['ir.model.data'].search(domain)
+        data = self.env['ir.model.data'].sudo().search(domain)
-        for data in self.env['ir.model.data'].search_read(domain, ['module', 'name', 'res_id']):
+        for data in self.env['ir.model.data'].sudo().search_read(domain, ['module', 'name', 'res_id']):
-        xmlid = self.env['ir.model.data'].search_read(domain, ['module', 'name'])[0]
+        xmlid = self.env['ir.model.data'].sudo().search_read(domain, ['module', 'name'])[0]
-        for data in self.env['ir.model.data'].search_read(domain, ['module', 'name', 'res_id']):
+        for data in self.env['ir.model.data'].sudo().search_read(domain, ['module', 'name', 'res_id']):
-            for data in IrModelData.search(imd_domain):
+            for data in IrModelData.sudo().search(imd_domain):
-        Data = self.env['ir.model.data']
+        Data = self.env['ir.model.data'].sudo()
-        Data = self.env['ir.model.data']
+        Data = self.env['ir.model.data'].sudo()
-        for data in self.env['ir.model.data'].search_read(domain, ['module', 'name', 'res_id']):
+        for data in self.env['ir.model.data'].sudo().search_read(domain, ['module', 'name', 'res_id']):
-                    if not self.env['ir.model.access'].check_groups("point_of_sale.group_pos_manager"):
+                    if not self.user_has_groups("point_of_sale.group_pos_manager"):
-        'data/crm_partner_assign_data.xml',
+        'security/ir_rule.xml',
-                field = self.env['ir.model.fields'].search([('name', '=', record[0]), ('model', '=', record[1]), ('relation', '=', record[2])], limit=1)
+                field = self.env['ir.model.fields'].sudo().search([('name', '=', record[0]), ('model', '=', record[1]), ('relation', '=', record[2])])
-        for record in records.sudo():
+        records = self.env['ir.model.fields'].sudo().search([('ttype', '=', 'reference')])
-                records_ref.sudo().write(values)
+                records_ref.write(values)
-        field = self.env['ir.model.fields'].search([('model', '=', 'res.partner'), ('name', '=', 'property_product_pricelist')])
+        field = self.env['ir.model.fields']._get('res.partner', 'property_product_pricelist')
-            field = self.env['ir.model.fields'].search([('name', '=', 'property_stock_journal'), ('model', '=', 'product.category'), ('relation', '=', 'account.journal')], limit=1)
+            field = self.env['ir.model.fields'].sudo().search([('name', '=', 'property_stock_journal'), ('model', '=', 'product.category'), ('relation', '=', 'account.journal')])
-                field = self.env['ir.model.fields'].search([('name', '=', record), ('model', '=', 'product.category'), ('relation', '=', 'account.account')], limit=1)
+                field = self.env['ir.model.fields'].sudo().search([('name', '=', record), ('model', '=', 'product.category'), ('relation', '=', 'account.account')])
-        fields = http.request.env['ir.model.fields']
+        fields = http.request.env['ir.model.fields'].sudo()
-        fields = self.env['ir.model.fields'].search([('model', '=', model_name)])
+        fields = self.env['ir.model.fields'].sudo().search([('model', '=', model_name)])
-        fields = self.env['ir.model.fields'].search([('model', '=', model_name)])
+        fields = self.env['ir.model.fields'].sudo().search([('model', '=', model_name)])
-        fields = self.env['ir.model.fields'].search([('model', '=', model_name)])
+        fields = self.env['ir.model.fields'].sudo().search([('model', '=', model_name)])
-            fnames = self.env['ir.model.fields'].browse(res_ids).mapped('name')
+            fnames = self.env['ir.model.fields'].sudo().browse(res_ids).mapped('name')
-                value = '%s,%d' % (field_id.relation, value)
+                value = '%s,%d' % (field_id.sudo().relation, value)
-                        env['ir.model.fields'].browse(field_child[0]).name
+                        env['ir.model.fields'].sudo().browse(field_child[0]).name
-                ttype = env['ir.model.fields'].browse(field_id).ttype
+                ttype = env['ir.model.fields'].sudo().browse(field_id).ttype
-                ttype = env['ir.model.fields'].browse(field_id).ttype
+                ttype = env['ir.model.fields'].sudo().browse(field_id).ttype
-                    return (model_id, field_id)
+            field = self.env['ir.model.fields']._get(vals['model_name'], vals['field_name'])
-            self.model_id = False
+        self.model_id = self.env['ir.model']._get(self.model_name)
-            ], limit=1)
+            self.field_id = self.env['ir.model.fields']._get(self.model_name, self.field_name)
-            model = self.env['ir.model'].search([('model', '=', model_name)])
+            model = self.env['ir.model']._get(model_name)
-            model = self.env['ir.model'].search([('model', '=', parent_model_name)])
+            model = self.env['ir.model']._get(parent_model_name)
-        res_model_id = self.env['ir.model'].search([('model', '=', res_model)], limit=1).id
+        res_model_id = self.env['ir.model']._get(res_model).id
-                    model = self.env['ir.model'].sudo().search([('model', '=', mail.model)])[0]
+                    model = self.env['ir.model']._get(mail.model)[0]
-            res['model_id'] = self.env['ir.model'].search([('model', '=', res.pop('model'))]).id
+            res['model_id'] = self.env['ir.model']._get(res.pop('model')).id
-                    self.sub_object = models.id
+                model = self.env['ir.model']._get(self.model_object_field.relation)
-            doc_name = self.env['ir.model'].search([('model', '=', self._name)]).read(['name'])[0]['name']
+            doc_name = self.env['ir.model']._get(self._name).name
-            model_name = self.env['ir.model'].sudo().search([('model', '=', self.env[message.model]._name)]).name_get()[0][1]
+            model_name = self.env['ir.model']._get(message.model).display_name
-                for alias in dest_aliases:
+                for alias in dest_aliases.sudo():
-            model_name = self.env['ir.model'].sudo().search([('model', '=', self.env[message.model]._name)]).name_get()[0][1]
+            model_name = self.env['ir.model']._get(message.model).display_name
-        mail_channel_model_id = self.env['ir.model'].search([('model', '=', 'mail.channel')], limit=1).id
+        mail_channel_model_id = self.env['ir.model']._get('mail.channel').id
-        mail_channel_model_id = self.env['ir.model'].search([('model', '=', 'mail.channel')], limit=1).id
+        mail_channel_model_id = self.env['ir.model']._get('mail.channel').id
-                'res_model_id': self.env['ir.model'].search([('model', '=', 'mail.channel')], limit=1).id,
+                'res_model_id': self.env['ir.model']._get('mail.channel').id,
-        self.mail_channel_model = self.env['ir.model'].search([('model', '=', 'mail.channel')], limit=1)
+        self.mail_channel_model = self.env['ir.model']._get('mail.channel')
-        self.mail_test_model = self.env['ir.model'].search([('model', '=', 'mail.test')], limit=1)
+        self.mail_test_model = self.env['ir.model']._get('mail.test')
-            'model_id': self.env['ir.model'].search([('model', '=', 'mail.channel')], limit=1).id,
+            'model_id': self.env['ir.model']._get('mail.channel').id,
-            model_name = self.env['ir.model'].search([('model', '=', model)]).name_get()[0][1]
+            model_name = self.env['ir.model']._get(model).display_name
-            model_name = model_ids.name_get()[0][1]
+            model_name = self.env['ir.model']._get(wizard.res_model).display_name
-                model_name = models.name
+            model = self.env['ir.model']._get(record.model or 'mail.message')
-                'model_id': models.id or False,
+                'model_id': model.id or False,
-            model = self.env['ir.model'].browse(model_id).model
+            model = self.env['ir.model'].browse(model_id).sudo().model
-    object_id = fields.Many2one(related='campaign_id.object_id', relation='ir.model', string='Object', readonly=True)
+    object_id = fields.Many2one('ir.model', related='campaign_id.object_id', string='Object', readonly=True)
-            ], limit=1).id
+            vals['alias_model_id'] = self.env['ir.model']._get(vals.get('alias_model', 'project.task')).id
-        model_record = request.env['ir.model'].search([('model', '=', model_name), ('website_form_access', '=', True)])
+        model_record = request.env['ir.model'].sudo().search([('model', '=', model_name), ('website_form_access', '=', True)])
-            k: v for k, v in self.get_authorized_fields().iteritems()
+            k: v for k, v in self.get_authorized_fields(self.model).iteritems()
-        model = self.env[self.model]
+    @api.model
-        authorized_fields = request.env['ir.model'].sudo().search([('model', '=', 'res.partner')])._get_form_writable_fields()
+        authorized_fields = request.env['ir.model']._get('res.partner')._get_form_writable_fields()
-        elif self.env[model_name].is_transient():
+        if model not in self.env:
-                         (model_name, self._uid,))
+                         (model, self._uid,))
-                             (model_name,))
+                             (model,))
-            groups = '\n\t'.join('- %s' % g for g in self.group_names_with_access(model_name, mode))
+            groups = '\n\t'.join('- %s' % g for g in self.group_names_with_access(model, mode))
-                msg_params = (groups, model_name)
+                msg_params = (groups, model)
-            _logger.info('Access Denied by ACLs for operation: %s, uid: %s, model: %s', mode, self._uid, model_name)
+                msg_params = (model,)
-            'ir.actions.server': 'model_id',
+        MODEL_GETTER = {
-                    access.check(menu.action[fname], 'read', False):
+        for menu in action_menus.sudo():
-        models = self.env['ir.model'].search([('state', '!=', 'manual')])
+        models = self.env['ir.model'].sudo().search([('state', '!=', 'manual')])
-        model_name = env['ir.model'].browse(report['model_id'][0]).model
+        model_name = env['ir.model'].browse(report['model_id'][0]).sudo().model
-        model = env['ir.model'].search([('model', '=', Model._name)])
+        model = env['ir.model']._get(Model._name)
-        IrConfigParam = request.env['ir.config_parameter'].sudo()
+        get_param = request.env['ir.config_parameter'].sudo().get_param
-            'reset_password_enabled': IrConfigParam.get_param('auth_signup.reset_password') == 'True',
+            'signup_enabled': get_param('auth_signup.allow_uninvited') == 'True',
-        IrConfigParam = self.env['ir.config_parameter']
+        get_param = self.env['ir.config_parameter'].get_param
-            'auth_signup_template_user_id': safe_eval(IrConfigParam.get_param('auth_signup.template_user_id', 'False')),
+            'auth_signup_reset_password': safe_eval(get_param('auth_signup.reset_password', 'False')),
-        IrConfigParam = self.env['ir.config_parameter']
+        set_param = self.env['ir.config_parameter'].set_param
-        IrConfigParam.set_param('auth_signup.template_user_id', repr(self.auth_signup_template_user_id.id), groups=['base.group_system'])
+        set_param('auth_signup.reset_password', repr(self.auth_signup_reset_password))
-        base_url = self.env['ir.config_parameter'].get_param('web.base.url')
+        base_url = self.env['ir.config_parameter'].sudo().get_param('web.base.url')
-        template_user_id = literal_eval(IrConfigParam.get_param('auth_signup.template_user_id', 'False'))
+        get_param = self.env['ir.config_parameter'].sudo().get_param
-            if not literal_eval(IrConfigParam.get_param('auth_signup.allow_uninvited', 'False')):
+            if not literal_eval(get_param('auth_signup.allow_uninvited', 'False')):
-            icp.set_param(self.GENGO_KEY, str(uuid.uuid4()), groups=self.GROUPS)
+        if not icp.get_param(self.GENGO_KEY):
-        base_url = self.env['ir.config_parameter'].get_param('web.base.url')
+        base_url = self.env['ir.config_parameter'].sudo().get_param('web.base.url')
-        if self.env['ir.config_parameter'].get_param('calendar.block_mail') or self._context.get("no_mail_to_attendees"):
+        if self.env['ir.config_parameter'].sudo().get_param('calendar.block_mail') or self._context.get("no_mail_to_attendees"):
-            'base_url': self.env['ir.config_parameter'].get_param('web.base.url', default='http://localhost:8069')
+            'base_url': self.env['ir.config_parameter'].sudo().get_param('web.base.url', default='http://localhost:8069')
-        Parameters = self.env['ir.config_parameter'].sudo()
+        get_param = self.env['ir.config_parameter'].sudo().get_param
-            'client_id': Parameters.get_param('google_%s_client_id' % service),
+            'redirect_uri': get_param('google_redirect_uri'),
-        client_id = Parameters.sudo().get_param('google_%s_client_id' % (service,), default=False)
+        get_param = self.env['ir.config_parameter'].sudo().get_param
-        client_secret = Parameters.sudo().get_param('google_%s_client_secret' % (service,), default=False)
+        get_param = self.env['ir.config_parameter'].sudo().get_param
-        client_secret = Parameters.get_param('google_%s_client_secret' % (service,), default=False)
+        get_param = self.env['ir.config_parameter'].sudo().get_param
-        number_of_week = self.env['ir.config_parameter'].get_param('calendar.week_synchro', default=13)
+        number_of_week = self.env['ir.config_parameter'].sudo().get_param('calendar.week_synchro', default=13)
-        return self.env['ir.config_parameter'].get_param('calendar.block_synchro_attendee', default=True)
+        return self.env['ir.config_parameter'].sudo().get_param('calendar.block_synchro_attendee', default=True)
-        return self.env['ir.config_parameter'].get_param('calendar.block_since_synchro', default=False)
+        return self.env['ir.config_parameter'].sudo().get_param('calendar.block_since_synchro', default=False)
-        return self.env['ir.config_parameter'].get_param('calendar.debug_print', default=False)
+        return self.env['ir.config_parameter'].sudo().get_param('calendar.debug_print', default=False)
-        self.env['ir.config_parameter'].set_param('google_calendar_client_secret', (self.cal_client_secret or '').strip(), groups=['base.group_system'])
+        set_param = self.env['ir.config_parameter'].set_param
-        server_uri = "%s/google_account/authentication" % self.env['ir.config_parameter'].get_param('web.base.url', default="http://yourcompany.odoo.com")
+        get_param = self.env['ir.config_parameter'].get_param
-        google_drive_refresh_token = Config.sudo().get_param('google_drive_refresh_token')
+        Config = self.env['ir.config_parameter'].sudo()
-        google_drive_client_secret = Config.sudo().get_param('google_drive_client_secret')
+        google_drive_client_id = Config.get_param('google_drive_client_id')
-        ICP.set_param('google_drive_refresh_token', refresh_token, groups=['base.group_system'])
+        ICP.set_param('google_drive_authorization_code', authorization_code)
-        url = self.env['ir.config_parameter'].get_param('web.base.url')
+        url = self.env['ir.config_parameter'].sudo().get_param('web.base.url')
-            "url": self.env['ir.config_parameter'].get_param('web.base.url'),
+            "url": self.env['ir.config_parameter'].sudo().get_param('web.base.url'),
-        base_url = self.env['ir.config_parameter'].get_param('web.base.url')
+        base_url = self.env['ir.config_parameter'].sudo().get_param('web.base.url')
-        info['server_url'] = self.env['ir.config_parameter'].get_param('web.base.url')
+        info['server_url'] = self.env['ir.config_parameter'].sudo().get_param('web.base.url')
-            short_schema = self.env['ir.config_parameter'].get_param('web.base.url') + '/r/'
+            short_schema = self.env['ir.config_parameter'].sudo().get_param('web.base.url') + '/r/'
-        base_url = self.env['ir.config_parameter'].get_param('web.base.url')
+        base_url = self.env['ir.config_parameter'].sudo().get_param('web.base.url')
-        self.short_url_host = self.env['ir.config_parameter'].get_param('web.base.url') + '/r/'
+        self.short_url_host = self.env['ir.config_parameter'].sudo().get_param('web.base.url') + '/r/'
-        base_url = self.env['ir.config_parameter'].get_param('web.base.url')
+        base_url = self.env['ir.config_parameter'].sudo().get_param('web.base.url')
-        database_uuid = self.env['ir.config_parameter'].get_param('database.uuid')
+        database_uuid = self.env['ir.config_parameter'].sudo().get_param('database.uuid')
-            self.env['ir.config_parameter'].set_param("mail.catchall.domain", record.alias_domain or '', groups=['base.group_system'])
+            self.env['ir.config_parameter'].set_param("mail.catchall.domain", record.alias_domain or '')
-                IrParamSudo.set_param('database.enterprise_code', result['enterprise_info'].get('enterprise_code'), ['base.group_user'])
+                set_param = self.env['ir.config_parameter'].sudo().set_param
-        base_url = self.env['ir.config_parameter'].get_param('web.base.url')
+        base_url = self.env['ir.config_parameter'].sudo().get_param('web.base.url')
-        base_url = self.env['ir.config_parameter'].get_param('web.base.url')
+        base_url = self.env['ir.config_parameter'].sudo().get_param('web.base.url')
-        domain = self.env["ir.config_parameter"].get_param("web.base.url")
+        domain = self.env["ir.config_parameter"].sudo().get_param("web.base.url")
-        base_url = self.env['ir.config_parameter'].get_param('web.base.url')
+        base_url = self.env['ir.config_parameter'].sudo().get_param('web.base.url')
-        base_url = self.env['ir.config_parameter'].get_param('web.base.url')
+        base_url = self.env['ir.config_parameter'].sudo().get_param('web.base.url')
-        base_url = request.env['ir.config_parameter'].get_param('web.base.url')
+        base_url = request.env['ir.config_parameter'].sudo().get_param('web.base.url')
-        base_url = self.env['ir.config_parameter'].get_param('web.base.url')
+        base_url = self.env['ir.config_parameter'].sudo().get_param('web.base.url')
-        base_url = self.env['ir.config_parameter'].get_param('web.base.url')
+        base_url = self.env['ir.config_parameter'].sudo().get_param('web.base.url')
-        base_url = self.env['ir.config_parameter'].get_param('web.base.url')
+        base_url = self.env['ir.config_parameter'].sudo().get_param('web.base.url')
-        base_url = self.env['ir.config_parameter'].get_param('web.base.url')
+        base_url = self.env['ir.config_parameter'].sudo().get_param('web.base.url')
-        base_url = self.env['ir.config_parameter'].get_param('web.base.url')
+        base_url = self.env['ir.config_parameter'].sudo().get_param('web.base.url')
-            'web_base_url': request.env['ir.config_parameter'].get_param('web.base.url'),
+            'web_base_url': request.env['ir.config_parameter'].sudo().get_param('web.base.url'),
-        res['web.base.url'] = self.env['ir.config_parameter'].get_param('web.base.url', default='')
+        res['web.base.url'] = self.env['ir.config_parameter'].sudo().get_param('web.base.url', default='')
-            web_base_url=self.env['ir.config_parameter'].get_param('web.base.url', default='')
+            web_base_url=self.env['ir.config_parameter'].sudo().get_param('web.base.url', default='')
-        base_url = '/' if self.env.context.get('relative_url') else self.env['ir.config_parameter'].get_param('web.base.url')
+        base_url = '/' if self.env.context.get('relative_url') else \
-        base_url = self.env['ir.config_parameter'].get_param('web.base.url')
+        base_url = self.env['ir.config_parameter'].sudo().get_param('web.base.url')
-            'google_maps_api_key', (self.google_maps_api_key or '').strip(), groups=['base.group_system'])
+        self.env['ir.config_parameter'].set_param('google_maps_api_key', (self.google_maps_api_key or '').strip())
-        v['base_url'] = request.env['ir.config_parameter'].get_param('web.base.url')
+        v['base_url'] = request.env['ir.config_parameter'].sudo().get_param('web.base.url')
-            self.env['ir.config_parameter'].get_param('web.base.url'),
+            self.env['ir.config_parameter'].sudo().get_param('web.base.url'),
-        portal_link = "%s/?db=%s" % (self.env['ir.config_parameter'].get_param('web.base.url'), self.env.cr.dbname)
+        portal_link = "%s/?db=%s" % (self.env['ir.config_parameter'].sudo().get_param('web.base.url'), self.env.cr.dbname)
-            forum_uuids.set_param('website_forum.uuid', str(uuid.uuid4()), ['base.group_system'])
+            forum_uuids.set_param('website_forum.uuid', str(uuid.uuid4()))
-            base_url = self.env['ir.config_parameter'].get_param('web.base.url')
+            base_url = self.env['ir.config_parameter'].sudo().get_param('web.base.url')
-        base_url = self.env['ir.config_parameter'].get_param('web.base.url')
+        base_url = self.env['ir.config_parameter'].sudo().get_param('web.base.url')
-        base_url = self.env['ir.config_parameter'].get_param('web.base.url')
+        base_url = self.env['ir.config_parameter'].sudo().get_param('web.base.url')
-        base_url = self.env['ir.config_parameter'].get_param('web.base.url')
+        base_url = self.env['ir.config_parameter'].sudo().get_param('web.base.url')
-            base_url = self.env['ir.config_parameter'].get_param('web.base.url')
+            base_url = self.env['ir.config_parameter'].sudo().get_param('web.base.url')
-        base_url = request.env['ir.config_parameter'].get_param('web.base.url')
+        base_url = request.env['ir.config_parameter'].sudo().get_param('web.base.url')
-        base_url = self.env['ir.config_parameter'].get_param('web.base.url')
+        base_url = self.env['ir.config_parameter'].sudo().get_param('web.base.url')
-        base_url = self.env['ir.config_parameter'].get_param('web.base.url')
+        base_url = self.env['ir.config_parameter'].sudo().get_param('web.base.url')
-        base_url = self.env['ir.config_parameter'].get_param('web.base.url')
+        base_url = self.env['ir.config_parameter'].sudo().get_param('web.base.url')
-        base_url = self.env['ir.config_parameter'].get_param('web.base.url')
+        base_url = self.env['ir.config_parameter'].sudo().get_param('web.base.url')
-        base_url = self.env['ir.config_parameter'].get_param('web.base.url')
+        base_url = self.env['ir.config_parameter'].sudo().get_param('web.base.url')
-        ICP.set_param(key, val, groups)
+    env['ir.config_parameter'].init(force=True)
-    "web.base.url": lambda: ("http://localhost:%s" % config.get('xmlrpc_port'), []),
+    "database.secret": lambda: str(uuid.uuid4()),
-                params.set_param(key, value, groups=groups)
+                params.set_param(key, func())
-    def set_param(self, key, value, groups=()):
+    def set_param(self, key, value):
-                param.write(vals)
+                param.write({'value': value})
-                self.create(vals)
+                self.create({'key': key, 'value': value})
-        IrConfigParam = request.env['ir.config_parameter']
+        IrConfigParam = request.env['ir.config_parameter'].sudo()
-            'reset_password_enabled': IrConfigParam.sudo().get_param('auth_signup.reset_password') == 'True',
+            'signup_enabled': IrConfigParam.get_param('auth_signup.allow_uninvited') == 'True',
-        IrConfigParam.set_param('auth_signup.template_user_id', repr(self.auth_signup_template_user_id.id))
+        IrConfigParam.set_param('auth_signup.reset_password', repr(self.auth_signup_reset_password), groups=['base.group_system'])
-    alias_domain = fields.Char('Alias Domain', default=lambda self: self.env["ir.config_parameter"].get_param("mail.catchall.domain"))
+    alias_domain = fields.Char('Alias Domain', default=lambda self: self.env["ir.config_parameter"].sudo().get_param("mail.catchall.domain"))
-    alias_domain = fields.Char('Alias Domain', default=lambda self: self.env["ir.config_parameter"].get_param("mail.catchall.domain"))
+    alias_domain = fields.Char('Alias Domain', default=lambda self: self.env["ir.config_parameter"].sudo().get_param("mail.catchall.domain"))
-            "url": self.env['ir.config_parameter'].sudo().get_param('web.base.url'),
+            "url": self.env['ir.config_parameter'].get_param('web.base.url'),
-        base_url = self.env['ir.config_parameter'].sudo().get_param('web.base.url')
+        base_url = self.env['ir.config_parameter'].get_param('web.base.url')
-                               default=lambda self: self.env["ir.config_parameter"].get_param("mail.catchall.domain"))
+                               default=lambda self: self.env["ir.config_parameter"].sudo().get_param("mail.catchall.domain"))
-        alias_domain = self.env["ir.config_parameter"].get_param("mail.catchall.domain")
+        alias_domain = self.env["ir.config_parameter"].sudo().get_param("mail.catchall.domain")
-                catchall_domain = self.env['ir.config_parameter'].get_param("mail.catchall.domain")
+                ICP = self.env['ir.config_parameter'].sudo()
-        alias_domain = self.env['ir.config_parameter'].get_param("mail.catchall.domain")
+        alias_domain = self.env['ir.config_parameter'].sudo().get_param("mail.catchall.domain")
-                catchall_alias = self.env['ir.config_parameter'].get_param("mail.catchall.alias")
+                catchall_alias = self.env['ir.config_parameter'].sudo().get_param("mail.catchall.alias")
-        bounce_alias = self.env['ir.config_parameter'].get_param("mail.bounce.alias")
+        bounce_alias = self.env['ir.config_parameter'].sudo().get_param("mail.bounce.alias")
-            self.env['ir.config_parameter'].set_param("mail.catchall.domain", record.alias_domain or '')
+            self.env['ir.config_parameter'].set_param("mail.catchall.domain", record.alias_domain or '', groups=['base.group_system'])
-                self.env['ir.config_parameter'].sudo().set_param('database.enterprise_code', result['enterprise_info'].get('enterprise_code'), ['base.group_user'])
+                IrParamSudo = self.env['ir.config_parameter'].sudo()
-        bounce_alias = self.env['ir.config_parameter'].get_param("mail.bounce.alias")
+        bounce_alias = self.env['ir.config_parameter'].sudo().get_param("mail.bounce.alias")
-        base_url = self.env['ir.config_parameter'].sudo().get_param('web.base.url')
+        base_url = self.env['ir.config_parameter'].get_param('web.base.url')
-        base_url = self.env['ir.config_parameter'].sudo().get_param('web.base.url')
+        base_url = self.env['ir.config_parameter'].get_param('web.base.url')
-            'web_base_url': request.env['ir.config_parameter'].sudo().get_param('web.base.url'),
+            'web_base_url': request.env['ir.config_parameter'].get_param('web.base.url'),
-        res['web.base.url'] = self.env['ir.config_parameter'].sudo().get_param('web.base.url', default='')
+        res['web.base.url'] = self.env['ir.config_parameter'].get_param('web.base.url', default='')
-        base_url = self.env['ir.config_parameter'].sudo().get_param('web.base.url')
+        base_url = self.env['ir.config_parameter'].get_param('web.base.url')
-    condition = fields.Char(default="True",
+    condition = fields.Char(default="True", groups='base.group_system',
-    code = fields.Text(string='Python Code',
+    code = fields.Text(string='Python Code', groups='base.group_system',
-        for action in self.filtered('code'):
+        for action in self.sudo().filtered('code'):
-        safe_eval(action.code.strip(), eval_context, mode="exec", nocopy=True)  # nocopy allows to return 'action'
+        safe_eval(action.sudo().code.strip(), eval_context, mode="exec", nocopy=True)  # nocopy allows to return 'action'
-            condition = action.condition
+            condition = action.sudo().condition
-            raise exceptions.UserError(_('You cannot cancel a move move having already consumed material'))
+            raise exceptions.UserError(_('You cannot cancel a stock move having already consumed material'))
-    address_id = fields.Many2one('res.partner', string='Working Address')
+    address_id = fields.Many2one('res.partner', string='Work Address')
-                       WHERE md.module IS NULL
+                       WHERE md.module NOT IN (SELECT name FROM ir_module_module)
-            report.record_result(custom_view_test)
+                    _logger.warning('Invalid custom view(s) for model %s', model)
-        self.assertItemsEqual(result.keys(), ['matches', 'headers', 'fields', 'preview', 'headers_type', 'options', 'debug'])
+        self.assertItemsEqual(result.keys(), ['matches', 'headers', 'fields', 'preview', 'headers_type', 'options', 'advanced_mode', 'debug'])
-        self.assertItemsEqual(result.keys(), ['matches', 'headers', 'fields', 'preview', 'headers_type', 'options', 'debug'])
+        self.assertItemsEqual(result.keys(), ['matches', 'headers', 'fields', 'preview', 'headers_type', 'options', 'advanced_mode', 'debug'])
-        self.assertItemsEqual(result.keys(), ['matches', 'headers', 'fields', 'preview', 'headers_type', 'options', 'debug'])
+        self.assertItemsEqual(result.keys(), ['matches', 'headers', 'fields', 'preview', 'headers_type', 'options','advanced_mode', 'debug'])
-        self.assertItemsEqual(result.keys(), ['matches', 'headers', 'fields', 'preview', 'headers_type', 'options', 'debug'])
+        self.assertItemsEqual(result.keys(), ['matches', 'headers', 'fields', 'preview', 'headers_type', 'options', 'advanced_mode', 'debug'])
-from odoo import fields, models
+from odoo import api, fields, models
-    po_lead = fields.Float(related='company_id.po_lead', string="Purchase Lead Time *")
+    po_lead = fields.Float(related='company_id.po_lead', string="Purchase Lead Time")
-    po_double_validation_amount = fields.Monetary(related='company_id.po_double_validation_amount', string="Double validation amount *", currency_field='company_currency_id')
+    po_double_validation_amount = fields.Monetary(related='company_id.po_double_validation_amount', string="Minimum Amount", currency_field='company_currency_id')
-        help='Work with product variant allows you to define some variant of the same products, an ease the product management in the ecommerce for example',
+    default_purchase_method = fields.Selection([
-        ], "Vendor Price",
+    group_uom = fields.Boolean("Units of Measure",
-                        name, interpret_handler
+                        mname, interpret_handler
-            or left in MAGIC_COLUMNS, "Invalid field %r in domain term %r" % (left, leaf)
+        assert leaf in (TRUE_LEAF, FALSE_LEAF) or left in model._fields, \
-                mo = re.search('<body>(.*)</body>',page)
+                mo = re.search('<body>(.*)</body>', page, re.DOTALL)
-        _options['nsmap'] = {}
+        if not options.get('nsmap'):
-        if call_options:
+        if nsmap or call_options:
-            content.extend([
+            content.append(
-            ])
+                )
-            nodes = arch.xpath(spec.get('expr'))
+            nodes = etree.ETXPath(spec.get('expr'))(arch)
-        if el.tag == 't':
+        extra_attrib = {}
-        body = [self._append(ast.Str(u'<%s' % el.tag))]
+
-        if el.tag in self._void_elements:
+        if unqualified_el_tag in self._void_elements:
-            body.append(self._append(ast.Str(u'</%s>' % el.tag)))
+            body.append(self._append(ast.Str(u'</%s>' % el_tag)))
-from itertools import izip, tee
+from itertools import chain, izip, tee
-        if el.tag == 't':
+        extra_attrib = {}
-        if el.tag in self._void_elements:
+        tag = u'<%s%s' % (el_tag, u''.join([u' %s="%s"' % (name, escape(unicodifier(value))) for name, value in chain(el.attrib.iteritems(), extra_attrib.iteritems())]))
-            return [self._append(ast.Str(tag + '>'))] + content + [self._append(ast.Str('</%s>' % el.tag))]
+            return [self._append(ast.Str(tag + '>'))] + content + [self._append(ast.Str('</%s>' % el_tag))]
-avoid_pattern = re.compile(r"[\s\n]*<!DOCTYPE", re.IGNORECASE)
+avoid_pattern = re.compile(r"\s*<!DOCTYPE", re.IGNORECASE | re.MULTILINE | re.UNICODE)
-        as a whole (without surrounding spaces):
+def translate_xml_node(node, callback, method, parser=None):
-            </div>
+    def nonspace(text):
-        """ Translate text.strip(), but keep the surrounding spaces from text. """
+    def concat(text1, text2):
-        trans = term and self.callback(term)
+        trans = term and callback(term)
-                etree.fromstring("<div>%s</div>" % encode(trans), parser=self.parser)
+                node = etree.fromstring(encode(text), parser=parser)
-        """ Process the given xml `node`: collect `todo` and `done` items. """
+                # fallback: escape the translation as text
-            node.getparent() is None and node.text and '<!DOCTYPE' in node.text
+            node.get('t-translation', "").strip() == "off" or
-            return
+            return (None, node)
-            return "%s>%s</%s>" % (elem[:-2], content, tag)
+        # make an element like node that will contain the result
-            return etree.tostring(etree.Element(tag, attrib), method=self.method)
+            todo.text = node.text
-        return trans.get_done()
+        result = translate_xml_node(root, callback, 'xml')
-        return trans.get_done()[5:-6]           # remove tags <div> and </div>
+        # root is html > body > div; translate the div only
-        trans = XMLTranslator(callback, 'html', parser)
+        # value may be some HTML fragment, wrap it into a div
-        value = trans.get_done()[5:-6]           # remove tags <div> and </div>
+        # root is html > body > div; translate the div only
-            return self._ogone_s2s_validate_tree(self, tree, tries - 1)
+            tree = self._ogone_s2s_get_tx_status()
-        def _get_rec(object, level, qty=1.0):
+        def _get_rec(object, level, qty=1.0, uom=False):
-                res['pqty'] = l.product_qty * qty
+                qty_per_bom = l.bom_id.product_qty
-                    _get_rec(l.child_line_ids, level, qty=res['pqty'])
+                    _get_rec(l.child_line_ids, level, qty=res['pqty'], uom=res['puom'])
-        ('paid', 'Done'),
+        ('paid', 'Paid'),
-        default.update(code=_("%s (copy)") % (self.code or ''))
+        default.setdefault('code', _("%s (copy)") % (self.code or ''))
-        res = map(lambda l: (l[0].name, formatLang(self.env, l[1], currency_obj=currency)), res)
+        res = map(lambda l: (l[0].name, l[1]), res)
-
+                            if not journal.refund_sequence_id:
-            debit_wo, credit_wo, amount_currency_wo, currency_id = aml_obj.with_context(date=self.payment_date).compute_amount_fields(self.payment_difference, self.currency_id, self.company_id.currency_id, invoice_currency)
+            amount_currency_wo, currency_id = aml_obj.with_context(date=self.payment_date).compute_amount_fields(self.payment_difference, self.currency_id, self.company_id.currency_id, invoice_currency)[2:]
-    note = fields.Text('Notes', help="Legal mentions that have to be printed on the invoices.")
+    note = fields.Text('Notes', translate=True, help="Legal mentions that have to be printed on the invoices.")
-        lines = self._get_account_move_lines(self.ids)
+        lines = self._get_account_move_lines(docids)
-        for partner_id in self.ids:
+        for partner_id in docids:
-            'doc_ids': self.ids,
+            'doc_ids': docids,
-            'docs': self.env['res.partner'].browse(self.ids),
+            'docs': self.env['res.partner'].browse(docids),
-                            to_reconcile_lines.reconcile()
+                            to_reconcile_lines.filtered(lambda l: l.reconciled == False).reconcile()
-        self.account_analytic_id = rec.analytic_id.id
+        if not self.account_analytic_id:
-
+from odoo import api, fields, models, tools
-            }
+        # update the anonymization fields:
-                if self.month_by == 'day':  # Eg : Second Monday of the month
+                if self.month_by == 'day' and self.byday and self.week_list:  # Eg : Second Monday of the month
-        self.price_unit = self.event_ticket_id.price
+        self.price_unit = (self.event_id.company_id or self.env.user.company_id).currency_id.compute(self.event_ticket_id.price, self.order_id.currency_id)
-
+    @api.multi
-            date_to = fields.Date.from_string(holiday.date_to)
+            # Convert date to user timezone, otherwise the report will not be consistent with the
-# (http://trigluu.com)
+# Copyright (c) 2009-2016 Salvatore JosuÃ© Trimarchi Pinto <trimarchi@bacgroup.net>
-    'version': '0.1',
+    'version': '0.2',
-    'website': 'http://trigluu.com',
+    'website': 'http://bacgroup.net',
-            'ITAX_167-OUT': account_obj.search([('code', '=', '216.13.01')]),
+            'IVA': account_obj.search([('code', '=', '208.01.01')]),
-                self.expense_currency_exchange_account_id.id),
+            'default_credit_account_id': account.id,
-from odoo import api, fields, models
+from odoo import fields, models
-        return cgi.escape(substitution)
+        # send the email only to the current record and not all the ids matching active_domain !
-def _reopen(self, res_id, model):
+def _reopen(self, res_id, model, context=None):
-            },
+            'context': context,
-            return _reopen(self, record.id, record.model)
+            return _reopen(self, record.id, record.model, context=self._context)
-        consume_move.quant_ids.write({'produced_quant_ids': [(6, 0, produced_quant_ids.ids)]})
+        consume_move.quant_ids.sudo().write({'produced_quant_ids': [(6, 0, produced_quant_ids.ids)]})
-            if not time_log or time_log.date_end:
+            # We search for a productivity line associated to this workcenter having no `date_end`.
-    def _update_name_and_code(self, name, code):
+    def _update_name_and_code(self, name=False, code=False):
-            if warehouse.manufacture_pull_id:
+            if warehouse.manufacture_pull_id and name:
-        post_msg = '''<div>
+        post_msg = _('''<div>
-</div>''' % {
+</div>''') % {
-    # - if that doesn't exist, create a new one
+    # to recover from this situation we create a new rescue session,
-            limit=1, order="start_at DESC")
+        _logger.warning('attempting to create recovery session for saving order %s', order['name'])
-            return new_session
+        return new_session
-            values.setdefault('session_id', session.config_id.pricelist_id.id)
+            values.setdefault('pricelist_id', session.config_id.pricelist_id.id)
-        data.update(self.get_sale_details(date_start, date_stop, company))
+        data = dict(data or {})
-    start_date = fields.Datetime(required=True, default=fields.Datetime.now)
+    def _default_start_date(self):
-            self.start_date, self.end_date, self.pos_config_ids))
+        data = {'date_start': self.start_date, 'date_stop': self.end_date, 'config_ids': self.pos_config_ids.ids}
-    _order = 'default_code'
+    _order = 'default_code, id'
-        res = super(ProductProduct, self).read_group(fields, groupby, offset=offset, limit=limit, orderby=orderby, lazy=lazy)
+        res = super(ProductProduct, self).read_group(domain, fields, groupby, offset=offset, limit=limit, orderby=orderby, lazy=lazy)
-            res_val = tot_products._compute_product_margin_fields_values([x for x in fields if fields in fields_list], '')
+            res_val = tot_products._compute_product_margin_fields_values(field_names=[x for x in fields if fields in fields_list])
-            dt_create_date = fields.Datetime.from_string(issue.create_date)
+            dt_create_date = fields.Datetime.from_string(issue.create_date) or current_datetime
-            r[group['product_id'][0]] = group['unit_quantity']
+        PurchaseOrderLines = self.env['purchase.order.line'].search(domain)
-        return True
+            product.purchase_count = len(PurchaseOrderLines.filtered(lambda r: r.product_id == product).mapped('order_id'))
-    def _update_name_and_code(self, name, code):
+    def _update_name_and_code(self, name=False, code=False):
-            context.get('set_viewport_size')
+            context.get('set_viewport_size'),
-        """ Given a list of weekdays, return matching resource.calendar.attendance"""
+    def get_attendances_for_weekday(self, day_dt):
-        date = fields.Date.today()
+        weekday = day_dt.weekday()
-                    not ((att.date_from and date < att.date_from) or (att.date_to and date > att.date_to))):
+
-        res = map(lambda l: (l[0].name, formatLang(self.env, l[1], currency_obj=currency)), res)
+        res = map(lambda l: (l[0].name, l[1]), res)
-                order.commitment_date = fields.Datetime.to_string(min(dates_list))
+                commit_date = min(dates_list) if order.picking_policy == 'direct' else max(dates_list)
-        default=lambda self: getattr(self.env.ref('stock.warehouse0', raise_if_not_found=False) or self.env['stock.warehouse'], 'lot_stock_id').id)
+        default=_default_location_id)
-                customerloc, location_dest_id = self.env['stock.warehouse']._get_partner_locations()
+                location_dest_id, supplierloc = self.env['stock.warehouse']._get_partner_locations()
-from odoo import api, models
+from odoo import api, models, tools
-            for product in self.with_context(location=location.id, compute_child=False):
+            for product in self.with_context(location=location.id, compute_child=False).filtered(lambda r: r.valuation == 'real_time'):
-                ('blog_id', 'in', self)
+                ('blog_id', 'in', self.ids)
-            post_ids.write({'active': vals['active']})
+            for blog_post in post_ids:
-                if country:
+            curr_country = Country.browse(country_id)
-                        'country_id': (country_id, country['name'])
+                        'country_id': (curr_country.id, curr_country.name)
-            curr_country = Country.browse(country_id)
+from odoo.tools.translate import html_translate
-    quote_description = fields.Html('Description for the quote', sanitize_attributes=False)
+    quote_description = fields.Html('Description for the quote', sanitize_attributes=False, translate=html_translate)
-            self = self.with_context(lang=self.partner_id.lang)
+        template = self.template_id.with_context(lang=self.partner_id.lang)
-        for line in self.template_id.quote_line:
+        for line in template.quote_line:
-        for option in self.template_id.options:
+        for option in template.options:
-            self.validity_date = fields.Date.to_string(datetime.now() + timedelta(self.template_id.number_of_days))
+        if template.number_of_days > 0:
-        self.require_payment = self.template_id.require_payment
+        self.website_description = template.website_description
-            self.note = self.template_id.note
+        if template.note:
-                    self.report.ir_values_id.sudo().unlink()
+                    report.ir_values_id.sudo().unlink()
-        # prevent all concurrent updates on ir_attachment while collecting!
+        # Continue in a new transaction. The LOCK statement below must be the
-                if name not in cls._fields:
+                field = cls._fields.get(name)
-                    _logger.warning("method %s.%s: @constrains parameter %r is not stored", cls._name, attr, name)
+                if not (field.store or field.inverse):
-        ids = self.registry('ir.translation').search(self.cr, self.uid,
+        ids = self.env['ir.translation'].search(
-    _inherit = ['sale.config.settings']
+    _inherit = 'sale.config.settings'
-    module_website_sign = fields.Boolean("Odoo Sign")
+    default_generate_lead_from_alias = fields.Boolean(default_model='sale.config.settings')
-        'views/report_deliveryslip.xml'
+        'views/report_deliveryslip.xml',
-        'views/sale_config_settings_views.xml',
+        'views/sale_config_settings_views.xml',
-                , an ease the product management in the ecommerce for example""",
+    sale_note = fields.Text(related='company_id.sale_note', string="Terms & Conditions")
-        ], "Addresses", implied_group='sale.group_delivery_invoice_address')
+    group_uom = fields.Boolean("Units of Measure",
-             'Advanced pricing based on formula: You can have all the rights on pricelist')
+        ('fixed', 'A single sales price per product'),
-        ], 'Default Invoicing',
+        ('order', 'Ordered quantities'),
-        ], "Sales Order Modification")
+    auto_done_setting = fields.Boolean("Lock Confirmed Orders")
-            'sale.config.settings', 'sale_pricelist_setting', self.sale_pricelist_setting)
+    group_multi_currency = fields.Boolean("Multi-Currencies", implied_group='base.group_multi_currency')
-            'sale.config.settings', 'deposit_product_id_setting', self.deposit_product_id_setting.id)
+    module_timesheet_grid_sale = fields.Boolean("Timesheets")
-            'sale.config.settings', 'auto_done_setting', self.auto_done_setting)
+    @api.model
-    @api.onchange('sale_pricelist_setting')
+    @api.onchange('multi_sales_price', 'multi_sales_price_method')
-    @api.multi
+    def set_default_sale_pricelist_setting(self):
-            'sale.config.settings', 'sale_show_tax', self.sale_show_tax)
+        return self.env['ir.values'].sudo().set_default('sale.config.settings', 'sale_show_tax', self.sale_show_tax)
-from odoo import api, fields, models
+from odoo import fields, models
-        ], "Order Routing",
+    security_lead = fields.Float(related='company_id.security_lead', string="Security Lead Time")
-        return super(SaleConfiguration, self).set_sale_defaults()
+    module_sale_order_dates = fields.Boolean("Delivery Date")
-class SaleConfigSettings(models.TransientModel):
+from odoo import fields, models
-        """ Given a list of weekdays, return matching resource.calendar.attendance"""
+    def get_attendances_for_weekday(self, day_dt):
-        date = fields.Date.today()
+        weekday = day_dt.weekday()
-                    not ((att.date_from and date < att.date_from) or (att.date_to and date > att.date_to))):
+
-            if country_id not in map(lambda x: x['country_id'][0], countries):
+            if country_id not in (x['country_id'][0] for x in countries if x['country_id']):
-        ], string='Interview Form')
+    module_website_hr_recruitment = fields.Boolean(string='Online Posting')
-
+    name_search = location_name_search
-            args = args + [('country_id', '=', self.env.context['country_id'])]
+            args = args + [('country_id', '=', self.env.context.get('country_id'))]
-        records = firsts_records + self.search(search_domain + args, limit=limit-len(firsts_records))
+        search_domain.append(('id', 'not in', firsts_records.ids))
-        template_id = self.env.ref('gamification.email_template_badge_received')
+        template = self.env.ref('gamification.email_template_badge_received')
-                partner_ids=badge_user.user_id.partner_id.ids
+            self.env['mail.thread'].message_post_with_template(
-        res_id = self.ids[0] or 0
+        res_id = kwargs.get('res_id', self.ids and self.ids[0] or 0)
-            active_model=self._name,
+            active_id=res_id,
-            default_res_id=self.ids[0] or 0,
+            default_model=kwargs.get('model', self._name),
-        if model:
+        if model and hasattr(self.env[model], 'message_get_reply_to'):
-    name_search = location_name_search
+    @api.model
-            args = args + [('country_id', '=', self.env.context.get('country_id'))]
+            args = args + [('country_id', '=', self.env.context['country_id'])]
-        records = firsts_records + self.search(search_domain + args, limit=limit)
+        if len(firsts_records):
-
+
-            'ITAX_167-OUT': account_obj.search([('code', '=', '216.13.01')]),
+            'IVA': account_obj.search([('code', '=', '208.01.01')]),
-                self.expense_currency_exchange_account_id.id),
+            'default_credit_account_id': account.id,
-        help="Technical field used to mark a tax line as exigible in the vat report or not (only exigible journal items are displayed). By default all new journal items are directly exigible, but with the module account_tax_cash_basis, some will become exigible only when the payment is recorded.")
+        help="Technical field used to mark a tax line as exigible in the vat report or not (only exigible journal items are displayed). By default all new journal items are directly exigible, but with the feature cash_basis on taxes, some will become exigible only when the payment is recorded.")
-            IrValues.set_default(model, field, self[name])
+            if isinstance(self[name], models.BaseModel):
-        'views/web_planner_data.xml',
+        'views/res_config_view.xml',
-        help="If you select 'Round per Line' : for each tax, the tax amount will first be computed and rounded for each PO/SO/invoice line and then these rounded amounts will be summed, leading to the total amount for that tax. If you select 'Round Globally': for each tax, the tax amount will be computed for each PO/SO/invoice line, then these amounts will be summed and eventually this total tax amount will be rounded. If you sell with tax included, you should choose 'Round per line' because you certainly want the sum of your tax-included line subtotals to be equal to the total amount with taxes.")
+        ], default='round_per_line', string='Tax Calculation Rounding Method')
-from odoo.tools import DEFAULT_SERVER_DATE_FORMAT as DF
+
-    has_chart_of_accounts = fields.Boolean(string='Company has a chart of accounts')
+    currency_id = fields.Many2one('res.currency', related="company_id.currency_id", required=True,
-        [
+    tax_calculation_rounding_method = fields.Selection([
-    module_account_reports = fields.Boolean("Get dynamic accounting reports")
+        ], related='company_id.tax_calculation_rounding_method', string='Tax calculation rounding method')
-
+        implied_group='base.group_multi_currency')
-             '-This installs the module account_reports_followup.')
+    module_account_reports_followup = fields.Boolean("Enable payment followup management")
-
+    default_sale_tax_id = fields.Many2one('account.tax', string="Default Sale Tax",
-            self.code_digits = company.accounts_code_digits
+    module_account_sepa = fields.Boolean(string='Use SEPA payments')
-        self.purchase_tax_rate = self.sale_tax_rate or False
+    @api.depends('company_id')
-            group_user.write({'implied_ids': [(4, group_product.id)]})
+            self.env.ref('base.group_user').write({'implied_ids': [(4, self.env.ref('product.group_sale_pricelist').id)]})
-    def set_product_taxes(self):
+    def set_default_product_taxes(self):
-        if self.chart_template_id and not self.has_chart_of_accounts and self.expects_chart_of_accounts:
+        if self.chart_template_id and not self.has_chart_of_accounts and self.company_id.expects_chart_of_accounts:
-                'transfer_account_id': self.template_transfer_account_id.id,
+                'transfer_account_id': self.chart_template_id.transfer_account_id.id,
-                'complete_tax_set': self.complete_tax_set,
+                'sale_tax_id': self.default_sale_tax_id.id,
-                'cash_account_code_prefix': self.cash_account_code_prefix or self.chart_template_id.cash_account_code_prefix,
+                'bank_account_code_prefix': self.chart_template_id.bank_account_code_prefix,
-        }
+    @api.onchange('module_account_yodlee')
-        'views/product_views.xml'
+        'views/product_views.xml',
-             "rather than via a simple format validation (checksum).")
+    vat_check_vies = fields.Boolean(string='VIES VAT Check')
-    conv_coll = fields.Char(related='company_id.conv_coll', string="Convention collective *")
+    plafond_secu = fields.Float(related='company_id.plafond_secu', string="Plafond de la Securite Sociale")
-        'views/account_config_settings_views.xml',
+        'views/account_config_settings_views.xml',
-        help="Allows you to specify an analytic account on purchase order lines.")
+        implied_group='purchase.group_analytic_accounting')
-        res = super(ProductProduct, self).read_group(fields, groupby, offset=offset, limit=limit, orderby=orderby, lazy=lazy)
+        res = super(ProductProduct, self).read_group(domain, fields, groupby, offset=offset, limit=limit, orderby=orderby, lazy=lazy)
-            res_val = tot_products._compute_product_margin_fields_values([x for x in fields if fields in fields_list], '')
+            res_val = tot_products._compute_product_margin_fields_values(field_names=[x for x in fields if fields in fields_list])
-    module_delivery_temando = fields.Boolean("Temando integration")
+        if inventory.company_id.id:
-                if not ('currency_id' in line and 'amount_currency' in line):
+                if not (line.get('currency_id') and line.get('amount_currency')):
-                line['price'] = currency.compute(line['price'], company_currency)
+                if not ('currency_id' in line and 'amount_currency' in line):
-                        'price': self.env['account.invoice.line']._get_price(inv, company_currency, i_line, price_unit),
+                        'price': price_unit * i_line.quantity,
-                        'price': -1 * self.env['account.invoice.line']._get_price(inv, company_currency, i_line, price_unit),
+                        'price': -1 * price_unit * i_line.quantity,
-        supplier_taxes_id = set(ir_values.get_default('product.template', 'supplier_taxes_id', company_id=company_id))
+        supplier_taxes_id = set(ir_values.get_default('product.template', 'supplier_taxes_id', company_id=company_id) or [])
-        taxes_id = set(self.env['ir.values'].get_default('product.template', 'taxes_id', company_id=company_id))
+        taxes_id = set(self.env['ir.values'].get_default('product.template', 'taxes_id', company_id=company_id) or [])
-    compress_html = fields.Boolean('Compress HTML') # TODO: REMOVE ME IN SAAS-14
+# -*- coding: utf-8 -*-
-from openerp.osv import osv
+from openerp.osv import osv, fields
-        return report_obj.render(cr, uid, ids, 'hr_holidays.report_holidayssummary', docargs, context=context)
+        return report_obj.render(cr, uid, ids, 'hr_holidays.report_holidayssummary', docargs, context=context)
-class Lead(FormatAddress, models.Model):
+class Lead(models.Model):
-    _inherit = ['mail.thread', 'mail.activity.mixin', 'utm.mixin']
+    _inherit = ['mail.thread', 'mail.activity.mixin', 'utm.mixin', 'format.address.mixin']
-    def fields_view_get(self, view_id=None, view_type='form', toolbar=False, submenu=False):
+    def _fields_view_get(self, view_id=None, view_type='form', toolbar=False, submenu=False):
-        res = super(Lead, self).fields_view_get(view_id=view_id, view_type=view_type, toolbar=toolbar, submenu=submenu)
+        res = super(Lead, self)._fields_view_get(view_id=view_id, view_type=view_type, toolbar=toolbar, submenu=submenu)
-            res['arch'] = self.fields_view_get_address(res['arch'])
+            res['arch'] = self._fields_view_get_address(res['arch'])
-            default='%(street)s\n%(street2)s\n%(city)s %(state_code)s %(zip)s\n%(country_name)s')
+    name = fields.Char(
-                break
+class FormatAddressMixin(models.AbstractModel):
-class Partner(models.Model, FormatAddress):
+class Partner(models.Model):
-    def fields_view_get(self, view_id=None, view_type='form', toolbar=False, submenu=False):
+    def _fields_view_get(self, view_id=None, view_type='form', toolbar=False, submenu=False):
-        res = super(Partner, self).fields_view_get(view_id=view_id, view_type=view_type, toolbar=toolbar, submenu=submenu)
+        res = super(Partner, self)._fields_view_get(view_id=view_id, view_type=view_type, toolbar=toolbar, submenu=submenu)
-            res['arch'] = self.fields_view_get_address(res['arch'])
+            res['arch'] = self._fields_view_get_address(res['arch'])
-        """
+    def _fields_view_get(self, view_id=None, view_type='form', toolbar=False, submenu=False):
-                View = View.with_context(base_model_name=root_view['model'])
+            result['base_model'] = root_view['model']
-
+        if where_clause:
-                      AND """ + where_clause + """
+                      """ + where_clause + """
-from odoo import fields, models
+from odoo import api, fields, models
-    default_lang_id = fields.Many2one(related='website_id.default_lang_id', relation='res.lang', required=True)
+    language_count = fields.Integer(string='Number of languages', compute='_compute_language_count', readonly=True)
-    favicon = fields.Binary('Favicon', related='website_id.favicon')
+    module_website_form_editor = fields.Boolean("Custom Forms")
-        return dict(google_maps_api_key=google_maps_api_key)
+    @api.depends('language_ids')
-    channel_id = fields.Many2one('im_livechat.channel', string='Website Live Chat Channel', related='website_id.channel_id')
+    channel_id = fields.Many2one('im_livechat.channel', string='Website Live Channel', related='website_id.channel_id')
-    module_website_sale_delivery = fields.Boolean("Add Delivery Costs to Online Sales")
+    module_website_sale_delivery = fields.Boolean("Shipping Costs")
-        ], "Optional Products", help='Installs *e-Commerce Optional Products*')
+
-        ], default=0, string="Pricing Strategy")
+    sale_pricelist_setting_split_1 = fields.Boolean(default=0, string="Multiple Prices per Products")
-             'Advanced pricing based on formulas (discounts, margins, rounding): apply price rules from a new *Pricelists* menu in Configuration.')
+        (0, 'Multiple prices per product (e.g. customer segments, currencies)'),
-                Example: 10% for retailers, promotion of 5 EUR on this product, etc.""")
+        implied_group='product.group_sale_pricelist')
-    order_mail_template = fields.Many2one('mail.template', string='Order Confirmation Email', readonly=True, default=_default_order_mail_template, help="Email sent to customer at the end of the checkout process")
+
-        string='Twitter API Key',
+        string='API Key',
-        string='Twitter API secret',
+        string='API secret',
-        string='Get favorites from this screen name',
+        string='Favorites From',
-                if self.month_by == 'day':  # Eg : Second Monday of the month
+                if self.month_by == 'day' and self.byday and self.week_list:  # Eg : Second Monday of the month
-            date_to = fields.Date.from_string(holiday.date_to)
+            # Convert date to user timezone, otherwise the report will not be consistent with the
-                    sum(l.qty * u.factor) as product_qty,
+                    sum(l.qty) as product_qty,
-        self.price_unit = self.event_ticket_id.price
+        self.price_unit = (self.event_id.company_id or self.env.user.company_id).currency_id.compute(self.event_ticket_id.price, self.order_id.currency_id)
-                      LEFT JOIN account_account a ON (l.account_id=a.id)
+        self._cr.execute("""SELECT account_move_line.partner_id, act.type, SUM(account_move_line.amount_residual)
-                      GROUP BY l.partner_id, act.type
+                      AND account_move_line.partner_id IN %s
-            r[group['product_id'][0]] = group['unit_quantity']
+        PurchaseOrderLines = self.env['purchase.order.line'].search(domain)
-        return True
+            product.purchase_count = len(PurchaseOrderLines.filtered(lambda r: r.product_id == product).mapped('order_id'))
-from odoo import api, models
+from odoo import api, models, tools
-                order.commitment_date = fields.Datetime.to_string(min(dates_list))
+                commit_date = min(dates_list) if order.picking_policy == 'direct' else max(dates_list)
-            dt_create_date = fields.Datetime.from_string(issue.create_date)
+            dt_create_date = fields.Datetime.from_string(issue.create_date) or current_datetime
-    rml_footer_readonly = fields.Text(related='rml_footer', string='Report Footer *', readonly=True)
+    custom_footer = fields.Selection(related="company_id.custom_footer")
-    custom_footer = fields.Boolean(help="Check this to define the report footer manually. Otherwise it will be filled in automatically.")
+    custom_footer = fields.Selection([
-    vat = fields.Char(related='partner_id.vat', string="Tax ID")
+    vat = fields.Char(related='partner_id.vat', string="TIN")
-from odoo import api, fields, models
+from odoo import fields, models
-        return cgi.escape(substitution)
+            'custom_layout': "purchase.mail_template_data_notification_email_purchase_order"
-            final_date = fields.datetime.context_timestamp(cr, uid, datetime.strptime(event.stop, tools.DEFAULT_SERVER_DATETIME_FORMAT) + timedelta(days=1), context=context).isoformat('T').split('T')[0]
+            start_date = event.start_date
-             "of accounting entries. The payment term may compute several due dates, for example 50% "
+             "of accounting entries. The Payment terms may compute several due dates, for example 50% "
-             "term is not set on the invoice. If you keep the payment term and the due date empty, it "
+             "term is not set on the invoice. If you keep the Payment terms and the due date empty, it "
-             "The payment term may compute several due dates, for example 50% now, 50% in one month.")
+             "of accounting entries. If you keep the payment terms and the due date empty, it means direct payment. "
-            # When no payment term defined
+            # When no payment terms defined
-    _description = "Payment Term"
+    _description = "Payment Terms"
-    active = fields.Boolean(default=True, help="If the active field is set to False, it will allow you to hide the payment term without removing it.")
+    active = fields.Boolean(default=True, help="If the active field is set to False, it will allow you to hide the payment terms without removing it.")
-            raise ValidationError(_('A Payment Term should have its last line of type Balance.'))
+            raise ValidationError(_('A Payment Terms should have its last line of type Balance.'))
-            raise ValidationError(_('A Payment Term should have only one line of type Balance.'))
+            raise ValidationError(_('A Payment Terms should have only one line of type Balance.'))
-    _description = "Payment Term Line"
+    _description = "Payment Terms Line"
-        help="Select here the kind of valuation related to this payment term line.")
+        help="Select here the kind of valuation related to this payment terms line.")
-    sequence = fields.Integer(default=10, help="Gives the sequence order when displaying a list of payment term lines.")
+    sequence = fields.Integer(default=10, help="Gives the sequence order when displaying a list of payment terms lines.")
-        help="This payment term will be used instead of the default one for sale orders and customer invoices", oldname="property_payment_term")
+        help="This payment term will be used instead of the default one for sales orders and customer invoices", oldname="property_payment_term")
-        # I set a new sale team giving access rights of salesman.
+        # I set a new sales team giving access rights of salesman.
-        ''' For every sale order, compute the price of the shipment
+        ''' For every sales order, compute the price of the shipment
-        :return list: A list of floats, containing the estimated price for the shipping of the sale order
+        :param orders: A recordset of sales orders
-        # Remove delivery products from the sale order
+        # Remove delivery products from the sales order
-        # Create the sale order line
+        # Create the sales order line
-        # Create sale order with Normal Delivery Charges
+        # Create sales order with Normal Delivery Charges
-        # I add delivery cost in Sale order
+        # I add delivery cost in Sales order
-        # I add delivery cost in Sale order
+        # I add delivery cost in Sales order
-        # I check sale order after added delivery cost
+        # I check sales order after added delivery cost
-        # I confirm the sale order
+        # I confirm the sales order
-        # Create one more sale order with Free Delivery Charges
+        # Create one more sales order with Free Delivery Charges
-        # I add free delivery cost in Sale order
+        # I add free delivery cost in Sales order
-        # I check sale order after adding delivery cost
+        # I check sales order after adding delivery cost
-        # I add delivery cost in Sale order
+        # I add delivery cost in Sales order
-        help="Reference of the document that created the registration, for example a sale order")
+        help="Reference of the document that created the registration, for example a sales order")
-        sale order line. It takes some registration data (dict-based) that are
+        sales order line. It takes some registration data (dict-based) that are
-Creating registration with sale orders.
+Creating registration with sales orders.
-choose an event category associated with it. When you encode a sale order for
+choose an event category associated with it. When you encode a sales order for
-when you confirm your sale order it will automatically create a registration for
+when you confirm your sales order it will automatically create a registration for
-    # handle attendees linked to sale orders and their lines
+    # handle attendees linked to sales orders and their lines
-    sale_order_line_id = fields.Many2one('sale.order.line', string='Sale Order Line', ondelete='cascade')
+    sale_order_id = fields.Many2one('sale.order', string='Source Sales Order', ondelete='cascade')
-        """ Create or update registrations linked to a sale order line. A sale
+        """ Create or update registrations linked to a sales order line. A sale
-        # I create a sale order
+        # I create a sales order
-        # In the sale order I add some sale order lines. i choose event product
+        # In the sales order I add some sales order lines. i choose event product
-            'name': 'sale order line',
+            'name': 'sales order line',
-    sale_order_id = fields.Many2one('sale.order', 'Sale Order', required=True)
+    sale_order_id = fields.Many2one('sale.order', 'Sales Order', required=True)
-    sale_order_line_id = fields.Many2one('sale.order.line', string='Sale Order Line')
+    sale_order_line_id = fields.Many2one('sale.order.line', string='Sales Order Line')
-        # Create Sale Journal
+        # Create Sales Journal
-        copy incoterm from sale order to invoice
+        copy incoterm from sales order to invoice
-            #if sales, the sale order is linked to the warehouse
+            #if sales, the sales order is linked to the warehouse
-        'account.journal', string='Sale Journal',
+        'account.journal', string='Sales Journal',
-            raise UserError(_("The company of the sale journal is different than the one of point of sale"))
+            raise UserError(_("The company of the sales journal is different than the one of point of sale"))
-    sale_journal = fields.Many2one('account.journal', related='session_id.config_id.journal_id', string='Sale Journal', store=True, readonly=True)
+    sale_journal = fields.Many2one('account.journal', related='session_id.config_id.journal_id', string='Sales Journal', store=True, readonly=True)
-        help="Total of all paid sale orders")
+        help="Total of all paid sales orders")
-                raise UserError(_("Unable to open the session. You have to assign a sale journal to your point of sale."))
+                raise UserError(_("Unable to open the session. You have to assign a sales journal to your point of sale."))
-        help="The number of point of sale orders related to this customer",
+        help="The number of point of sales orders related to this customer",
-        # euro's. this will cause issues as the sale journal is in
+        # euro's. this will cause issues as the sales journal is in
-        test_sale_journal = journal_obj.create({'name': 'Sale Journal - Test',
+        test_sale_journal = journal_obj.create({'name': 'Sales Journal - Test',
-    _description = 'Open Sale Details Report'
+    _description = 'Open Sales Details Report'
-    The goal is that when you have one sale order of several products
+    The goal is that when you have one sales order of several products
-    having the moves grouped into pickings that represent the sale order.
+    having the moves grouped into pickings that represent the sales order.
-    The name is usually the name of the original document (sale order) or a
+    The name is usually the name of the original document (sales order) or a
-This module will automatically reserve the picking from stock when a sale order is confirmed
+This module will automatically reserve the picking from stock when a sales order is confirmed
-Upon confirmation of a sale order or when quantities are added,
+Upon confirmation of a sales order or when quantities are added,
-             "This description will be copied to every Sale Order, Delivery Order and Customer Invoice/Refund")
+             "This description will be copied to every Sales Order, Delivery Order and Customer Invoice/Refund")
-             "request (e.g. a sale order or an internal procurement request)")
+             "request (e.g. a sales order or an internal procurement request)")
-With this module you can personnalize the sale order and invoice report with
+With this module you can personnalize the sales order and invoice report with
-        Returns this sale order lines ordered by sale_layout_category sequence. Used to render the report.
+        Returns this sales order lines ordered by sale_layout_category sequence. Used to render the report.
-        string='Sale Order Lines', readonly=True, copy=False)
+        string='Sales Order Lines', readonly=True, copy=False)
-    sale_line_id = fields.Many2one('sale.order.line', string='Sale Order Line')
+    sale_line_id = fields.Many2one('sale.order.line', string='Sales Order Line')
-             "Create a task and track hours: Create a task on the sale order validation and track the work hours.",
+             "Create a task and track hours: Create a task on the sales order validation and track the work hours.",
-    confirmation_date = fields.Datetime(string='Confirmation Date', readonly=True, index=True, help="Date on which the sale order is confirmed.", oldname="date_confirm")
+    confirmation_date = fields.Datetime(string='Confirmation Date', readonly=True, index=True, help="Date on which the sales order is confirmed.", oldname="date_confirm")
-        - Payment term
+        - Payment terms
-            raise UserError(_('Please define an accounting sale journal for this company.'))
+            raise UserError(_('Please define an accounting sales journal for this company.'))
-        " They are not copied when duplicating a sale order.")
+        string="Is a down payment", help="Down payments are made when creating invoices from a sales order."
-        ('sale', 'Sale Order'),
+        ('sale', 'Sales Order'),
-            raise UserError(_('You can not remove a sale order line.\nDiscard changes and try setting the quantity to 0.'))
+            raise UserError(_('You can not remove a sales order line.\nDiscard changes and try setting the quantity to 0.'))
-            :param integer pricelist_id: pricelist id of sale order"""
+            :param integer pricelist_id: pricelist id of sales order"""
-    so_line = fields.Many2one('sale.order.line', string='Sale Order Line')
+    so_line = fields.Many2one('sale.order.line', string='Sales Order Line')
-                raise UserError(_('The Sale Order %s linked to the Analytic Account must be validated before registering expenses.') % order.name)
+                raise UserError(_('The Sales Order %s linked to the Analytic Account must be validated before registering expenses.') % order.name)
-        ], "Sale Order Modification")
+        ], "Sales Order Modification")
-        """ Test the sale order flow (invoicing and quantity updates)
+        """ Test the sales order flow (invoicing and quantity updates)
-        """ Test deleting and cancelling sale orders depending on their state and on the user's rights """
+        """ Test deleting and cancelling sales orders depending on their state and on the user's rights """
-        journal_obj.create({'name': 'Sale Journal - Test', 'code': 'STSJ', 'type': 'sale', 'company_id': company_id})
+        # Create Sales Journal
-        # I create partner for sale order.
+        # I create partner for sales order.
-        # In order to test I create sale order and confirmed it.
+        # In order to test I create sales order and confirmed it.
-        assert order, "Sale order will not created."
+        assert order, "Sales order will not created."
-        assert order.invoice_ids, "No any invoice is created for this sale order"
+        assert order.invoice_ids, "No any invoice is created for this sales order"
-If different cases are open (a list), it generates one sale order by case.
+If different cases are open (a list), it generates one sales order by case.
-    target_sales_invoiced = fields.Integer('Invoiced in Sale Orders Target')
+    target_sales_invoiced = fields.Integer('Invoiced in Sales Orders Target')
-    'summary': 'Quotation, Sale Orders, Delivery & Invoicing Control',
+    'summary': 'Quotation, Sales Orders, Delivery & Invoicing Control',
-        # create some expense and validate it (expense at sales price)
+        # create some expense and validate it (expense at sale price)
-        # Create a sale order for product Graphics Card.
+        # Create a sales order for product Graphics Card.
-        # Confirm the sale order.
+        # Confirm the sales order.
-        self.assertEqual(sale_order_so11.margin, 3000.00, "Sale order margin should be 3000.00")
+        self.assertEqual(sale_order_so11.margin, 3000.00, "Sales order margin should be 3000.00")
-        """check that when creating a sale order with a product that has a phantom BoM, move explode into content of the
+        """check that when creating a sales order with a product that has a phantom BoM, move explode into content of the
-        #create sale order with one sale order line containing product with a phantom bom
+        #create sales order with one sales order line containing product with a phantom bom
-        #confirm sale order
+        #confirm sales order
-        # Create sale order of 10 Dozen product A.
+        # Create sales order of 10 Dozen product A.
-        self.assertTrue(order, "Sale order not created.")
+        self.assertTrue(order, "Sales order not created.")
-        #  Sale order of 10 Dozen product A should create production order
+        #  Sales order of 10 Dozen product A should create production order
-    """Add several date fields to Sale Orders, computed or user-entered"""
+    """Add several date fields to Sales Orders, computed or user-entered"""
-        # I copy a demo Sale Order with Requested Date on 2010-07-12
+        # In order to test the Requested Date feature in Sales Orders in Odoo,
-        # I confirm the Sale Order.
+        # I confirm the Sales Order.
-This module allows a customer to give rating on task which are created from sale order.
+This module allows a customer to give rating on task which are created from sales order.
-    'summary': 'Quotation, Sale Orders, Delivery & Invoicing Control',
+    'summary': 'Quotation, Sales Orders, Delivery & Invoicing Control',
-        """Computes the delivered quantity on sale order lines, based on done stock moves related to its procurements
+        """Computes the delivered quantity on sales order lines, based on done stock moves related to its procurements
-        help='Trigger a decrease of the delivered quantity in the associated Sale Order')
+        help='Trigger a decrease of the delivered quantity in the associated Sales Order')
-        # Update delivered quantities on sale order lines
+        # Update delivered quantities on sales order lines
-    sale_id = fields.Many2one('sale.order', "Sale Order", compute='_compute_sale_id', search='_search_sale_id')
+    sale_id = fields.Many2one('sale.order', "Sales Order", compute='_compute_sale_id', search='_search_sale_id')
-    to_refund_so = fields.Boolean(string="To Refund", help='Trigger a decrease of the delivered quantity in the associated Sale Order')
+    to_refund_so = fields.Boolean(string="To Refund", help='Trigger a decrease of the delivered quantity in the associated Sales Order')
-        help='Create a task under this project on sale order validation. This setting must be set for each company.')
+        help='Create a task under this project on sales order validation. This setting must be set for each company.')
-            raise ValidationError(_('You cannot delete a task related to a Sale Order. You can only archive this task.'))
+            raise ValidationError(_('You cannot delete a task related to a Sales Order. You can only archive this task.'))
-                    raise ValidationError(_("You can use only one product on timesheet within the same sale order. You should split your order to include only one contract based on time and material."))
+                    raise ValidationError(_("You can use only one product on timesheet within the same sales order. You should split your order to include only one contract based on time and material."))
-        help='If set, sale team used notably for sales and assignations related to this partner')
+        help='If set, sales team used notably for sales and assignations related to this partner')
-        (1, 'Reserve products immediately after the sale order confirmation'),
+        (1, 'Reserve products immediately after the sales order confirmation'),
-        products when confirming a sale order.
+        products when confirming a sales order.
-    # Quotations and Sale Orders
+    # Quotations and Sales Orders
-    sale_order_id = fields.Many2one('sale.order', string='Sale Order')
+    # link with the sales order
-        """ Override to confirm the sale order, if defined, and if the transaction
+        """ Override to confirm the sales order, if defined, and if the transaction
-        # TDE note: read access on sale order to portal users granted to followed sale orders
+        # TDE note: read access on sales order to portal users granted to followed sales orders
-    order_id = fields.Many2one('sale.order', 'Sale Order Reference', ondelete='cascade', index=True)
+    order_id = fields.Many2one('sale.order', 'Sales Order Reference', ondelete='cascade', index=True)
-        # must have a draft sale order with lines at this point, otherwise reset
+        # must have a draft sales order with lines at this point, otherwise reset
-         - a draft sale order with lines; otherwise, clean context / session and
+         - a draft sales order with lines; otherwise, clean context / session and
-        (0, 'A single sales price per product'),
+        (0, 'A single sale price per product'),
-        ], default=0, string="Sales Price",
+        ], default=0, string="Sale Price",
-            raise UserError(_('It is forbidden to modify a sale order which is not in draft status'))
+            raise UserError(_('It is forbidden to modify a sales order which is not in draft status'))
-        :param bool force_create: Create sale order if not already existing
+        """ Return the current sales order after mofications specified by params.
-        :param bool update_pricelist: Force to recompute all the lines from sale order to adapt the price with the current pricelist.
+        :param bool update_pricelist: Force to recompute all the lines from sales order to adapt the price with the current pricelist.
-        :returns: browse record for the current sale order
+        :returns: browse record for the current sales order
-    last_website_so_id = fields.Many2one('sale.order', string='Last Online Sale Order')
+    last_website_so_id = fields.Many2one('sale.order', string='Last Online Sales Order')
-        # link a product to the sale order
+        # link a product to the sales order
-                value['start_date'] = datetime.strftime(start, DEFAULT_SERVER_DATE_FORMAT)
+                value['start_date'] = fields.date.context_today(self, cr, uid, context=context, timestamp=start)
-                value['stop_date'] = datetime.strftime(end, DEFAULT_SERVER_DATE_FORMAT)
+                value['stop_date'] = fields.date.context_today(self, cr, uid, context=context, timestamp=end)
-    start_date = fields.Datetime(required=True, default=fields.Datetime.now)
+    def _default_start_date(self):
-        data.update(self.get_sale_details(date_start, date_stop, company))
+        data = dict(data or {})
-            self.start_date, self.end_date, self.pos_config_ids))
+        data = {'date_start': self.start_date, 'date_stop': self.end_date, 'config_ids': self.pos_config_ids.ids}
-        # prevent all concurrent updates on ir_attachment while collecting!
+        # Continue in a new transaction. The LOCK statement below must be the
-            for product in self.with_context(location=location.id, compute_child=False):
+            for product in self.with_context(location=location.id, compute_child=False).filtered(lambda r: r.valuation == 'real_time'):
-        domain += ['|', ('website_id', '=', request.website.id), ('website_id', '=', False)]
+        website_id = request.context.get('website_id') or request.registry['website'].search(cr, uid, [], limit=1)[0]
-    def get_fields(self, model, depth=FIELDS_RECURSION_LIMIT, full=False):
+    def get_fields(self, model, depth=FIELDS_RECURSION_LIMIT):
-
+        blacklist = models.MAGIC_COLUMNS + [Model.CONCURRENCY_CHECK_FIELD]
-                field_value['fields'] = self.get_fields(field['relation'], depth=depth - 1, full=full)
+                field_value['fields'] = self.get_fields(field['relation'], depth=depth-1)
-        }
+            if not line[index]:
-
+        # Get fields of type date/datetime
-        for follower in request.env['mail.followers'].browse(follower_ids):
+        follower_recs = request.env['mail.followers'].sudo().browse(follower_ids)
-        ids = self.registry('ir.translation').search(self.cr, self.uid,
+        ids = self.env['ir.translation'].search(
-    _inherit = ['mail.thread']
+    _inherit = ['mail.thread', 'mail.activity.mixin']
-    _inherit = ['mail.thread']
+    _inherit = ['mail.thread', 'mail.activity.mixin']
-    _inherit = "mail.thread"
+    _inherit = ['mail.thread']
-    _inherit = ['mail.thread']
+    _inherit = ['mail.thread', 'mail.activity.mixin']
-    _inherit = ['mail.thread']
+    _inherit = ['mail.thread', 'mail.activity.mixin']
-    _inherit = ['mail.thread']
+    _inherit = ['mail.thread', 'mail.activity.mixin']
-    _inherit = ['mail.thread']
+    _inherit = ['mail.thread', 'mail.activity.mixin']
-    _inherit = ['mail.thread']
+    _inherit = ['mail.thread', 'mail.activity.mixin']
-    _inherit = ['mail.thread']
+    _inherit = ['mail.thread', 'mail.activity.mixin']
-    _inherit = ['mail.thread']
+    _inherit = ['mail.thread', 'mail.activity.mixin']
-    _inherit = 'mail.thread'
+    _inherit = ['mail.thread', 'mail.activity.mixin']
-    _inherit = ['mail.thread']
+    _inherit = ['mail.thread', 'mail.activity.mixin']
-    _inherit = ['mail.thread']
+    _inherit = ['mail.thread', 'mail.activity.mixin']
-    _inherit = ['res.partner', 'mail.thread']
+    _inherit = ['res.partner', 'mail.thread', 'mail.activity.mixin']
-    'demo': ['data/hr_recruitment_demo.xml'],
+    'demo': [
-    _inherit = ['mail.thread', 'utm.mixin']
+    _inherit = ['mail.thread', 'mail.activity.mixin', 'utm.mixin']
-        'views/crm_activity_views.xml',
+        'data/mail_activity_demo.xml',
-    _inherit = ['mail.thread', 'utm.mixin']
+    _order = "priority desc,activity_date_deadline,id desc"
-                lead_date = fields.Date.from_string(lead.date_action)
+            if lead.activity_date_deadline:
-                if date_action == date.today():
+            for activity in opp.activity_ids:
-                if date.today() <= date_action <= date.today() + timedelta(days=7):
+                if date.today() <= date_deadline <= date.today() + timedelta(days=7):
-                if date_action < date.today():
+                if date_deadline < date.today():
-                INNER JOIN crm_activity A ON (M.subtype_id = A.subtype_id)
+                mail_message.id,
-                (M.model = 'crm.lead') AND (L.user_id = %s) AND (L.type = 'opportunity')
+                (mail_message.model = 'crm.lead') AND (crm_lead.user_id = %s) AND (crm_lead.type = 'opportunity')
-    subtype_id = fields.Many2one('mail.message.subtype', 'Activity', readonly=True)
+    subtype_id = fields.Many2one('mail.message.subtype', 'Subtype', readonly=True)
-                    (m.model = 'crm.lead')
+                    (m.model = 'crm.lead' AND m.mail_activity_type_id IS NOT NULL)
-from datetime import date
+from datetime import datetime, timedelta
-class TestCrmActivity(TestCrmCases):
+class TestCrmMailActivity(TestCrmCases):
-        super(TestCrmActivity, self).setUp()
+        super(TestCrmMailActivity, self).setUp()
-        self.activity3 = Activity.create({
+        lead_model_id = self.env['ir.model'].search([('model', '=', 'crm.lead')]).id
-            'res_model': 'crm.lead',
+            'summary': 'ACT 3 : Beers for everyone because I am a good salesman !',
-        self.activity2 = Activity.create({
+        self.activity2 = ActivityType.create({
-            'recommended_activity_ids': [(6, 0, [self.activity3.id])],
+            'summary': 'ACT 2 : I want to show you my ERP !',
-        self.activity1 = Activity.create({
+        self.activity1 = ActivityType.create({
-            'recommended_activity_ids': [(6, 0, [self.activity2.id])],
+            'summary': 'ACT 1 : Presentation, barbecue, ... ',
-        self.lead = Lead.create({
+        self.lead = self.env['crm.lead'].sudo(self.crm_salesman.id).create({
-        """ This test case check :
+        """ This test case checks
-        self.assertFalse(any(is_internal_subtype_for_client), 'Partner client is following an internal subtype')
+        internal_subtypes = self.lead.message_follower_ids.filtered(lambda fol: fol.partner_id == self.partner_client).mapped('subtype_ids').filtered(lambda subtype: subtype.internal)
-        wizard = ActivityLogWizard.create({
+        activity = self.env['mail.activity'].sudo(self.crm_salesman.id).create({
-            'next_activity_id': activity.id,
+            'res_id': self.lead.id,
-        # Check message recipients
+        activity._onchange_activity_type_id()
-        self.assertEqual(self.lead.next_activity_id.id, False, 'When logging activity, the next activity planned is erased')
+        self.assertEqual(activity_message.needaction_partner_ids, self.crm_salemanager.partner_id)
-            'next_activity_id': self.activity1.id
+        lead_model_id = self.env['ir.model'].search([('model', '=', 'crm.lead')]).id
-        self.lead._onchange_next_activity_id()
+        activity._onchange_activity_type_id()
-        self.assertEqual(self.lead.title_action, self.activity1.description, 'Activity title should be the same on the lead and on the chosen activity')
+        self.assertEqual(self.lead.activity_summary, activity.summary)
-        wizard = self.env['crm.activity.log'].sudo(self.crm_salesman.id).create({
+        activity.write({
-        wizard.action_log()
+        activity._onchange_activity_type_id()
-        self.assertFalse(self.lead.next_activity_id.id, 'No next activity should be set on lead, since we jsut log another activity')
+        self.assertEqual(self.lead.activity_summary, activity.activity_type_id.summary)
-        wizard.action_schedule()
+        activity.action_done()
-        self.assertEqual(self.lead.title_action, self.activity3.description, 'Activity title should be the same on the lead and on the activity 3')
+        # Check the next activity on the lead has been removed
-                leads.write({'active': True, 'next_activity_id': False, 'lost_reason': False})
+                leads.write({'active': True, 'activity_type_id': False, 'lost_reason': False})
-            'today': {'label': _('Today Activities'), 'domain': [('date_action', '=', today)]},
+            'today': {'label': _('Today Activities'), 'domain': [('activity_date_deadline', '=', today)]},
-            'overdue': {'label': _('Overdue Activities'), 'domain': [('date_action', '<', today)]},
+                     'domain': [('activity_date_deadline', '>=', today), ('activity_date_deadline', '<=', this_week_end_date)]},
-                'activities': request.env['crm.activity'].sudo().search([], order='sequence desc'),
+                'activity_types': request.env['mail.activity.type'].sudo().search([]),
-            lead.write({
+            lead_values = {
-            })
+            }
-        }
+        }
-    _inherit = ['mail.thread']
+    _inherit = ['mail.thread', 'mail.activity.mixin']
-                    partner_data[pid] = default_subtypes.ids
+                    if pid not in employee_pids:
-                    partner_data[pid] = default_subtypes.ids
+                    if pid not in employee_pids:
-        data = self.read(cr, uid, id, ['final_date', 'recurrency', 'rrule_type', 'count', 'end_type', 'stop'], context=context)
+        data = self.read(cr, uid, id, ['final_date', 'recurrency', 'rrule_type', 'count', 'end_type', 'stop', 'interval'], context=context)
-            count = data['count'] + 1
+        if end_type == 'count' and all(data.get(key) for key in ['count', 'rrule_type', 'stop', 'interval']):
-            data['day'] = r._bymonthday[0]
+            data['day'] = list(r._bymonthday)[0]
-    displayed_image_id = fields.Many2one('ir.attachment', domain="[('res_model', '=', 'project.task'), ('res_id', '=', id), ('mimetype', 'ilike', 'image')]", string='Displayed Image')
+    displayed_image_id = fields.Many2one('ir.attachment', domain="[('res_model', '=', 'project.task'), ('res_id', '=', id), ('mimetype', 'ilike', 'image')]", string='Cover Image')
-    procurement_id = fields.Many2one('procurement.order', 'Procurement', ondelete='set null')
+    procurement_id = fields.Many2one('procurement.order', 'Assign to Order', ondelete='set null', help="Procurement of the sale order line on which the timesheets should be assigned")
-                        lines_to_update[po_line] += [(proc.id, qty)]
+                        lines_to_update[po_line] += [proc]
-                        lines_to_update[po_line] = [(proc.id, qty)]
+                        lines_to_update[po_line] = [proc]
-                line_values += [(1, line.id, {'product_qty': line.product_qty + tot_qty, 'procurement_ids': [(4, x[0]) for x in lines_to_update[line]]})]
+                for proc in lines_to_update[line]:
-    def get_fields(self, model, depth=FIELDS_RECURSION_LIMIT):
+    def get_fields(self, model, depth=FIELDS_RECURSION_LIMIT, full=False):
-        blacklist = models.MAGIC_COLUMNS + [Model.CONCURRENCY_CHECK_FIELD]
+        blacklist = ([] if full else models.MAGIC_COLUMNS) + [Model.CONCURRENCY_CHECK_FIELD]
-                field_value['fields'] = self.get_fields(field['relation'], depth=depth-1)
+                field_value['fields'] = self.get_fields(field['relation'], depth=depth - 1, full=full)
-                raise ValueError(_("Column %s contains incorrect values (value: %s)" % (name, old_value)))
+            for (name, index, dummy) in indexes:
-                self._parse_float_from_data(data, index, name, options)
+        all_fields = self.get_fields(self.res_model, full=True)
-        pl = Property.get('property_product_pricelist', Partner._name, '%s,%s' % (Partner._name, p.id)).id
+        pl = Property.get('property_product_pricelist', Partner._name, '%s,%s' % (Partner._name, p.id))
-        pl = Property.get('property_product_pricelist', Partner._name, '%s,%s' % (Partner._name, p.id))
+        pl = Property.get('property_product_pricelist', Partner._name, '%s,%s' % (Partner._name, p.id)).id
-                        taxes[tax['id']]['base_amount'] += line.price_unit
+                        taxes[tax['id']]['base_amount'] += line.price_subtotal
-                moves = (moves | st_line.journal_entry_ids)
+                for aml in st_line.journal_entry_ids:
-                        WHERE account_id IS NULL AND not exists (select 1 from account_move m where m.statement_line_id = stl.id)
+        sql_query = """SELECT stl.id
-    journal_entry_ids = fields.One2many('account.move', 'statement_line_id', 'Journal Entries', copy=False, readonly=True)
+    journal_entry_ids = fields.One2many('account.move.line', 'statement_line_id', 'Journal Items', copy=False, readonly=True)
-    state = fields.Selection(related='statement_id.state' , string='Status', readonly=True)
+    state = fields.Selection(related='statement_id.state', string='Status', readonly=True)
-        moves_to_cancel = self.env['account.move']
+        aml_to_unbind = self.env['account.move.line']
-            moves_to_unbind |= st_line.journal_entry_ids
+            aml_to_unbind |= st_line.journal_entry_ids
-                        moves_to_cancel |= st_line.journal_entry_ids
+                        aml_to_cancel |= st_line.journal_entry_ids
-        moves_to_unbind = moves_to_unbind - moves_to_cancel
+        aml_to_unbind = aml_to_unbind - aml_to_cancel
-                move.line_ids.filtered(lambda x:x.statement_id == st_line.statement_id).write({'statement_id': False})
+        if aml_to_unbind:
-                move.line_ids.remove_move_reconcile()
+        if aml_to_cancel:
-        domain_reconciliation = ['&', '&', ('statement_id', '=', False), ('account_id', 'in', reconciliation_aml_accounts), ('payment_id','<>', False)]
+        domain_reconciliation = ['&', '&', ('statement_line_id', '=', False), ('account_id', 'in', reconciliation_aml_accounts), ('payment_id','<>', False)]
-            aml_rec.move_id.write({'statement_line_id': self.id})
+            total -= aml_rec.debit - aml_rec.credit
-                aml_dict['statement_id'] = self.statement_id.id
+                aml_dict['statement_line_id'] = self.id
-            number_to_reconcile = all_lines - already_reconciled
+            self.env.cr.execute("""SELECT COUNT(DISTINCT(line.id))
-    statement_id = fields.Many2one('account.bank.statement', string='Statement',
+    statement_line_id = fields.Many2one('account.bank.statement.line', index=True, string='Bank statement line reconciled with this entry', copy=False, readonly=True)
-            if 'statement_id' in vals and record.payment_id:
+            if 'statement_line_id' in vals and record.payment_id:
-        self.assertTrue(rec_move)
+        self.assertTrue(st_line.journal_entry_ids)
-        for l in rec_move.line_ids:
+        for l in st_line.journal_entry_ids:
-        self.assertEqual(liquidity_aml.move_id.statement_line_id, bank_statement.line_ids[0])
+        self.assertEqual(liquidity_aml.statement_line_id, bank_statement.line_ids[0])
-        default=lambda self: getattr(self.env.ref('stock.warehouse0', raise_if_not_found=False) or self.env['stock.warehouse'], 'lot_stock_id').id)
+        default=_default_location_id)
-                res[product.id] = res[product.id] = product.sudo()[ptype]
+                res[product.id] = product.sudo()[ptype]
-                        # copy account.tax translations
+                        # copy account.tax name translations
-                    # copy account.tax translations
+                    # copy account.tax name translations
-    def _select_seller(self, cr, uid, product_id, partner_id=False, quantity=0.0, date=time.strftime(DEFAULT_SERVER_DATE_FORMAT), uom_id=False, context=None):
+    def _select_seller(self, cr, uid, product_id, partner_id=False, quantity=0.0, date=None, uom_id=False, context=None):
-                if country:
+            curr_country = Country.browse(country_id)
-                        'country_id': (country_id, country['name'])
+                        'country_id': (curr_country.id, curr_country.name)
-            vals.update({'sequence': self.sale_line_id.sequence})
+        if procurement.sale_line_id:
-        children_acc_template = self.search(cr, uid, [('nocreate','!=',True)] + children_acc_criteria, order='id')
+        children_acc_template = self.search(cr, uid, [('nocreate','!=',True)] + children_acc_criteria, order='id', context=context)
-        """ Parse a text reponse for a PDT verification .
+        """ Parse a text response for a PDT verification .
-        """ Parse a text response for a PDT verification .
+        """ Parse a text reponse for a PDT verification .
-            res.append(new_moves)
+            res.extend(new_moves)
-        """ Parse a text reponse for a PDT verification .
+        """ Parse a text response for a PDT verification .
-        'partner_id': fields.many2one('res.partner', string='Contact', required=True, readonly=True),
+        'partner_id': fields.many2one(
-                    'name': _('Salary Slip of %s for %s') % (employee_id.name, tools.ustr(babel.dates.format_date(date=ttyme, format='MMMM-y', locale=self.env.context.get('lang', 'en_US')))),
+                    'name': _('Salary Slip of %s for %s') % (employee_id.name, tools.ustr(babel.dates.format_date(date=ttyme, format='MMMM-y', locale=context.get('lang', 'en_US')))),
-            }
+        # update the anonymization fields:
-            if warehouse.manufacture_pull_id:
+            if warehouse.manufacture_pull_id and name:
-    def _update_name_and_code(self, name, code):
+    def _update_name_and_code(self, name=False, code=False):
-    def _update_name_and_code(self, name, code):
+    def _update_name_and_code(self, name=False, code=False):
-                ('blog_id', 'in', self)
+                ('blog_id', 'in', self.ids)
-            post_ids.write({'active': vals['active']})
+            for blog_post in post_ids:
-                    'name': _('Salary Slip of %s for %s') % (employee_id.name, tools.ustr(ttyme.strftime('%B-%Y'))),
+                    'name': _('Salary Slip of %s for %s') % (employee_id.name, tools.ustr(babel.dates.format_date(date=ttyme, format='MMMM-y', locale=self.env.context.get('lang', 'en_US')))),
-        self.name = _('Salary Slip of %s for %s') % (employee_id.name, tools.ustr(ttyme.strftime('%B-%Y')))
+        self.name = _('Salary Slip of %s for %s') % (employee_id.name, tools.ustr(babel.dates.format_date(date=ttyme, format='MMMM-y', locale=self.env.context.get('lang', 'en_US'))))
-        return super(MailMail, self)._postprocess_sent_message(mail_sent=mail_sent)
+from openerp.tools import float_compare
-            if leave_days['remaining_leaves'] < 0 or leave_days['virtual_remaining_leaves'] < 0:
+            if float_compare(leave_days['remaining_leaves'], 0, precision_digits=2) == -1 or \
-        'product_id': fields.many2one('product.product', 'Product', required=True, domain=[("event_type_id", "!=", False)]),
+        'product_id': fields.many2one('product.product', 'Product', required=True,
-                    self.report.ir_values_id.sudo().unlink()
+                    report.ir_values_id.sudo().unlink()
-        res = map(lambda l: (l[0].name, formatLang(self.env, l[1], currency_obj=currency)), res)
+        res = map(lambda l: (l[0].name, l[1]), res)
-        res = map(lambda l: (l[0].name, formatLang(self.env, l[1], currency_obj=currency)), res)
+        res = map(lambda l: (l[0].name, l[1]), res)
-    note = fields.Text('Notes', help="Legal mentions that have to be printed on the invoices.")
+    note = fields.Text('Notes', translate=True, help="Legal mentions that have to be printed on the invoices.")
-                        taxes[tax['id']]['total'] += tax['amount']
+                        taxes.setdefault(tax['id'], {'name': tax['name'], 'tax_amount':0.0, 'base_amount':0.0})
-        help='Explanation text to help users using the star and priority mechanism on stages or issues that are in this stage.')
+        string='Starred Explanation', translate=True,
-        ], default='0', index=True)
+            ('0','Non Starred'),
-        ], size=1, readonly=True)
+            ('0','Non Starred'),
-            if not time_log or time_log.date_end:
+            # We search for a productivity line associated to this workcenter having no `date_end`.
-                 'child_ids.planned_hours', 'child_ids.effective_hours', 'child_ids.children_hours')
+                 'child_ids.planned_hours', 'child_ids.effective_hours', 'child_ids.children_hours', 'child_ids.timesheet_ids.unit_amount')
-
+        for task in self.sorted(key='id', reverse=True):
-                if child_task.stage_id and child_task.stage_id.fold:
+                if child_task.stage_id and not child_task.stage_id.fold:
-            elif (task.planned_hours > 0.0 and task.effective_hours):
+            elif (task.planned_hours > 0.0 and (task.effective_hours or task.children_hours)):
-            context
+                if self._context.get(MODULE_UNINSTALL_FLAG):
-            return _reopen(self, record.id, record.model, context=context)
+            return _reopen(self, record.id, record.model, context=self._context)
-            debit_wo, credit_wo, amount_currency_wo, currency_id = aml_obj.with_context(date=self.payment_date).compute_amount_fields(self.payment_difference, self.currency_id, self.company_id.currency_id, invoice_currency)
+            amount_currency_wo, currency_id = aml_obj.with_context(date=self.payment_date).compute_amount_fields(self.payment_difference, self.currency_id, self.company_id.currency_id, invoice_currency)[2:]
-        rec = self.env['account.analytic.default'].account_get(self.product_id.id, self.invoice_id.partner_id.id, self._uid,
+        if not self.account_analytic_id:
-            self.account_analytic_id = False
+            if rec:
-                            to_reconcile_lines.reconcile()
+                            to_reconcile_lines.filtered(lambda l: l.reconciled == False).reconcile()
-    _description = "Hr Department"
+    _description = "HR Department"
-                            to_reconcile_lines.reconcile()
+                            to_reconcile_lines.filtered(lambda l: l.reconciled == False).reconcile()
-                customerloc, location_dest_id = self.env['stock.warehouse']._get_partner_locations()
+                location_dest_id, supplierloc = self.env['stock.warehouse']._get_partner_locations()
-def _reopen(self, res_id, model):
+def _reopen(self, res_id, model, context=None):
-            },
+            'context': context,
-            return _reopen(self, record.id, record.model)
+            return _reopen(self, record.id, record.model, context=context)
-        help="Total amount in the currency of the invoice, negative for credit notes.")
+        help="Total amount in the currency of the invoice, negative for refunds.")
-        help="Total amount in the currency of the company, negative for credit notes.")
+        help="Total amount in the currency of the company, negative for refunds.")
-        help="Total amount in the currency of the company, negative for credit notes.")
+        help="Total amount in the currency of the company, negative for refunds.")
-                if name not in cls._fields:
+                field = cls._fields.get(name)
-                    _logger.warning("method %s.%s: @constrains parameter %r is not stored", cls._name, attr, name)
+                if not (field.store or field.column and field.column._fnct_inv):
-        consume_move.quant_ids.write({'produced_quant_ids': [(6, 0, produced_quant_ids.ids)]})
+        consume_move.quant_ids.sudo().write({'produced_quant_ids': [(6, 0, produced_quant_ids.ids)]})
-                if name not in cls._fields:
+                field = cls._fields.get(name)
-                    _logger.warning("method %s.%s: @constrains parameter %r is not stored", cls._name, attr, name)
+                if not (field.store or field.inverse):
-                if not cls._fields[name].store:
+                if not cls._fields[name].column:
-            context.get('set_viewport_size')
+            context.get('set_viewport_size'),
-    def _run_wkhtmltopdf(self, cr, uid, headers, footers, bodies, landscape, paperformat, spec_paperformat_args=None, save_in_attachment=None, set_viewport_size=False):
+    def _run_wkhtmltopdf(self, cr, uid, headers, footers, bodies, landscape, paperformat, spec_paperformat_args=None, save_in_attachment=None, set_viewport_size=False, context=None):
-                            self.pool['ir.attachment'].create(cr, uid, attachment)
+                            self.pool['ir.attachment'].create(cr, uid, attachment, context)
-        post_msg = '''<div>
+        post_msg = _('''<div>
-</div>''' % {
+</div>''') % {
-        save_in_attachment = self._check_attachment_use(cr, uid, ids, report)
+        save_in_attachment = self._check_attachment_use(cr, uid, ids, report, context=context)
-    def _check_attachment_use(self, cr, uid, ids, report):
+    def _check_attachment_use(self, cr, uid, ids, report, context=None):
-            records = self.pool[report.model].browse(cr, uid, ids)
+            records = self.pool[report.model].browse(cr, uid, ids, context=context)
-        default.update(code=_("%s (copy)") % (account['code'] or ''))
+        default.setdefault('code', _("%s (copy)") % (account['code'] or ''))
-            })
+            }, context=context)
-            'name': self.pool['ir.sequence'].next_by_code(cr, uid, 'pos.session', context=context),
+            'name': unique_name,
-    # - if that doesn't exist, create a new one
+    # to recover from this situation we create a new rescue session,
-
+        _logger.warning('attempting to create recovery session for saving order %s', order['name'])
-            new_session.signal_workflow('open')
+        # bypass opening_control (necessary when using cash control)
-            return new_session_id
+        return new_session_id
-            values.setdefault('session_id', session.config_id.pricelist_id.id)
+            values.setdefault('pricelist_id', session.config_id.pricelist_id.id)
-                        [l.id for l in invoice.invoice_line])])
+                        [l.id for l in invoice.invoice_line_ids])])
-    _order = 'default_code,name_template'
+    _order = 'default_code,name_template,id'
-                line.update({'date_planned': order.date_planned})
+            order.order_line.update({'date_planned': order.date_planned})
-                line.update({'date_planned': order.date_planned})
+                line.update({'date_planned': date_planned})
-    _order = 'parent_left'
+    _order = 'name'
-    parent_right = fields.Integer('Right Parent', index=True)
+        external_default_subtypes = default_subtypes.filtered(lambda subtype: not subtype.internal)
-                    partner_data[pid] = default_subtypes.ids
+                    if pid not in employee_pids:
-    quote_description = fields.Html('Description for the quote', sanitize_attributes=False)
+    quote_description = fields.Html('Description for the quote', sanitize_attributes=False, translate=html_translate)
-        orderpoint_ids = orderpoint_obj.search(cr, uid, dom)
+        orderpoint_ids = orderpoint_obj.search(cr, uid, dom, context=context)
-                    seq_obj.write(cr, uid, warehouse.in_type_id.sequence_id.id, {'name': name + _(' Sequence in'), 'prefix': vals.get('code', warehouse.code) + '\IN\\'}, context=context)
+                    seq_obj.write(cr, uid, warehouse.in_type_id.sequence_id.id, {'name': name + _(' Sequence in'), 'prefix': vals.get('code', warehouse.code) + '/IN/'}, context=context)
-                    seq_obj.write(cr, uid, warehouse.out_type_id.sequence_id.id, {'name': name + _(' Sequence out'), 'prefix': vals.get('code', warehouse.code) + '\OUT\\'}, context=context)
+                    seq_obj.write(cr, uid, warehouse.out_type_id.sequence_id.id, {'name': name + _(' Sequence out'), 'prefix': vals.get('code', warehouse.code) + '/OUT/'}, context=context)
-                    seq_obj.write(cr, uid, warehouse.pack_type_id.sequence_id.id, {'name': name + _(' Sequence packing'), 'prefix': vals.get('code', warehouse.code) + '\PACK\\'}, context=context)
+                    seq_obj.write(cr, uid, warehouse.pack_type_id.sequence_id.id, {'name': name + _(' Sequence packing'), 'prefix': vals.get('code', warehouse.code) + '/PACK/'}, context=context)
-                    seq_obj.write(cr, uid, warehouse.pick_type_id.sequence_id.id, {'name': name + _(' Sequence picking'), 'prefix': vals.get('code', warehouse.code) + '\PICK\\'}, context=context)
+                    seq_obj.write(cr, uid, warehouse.pick_type_id.sequence_id.id, {'name': name + _(' Sequence picking'), 'prefix': vals.get('code', warehouse.code) + '/PICK/'}, context=context)
-                    seq_obj.write(cr, uid, warehouse.int_type_id.sequence_id.id, {'name': name + _(' Sequence internal'), 'prefix': vals.get('code', warehouse.code) + '\INT\\'}, context=context)
+                    seq_obj.write(cr, uid, warehouse.int_type_id.sequence_id.id, {'name': name + _(' Sequence internal'), 'prefix': vals.get('code', warehouse.code) + '/INT/'}, context=context)
-
+                            if not journal.refund_sequence_id:
-        help="This field depict the efficiency of the resource to complete tasks. e.g  resource put alone on a phase of 5 days with 5 tasks assigned to him, will show a load of 100% for this phase by default, but if we put a efficiency of 200%, then his load will only be 50%.")
+        help="This field is used to calculate the the expected duration of a work order at this work center. For example, if a work order takes one hour and the efficiency factor is 100%, then the expected duration will be one hour. If the efficiency factor is 200%, however the expected duration will be 30 minutes.")
-
+from odoo import api, fields, models, tools
-            self = self.with_context(lang=self.partner_id.lang)
+        template = self.template_id.with_context(lang=self.partner_id.lang)
-        for line in self.template_id.quote_line:
+        for line in template.quote_line:
-        for option in self.template_id.options:
+        for option in template.options:
-            self.validity_date = fields.Date.to_string(datetime.now() + timedelta(self.template_id.number_of_days))
+        if template.number_of_days > 0:
-        self.require_payment = self.template_id.require_payment
+        self.website_description = template.website_description
-            self.note = self.template_id.note
+        if template.note:
-        lines = self._get_account_move_lines(self.ids)
+        lines = self._get_account_move_lines(docids)
-        for partner_id in self.ids:
+        for partner_id in docids:
-            'doc_ids': self.ids,
+            'doc_ids': docids,
-            'docs': self.env['res.partner'].browse(self.ids),
+            'docs': self.env['res.partner'].browse(docids),
-        return seller
+        if date is None:
-        help="The cost price is used for valuate stocks or to assess the price of manufacturing a product. The purchase orders are fetching the vendor prices.")
+        help="Cost of the product, in the default unit of measure of the product.")
-        if self.product_uom and seller_uom != self.product_uom:
+
-        seller_min_qty = self.product_id.product_seller_ids\
+        seller_min_qty = self.product_id.seller_ids\
-                or seller_min_qty[0].product_id.product_tmpl_id.uom_id
+            self.product_uom = seller_min_qty[0].product_uom
-                suppliers = procurement.product_id.seller_ids.filtered(lambda r: not r.product_id or r.product_id == procurement.product_id)
+            suppliers = procurement.product_id.seller_ids.filtered(lambda r: not r.product_id or r.product_id == procurement.product_id)
-from odoo import fields
+    def test_00_purchase_order_flow(self):
-# (http://trigluu.com)
+# Copyright (c) 2009-2016 Salvatore JosuÃ© Trimarchi Pinto <trimarchi@bacgroup.net>
-    'version': '0.1',
+    'version': '0.2',
-    'website': 'http://trigluu.com',
+    'website': 'http://bacgroup.net',
-            self._compute_value(record)
+            fields = record._field_computed[self]
-            return accounts['stock_input']
+            if accounts['stock_input']:
-            }, context=context)
+            })
-
+                qcontext['error'] = e.message or e.name
-    "depends": ["account", "base_vat"],
+    "depends": [
-from odoo import fields, models, tools
+from odoo import fields, models, tools, api
-                    c.date_deadline,
+    def _select(self):
-                    c.date_last_stage_update as date_last_stage_update,
+            c.user_id,
-                FROM
+    def _from(self):
-            )""")
+        """
-    color = fields.Integer(related='mass_mailing_campaign_id.color', string='Color Index')
+    color = fields.Integer(string='Color Index')
-    "version": "1.0",
+    "version": "1.1",
-#!/usr/bin/env python
+#!/usr/bin/env python2
-            allowed = self.env[res_model].search([('id', 'in', target_ids)])
+            allowed = self.env[res_model].with_context(active_test=False).search([('id', 'in', target_ids)])
-        paypal_urls = tx.acquirer_id._get_paypal_urls(tx.acquirer_id.environment or 'prod')
+        paypal_urls = request.env['payment.acquirer']._get_paypal_urls(tx and tx.acquirer_id.environment or 'prod')
-            if field is self:
+            if field in fields:
-        for field in computed:
+        for field in records._field_computed[self]:
-            records.env.computed[field].difference_update(records._ids)
+            saved = {}
-                    safe_eval(self.callback_eval, {'self': self})
+                init_state = self.state
-                if self.callback_eval:
+                if self.callback_eval and init_state != 'authorized':
-            _logger.info('<%s> transaction processed: tx ref:%s, tx amount: %s', acquirer_name, tx.reference if tx else 'n/a', tx.amount if tx else 'n/a')
+        # fetch the tx
-            _logger.exception('Fail to confirm the order or send the confirmation email%s', tx and ' for the transaction %s' % tx.reference or '')
+        if tx:
-                return dict(success=True, url='/shop/payment/validate')
+                else:
-            view_id = self.env['ir.ui.view'].get_view_id(name)
+        # with view ids or children view or children primary views, force it here.
-            return view.inherit_id is not None and view.mode != 'primary'
+            return view.inherit_id is not None
-        # render with an id
+        # render view and child view with an id
-        # render with an xmlid
+        # render view and child view with an xmlid
-        model_fields = sorted(self._fields.itervalues(), key=lambda field: field.type == 'sparse')
+        model_fields = sorted(self._fields.itervalues(), key=lambda field: bool(field.sparse))
-            if getattr(field, 'serialization_field', None):
+            if field.sparse:
-                serialization_field = Fields.search([('model', '=', vals['model']), ('name', '=', field.serialization_field)])
+                serialization_field = Fields.search([('model', '=', vals['model']), ('name', '=', field.sparse)])
-                    raise UserError(_("Serialization field `%s` not found for sparse field `%s`!") % (field.serialization_field, field.name))
+                    raise UserError(_("Serialization field `%s` not found for sparse field `%s`!") % (field.sparse, field.name))
-        states={'draft': [('readonly', False)]}, domain=[('appears_on_payslip', '=', True)])
+        states={'draft': [('readonly', False)]})
-            'get_lines_by_contribution_register': self.get_lines_by_contribution_register(payslips.mapped('line_ids')),
+            'get_details_by_rule_category': self.get_details_by_rule_category(payslips.mapped('details_by_salary_rule_category').filtered(lambda r: r.appears_on_payslip)),
-                if leaves[0].double_validation:
+                if leaves and leaves[0].double_validation:
-    'version': '1.1',
+    'version': '1.2',
-                workorder.production_id.state = 'progress'
+                workorder.production_id.write({
-        return action
+        return action
-            self.production_id.state = 'progress'
+            self.production_id.write({
-        elif vals.get('probability') < 100:
+        elif 'probability' in vals and vals['probability'] < 100:
-        self.unlink(cr, uid, ids, context=context)
+
-        wkhtmltopdf_state = 'ok'
+    match = re.search('([0-9.]+)', out)
-        wkhtmltopdf_state = 'workers'
+        if config['workers'] == 1:
-            leads.write(values)
+            leads.with_context(mail_auto_subscribe_no_notify=1).write(values)
-            {'id': 'parent_id', 'name': 'parent_id', 'string': 'Parent id', 'type': 'many2one', 'required': False, 'fields': [
+            {'id': 'parent_id', 'name': 'parent_id', 'string': 'Parent', 'type': 'many2one', 'required': False, 'fields': [
-            self.string = name.replace('_', ' ').capitalize()
+            self.string = (
-    @api.constrains('product_id', 'product_uom')
+    @api.constrains('product_id')
-    @api.constrains('arch', 'arch_base')
+    @api.constrains('arch_db')
-            res.update({'bank_account_ids': [{'acc_name': _('Cash'), 'account_type': 'cash'}, {'acc_name': _('Bank'), 'account_type': 'bank'}]})
+            res.update({'bank_account_ids': self._get_default_bank_account_ids()})
-            'company_id': company.id,})
+        # Create the current year earning account if it wasn't present in the CoA
-                amount = line.currency_id.round((line.credit_cash_basis - line.debit_cash_basis) - (line.credit - line.debit) * matched_percentage)
+                amount = currency_id.round((line.credit_cash_basis - line.debit_cash_basis) - (line.credit - line.debit) * matched_percentage)
-                                'credit': line.currency_id.round(line.credit_cash_basis - line.credit * matched_percentage),
+                                'debit': currency_id.round(line.debit_cash_basis - line.debit * matched_percentage),
-                                'debit': line.currency_id.round(line.credit_cash_basis - line.credit * matched_percentage),
+                                'credit': currency_id.round(line.debit_cash_basis - line.debit * matched_percentage),
-            res.update({'bank_account_ids': [{'acc_name': _('Cash'), 'account_type': 'cash'}, {'acc_name': _('Bank'), 'account_type': 'bank'}]})
+            res.update({'bank_account_ids': self._get_default_bank_account_ids()})
-            self.partner_id = self.project_id.partner_id
+            self.partner_id = self.project_id.partner_id or default_partner
-            self.partner_id = False
+            self.partner_id = default_partner
-            partner.task_count = len(partner.task_ids)
+            partner.task_count = result.get(partner.id, 0)
-            self.email_from = False
+            self.partner_id = default_partner
-                        user_signature=self.env.context.get('mail_notify_user_signature', True))
+        if not self.env.context.get('message_create_from_mail_mail'):
-        # 1. message is a reply to an existing message (exact match of message_id or compat-mode)
+        # 1. Check if message is a reply on a thread
-        # 4. Look for a matching mail.alias entry
+                is_a_reply = False
-            result['res_id'] = invoice_ids.ids[0]
+        invoices = self.mapped('invoice_ids')
-        return result
+            action = {'type': 'ir.actions.act_window_close'}
-                depreciation_date = datetime.strptime(self._get_last_depreciation_date()[self.id], DF).date()
+                # if we already have some previous validated entries, starting date is last entry + method period
-                _logger.warning("@constrains%r parameters must be field names", func._constrains)
+            for name in func._constrains:
-                'context': {'statement_ids': bank_stmt.ids},
+                'context': {'statement_ids': bank_stmt.ids, 'company_ids': self.mapped('company_id').ids},
-            action_context = {'show_mode_selector': False}
+            action_context = {'show_mode_selector': False, 'company_ids': self.mapped('company_id').ids}
-        self.assertEqual(len(mails), 2, 'event: wrong number of reminders in outgoing mail queue')
+        self.assertEqual(len(mails), 3, 'event: wrong number of reminders in outgoing mail queue')
-        self.assertEqual(schedulers[0].scheduled_date, datetime.datetime.strftime(event_date_begin + relativedelta(days=-2), tools.DEFAULT_SERVER_DATETIME_FORMAT), 'event: incorrect scheduled date')
+        self.assertEqual(schedulers[0].scheduled_date, datetime.datetime.strftime(event_date_begin + relativedelta(days=-1), tools.DEFAULT_SERVER_DATETIME_FORMAT), 'event: incorrect scheduled date')
-    issue_id = fields.Many2one('project.issue', 'Issue')
+    issue_id = fields.Many2one('project.issue', 'Issue', copy=False)
-                    'interval_nbr': 2,
+                (0, 0, {  # 1 days before event
-        mails = self.env['mail.mail'].search([('subject', 'ilike', 'reminder'), ('date', '>=', datetime.datetime.strftime(now, tools.DEFAULT_SERVER_DATETIME_FORMAT))], order='date DESC', limit=3)
+        mails = self.env['mail.mail'].search([('subject', 'ilike', 'TestEventMail'), ('date', '>=', datetime.datetime.strftime(now, tools.DEFAULT_SERVER_DATETIME_FORMAT))], order='date DESC', limit=3)
-            'company_id': company.id,})
+        # Create the current year earning account if it wasn't present in the CoA
-        elif event_date.month == (today + relativedelta(months=+1)):
+        elif event_date.month == (today + relativedelta(months=+1)).month:
-    tax_adjustment = fields.Boolean(default=False)
+    use_cash_basis = fields.Boolean(
-                                        help='Generate tax cash basis entrie when reconciliating entries')
+    tax_cash_basis_journal_id = fields.Many2one(
-        self.assertEqual(self.event_0.registration_ids.get_date_range_str(), u'this month')
+        self.event_0.registration_ids.event_begin_date = datetime.datetime(2016, 1, 25, 6, 0)
-    date_end_located = fields.Datetime(string='End Date Located', compute='_compute_date_end_tz')
+    date_begin_located = fields.Char(string='Start Date Located', compute='_compute_date_begin_tz')
-            self.date_begin_located = fields.Datetime.to_string(fields.Datetime.context_timestamp(self_in_tz, date_begin))
+            self.date_begin_located = format_tz(self.with_context({'use_babel': True}).env, self.date_begin, tz=self.date_tz)
-            self.date_end_located = fields.Datetime.to_string(fields.Datetime.context_timestamp(self_in_tz, date_end))
+            self.date_end_located = format_tz(self.with_context({'use_babel': True}).env, self.date_end, tz=self.date_tz)
-            return _('on ') + format_tz(self.env, self.event_begin_date, tz=self.event_id.date_tz or 'UTC')
+            return _('on ') + format_tz(self.with_context({'use_babel': True}).env, self.event_begin_date, tz=self.event_id.date_tz or 'UTC')
-            'interval_nbr': 2,
+            'interval_nbr': 1,
-            'interval_nbr': 15,
+            'interval_nbr': 10,
-            return _('Today')
+        if diff.days <= 0:
-            return _('Tomorrow')
+            return _('tomorrow')
-            return _('This month')
+            return _('this month')
-            return _('Next month')
+            return _('next month')
-            return format_tz(self.env, self.event_begin_date, tz='UTC', format='%Y%m%dT%H%M%SZ')
+            return _('on ') + format_tz(self.env, self.event_begin_date, tz=self.event_id.date_tz or 'UTC')
-        self.assertEqual(self.event_0.registration_ids.get_date_range_str(), u'Tomorrow')
+        self.assertEqual(self.event_0.registration_ids.get_date_range_str(), u'tomorrow')
-        self.assertEqual(self.event_0.registration_ids.get_date_range_str(), u'Today')
+        self.assertEqual(self.event_0.registration_ids.get_date_range_str(), u'today')
-        self.assertEqual(self.event_0.registration_ids.get_date_range_str(), u'Tomorrow')
+        self.assertEqual(self.event_0.registration_ids.get_date_range_str(), u'tomorrow')
-        self.assertEqual(self.event_0.registration_ids.get_date_range_str(), u'This week')
+        self.assertEqual(self.event_0.registration_ids.get_date_range_str(), u'in 2 days')
-        self.mock_datetime.now.return_value = Datetime.to_string(datetime.datetime(2015, 12, 15, 12, 0))
+        self.mock_datetime.now.return_value = Datetime.to_string(datetime.datetime(2015, 12, 10, 12, 0))
-        self.assertEqual(self.event_0.registration_ids.get_date_range_str(), u'This month')
+        self.assertEqual(self.event_0.registration_ids.get_date_range_str(), u'this month')
-            membership_lines_ids = membership_line_obj.search(cr, uid, line_domain, context=context)
+            membership_line_ids = membership_line_obj.search(cr, uid, line_domain, context=context)
-            factor = production.product_uom_id._compute_quantity(production.product_qty - production.qty_produced, production.bom_id.product_uom_id) / production.bom_id.product_qty
+            done_moves = production.move_finished_ids.filtered(lambda x: x.state == 'done' and x.product_id == production.product_id)
-            self._update_product_to_produce(production, production.product_qty - production.qty_produced)
+            self._update_product_to_produce(production, production.product_qty - qty_produced)
-            return ValidationError(_('Error ! Task starting date must be lower than its ending date.'))
+            raise ValidationError(_('Error ! Task starting date must be lower than its ending date.'))
-
+from odoo import api, fields, models
-    _inherit = ['mail.thread', 'ir.needaction_mixin']
+    _inherit = ['mail.thread']
-    _inherit = ["mail.thread", "ir.needaction_mixin"]
+    _inherit = ["mail.thread"]
-    _inherit = ['mail.thread', 'ir.needaction_mixin', 'utm.mixin']
+    _inherit = ['mail.thread', 'utm.mixin']
-    _inherit = ['mail.thread', 'ir.needaction_mixin']
+    _inherit = ['mail.thread']
-    _inherit = ['mail.thread', 'ir.needaction_mixin']
+    _inherit = ['mail.thread']
-    _inherit = ['mail.thread', 'ir.needaction_mixin']
+    _inherit = ['mail.thread']
-    _inherit = ['mail.thread', 'ir.needaction_mixin']
+    _inherit = ['mail.thread']
-    _inherit = ['mail.thread', 'ir.needaction_mixin']
+    _inherit = ['mail.thread']
-    _inherit = ['mail.thread', 'ir.needaction_mixin']
+    _inherit = ['mail.thread']
-    _inherit = ['mail.thread', 'ir.needaction_mixin']
+    _inherit = ['mail.thread']
-    _inherit = ['mail.thread', 'ir.needaction_mixin', 'utm.mixin']
+    _inherit = ['mail.thread', 'utm.mixin']
-    _inherit = ['mail.thread', 'ir.needaction_mixin']
+    _inherit = ['mail.thread']
-        na_emp2_base = self.env['mail.message'].sudo()._needaction_count(domain=[])
+        na_emp1_base = self.group_pigs.sudo(self.user_employee).message_needaction_counter
-        na_emp2_new = self.env['mail.message'].sudo()._needaction_count(domain=[])
+        na_emp1_new = self.group_pigs.sudo(self.user_employee).message_needaction_counter
-    _inherit = ['mail.thread', 'ir.needaction_mixin']
+    _inherit = ['mail.thread']
-    _inherit = ['mail.thread','ir.needaction_mixin']
+    _inherit = ['mail.thread']
-    _inherit = ['mail.alias.mixin', 'mail.thread', 'ir.needaction_mixin']
+    _inherit = ['mail.alias.mixin', 'mail.thread']
-    _inherit = ['mail.thread', 'ir.needaction_mixin']
+    _inherit = ['mail.thread']
-    _inherit = ['mail.thread', 'ir.needaction_mixin']
+    _inherit = ['mail.thread']
-    _inherit = ['mail.thread', 'ir.needaction_mixin']
+    _inherit = ['mail.thread']
-    _inherit = ['mail.thread', 'ir.needaction_mixin']
+    _inherit = ['mail.thread']
-    _inherit = ['mail.thread', 'ir.needaction_mixin']
+    _inherit = ['mail.thread']
-    _inherit = ['mail.thread', 'ir.needaction_mixin']
+    _inherit = ['mail.thread']
-    _inherit = ['mail.thread', 'ir.needaction_mixin']
+    _inherit = ['mail.thread']
-    _inherit = ['mail.thread', 'ir.needaction_mixin', 'website.seo.metadata', 'website.published.mixin']
+    _inherit = ['mail.thread', 'website.seo.metadata', 'website.published.mixin']
-
+        hr_actions = []
-            hr_actions = [{'url': app_action, 'title': _('Approve')}]
+            hr_actions += [{'url': app_action, 'title': _('Approve')}]
-            hr_actions = [{'url': ref_action, 'title': _('Refuse')}]
+            hr_actions += [{'url': ref_action, 'title': _('Refuse')}]
-        self.env['ir.qweb']._get_asset.clear_cache(self.env['ir.qweb'])
+        if 'xml' not in tools.config['dev_mode']:
-            "is_admin": request.env.user.has_group('base.group_system'),
+        current_website = request.website
-        sitemap = ira.search_read(cr, uid, [('url', '=' , '/sitemap.xml'), ('type', '=', 'binary')], ('datas', 'create_date'), context=context)
+        dom = [('url', '=' , '/sitemap-%d.xml' % current_website.id), ('type', '=', 'binary')]
-            sitemap_ids = ira.search(cr, uid, [('url', '=like' , '/sitemap%.xml'), ('type', '=', 'binary')], context=context)
+            dom = [('type', '=', 'binary'), '|', ('url', '=like' , '/sitemap-%d-%%.xml' % current_website.id),
-                    last = create_sitemap('/sitemap-%d.xml' % pages, content)
+                    last = create_sitemap('/sitemap-%d-%d.xml' % (current_website.id, pages), content)
-                ira.write(cr, uid, last, dict(url="/sitemap.xml", name="/sitemap.xml"), context=context)
+                # rename the -id-page.xml => -id.xml
-                create_sitemap('/sitemap.xml', content)
+                create_sitemap('/sitemap-%d.xml' % current_website.id, content)
-            if view['priority'] <> 16:
+            if view['priority'] != 16:
-            'arch': '<t><p><h1>hello world</h1></p></t>',
+            'arch': '<t t-name="dummy"><p><h1>hello world</h1></p></t>',
-        if res_id:
+        # QWeb's `read_template` will check if one of the first children of
-        return template
+                    node.set('t-name', str(name))
-                if node.get('t-name') == template:
+                if node.get('t-name') == str(template):
-            return (element, document)
+
-            if not self.company_id.currency_id.is_zero(v):
+            "is_system": request.env.user._is_system(),
-        return request.render('rating.rating_external_page_submit', {
+        rating.write({'rating': rate, 'consumed': True})
-        return request.render('rating.rating_external_page_view', {
+        lang = rating.partner_id.lang or 'en_US'
-            template.send_mail(record.id, force_send=force_send)
+            lang = partner.lang or 'en_US'
-                task.rating_send_request(rating_template, reuse_rating=False, force_send=force_send)
+                task.rating_send_request(rating_template, partner=task.partner_id, reuse_rating=False, force_send=force_send)
-                issue.rating_send_request(rating_template, reuse_rating=False)
+                issue.rating_send_request(rating_template, partner=issue.partner_id, reuse_rating=False)
-        return res
+        SupInfo = self.env['product.supplierinfo']
-        help="Cost of the product, in the default unit of measure of the product.")
+        help="The cost price is used for valuate stocks or to assess the price of manufacturing a product. The purchase orders are fetching the vendor prices.")
-        if seller and self.product_uom and seller.product_uom != self.product_uom:
+        seller_uom = seller.product_uom or seller.product_id.product_tmpl_id.uom_id
-        seller_min_qty = self.product_id.seller_ids\
+        seller_min_qty = self.product_id.product_seller_ids\
-            self.product_uom = seller_min_qty[0].product_uom
+            self.product_uom = seller_min_qty[0].product_uom\
-            suppliers = procurement.product_id.seller_ids.filtered(lambda r: not r.product_id or r.product_id == procurement.product_id)
+            suppliers = procurement.product_id.product_seller_ids.filtered(lambda r: not r.product_id or r.product_id == procurement.product_id)
-    def test_00_purchase_order_flow(self):
+        self.partner_id_1 = self.env.ref('base.res_partner_3')
-            event = env['calendar.event'].with_context(tz=timezone).browse(int(id))
+            lang = attendee.partner_id.lang or 'en_US'
-            return response
+            # NOTE : we don't use request.render() since:
-        'default_lang_id': fields.related('website_id', 'default_lang_id', type='many2one', relation='res.lang', string='Default language'),
+        'default_lang_id': fields.related('website_id', 'default_lang_id', type='many2one', relation='res.lang', string='Default language', required=True),
-        'default_lang_id': fields.many2one('res.lang', string="Default language"),
+        'default_lang_id': fields.many2one('res.lang', string="Default language", required=True),
-                    price_uom = bom_line.product_uom_id._compute_quantity(bom_line.product_id.standard_price, bom_line.product_uom_id)
+                    price_uom = bom_line.product_id.uom_id._compute_price(bom_line.product_id.standard_price, bom_line.product_uom_id)
-                exchange_rate_entries = self.env['account.move'].search([('rate_diff_partial_rec_id', 'in', [x.id for x in partial_rec_set.keys()])])
+                exchange_rate_entries |= self.env['account.move'].search([('rate_diff_partial_rec_id', 'in', [x.id for x in partial_rec_set.keys()])])
-    name = fields.Char(required=True, index=True, translate=True)
+    name = fields.Char(translate=True)
-    name = fields.Char(required=True, index=True, translate=True)
+    name = fields.Char(translate=True)
-    name = fields.Char(string='Tax Name', required=True, index=True, translate=True)
+    name = fields.Char(translate=True)
-    name = fields.Char(string='Tax Name', required=True, index=True, translate=True)
+    name = fields.Char(translate=True)
-    name = fields.Char(required=True, translate=True)
+    name = fields.Char(translate=True)
-    note = fields.Text(string='Notes', translate=True)
+    name = fields.Char(translate=True)
-    note = fields.Text(string='Notes', translate=True)
+    name = fields.Char(translate=True)
-    name = fields.Char(string='Journal Name', required=True, translate=True)
+    name = fields.Char(translate=True)
-    name = fields.Char(string='Account Name', required=True, translate=True)
+    name = fields.Char(translate=True)
-    state = fields.Selection([('draft', 'Draft'), ('posted', 'Posted'), ('sent', 'Sent'), ('reconciled', 'Reconciled')], readonly=True, default='draft', copy=False, string="Status")
+    state = fields.Selection([('draft', 'Draft'), ('posted', 'Posted'), ('sent', 'Sent'), ('reconciled', 'Reconciled'), ('cancel', 'Cancelled')], readonly=True, default='draft', copy=False, string="Status")
-            rec.state = 'draft'
+            rec.state = 'cancel'
-            if res['mailing_model'] in ['res.partner', 'mail.mass_mailing.contact']:
+        if 'reply_to_mode' in fields and not 'reply_to_mode' in res and res.get('mailing_model_real'):
-        res.append(('mail.mass_mailing.contact', _('Mailing List')))
+        res.append(('mail.mass_mailing.contact', _('Mail Contacts')))
-    mailing_model = fields.Selection(selection=_mailing_model, string='Recipients Model', required=True, default='mail.mass_mailing.contact')
+    mailing_model_real = fields.Char(compute='_compute_model', string='Recipients Real Model', default='mail.mass_mailing.contact', required=True)
-        if self.mailing_model == 'mail.mass_mailing.contact':
+        if self.mailing_model == 'mail.mass_mailing.list':
-        model = self.env[self.mailing_model]
+        model = self.env[self.mailing_model_real]
-            res_ids = self.env[self.mailing_model].search(domain).ids
+            res_ids = self.env[self.mailing_model_real].search(domain).ids
-            contact_nbr = self.env[self.mailing_model].search_count(domain)
+            contact_nbr = self.env[self.mailing_model_real].search_count(domain)
-        already_mailed = self.env['mail.mail.statistics'].search_read([('model', '=', self.mailing_model),
+        already_mailed = self.env['mail.mail.statistics'].search_read([('model', '=', self.mailing_model_real),
-                'model': mailing.mailing_model,
+                'model': mailing.mailing_model_real,
-        mapped_data = dict([(c['list_id'][0], c['list_id_count']) for c in contacts_data])
+        self.env.cr.execute('''
-            mailing_list.contact_nbr = mapped_data.get(mailing_list.id, 0)
+            mailing_list.contact_nbr = data.get(mailing_list.id, 0)
-        ondelete='cascade', required=True, default=lambda self: self.env['mail.mass_mailing.list'].search([], limit=1, order='id desc'))
+    create_date = fields.Datetime(string='Creation Date')
-    message_bounce = fields.Integer(string='Bounce', help='Counter of the number of bounced emails for this contact.')
+    message_bounce = fields.Integer(string='Bounced', help='Counter of the number of bounced emails for this contact.')
-        contact = self.create({'name': name, 'email': email, 'list_id': list_id})
+        contact = self.create({'name': name, 'email': email, 'list_ids': [(4, list_id)]})
-                self.mailing_domain = "[('list_id', 'in', %s), ('opt_out', '=', False)]" % self.contact_list_ids.ids
+                self.mailing_domain = "[('list_ids', 'in', [%s]), ('opt_out', '=', False)]" % (','.join(map(str,self.contact_list_ids.ids)),)
-                self.mailing_domain = "[('list_id', '=', False)]"
+                self.mailing_domain = "[(0, '=', 1)]"
-            contacts_count = request.env['mail.mass_mailing.contact'].sudo().search_count([('list_id', '=', int(list_id)), ('email', '=', email), ('opt_out', '=', False)])
+            contacts_count = request.env['mail.mass_mailing.contact'].sudo().search_count([('list_ids', 'in', [int(list_id)]), ('email', '=', email), ('opt_out', '=', False)])
-            ('list_id', '=', int(list_id)),
+            ('list_ids', 'in', [int(list_id)]),
-            Contacts.create({'name': name, 'email': email, 'list_id': int(list_id)})
+            Contacts.create({'name': name, 'email': email, 'list_ids': [(6,0,[int(list_id)])]})
-        groups['user']['actions'] = [{'url': new_action, 'title': _('New Note')}]
+        for group, method, kwargs in groups:
-        domain = action_domain + [('res_id', 'in', self.tasks.ids), ('res_model', '=', 'project.task')]
+        domain = ['&', ('res_id', 'in', self.tasks.ids), ('res_model', '=', 'project.task')]
-        domain = action_domain + [('res_id', 'in', issues.ids), ('res_model', '=', 'project.issue')]
+        domain = ['&', ('res_id', 'in', issues.ids), ('res_model', '=', 'project.issue')]
-            domain = ['&'] + task_domain
+            domain = task_domain
-            domain = domain + ['&', ('res_id', 'in', issues.ids), ('res_model', '=', 'project.issue')]
+            issue_domain = self.action_view_issue_rating()['domain']
-    split_lot = action_split_lots
+    def _set_additional_fields(self, invoice):
-from openerp import tools, api
+from openerp import tools, api, SUPERUSER_ID
-        result = super(res_partner, self).write(vals)
+        result = True
-                    price_unit = uom_obj._compute_qty_obj(self.uom_id, price_unit, self.product_id.uom_id, round=False)
+                    price_unit = self.product_id.uom_id._compute_price(self.product_id.uom_id.id, price_unit, to_uom_id=self.uom_id.id)
-                price_unit = uom_obj._compute_qty_obj(self.uom_id, price_unit, self.product_id.uom_id, round=False)
+                price_unit = self.product_id.uom_id._compute_price(self.product_id.uom_id.id, price_unit, to_uom_id=self.uom_id.id)
-        return self.product_id.standard_price
+        price = self.product_id.standard_price
-            :param target_currency: curreny you want the move line debit/credit converted into
+            :param target_currency: currency (browse_record or ID) you want the move line debit/credit converted into
-            quantity = self._context.get('quantity')
+            quantity = self._context.get('quantity', 1.0)
-            aml_obj.reconcile_partial(cr, uid, pair, context=context)
+            # DO NOT FORWARD PORT
-            })
+            # DO NOT FORWARD PORT
-                order.button_approve(force=True)
+            if order.company_id.po_double_validation == 'one_step'\
-        self.env.user.company_id.write({'po_double_validation': 'two_step'})
+        self.env.user.company_id.write({'po_double_validation': 'two_step','po_double_validation_amount':2000.00})
-            tx.sudo()._ogone_s2s_validate()
+            tx = request.env['payment.transaction'].sudo()._ogone_form_get_tx_from_data(kwargs)
-        'company_id': fields.related('order_id', 'company_id', type='many2one', relation='res.company', string='Company', store=True, readonly=True),
+        'company_id': fields.related('order_id', 'company_id', type='many2one', relation='res.company', string='Company', store={
-            readonly=True, relation='res.company', string='Company', store=True)
+            readonly=True, relation='res.company', string='Company', store={
-            readonly=True, relation='res.company', string='Company', store=True)
+            readonly=True, relation='res.company', string='Company', store={
-        for el in doc.iter():
+        for el in doc.iter(tag=etree.Element):
-            for el in doc.iter():
+            for el in doc.iter(tag=etree.Element):
-        request.session['sale_transaction_id'] = tx.id
+        tx = request.env['payment.transaction'].sudo().browse(
-                            line.product_uom_id.id, line.price_unit, to_uom_id=self.product_uom.id)
+                        self.price_unit = line.product_uom_id._compute_price(
-            purchase_price = self.env['product.uom']._compute_price(product.uom_id.id, purchase_price, to_uom_id=product_uom.id)
+            purchase_price = product.uom_id._compute_price(purchase_price, product_uom)
-                    price_unit = self.product_id.uom_id._compute_price(self.product_id.uom_id.id, price_unit, to_uom_id=self.uom_id.id)
+                    price_unit = self.product_id.uom_id._compute_price(price_unit, self.uom_id)
-                price_unit = self.product_id.uom_id._compute_price(self.product_id.uom_id.id, price_unit, to_uom_id=self.uom_id.id)
+                price_unit = self.product_id.uom_id._compute_price(price_unit, self.uom_id)
-            return self.product_id.uom_id._compute_price(self.product_id.uom_id.id, price, to_uom_id=self.uom_id.id)
+            return self.product_id.uom_id._compute_price(price, self.uom_id)
-            }))
+            # Only entries with cash flow must be created
-    bank_statements_source = fields.Selection([('manual', 'Record Manually')], string='Bank Feeds')
+    bank_statements_source = fields.Selection([('no_feeds', 'No Feeds'),('manual', 'Record Manually')], string='Bank Feeds', default='no_feeds')
-        if self.currency_id and self.currency_id != self.company_id.currency_id:
+        if self.currency_id and self.company_id and self.currency_id != self.company_id.currency_id:
-        if self.invoice_id.currency_id and self.invoice_id.currency_id != self.invoice_id.company_id.currency_id:
+        if self.invoice_id.currency_id and self.invoice_id.company_id and self.invoice_id.currency_id != self.invoice_id.company_id.currency_id:
-        return new_id
+        return new_id.id
-            tx._ogone_s2s_validate()
+            tx.sudo()._ogone_s2s_validate()
-    @api.one
+    @api.multi
-            package.children_quant_ids = self.env['stock.quant'].search([('package_id', 'child_of', package.id)]).ids
+            if package.id:
-        'stock.location', 'Location', compute='_compute_package_info',
+        'stock.location', 'Location', compute='_compute_package_info', search='_search_location',
-        'res.company', 'Company', compute='_compute_package_info',
+        'res.company', 'Company', compute='_compute_package_info', search='_search_company',
-        'res.partner', 'Owner', compute='_compute_package_info',
+        'res.partner', 'Owner', compute='_compute_package_info', search='_search_owner',
-                    self.env['purchase.order'].signal_workflow([mail.res_id], 'send_rfq')
+                    purchase_order.state = 'sent'
-                                 help="When a relationship field is selected as first field, "
+                                 help="fWhen a relationship field is selected as first field, "
-        """ When changing the action base model, reset workflow and crud config
+        """ When changing the action base model, reset crud config
-    be provided too in the future).
+    in one case: reports. For reports, odoo.report.render_report() should
-a distributed server, flexible workflows, an object database, a dynamic GUI,
+a distributed server, an object database, a dynamic GUI,
-    if method not in ['execute', 'execute_kw', 'exec_workflow']:
+    if method not in ['execute', 'execute_kw']:
-        return self.wkf_expr_eval_expr(transition['condition'])
+    res_model_id = fields.Many2one(
-        'Related Document Model', required=True, index=True, help='Model of the followed resource')
+        'Related Document Model Name', index=True, readonly=True, related='res_model_id.model', store=True)
-            generic.append([0, 0, {'res_model': res_model, 'partner_id': pid, 'subtype_ids': [(6, 0, partner_data.get(pid) or default_subtypes.ids)]}])
+            generic.append([0, 0, {'res_model_id': res_model_id, 'partner_id': pid, 'subtype_ids': [(6, 0, partner_data.get(pid) or default_subtypes.ids)]}])
-            generic.append([0, 0, {'res_model': res_model, 'channel_id': cid, 'subtype_ids': [(6, 0, channel_data.get(cid) or default_subtypes.ids)]}])
+            generic.append([0, 0, {'res_model_id': res_model_id, 'channel_id': cid, 'subtype_ids': [(6, 0, channel_data.get(cid) or default_subtypes.ids)]}])
-                        'res_model': res_model,
+                        'res_model_id': res_model_id,
-                        'res_model': res_model,
+                        'res_model_id': res_model_id,
-                         set(['mail.channel']))
+        self.assertEqual(set([generic[0][2]['res_model_id'], generic[1][2]['res_model_id']]),
-        self.env['mail.followers'].create({'partner_id': self.user_employee.partner_id.id, 'res_model': 'mail.channel', 'res_id': self.group_pigs.id})
+        self.env['mail.followers'].create({'partner_id': self.user_employee.partner_id.id, 'res_model_id': mail_channel_model_id, 'res_id': self.group_pigs.id})
-        self.assertEqual(generic[0][2]['res_model'], 'mail.channel')
+        self.assertEqual(generic[0][2]['res_model_id'], mail_channel_model_id)
-        self.assertEqual(specific[self.group_public.id][0][2]['res_model'], 'mail.channel')
+        self.assertEqual(specific[self.group_public.id][0][2]['res_model_id'], mail_channel_model_id)
-                'res_model': 'mail.channel',
+                'res_model_id': self.env['ir.model'].search([('model', '=', 'mail.channel')], limit=1).id,
-                record.signal_workflow('validate')
+                record.action_validate()
-                record.signal_workflow('refuse')
+                record.action_refuse()
-        self.analytic_amount_currency = abs(self.amount_currency) * copysign(1, self.amount)
+        for line in self:
-        if self.env.user.share:
+        if self.env.user.share or self.env.context.get('force_website'):
-            order.order_line.update({'date_planned': order.date_planned})
+            #DO NOT FORWARD PORT
-    name = fields.Char('Name', required=True)
+    name = fields.Char('Name', required=True, translate=True)
-    name = fields.Char(required=True)
+    name = fields.Char(required=True, translate=True)
-    name = fields.Char(required=True)
+    name = fields.Char(required=True, translate=True)
-    name = fields.Char('Tag Name', required=True)
+    name = fields.Char('Tag Name', required=True, translate=True)
-    name = fields.Char('Name', required=True)
+    name = fields.Char('Name', required=True, translate=True)
-    name = fields.Char('Name', required=True)
+    name = fields.Char('Name', required=True, translate=True)
-            if total_amount == 0.0:
+            if float_is_zero(total_amount, precision_rounding=move.currency_id.rounding):
-                amount = (line.credit_cash_basis - line.debit_cash_basis) - (line.credit - line.debit) * matched_percentage
+                amount = line.currency_id.round((line.credit_cash_basis - line.debit_cash_basis) - (line.credit - line.debit) * matched_percentage)
-                                'credit': line.credit_cash_basis - line.credit * matched_percentage,
+                                'debit': line.currency_id.round(line.debit_cash_basis - line.debit * matched_percentage),
-                                'debit': line.credit_cash_basis - line.credit * matched_percentage,
+                                'credit': line.currency_id.round(line.debit_cash_basis - line.debit * matched_percentage),
-    def find_module(self, name, path):
+    def find_module(self, name, path=None):
-                    break
+            res.append(page)
-        if not values.get('name', False) or values['name'] == 'New':
+        if not values.get('name', False) or values['name'] == _('New'):
-            self.location_id = warehouses.lot_stock_id
+            warehouse = self.env['stock.warehouse'].search(args, limit=1)
-        while current.location_id and current.usage != 'view':
+        while current.location_id:
-        return [(location.id, location.complete_name) for location in self]
+        ret_list = []
-            order.order_line.update({'date_planned': order.date_planned})
+            #DO NOT FORWARD PORT
-from odoo import api, fields, models, tools, _
+from odoo import api, fields, models, tools, _, SUPERUSER_ID
-                    (ti.type = 'model' AND ti.res_id = irt.res_id AND irt.src = ti.src)
+                    (ti.type = 'model' AND ti.res_id = irt.res_id AND ti.name IN %s AND irt.src = ti.src)
-                       """ % (self._model_table, self._table, find_expr))
+                       """ % (self._model_table, self._table, find_expr),
-                   """ % (self._model_table, self._table, self._model_table, find_expr))
+                   """ % (self._model_table, self._table, self._model_table, find_expr),
-                       (self._model_table, self._table, find_expr))
+                       (self._model_table, self._table, find_expr),
-from openerp import api, tools
+from openerp import api, tools, SUPERUSER_ID
-                    (ti.type = 'model' AND ti.res_id = irt.res_id AND irt.src = ti.src)
+                    (ti.type = 'model' AND ti.res_id = irt.res_id AND ti.name IN %s AND irt.src = ti.src)
-                """ % (self._parent_table, self._table_name, find_expr))
+                """ % (self._parent_table, self._table_name, find_expr),
-              """ % (self._parent_table, self._table_name, self._parent_table, find_expr))
+              """ % (self._parent_table, self._table_name, self._parent_table, find_expr),
-                (self._parent_table, self._table_name, find_expr))
+                (self._parent_table, self._table_name, find_expr),
-            """, ('server', self._cr.dbname, __name__, level, message, "action", action.id, action.name))
+            """, (self._uid, 'server', self._cr.dbname, __name__, level, message, "action", action.id, action.name))
-            return res
+from math import copysign
-        amount = (self.debit or 0.0) - (self.credit or 0.0)
+        amount = (self.credit or 0.0) - (self.debit or 0.0)
-    @api.depends('expense_line_ids')
+    @api.depends('expense_line_ids', 'expense_line_ids.total_amount')
-        values = super(sale_order,self)._website_product_id_change(cr, uid, ids, order_id, product_id, qty=qty, line_id=line_id, context=None)
+        values = super(sale_order, self)._website_product_id_change(
-            for notification in message.notification_ids.filtered(lambda notif: notif.res_partner_id.partner_share):
+            for notification in message.notification_ids.filtered(lambda notif: notif.res_partner_id.partner_share and notif.res_partner_id.active):
-                if user.partner_id.company_id.id != values['company_id']:
+                if user.partner_id.company_id and user.partner_id.company_id.id != values['company_id']:
-    "author" : "General Solutions",
+    "name": "Vietnam - Accounting",
-This module applies to companies based in Vietnamese Accounting Standard (VAS).
+This module applies to companies based in Vietnamese Accounting Standard (VAS)
-**Credits:** General Solutions.
+**Credits:**
-             'data/account_chart_template_data.yml'],
+    "depends": [
-            base_partner_domain, order="grade_id DESC, display_name ASC")  # todo in trunk: order="grade_id DESC, implemented_count DESC", offset=pager['offset'], limit=self._references_per_page
+            base_partner_domain, order="grade_sequence DESC, implemented_count DESC, display_name ASC, id ASC",
-        partners = partners[pager['offset']:pager['offset'] + self._references_per_page]
+    grade_sequence = fields.Integer(related='grade_id.sequence', readonly=True, store=True)
-    date_planned = fields.Datetime(string='Scheduled Date', compute='_compute_date_planned', inverse='_inverse_date_planned', required=True, index=True, oldname='minimum_planned_date')
+    # There is no inverse function on purpose since the date may be different on each line
-                    picking.with_context(reserve_only_ops=True, no_state_change=True).rereserve_quants(move_ids=todo_moves.ids)
+                    picking.with_context(reserve_only_ops=True, no_state_change=True).rereserve_quants(move_ids=picking.move_lines.ids)
-        ctx = dict(eval_context.get('context', {}))
+        ctx = dict(eval_context['env'].context)
-        eval_context['context'] = ctx
+        eval_context['env'].context = ctx
-from odoo import api, fields, models, tools, workflow, _
+from odoo import api, fields, models, tools, _
-                run_self = self.with_context(eval_context['context'])
+                run_self = self.with_context(eval_context['env'].context)
-                    eval_context["context"] = run_self._context
+                    eval_context["env"].context = run_self._context
-            'code': 'obj.write({"comment": "MyComment"})',
+            'code': 'record.write({"comment": "MyComment"})',
-                     "workflow"),
+            'code': ("partner_name = record.name + '_code'\n"
-            'code': 'obj.write({"comment": "MyComment"})',
+            'code': 'record.write({"comment": "MyComment"})',
-            'code': 'obj.write({"code": "ZZ"})',
+            'code': 'record.write({"code": "ZZ"})',
-                             (0, 0, {'col1': self.res_country_code_field.id, 'value': 'obj.name[0:2]', 'type': 'equation'})],
+                             (0, 0, {'col1': self.res_country_name_field.id, 'value': 'record.name', 'type': 'equation'}),
-            'fields_lines': [(5,), (0, 0, {'col1': self.res_country_name_field.id, 'value': 'obj.name', 'type': 'equation'})],
+            'fields_lines': [(5,), (0, 0, {'col1': self.res_country_name_field.id, 'value': 'record.name', 'type': 'equation'})],
-            'write_expression': 'object.country_id',
+            'write_expression': 'record.country_id',
-
+
-                    price_unit = uom_obj._compute_qty_obj(self.uom_id, price_unit, self.product_id.uom_id, round=False)
+                    price_unit = self.product_id.uom_id._compute_price(self.product_id.uom_id.id, price_unit, to_uom_id=self.uom_id.id)
-                price_unit = uom_obj._compute_qty_obj(self.uom_id, price_unit, self.product_id.uom_id, round=False)
+                price_unit = self.product_id.uom_id._compute_price(self.product_id.uom_id.id, price_unit, to_uom_id=self.uom_id.id)
-        return self.product_id.standard_price
+        price = self.product_id.standard_price
-    compress_html = fields.Boolean('Compress HTML')
+    compress_html = fields.Boolean('Compress HTML') # TODO: REMOVE ME IN SAAS-14
-            leads = self.browse(lead_ids)
+                if lead.partner_assigned_id and lead.partner_assigned_id.user_id != lead.user_id:
-                                 "a Python expression, like 'object.list_price > 5000'. A void "
+                                 "a Python expression, like 'record.list_price > 5000'. A void "
-            custom = json.loads(post.pop('custom', False) or '{}')
+            custom = json.loads(post.pop('custom', False) or post.pop('cm', False) or '{}')
-         - step 3: paypal send either VERIFIED or INVALID (single word)
+           by cmd=_notify-validate or _notify-synch for PDT), with same encoding
-        if resp == 'VERIFIED':
+        if pdt_request:
-            _logger.warning('Paypal: answered INVALID on data verification')
+        elif resp == 'INVALID' or pdt_request and resp == 'FAIL':
-            _logger.warning('Paypal: unrecognized paypal answer, received %s instead of VERIFIED or INVALID' % resp.text)
+            _logger.warning('Paypal: unrecognized paypal answer, received %s instead of VERIFIED/SUCCESS or INVALID/FAIL (validation: %s)' % (resp, 'PDT' if pdt_request else 'IPN/DPN'))
-        self.assertEqual(order.picking_ids[0].min_date, out_schedule_date, 'Schedule date of picking should be equal to: Order date + Customer Lead Time - Sales Safety Days.')
+        min_date = fields.Datetime.from_string(order.picking_ids[0].min_date)
-        self.assertEqual(manufacturing_order.date_planned_start, mo_schedule_date, "Schedule date of manufacturing order should be equal to: Schedule date of picking - product's Manufacturing Lead Time - company's Manufacturing Lead Time.")
+        date_planned_start = fields.Datetime.from_string(manufacturing_order.date_planned_start)
-        self.assertEqual(out.min_date, out_schedule_date, 'Schedule date of ship type picking should be equal to: order date + Customer Lead Time - pull rule delay.')
+        self.assertTrue(abs(out_min_date - out_date) <= timedelta(seconds=1), 'Schedule date of ship type picking should be equal to: order date + Customer Lead Time - pull rule delay.')
-        self.assertEqual(pack.min_date, pack_schedule_date, 'Schedule date of pack type picking should be equal to: Schedule date of ship type picking - pull rule delay.')
+        self.assertTrue(abs(pack_min_date - pack_date) <= timedelta(seconds=1), 'Schedule date of pack type picking should be equal to: Schedule date of ship type picking - pull rule delay.')
-        self.assertEqual(pick.min_date, pack_schedule_date, 'Schedule date of pick type picking should be equal to: Schedule date of pack type picking.')
+        pick_min_date = fields.Datetime.from_string(pick.min_date)
-        self.assertEqual(manufacturing_order.date_planned_start, mo_schedule_date, "Schedule date of manufacturing order should be equal to: Schedule date of pack type picking - product's Manufacturing Lead Time.")
+        date_planned_start = fields.Datetime.from_string(manufacturing_order.date_planned_start)
-        self.assertEqual(order.picking_ids[0].min_date, schedule_date, 'Schedule date of picking should be equal to: order date + Customer Lead Time - Sales Safety Days.')
+        min_date = fields.Datetime.from_string(order.picking_ids[0].min_date)
-        self.assertEqual(out.min_date, out_schedule_date, 'Schedule date of ship type picking should be equal to: order date + Customer Lead Time - pull rule delay.')
+        self.assertTrue(abs(out_min_date - out_date) <= timedelta(seconds=1), 'Schedule date of ship type picking should be equal to: order date + Customer Lead Time - pull rule delay.')
-        self.assertEqual(pack.min_date, pack_schedule_date, 'Schedule date of pack type picking should be equal to: Schedule date of ship type picking - pull rule delay.')
+        self.assertTrue(abs(pack_min_date - pack_date) <= timedelta(seconds=1), 'Schedule date of pack type picking should be equal to: Schedule date of ship type picking - pull rule delay.')
-        self.assertEqual(pick.min_date, pick_schedule_date, 'Schedule date of pick type picking should be equal to: Schedule date of pack type picking - pull rule delay.')
+        self.assertTrue(abs(pick_min_date - pick_date) <= timedelta(seconds=1), 'Schedule date of pick type picking should be equal to: Schedule date of pack type picking - pull rule delay.')
-        ('unique_number', 'unique(sanitized_acc_number)', 'Account Number must be unique'),
+        ('unique_number', 'unique(sanitized_acc_number, company_id)', 'Account Number must be unique'),
-            })
+            self.date_assign = fields.Date.context_today(self)
-        except Exception:
+        except Exception as e:
-                _logger.info("bad query: %s", self._obj.query or query)
+                _logger.info("bad query: %s \nERROR: %s", self._obj.query or query, e)
-                line.product_uom_id.id, line.name, partner, False, True, time.strftime('%Y-%m-%d'),
+                line.product_uom_id.id, line.name, partner, False, True, date,
-    _order = "name"
+    _order = "sequence, name"
-    _order = "name"
+    _order = "sequence, name"
-                'body_html': '',
+                'body_html': mailing.body_html,
-            invoice_ids = order.order_line.mapped('invoice_lines').mapped('invoice_id')
+            invoice_ids = order.order_line.mapped('invoice_lines').mapped('invoice_id').filtered(lambda r: r.type in ['out_invoice', 'out_refund'])
-                                  # To return an action, assign: action = {...}""",
+                       default=DEFAULT_PYTHON_CODE,
-            return (False, None, 'Your expression should begin with obj or object.\nAn expression builder is available in the help tab.')
+        if initial not in ['obj', 'object', 'record']:
-        obj = None
+        record = None
-            obj = model.browse(self._context['active_id'])
+            record = model.browse(self._context['active_id'])
-            obj = self._context['onchange_self']
+            record = self._context['onchange_self']
-            'obj': obj,
+            'record': record,
-            template.currency_id = template.company_id.currency_id.id or main_company.currency_id.id
+            template.currency_id = template.company_id.sudo().currency_id.id or main_company.currency_id.id
-                        _('Warning!'),
+                    raise UserError(
-        res = super(Task, self)._rating_get_partner_id()
+    def rating_get_partner_id(self):
-                    ('state', '=', 'sale'),
+                    ('state', 'in', ('sale', 'done')),
-            return Usb(printers[0]['vendor'], printers[0]['product'])
+            print_dev = Usb(printers[0]['vendor'], printers[0]['product'])
-    def __init__(self, idVendor, idProduct, interface=0, in_ep=0x82, out_ep=0x01):
+    def __init__(self, idVendor, idProduct, interface=0, in_ep=None, out_ep=None):
-            'date_planned': datetime.strptime(self.order_id.date_order, DEFAULT_SERVER_DATETIME_FORMAT) + timedelta(days=self.customer_lead),
+            'date_planned': datetime.strptime(self.order_id.confirmation_date, DEFAULT_SERVER_DATETIME_FORMAT) + timedelta(days=self.customer_lead),
-        date_planned = datetime.strptime(self.order_id.date_order, DEFAULT_SERVER_DATETIME_FORMAT)\
+        date_planned = datetime.strptime(self.order_id.confirmation_date, DEFAULT_SERVER_DATETIME_FORMAT)\
-                            flag = quant.package_id and bool(package_obj.search(cr, uid, [('id', 'child_of', [ops.package_id.id])], context=context)) or False
+                            flag = quant.package_id == ops.package_id
-
+        
-        self.assertEqual(total_qty, 0, 'Expecting 0 units lot of lotproduct, but we got %.4f on location stock!' % (total_qty))
+        self.assertEqual(total_qty, 0, 'Expecting 0 units lot of lotproduct, but we got %.4f on location stock!' % (total_qty))
-                order.write({'effective_date': fields.Datetime.to_string(min(dates_list))})
+                order.effective_date = fields.Datetime.to_string(min(dates_list))
-        help="Select an email template. An email will be sent to the customer when the task reach this step.")
+        help="If set and if the project's rating configuration is 'Rating when changing stage', then an email will be sent to the customer when the task reaches this step.")
-        help="Automatically modify the kanban state when the customer reply to the feedback for this stage.\n"
+        help="Automatically modify the kanban state when the customer replies to the feedback for this stage.\n"
-            return process((value[0],))
+            # value is either a pair (id, name), or a tuple of ids
-            # value is a list of record ids or commands
+        elif isinstance(value, (list, tuple)):
-        for fname, fvalue in onchange_res['values'].iteritems():
+        for fname, fvalue in onchange_res['value'].iteritems():
-    department_id = fields.Many2one('hr.department', "Department", related='user_id.employee_ids.department_id', store=True)
+    department_id = fields.Many2one('hr.department', "Department", related='user_id.employee_ids.department_id', store=True, readonly=True)
-    "author" : "General Solutions",
+    "name": "Vietnam - Accounting",
-This module applies to companies based in Vietnamese Accounting Standard (VAS).
+This module applies to companies based in Vietnamese Accounting Standard (VAS)
-**Credits:** General Solutions.
+**Credits:**
-             'data/account_chart_template_data.yml'],
+    "depends": [
-                        with open(module_resource_path, 'r') as f:
+                        with open(module_resource_path, 'rb') as f:
-        <p>For any other question, please contact the Odoo support at <a href='mailto:help@odoo.com'>help@odoo.com</a>
+        <p>For any other question, please contact the Odoo support at <a href='http://www.odoo.com/help'>www.odoo.com/help</a>
-        The PosBox is an hardware adapter that allows you to use 
+        The PosBox is a hardware adapter that allows you to use
-        or <a href='https://www.odoo.com/start?download'>download and install</a> it yourself.
+        or <a href='https://www.odoo.com/page/download'>download and install</a> it yourself.
-        The PosBox software installed on this posbox is <b>version 14</b>,
+        If you need to grant remote debugging access to a developer, you can do it <a href='/remote_connect'>here</a>.
-    def status_http(self):
+    def status_http(self, debug=None, **kwargs):
-from openerp.tools.translate import _
+DRIVER_NAME = 'scale'
-        self.probed_device_paths = []
+        self.protocol = None
-    def set_status(self, status, message = None):
+    def set_status(self, status, message=None):
-            if message != None and message != self.status['messages'][-1]:
+            if message is not None and message != self.status['messages'][-1]:
-                    _logger.error('Scale Error: '+message)
+                    _logger.error('Scale Error: '+ message)
-                    _logger.warning('Disconnected Scale: '+message)
+                    _logger.warning('Disconnected Scale: '+ message)
-                _logger.error('Scale Error: '+message)
+                _logger.error('Scale Error: '+ message)
-        response = ""
+        answer = []
-                response += byte
+            char = connection.read(1) # may return `bytes` or `str`
-                return response
+                answer.append(char)
-            devices = [ device for device in listdir(self.input_dir)]
+        if self.device:
-            if len(devices) > 0:
+                    driver = hw_proxy.rs232_devices.get(device)
-                        _logger.debug('Probing: ' + path)
+                    for protocol in SCALE_PROTOCOLS:
-                            _logger.debug(path + ' is scale')
+                                                   baudrate=protocol.baudrate,
-                            connection.writeTimeout = 0.02
+                            self.protocol = protocol
-            self.set_status('error',str(e))
+                self.set_status('disconnected', 'No supported RS-232 scale found')
-    
+
-                    self.set_status('error',str(e))
+            p = self.protocol
-                    self.device.write('Z')
+                try:
-                    self.set_status('error',str(e))
+                    self.set_status(
-                    self.device.write('T')
+                try:
-                    self.set_status('error',str(e))
+                    self.set_status(
-                    self.device.write('C')
+                p = self.protocol
-                    self.set_status('error',str(e))
+                    self.set_status(
-        self.device   = None
+        self.device = None
-        while True: 
+        while True:
-                time.sleep(0.15)
+                if self.weight != old_weight:
-                    time.sleep(5)
+                    # retry later to support "plug and play"
-    hw_proxy.drivers['scale'] = scale_thread
+    hw_proxy.drivers[DRIVER_NAME] = scale_thread
-            return {'weight': scale_thread.get_weight(), 'unit':'kg', 'info': scale_thread.get_weight_info()}
+            return {'weight': scale_thread.get_weight(),
-        
+DRIVER_NAME = 'fiscal_data_module'
-            return ""
+        with hw_proxy.rs232_lock:
-    hw_proxy.drivers['fiscal_data_module'] = blackbox_thread
+    hw_proxy.drivers[DRIVER_NAME] = blackbox_thread
-        msg = _("Shipment sent to carrier %s for expedition with tracking number %s<br/>Cost: %.2f %s") % (self.carrier_id.name, self.carrier_tracking_ref, self.carrier_price, order_currency.name)
+        msg = _("Shipment sent to carrier %s for shipping with tracking number %s<br/>Cost: %.2f %s") % (self.carrier_id.name, self.carrier_tracking_ref, self.carrier_price, order_currency.name)
-from odoo import http, _
+from odoo import _, exceptions, http
-    def mailing(self, mailing_id, email=None, res_id=None, **post):
+    def mailing(self, mailing_id, email=None, res_id=None, token="", **post):
-                'params': werkzeug.url_encode({'db': self.env.cr.dbname, 'res_id': self.res_id, 'email': email_to})
+                'params': werkzeug.url_encode({
-        message_bodies = opportunities._mail_body(CRM_LEAD_FIELDS_TO_MERGE)
+        message_bodies = opportunities._mail_body(list(CRM_LEAD_FIELDS_TO_MERGE))
-        merged_data = opportunities._merge_data(CRM_LEAD_FIELDS_TO_MERGE)
+        merged_data = opportunities._merge_data(list(CRM_LEAD_FIELDS_TO_MERGE))
-            'class': single_event_dict.get('visibility', 'public'),
+            'privacy': single_event_dict.get('visibility', 'public'),
-            if already_installed:
+            if already_installed or to_install_ids:
-            return product.lst_price
+            return self.order_id.company_id.currency_id.compute(
-        if warehouse.buy_pull_id:
+        if warehouse.buy_pull_id and name:
-            carrier_ids = DeliveryCarrier.sudo().search(
+        carrier_ids = DeliveryCarrier.sudo().search(
-            kanban_state = 'red'
+            kanban_state = 'grey'
-                    kanban_state = 'grey'
+                    kanban_state = 'red'
-                order.order_line.mapped('move_ids').force_assign()
+                moves = moves.filtered(lambda x: x.state not in ('done', 'cancel')).action_confirm()
-                                          'lot_produced_qty': self.qty_producing,})
+        self.move_lot_ids.filtered(
-                    filtered_st_lines.append(line_vals)
+                    if line_vals['amount'] != 0:
-            moves.action_confirm()
+            moves.with_context(skip_check=True).action_confirm()
-        return True
+            backorders |= backorder_picking
-class Board(models.Model):
+class Board(models.AbstractModel):
-        self.env['crm.partner.report.assign'].init()
+        # make sure all tables are present
-    push_ids = fields.One2many('stock.location.path', 'route_id', 'Push Rules', copy=True)
+    pull_ids = fields.One2many('procurement.rule', 'route_id', 'Procurement Rules', copy=True, 
-                sheet.user_id = employee.user_id
+    def onchange_employee_id(self):
-        this = this.with_context(overwrite=this.overwrite)
+        self.ensure_one()
-        this.state = 'done'
+        mods.with_context(overwrite=self.overwrite).update_translations(self.lang)
-            'res_id': this.id,
+            'res_id': self.id,
-        self.assertItemsEqual(result.keys(), ['matches', 'headers', 'fields', 'preview', 'headers_type', 'options', 'debug'])
+        self.assertItemsEqual(result.keys(), ['matches', 'headers', 'fields', 'preview', 'headers_type', 'options', 'advanced_mode', 'debug'])
-        self.assertItemsEqual(result.keys(), ['matches', 'headers', 'fields', 'preview', 'headers_type', 'options', 'debug'])
+        self.assertItemsEqual(result.keys(), ['matches', 'headers', 'fields', 'preview', 'headers_type', 'options', 'advanced_mode', 'debug'])
-        self.assertItemsEqual(result.keys(), ['matches', 'headers', 'fields', 'preview', 'headers_type', 'options', 'debug'])
+        self.assertItemsEqual(result.keys(), ['matches', 'headers', 'fields', 'preview', 'headers_type', 'options','advanced_mode', 'debug'])
-        self.assertItemsEqual(result.keys(), ['matches', 'headers', 'fields', 'preview', 'headers_type', 'options', 'debug'])
+        self.assertItemsEqual(result.keys(), ['matches', 'headers', 'fields', 'preview', 'headers_type', 'options', 'advanced_mode', 'debug'])
-        self.productD = self.ProductObj.create({'name': 'Product D'})
+        self.productA = self.ProductObj.create({'name': 'Product A', 'type': 'product'})
-        self.gB = self.ProductObj.create({'name': 'g-B', 'uom_id': self.uom_gm.id, 'uom_po_id': self.uom_gm.id})
+        self.DozA = self.ProductObj.create({'name': 'Dozon-A', 'type': 'product', 'uom_id': self.uom_dozen.id, 'uom_po_id': self.uom_dozen.id})
-            self.assertEqual(move.state, 'assigned', 'Wrong state of move line.')
+        self.assertEqual(picking_out.move_lines[0].state, 'confirmed', 'Wrong state of move line.')
-        aval_a_qty = self.MoveObj.search([('product_id', '=', self.productA.id), ('picking_id', '=', picking_out.id)], limit=1).availability
+        aval_a_qty = self.MoveObj.search([('product_id', '=', self.productA.id), ('picking_id', '=', picking_out.id)], limit=1).reserved_availability
-        aval_b_qty = self.MoveObj.search([('product_id', '=', self.productB.id), ('picking_id', '=', picking_out.id)], limit=1).availability
+        aval_b_qty = self.MoveObj.search([('product_id', '=', self.productB.id), ('picking_id', '=', picking_out.id)], limit=1).reserved_availability
-        aval_c_qty = self.MoveObj.search([('product_id', '=', self.productC.id), ('picking_id', '=', picking_out.id)], limit=1).availability
+        aval_c_qty = self.MoveObj.search([('product_id', '=', self.productC.id), ('picking_id', '=', picking_out.id)], limit=1).reserved_availability
-        aval_d_qty = self.MoveObj.search([('product_id', '=', self.productD.id), ('picking_id', '=', picking_out.id)], limit=1).availability
+        aval_d_qty = self.MoveObj.search([('product_id', '=', self.productD.id), ('picking_id', '=', picking_out.id)], limit=1).reserved_availability
-        DozA_qty = self.MoveObj.search([('product_id', '=', self.DozA.id), ('picking_id', '=', picking_out.id)], limit=1).availability
+        DozA_qty = self.MoveObj.search([('product_id', '=', self.DozA.id), ('picking_id', '=', picking_out.id)], limit=1).reserved_availability
-        SDozA_qty = self.MoveObj.search([('product_id', '=', self.SDozA.id), ('picking_id', '=', picking_out.id)], limit=1).availability
+        SDozA_qty = self.MoveObj.search([('product_id', '=', self.SDozA.id), ('picking_id', '=', picking_out.id)], limit=1).reserved_availability
-        SDozARound_qty = self.MoveObj.search([('product_id', '=', self.SDozARound.id), ('picking_id', '=', picking_out.id)], limit=1).availability
+        SDozARound_qty = self.MoveObj.search([('product_id', '=', self.SDozARound.id), ('picking_id', '=', picking_out.id)], limit=1).reserved_availability
-        gB_qty = self.MoveObj.search([('product_id', '=', self.gB.id), ('picking_id', '=', picking_out.id)], limit=1).availability
+        gB_qty = self.MoveObj.search([('product_id', '=', self.gB.id), ('picking_id', '=', picking_out.id)], limit=1).reserved_availability
-        kgB_qty = self.MoveObj.search([('product_id', '=', self.kgB.id), ('picking_id', '=', picking_out.id)], limit=1).availability
+        kgB_qty = self.MoveObj.search([('product_id', '=', self.kgB.id), ('picking_id', '=', picking_out.id)], limit=1).reserved_availability
-        self.assertEqual(sum([x.qty for x in quants if x.lot_id.id == lot3.id]), 2.0, 'Wrong sum of quants with lot 3')
+        self.assertEqual(sum([x.qty for x in quants if x.lot_id.id == lot3.id]), 2.0, 'Wrong sum of quants with lot 3')
-                'date': self.asset_start_date or self.invoice_id.date_invoice,
+                'date': self.invoice_id.date_invoice,
-            self.carrier_price = self.carrier_id.price
+            order = self.sale_id
-            'target': action.target,
+            'target': 'current',
-    _order = "priority,name"
+    _order = "priority,name,id"
-        default='normal', required=True, track_visibility='onchange',
+        copy=False, default='normal', required=True, track_visibility='onchange',
-        string='Kanban Blocked Explanation', translate=True,
+        'Red Kanban Label', default='Blocked', translate=True,
-        string='Kanban Valid Explanation', translate=True,
+        'Green Kanban Label', default='Ready for Next Stage', translate=True,
-        string='Kanban Ongoing Explanation', translate=True,
+        'Grey Kanban Label', default='In Progress', translate=True,
-        required=True, copy=False,
+        ('normal', 'Grey'),
-             " * Ready for next stage indicates the task is ready to be pulled to the next stage")
+             " * Grey is the default situation\n"
-                                           * Ready for next stage indicates the issue is ready to be pulled to the next stage""")
+    kanban_state = fields.Selection([
-        'hr_timesheet_sheet',
+        'hr_timesheet',
-        """ prepare the values to render portal layout """
+        """ prepare the values to render portal layout template. This returns the
-            'task_count': task_count,
+    @http.route()
-        return values
+        return response
-        values = super(WebsiteAccount, self)._prepare_portal_layout_values()
+    @http.route()
-            'issue_count': issue_count,
+        response.qcontext.update({
-        return values
+        return response
-    def portal_my_leads(self, page=1, date_begin=None, date_end=None, lead=None, sortby=None, **kw):
+    def portal_my_leads(self, page=1, date_begin=None, date_end=None, sortby=None, **kw):
-        sortings = {
+        searchbar_sortings = {
-        order = sortings.get(sortby, sortings['date'])['order']
+        # default sort by value
-            url_args={'date_begin': date_begin, 'date_end': date_end, 'sortby': sortby, 'lead': lead},
+            url_args={'date_begin': date_begin, 'date_end': date_end, 'sortby': sortby},
-            'pager': pager
+            'pager': pager,
-    def portal_my_opportunities(self, page=1, date_begin=None, date_end=None, opportunity=None, sortby=None, **kw):
+    def portal_my_opportunities(self, page=1, date_begin=None, date_end=None, sortby=None, filterby=None, **kw):
-        filters = {
+        searchbar_filters = {
-        sortings = {
+        searchbar_sortings = {
-        order = sortings.get(sortby, sortings['date'])['order']
+        # default sort by value
-            url_args={'date_begin': date_begin, 'date_end': date_end, 'sortby': sortby, 'opportunity': opportunity},
+            url_args={'date_begin': date_begin, 'date_end': date_end, 'sortby': sortby, 'filterby': filterby},
-            'pager': pager
+            'pager': pager,
-    def portal_my_quotes(self, page=1, date_begin=None, date_end=None, **kw):
+    def portal_my_quotes(self, page=1, date_begin=None, date_end=None, sortby=None, **kw):
-            url_args={'date_begin': date_begin, 'date_end': date_end},
+            url_args={'date_begin': date_begin, 'date_end': date_end, 'sortby': sortby},
-        quotations = SaleOrder.search(domain, limit=self._items_per_page, offset=pager['offset'])
+        quotations = SaleOrder.search(domain, order=sort_order, limit=self._items_per_page, offset=pager['offset'])
-    def portal_my_orders(self, page=1, date_begin=None, date_end=None, **kw):
+    def portal_my_orders(self, page=1, date_begin=None, date_end=None, sortby=None, **kw):
-            url_args={'date_begin': date_begin, 'date_end': date_end},
+            url_args={'date_begin': date_begin, 'date_end': date_end, 'sortby': sortby},
-        orders = SaleOrder.search(domain, limit=self._items_per_page, offset=pager['offset'])
+        orders = SaleOrder.search(domain, order=sort_order, limit=self._items_per_page, offset=pager['offset'])
-    def portal_my_invoices(self, page=1, date_begin=None, date_end=None, **kw):
+    def portal_my_invoices(self, page=1, date_begin=None, date_end=None, sortby=None, **kw):
-            url_args={'date_begin': date_begin, 'date_end': date_end},
+            url_args={'date_begin': date_begin, 'date_end': date_end, 'sortby': sortby},
-        invoices = AccountInvoice.search(domain, limit=self._items_per_page, offset=pager['offset'])
+        invoices = AccountInvoice.search(domain, order=order, limit=self._items_per_page, offset=pager['offset'])
-        sortings = {
+        searchbar_sortings = {
-        order = sortings.get(sortby, sortings['date'])['order']
+        if not sortby:
-            total=values['project_count'],
+            total=project_count,
-            'pager': pager
+            'pager': pager,
-    def my_tasks(self, page=1, date_begin=None, date_end=None, project=None, sortby=None, **kw):
+    def my_tasks(self, page=1, date_begin=None, date_end=None, sortby=None, filterby=None, **kw):
-        sortings = {
+        searchbar_sortings = {
-        project_filters = {
+        searchbar_filters = {
-
+        # extends filterby criteria with project (criteria name is the project id)
-            project_filters.update({
+            searchbar_filters.update({
-        order = sortings.get(sortby, sortings['date'])['order']
+        # default sort by value
-            total=values['task_count'],
+            url_args={'date_begin': date_begin, 'date_end': date_end, 'sortby': sortby, 'filterby': filterby},
-            'pager': pager
+            'pager': pager,
-    def my_issues(self, page=1, date_begin=None, date_end=None, project=None, sortby=None, **kw):
+    def my_issues(self, page=1, date_begin=None, date_end=None, sortby=None, filterby=None, **kw):
-        sortings = {
+        searchbar_sortings = {
-        project_filters = {
+        searchbar_filters = {
-
+        # extends filterby criteria with project (criteria name is the project id)
-            project_filters.update({
+            searchbar_filters.update({
-        order = sortings.get(sortby, sortings['date'])['order']
+        # default sort by value
-            total=values['issue_count'],
+            total=issue_count,
-            'pager': pager
+            'pager': pager,
-                                             and (x.location_id.id == ops.location_id.id) and (x.package_id.id != ops.package_id.id)]
+                                            and (x.location_id.id == ops.location_id.id) and (x.package_id.id == ops.package_id.id)]
-        return request.render('rating.rating_external_page_view')
+        return request.render('rating.rating_external_page_view', {'rating': rating})
-    partner_id = fields.Many2one('res.partner', related='line_ids.partner_id', string="Partner", store=True, readonly=True)
+    partner_id = fields.Many2one('res.partner', compute='_compute_partner_id', string="Partner", store=True, readonly=True)
-        amount = (self.credit or 0.0) - (self.debit or 0.0)
+        amount = (self.debit or 0.0) - (self.credit or 0.0)
-from openerp.tools import float_compare
+from openerp.tools import float_compare, float_is_zero
-                        amount = (amount_to_depr / self.method_number) / total_days * (total_days - days)
+                        if self.method_period % 12 != 0:
-                        amount = (residual_amount * self.method_progress_factor) / total_days * (total_days - days)
+                        if self.method_period % 12 != 0:
-        self.assertEqual(account_asset_asset_office0.method_number, len(account_asset_asset_office0.depreciation_line_ids) - 1)
+        self.assertEqual(account_asset_asset_office0.method_number, len(account_asset_asset_office0.depreciation_line_ids))
-    carrier_price = fields.Float(string="Shipping Cost", readonly=True)
+    carrier_price = fields.Float(string="Shipping Cost")
-            leads = self.opportunity_ids.merge_opportunity()
+            leads = self.with_context(active_test=False).opportunity_ids.merge_opportunity()
-    _order = "statement_id desc, sequence"
+    _order = "statement_id desc, sequence, id desc"
-            journal_id = self.pool['ir.config_parameter'].get_param(cr, SUPERUSER_ID, 'pos.closing.journal_id', default=session.config_id.journal_id.id, context=context)
+            journal_id = self.pool['ir.config_parameter'].get_param(cr, SUPERUSER_ID, 'pos.closing.journal_id_%s' % (company_id), default=session.config_id.journal_id.id, context=context)
-                journal_id = self.pool['ir.config_parameter'].get_param(cr, SUPERUSER_ID, 'pos.closing.journal_id', default=order.sale_journal.id, context=context)
+                journal_id = self.pool['ir.config_parameter'].get_param(cr, SUPERUSER_ID, 'pos.closing.journal_id_%s' % (current_company.id), default=order.sale_journal.id, context=context)
-            'context': dict(self.env.context or {}, search_default_asset_id=self.id, default_asset_id=self.id),
+            'context': dict(search_default_asset_id=self.id, default_asset_id=self.id),
-        if 'new_price' in fields and 'default_new_price' not in res:
+        if 'new_price' in fields and 'new_price' not in res:
-                        filename = safe_eval(report.print_report_name, {'object': obj, 'time': time})
+                        report_name = safe_eval(report.print_report_name, {'object': obj, 'time': time})
-        domain="[('scrap_location', '=', True)]", states={'done': [('readonly', True)]})
+        domain="[('scrap_location', '=', True)]", required=True, states={'done': [('readonly', True)]})
-            'search_default_opportunity_id': self.id if self.type == 'opportunity' else False,
+import calendar
-                    line['tax_amount'] = currency.compute(line['tax_amount'], company_currency)
+            # Force recomputation of tax_amount, since the rate potentially changed between creation
-        tax_sign = (self.tax_amount / self.amount) if self.amount else 1
+        tax_sign = math.copysign(1, (self.tax_amount * self.amount))
-    'name' : 'Website Live Chat',
+    'name' : 'Live Chat',
-    'summary': 'Website Live Chat with Visitors/Customers',
+    'summary': 'Live Chat with Visitors/Customers',
-Website Live Chat Support
+Live Chat Support
-        project = procurement.product_id.project_id
+        project = procurement.product_id.with_context(force_company=procurement.company_id.id).project_id
-                if move_date > self.company_id.period_lock_date and newly_created_move.date > move_date:
+                if move_date > self.company_id.period_lock_date and newly_created_move.date != move_date:
-                    # recorded after the period lock date as the tax statement for this period is
+                    # recorded before the period lock date as the tax statement for this period is
-            'tax_cash_basis_rec_id': self.id
+            'tax_cash_basis_rec_id': self.id,
-                           OR {reference} {operator} {percent})
+                           OR {reference} {operator} {percent}
-                               percent=unaccent('%s'))
+                               percent=unaccent('%s'),
-            where_clause_params += [search_name]*4
+            where_clause_params += [search_name]*5
-    currency_rate = fields.Float(string='Currency Rate', readonly=True, group_operator="avg")
+    currency_rate = fields.Float(string='Currency Rate', readonly=True, group_operator="avg", groups="base.group_multi_currency")
-    residual = fields.Float(string='Total Residual', readonly=True)
+    residual = fields.Float(string='Due Amount', readonly=True)
-                    SUM(pr.volume * (invoice_type.sign*ail.quantity) / u.factor * u2.factor) AS volume
+                    partner.country_id
-        if 'model' in vals:
+        if 'model' in vals and any(rec.model != vals['model'] for rec in self):
-        if 'state' in vals:
+        if 'state' in vals and any(rec.state != vals['state'] for rec in self):
-        if 'transient' in vals:
+        if 'transient' in vals and any(rec.transient != vals['transient'] for rec in self):
-                res[group] += tax.compute_all(line.price_unit, quantity=line.product_uom_qty)['taxes'][0]['amount']
+                res[group] += tax.compute_all(line.price_reduce, quantity=line.product_uom_qty)['taxes'][0]['amount']
-            'name': carrier.description_sale or carrier.name,
+            'name': carrier.name,
-        self.name = product_lang.description_purchase or product_lang.display_name
+        self.name = product_lang.display_name
-        vals['name'] = product.description_sale or product.name
+        name = product.name_get()[0][1]
-        name = product.description_sale or product.display_name
+        name = product.display_name
-            self.diff_income_account.id: {'debit': 0.0, 'credit': 7.3, 'amount_currency': 0, 'currency_id': False},
+            self.diff_income_account.id: {'debit': 0.0, 'credit': 7.3, 'amount_currency': -9.37, 'currency_id': self.currency_usd_id},
-        if 'default_team_id' in self.env.context:
+        team_id = self.env['crm.team'].sudo().search(
-            package.children_quant_ids = res[package.id].ids
+            package.children_quant_ids = self.env['stock.quant'].search([('package_id', 'child_of', package.id)]).ids
-            values = res.get(package.id, {'location_id': False, 'company_id': self.env.user.company_id.id, 'owner_id': False})
+            quants = package.children_quant_ids
-    duration = fields.Integer('Amount', required=True, default=1)
+    duration = fields.Integer('Remind Before', required=True, default=1)
-from odoo import models, fields, api
+from odoo import models, fields, api, _
-    def partner_desinterested(self, comment=False, contacted=False):
+    def partner_desinterested(self, comment=False, contacted=False, spam=False):
-            message = _('<p>I am not interested by this lead. I contacted the lead.</p>')
+            message = '<p>%s</p>' % _('I am not interested by this lead. I contacted the lead.')
-            message = _('<p>I am not interested by this lead. I have not contacted the lead.</p>')
+            message = '<p>%s</p>' % _('I am not interested by this lead. I have not contacted the lead.')
-            'partner_assigned_id': False
+            'partner_assigned_id': False,
-        if link_type not in ['view', 'new']:
+        if link_type not in ['view']:
-            project_actions = [{'url': new_action, 'title': _('New Task')}]
+            project_actions = []
-            project_actions = [{'url': new_action, 'title': _('New Issue')}]
+            project_actions = []
-                'message_id': kwargs.pop('message_id')
+                'message_id': kwargs['message_id']
-            params = dict(base_params)
+            controller = local_kwargs.pop('controller')
-        for pack in pick.pack_operation_ids.filtered(lambda pack: pack.product_id.tracking == 'none'):
+        for pack in pick.pack_operation_ids.filtered(lambda x: x.product_id.tracking == 'none'):
-        picking_obj.action_done(cr, uid, [picking_id], context=context)
+        if not any([(x.product_id.tracking != 'none') for x in pick.pack_operation_ids]):
-                move_obj.action_done(cr, uid, move_list, context=context)
+                active_move_list = [x.id for x in move_obj.browse(cr, uid, move_list, context=context) if x.product_id.tracking == 'none']
-            'name': carrier.name,
+            'name': carrier.description_sale or carrier.name,
-            self.name += '\n' + product_lang.description_purchase
+        self.name = product_lang.description_purchase or product_lang.display_name
-        vals['name'] = name
+        vals['name'] = product.description_sale or product.name
-        name = product.display_name
+        name = product.description_sale or product.display_name
-        for pack in pick.pack_operation_ids:
+        for pack in pick.pack_operation_ids.filtered(lambda pack: pack.product_id.tracking == 'none'):
-    def payment_transaction(self, acquirer_id):
+    def payment_transaction(self, acquirer_id, **kwargs):
-from . import test_onchange_product_id, test_purchase_order, test_create_picking
+import test_onchange_product_id
-    _order = 'sequence'
+    _order = 'sequence, id'
-    @api.onchange('partner_id')
+    @api.onchange('partner_id', 'type')
-    def payment_transaction(self, acquirer_id, tx_type='form', token=None):
+    def payment_transaction(self, acquirer_id, tx_type='form', token=None, **kwargs):
-        order = request.website.sale_get_order()
+
-                                          default=lambda self: self._default_previous_order_ids())
+    previous_order_ids = fields.Many2many('lunch.order.line', compute='_compute_previous_order')
-        self.previous_order_ids = self._default_previous_order_ids()
+    @api.multi
-        if not self.product_uom or (self.product_id.uom_id.category_id.id != self.product_uom.category_id.id):
+        if not self.product_uom or (self.product_id.uom_id.id != self.product_uom.id):
-            quantity=self.product_uom_qty,
+            quantity=vals.get('product_uom_qty') or self.product_uom_qty,
-                dates.append((start_date, {}, bool(location)))
+                formatted_time = self._get_locale_time(start_date, lang_code)
-        days_tracks_count = {}
+        tracks_by_days = {}
-            days_tracks_count[day] = len(tracks)
+            tracks_by_days[day] = tracks
-            'days_nbr': days_tracks_count,
+            'tracks_by_days': tracks_by_days,
-                        amount = (amount_to_depr / asset.method_number) / total_days * (total_days - days)
+                        purchase_date = datetime.strptime(asset.purchase_date, '%Y-%m-%d')
-                        amount = (residual_amount * asset.method_progress_factor) / total_days * (total_days - days)
+                        purchase_date = datetime.strptime(asset.purchase_date, '%Y-%m-%d')
-from openerp.tools import float_compare
+from openerp.tools import float_compare, float_is_zero
-                        amount = (amount_to_depr / self.method_number) / total_days * days
+                        if self.method_period % 12 != 0:
-                        amount = (residual_amount * self.method_progress_factor) / total_days * days
+                        if self.method_period % 12 != 0:
-        self.assertEqual(account_asset_asset_office0.method_number, len(account_asset_asset_office0.depreciation_line_ids) - 1)
+        self.assertEqual(account_asset_asset_office0.method_number, len(account_asset_asset_office0.depreciation_line_ids))
-from odoo import api, fields, models, _
+from odoo import api, fields, models
-    sale_amount_total= fields.Monetary(compute='_compute_sale_amount_total', string="Sum of Orders", currency_field='company_currency')
+    sale_amount_total = fields.Monetary(compute='_compute_sale_amount_total', string="Sum of Orders", currency_field='company_currency')
-            ('date', '>=', date_today.replace(day=1) - relativedelta(months=+1)),
+            ('date_invoice', '>=', date_today.replace(day=1) - relativedelta(months=+1)),
-        invoice_data = self.env['account.invoice'].search_read(account_invoice_domain, ['date', 'amount_untaxed_signed'])
+        invoice_data = self.env['account.invoice'].search_read(account_invoice_domain, ['date_invoice', 'amount_untaxed_signed'])
-                invoice_date = fields.Date.from_string(invoice['date'])
+            if invoice['date_invoice']:
-                procurement.message_post(body=_("Manufacturing Order <em>%s</em> created.") % (production.name))
+import models
-            move = get_parent_move(production.move_finished_ids[0])
+            move = production._get_parent_move(production.move_finished_ids[0])
-                'Access-Control-Allow-Headers': 'Origin, X-Requested-With, Content-Type, Accept'
+                'Access-Control-Allow-Headers': 'Origin, X-Requested-With, Content-Type, Accept, X-Debug-Mode'
-    date = fields.Datetime('Date', default=fields.Datetime.now, required=True)
+    compute_at_date = fields.Selection([
-        }
+        if self.compute_at_date and self.date:
-    
+
-        return dict(action, domain=[('res_id', 'in', self.tasks.ids), ('res_model', '=', 'project.task')])
+        action_domain = safe_eval(action['domain']) if action['domain'] else []
-        return dict(action, domain=[('res_id', 'in', issues.ids), ('res_model', '=', 'project.issue')])
+        action_domain = safe_eval(action['domain']) if action['domain'] else []
-            project.issue_ids._send_issue_rating_mail()
+            self.env['project.issue'].search([('project_id', '=', project.id)])._send_issue_rating_mail()
-                activity_issue = project.issue_ids.rating_get_grades(domain)
+                activity_issue = self.env['project.issue'].search([('project_id', '=', project.id)]).rating_get_grades(domain)
-import test_purchase_lead_time
+from . import test_onchange_product_id, test_purchase_order, test_create_picking
-        self.assertEqual(incomming_shipment2.min_date, incomming_shipment2_schedule_date, 'Schedule date of Internal Type shipment for quality control stock location should be equal to: schedule date of Internal type shipment for input stock location + push rule delay..')
+        liquidity_amt_clause = currency and '%(amount)s' or 'abs(%(amount)s)'
-                " AND ("+field+" = %(amount)s OR (acc.internal_type = 'liquidity' AND "+liquidity_field+" = %(amount)s)) \
+                " AND ("+field+" = %(amount)s OR (acc.internal_type = 'liquidity' AND "+liquidity_field+" = " + liquidity_amt_clause + ")) \
-                    'name': expense.employee_id.name,
+                    'name': aml_name,
-                    'name': expense.name.split('\n')[0][:64],
+                    'name': aml_name,
-            def __init__(self, employee_id, dict):
+            def __init__(self, employee_id, dict, env):
-        rules = BrowsableObject(payslip.employee_id.id, rules_dict)
+        categories = BrowsableObject(payslip.employee_id.id, {}, self.env)
-                                  or self.get_nearest_lang(request.lang)
+                                  or (not is_a_bot and self.get_nearest_lang(request.lang))
-                total_debit += line.debit or 0.0
+                total_credit += line.credit and line.amount_residual or 0.0
-                total_debit += line.debit and line.amount_currency or 0.0
+                line_residual = currency_pool.compute(cr, uid, company_currency, currency_id, abs(line.amount_residual), context=context_multi_currency)
-        return {year: [m for m in months] for year, months in itertools.groupby(groups, lambda g: g['year'])}
+            group['date_begin'] = start
-        group.add_option("--load", dest="server_wide_modules", help="Comma-separated list of server-wide modules. Default is 'web,web_kanban'")
+        group.add_option("--load", dest="server_wide_modules", help="Comma-separated list of server-wide modules.", my_default='web,web_kanban')
-            m.strip() for m in server_wide_modules.split(',')
+            m.strip() for m in self.options['server_wide_modules'].split(',') if m.strip()
-        'setup_full_done': False,       # whether the field has been fully setup
+        '_setup_done': None,            # the field's setup state: None, 'base' or 'full'
-        self.setup_full_done = False
+        self._setup_done = None
-        if self.setup_full_done and not self.related:
+        if self._setup_done and not self.related:
-            self.setup_full_done = False
+            self._setup_done = 'base'
-        if not self.setup_full_done:
+        if self._setup_done != 'full':
-            self.setup_full_done = True
+            self._setup_done = 'full'
-    product_uom_qty = fields.Float('# of Qty', readonly=True)
+    product_uom_qty = fields.Float('Qty Ordered', readonly=True)
-        line_to_create = []
+    def create_tax_cash_basis_entry(self, percentage_before_rec):
-                amount = (line.credit_cash_basis - line.debit_cash_basis) - (line.credit - line.debit) * matched_percentage
+                # create reporting issues. Not sure of the behavior to implement in that case, though.
-                            tax_group[acc] = amount
+                        if not newly_created_move:
-                            total_by_cash_basis_account[key] = amount
+                        self.env['account.move.line'].with_context(check_move_validity=False).create({
-                                'credit': line.credit_cash_basis - line.credit * matched_percentage,
+                            self.env['account.move.line'].with_context(check_move_validity=False).create({
-                                'debit': line.credit_cash_basis - line.credit * matched_percentage,
+                                'tax_ids': [(6, 0, [tax.id])],
-        return line_to_create, move_date
+                                'move_id': newly_created_move.id,
-            move.post()
+    def _create_tax_basis_move(self):
-                value_before_reconciliation[line.move_id.id] = line.move_id.matched_percentage
+        percentage_before_rec = lines._get_matched_percentage()
-        res.create_tax_cash_basis_entry(value_before_reconciliation)
+        # if the reconciliation is a matching on a receivable or payable account, eventually create a tax cash basis entry
-            data['byday'] = str(r._bynweekday[0][1])
+            data['week_list'] = day_list[list(r._bynweekday)[0][0]].upper()
-                'partner_country_id': partner and partner.country_id.id or self._default_partner_country_id(),
+                'partner_country_id': partner and partner.country_id.id or self._get_default_partner_country_id(),
-from odoo import api, fields, models
+from odoo import api, fields, models, tools
-            create or replace view purchase_report as (
+            create view purchase_report as (
-        self.valuation = self.property_valuation if self.property_valuation else self.categ_id.property_valuation
+        self.valuation = self.property_valuation or self.categ_id.property_valuation
-        self.cost_method = self.property_cost_method if self.property_cost_method else self.categ_id.property_cost_method
+        self.cost_method = self.property_cost_method or self.categ_id.property_cost_method
-        return {}
+        # TO REMOVE IN MASTER
-        return {}
+        # TO REMOVE IN MASTER
-            for pack_operation in picking.pack_operation_ids:
+            for pack_operation in (picking or self.picking_id).pack_operation_ids:
-                self.product_uom_qty = self.quantity_done #TODO: could change qty on move_dest_id also (in case of 2-step in/out)
+                if float_compare(self.product_uom_qty, self.quantity_done, precision_rounding=rounding) < 0:
-            quantity_to_split = self.quantity_done - self.product_uom_qty 
+            quantity_to_split = self.quantity_done - self.product_uom_qty
-            extra_move = self.copy(default={'quantity_done': quantity_to_split, 'product_uom_qty': quantity_to_split, 'production_id': self.production_id.id, 
+            extra_move = self.copy(default={'quantity_done': quantity_to_split, 'product_uom_qty': uom_qty_to_split, 'production_id': self.production_id.id, 
-            self.product_uom_qty = self.quantity_done - quantity_to_split
+                self.quantity_done -= quantity_to_split
-            res = super(AccountPartialReconcile, to_unlink).unlink()
+        for rec in self:
-                pair_to_rec.reconcile()
+            if rec.exchange_move_id:
-    @api.constrains('vat', 'country_id', 'commercial_partner_id.country_id')
+    @api.constrains('vat', 'commercial_partner_country_id')
-            picking_id = False
+            return_pick_type = order.picking_type_id.return_picking_type_id or order.picking_type_id
-                picking_id = Picking.create({
+                picking_vals = {
-                order.write({'picking_id': picking_id.id})
+                    'location_id': location_id,
-                Move += Move.create({
+                moves |= Move.create({
-                    'picking_type_id': picking_type.id,
+                    'picking_id': order_picking.id if line.qty >= 0 else return_picking.id,
-                    'location_dest_id': destination_id if line.qty >= 0 else location_id,
+                    'location_dest_id': destination_id if line.qty >= 0 else return_pick_type != picking_type and return_pick_type.default_location_dest_id.id or location_id,
-                Move.action_done()
+
-        return self.env['report'].render('point_of_sale.report_saledetails', data)
+        return self.env['report'].render('point_of_sale.report_saledetails', data)
-        #I create a new PoS order with 2 units of PC1 at 450 EUR (Tax Incl) and 3 units of PCSC349 at 300 EUR. (Tax Excl)
+        # I create a new PoS order with 2 units of PC1 at 450 EUR (Tax Incl) and 3 units of PCSC349 at 300 EUR. (Tax Excl)
-        total_excluded = total_included = base = round(price_unit * quantity, prec)
+
-                ret = tax.children_tax_ids.compute_all(price_unit, currency, quantity, product, partner)
+                children = tax.children_tax_ids.with_context(base_values=(total_excluded, total_included, base))
-                base = ret['base']
+                base = ret['base'] if tax.include_base_amount else base
-                    'ids': automatic_reconciliation_entries.ids
+                    'ids': automatic_reconciliation_entries.mapped('journal_entry_ids').ids
-        id1='mail_channel_id', id2='groups_id', string='Auto Subscription',
+        'res.groups', string='Auto Subscription',
-        'product.attribute.value', id1='prod_id', id2='att_id', string='Attributes', ondelete='restrict')
+        'product.attribute.value', string='Attributes', ondelete='restrict')
-    product_ids = fields.Many2many('product.product', id1='att_id', id2='prod_id', string='Variants', readonly=True)
+    product_ids = fields.Many2many('product.product', string='Variants', readonly=True)
-    value_ids = fields.Many2many('product.attribute.value', id1='line_id', id2='val_id', string='Attribute Values')
+    value_ids = fields.Many2many('product.attribute.value', string='Attribute Values')
-            move_id = pos_order_obj._create_account_move(cr, uid, session.start_at, session.name, session.config_id.journal_id.id, company_id, context=context)
+            # FORWARD-PORT UP TO SAAS-12
-                move_id = self._create_account_move(cr, uid, order.session_id.start_at, order.name, order.sale_journal.id, order.company_id.id, context=context)
+                # FORWARD-PORT UP TO SAAS-12
-            CREATE OR REPLACE VIEW crm_opportunity_report AS (
+            CREATE VIEW crm_opportunity_report AS (
-    'mx': 'MXABC123456T1B',
+    'mx': 'ABC123456T1B',
-    @api.constrains("vat")
+    @api.constrains('vat', 'country_id', 'commercial_partner_id.country_id')
-    def _construct_constraint_msg(self):
+                #if fails, check with country code from country
-                return '\n' + _('The VAT number [%s] for partner [%s] either failed the VIES VAT validation check or did not respect the expected format %s.') % (self.vat, self.name, vat_no)
+        vat_no = _ref_vat.get(country_code) or vat_no
-            track.website_url = '/event/%s/track/%s' % (slug(track.event_id), slug(track))
+            if not isinstance(track.id, models.NewId):
-            (getattr(loglevels, 'LOG_%s' % x), getattr(logging, x)) 
+            (getattr(loglevels, 'LOG_%s' % x), getattr(logging, x))
-        group.add_option("--load", dest="server_wide_modules", help="Comma-separated list of server-wide modules default=web")
+        group.add_option("--load", dest="server_wide_modules", help="Comma-separated list of server-wide modules. Default is 'web,web_kanban'")
-            openerp.conf.server_wide_modules = ['web','web_kanban']
+
-from odoo import models
+from odoo import fields, models
-        )
+        values['medium_id'] = values.get('medium_id') or \
-                'product_name': product.name[:20],
+                'product_name': product.name,
-            [('model', '=', 'mail.channel'), ('res_id', '=', group_id)], ['subject', 'date'],
+            [('model', '=', 'mail.channel'), ('res_id', '=', group_id), ('message_type', '!=', 'notification')],
-            [('model', '=', 'mail.channel'), ('date', '>=', fields.Datetime.to_string(month_date))],
+            [('model', '=', 'mail.channel'), ('date', '>=', fields.Datetime.to_string(month_date)), ('message_type', '!=', 'notification')],
-        states={'draft': [('readonly', False)], 'confirm': [('readonly', False)]})
+        states={'draft': [('readonly', False)], 'confirm': [('readonly', False)]}, track_visibility='onchange')
-        states={'draft': [('readonly', False)], 'confirm': [('readonly', False)]})
+        states={'draft': [('readonly', False)], 'confirm': [('readonly', False)]}, track_visibility='onchange')
-        states={'draft': [('readonly', False)], 'confirm': [('readonly', False)]}, default=_default_employee)
+        states={'draft': [('readonly', False)], 'confirm': [('readonly', False)]}, default=_default_employee, track_visibility='onchange')
-    number_of_days = fields.Float('Number of Days', compute='_compute_number_of_days', store=True)
+    number_of_days = fields.Float('Number of Days', compute='_compute_number_of_days', store=True, track_visibility='onchange')
-            picking_id = False
+            return_pick_type = order.picking_type_id.return_picking_type_id or order.picking_type_id
-            #All qties negative => Create negative
+            # Create the normal use case picking (Stock -> Customer)
-                picking_id = picking_obj.create(cr, uid, {
+                picking_vals = {
-                    'date_done' : order.date_order,
+                    'partner_id': addr.get('delivery', False),
-                self.write(cr, uid, [order.id], {'picking_id': picking_id}, context=context)
+                    'location_id': location_id,
-                move_list.append(move_obj.create(cr, uid, {
+                move_id = move_obj.create(cr, uid, {
-                    'picking_type_id': picking_type.id, 
+                    'picking_id': order_picking_id if line.qty >= 0 else return_picking_id,
-            elif move_list:
+                }, context=context)
-                move = self.env['account.move'].create({
+            journal = expense.sheet_id.bank_journal_id if expense.payment_mode == 'company_account' else expense.sheet_id.journal_id
-                    'name': '/',
+                    'payment_date': expense.date,
-                        'name': expense.name,
+                payment_id = payment.id
-                    expense.sheet_id.paid_expense_sheets()
+
-    @api.depends('move_id', 'asset_id.account_move_ids')
+    @api.depends('move_id')
-            account_id = order.fiscal_position_id.map_account(prop_id)
+            inc_acc = ir_property_obj.get('property_account_income_categ_id', 'product.category')
-    @api.onchange('partner_shipping_id')
+    @api.onchange('partner_shipping_id', 'partner_id')
-            'date': self.sheet_id.accounting_date,
+                acc_date = expense.sheet_id.accounting_date or expense.date
-                    'ref': expense.name,
+                    'date': acc_date,
-        select=True, states={'draft': [('readonly', False)]},
+        index=True, states={'draft': [('readonly', False)]},
-        readonly=True, select=True, states={'draft': [('readonly', False)]},
+        readonly=True, index=True, states={'draft': [('readonly', False)]},
-            })
+        # create an xmlid for the view
-            'res_id': self.view_id,
+            'model': self.view_id._name,
-    model_data_id = fields.Many2one('ir.model.data', compute='_compute_model_data_id', string="Model Data", store=True)
+    model_data_id = fields.Many2one('ir.model.data', string="Model Data",
-            return super(View, self).create(self._compute_defaults(values))
+        return super(View, self).create(self._compute_defaults(values))
-                    sellers = [x for x in product.seller_ids if (x.name.id in partner_ids) and (x.product_id == product)]
+                sellers = [x for x in product.seller_ids if (x.name.id in partner_ids) and (x.product_id == product)]
-            })
+                #create the move that will contain the accounting entries
-                        'ref': expense.employee_id.address_home_id.ref or False,
+                move.post()
-            move.post()
+            tax.base = 0.0
-                        END /60  as total_attendance
+                        SUM(total_attendance) /60 as total_attendance
-                                - (EXTRACT(hour FROM (a.check_in AT TIME ZONE 'UTC' AT TIME ZONE coalesce(p.tz, 'UTC'))) * 60 + EXTRACT(minute FROM (a.check_in AT TIME ZONE 'UTC' AT TIME ZONE coalesce(p.tz, 'UTC'))))) as total_attendance
+                                SUM(DATE_PART('day', (a.check_out AT TIME ZONE 'UTC' AT TIME ZONE coalesce(p.tz, 'UTC'))
-                _logger.warning('Tax Base Amount not computable probably due to a change in an underlying tax (%s).', tax.tax_id.name)
+            if tax.tax_id:
-                tax.base = 0.0
+                _logger.warning('Tax Base Amount not computable probably due to a change in an underlying tax (%s).', tax.tax_id.name)
-        'calendar_id' : fields.many2one("resource.calendar", "Resource's Calendar", required=True),
+        'calendar_id' : fields.many2one("resource.calendar", "Resource's Calendar", required=True, ondelete='cascade'),
-from . import test_sale_mrp_flow
+import test_move_explode
-from . import test_onchange_product_id, test_purchase_order, test_create_picking
+import test_onchange_product_id
-                _logger.warning('Tax Base Amount not computable probably due to a change in an underlying tax (%s).', tax.tax_id.name)
+                tax.base = 0.0
-                _logger.warning('Tax Base Amount not computable probably due to a change in an underlying tax (%s).', tax.tax_id.name)
+            if tax.tax_id:
-            'products': [{
+            'products': sorted([{
-            } for (product, price_unit, discount), qty in products_sold.items()]
+            } for (product, price_unit, discount), qty in products_sold.items()], key=lambda l: l['product_name'])
-            if operation.product_id.tracking != 'none' and not operation.lot_id :
+            if operation.product_id.tracking != 'none' and not operation.lot_id:
-            self.action_repair_done()
+            self.write({'state': 'done'})
-            if not order.invoiced and order.invoice_method == 'after_repair':
+        for repair in self:
-            order.write(vals)
+            repair.write(vals)
-            raise UserError(_("Repair must be invoiced in order to finalize it."))
+            raise UserError(_("Repair must be repaired in order to make the product moves."))
-        help='When a new a Serial Number is issued, this is the number of days before the goods may become dangerous and must not be consumed.')
+        help='Number of days before the goods may become dangerous and must not be consumed. It will be computed on the lot/serial number.')
-        help='When a new a Serial Number is issued, this is the number of days before the goods starts deteriorating, without being dangerous yet.')
+        help='Number of days before the goods starts deteriorating, without being dangerous yet. It will be computed on the lot/serial number.')
-        help='When a new a Serial Number is issued, this is the number of days before the goods should be removed from the stock.')
+        help='Number of days before the goods should be removed from the stock. It will be computed on the lot/serial number.')
-        help='When a new a Serial Number is issued, this is the number of days before an alert should be notified.')
+        help='Number of days before an alert should be raised on the lot/serial number.')
-        res = None
+        res = {}
-        if values['cc_number']:
+        if values.get('cc_number'):
-            values.pop(field_name)
+            values.pop(field_name, None)
-        return super(PaymentToken, self).create(clean_vals)
+                values = {field: values[field] for field in fields_wl}
-        carrier_ids = DeliveryCarrier.sudo().search(
+        user = request.env.user
-            'domain': [('statement_id', 'in', self.ids)],
+            'domain': [('id', 'in', aml.ids)],
-                        END
+                    SUM(ABS(ail.price_subtotal_signed)
-                    journal = expense.bank_journal_id
+                    journal = expense.sheet_id.bank_journal_id
-    currency_rate = fields.Float(string='Currency Rate', readonly=True)
+    currency_rate = fields.Float(string='Currency Rate', readonly=True, group_operator="avg")
-    @api.depends('move_id')
+    @api.depends('move_id', 'asset_id.account_move_ids')
-            """, ('server', self._cr.dbname, __name__, level, message, "action", action.id, action.name))
+            """, (self.env.uid, 'server', self._cr.dbname, __name__, level, message, "action", action.id, action.name))
-                    pay_prop = prop.search(pay_dom + res_dom) or prop.search(pay_dom)
+                    rec_prop = prop.search(rec_dom + res_dom) or prop.search(rec_dom, limit=1)
-        if self.invoice_id.currency_id.id != company_currency:
+        if self.invoice_id.currency_id.id != company_currency.id:
-        'Quantity On Hand', compute='_compute_quantities', search='_search_quantities',
+        'Quantity On Hand', compute='_compute_quantities', search='_search_qty_available',
-        'Forecasted Quantity', compute='_compute_quantities', search='_search_quantities',
+        'Forecasted Quantity', compute='_compute_quantities', search='_search_virtual_available',
-        'Incoming', compute='_compute_quantities', search='_search_quantities',
+        'Incoming', compute='_compute_quantities', search='_search_incoming_qty',
-        'Outgoing', compute='_compute_quantities', search='_search_quantities',
+        'Outgoing', compute='_compute_quantities', search='_search_outgoing_qty',
-        domain = []  # TDE ADDED
+    def _search_qty_available(self, operator, value):
-        invoice.signal_workflow('invoice_open')
+        invoice.action_invoice_open()
-            self.view_id = View.create(self.cr, self.uid, {
+            self.view_id = View.create({
-        self.assertEqual(View.browse(self.cr, self.uid, self.view_id).model_data_id, imd)
+        self.assertEqual(self.view_id.model_data_id, imd)
-        res_ids_to_templates = self.get_email_template_batch(res_ids)
+        res_ids_to_templates = self.get_email_template(res_ids)
-    generate_email_batch = generate_email
+    def render_template_batch(self, template_txt, model, res_ids, post_process=False):
-    #     return self.render_template_batch(cr, uid, template, model, [res_id], context)[res_id]
+    def get_email_template_batch(self, res_ids):
-    #     return self.generate_email_batch(cr, uid, template_id, [res_id], context)[res_id]
+    def generate_email_batch(self, res_ids, fields=None):
-        res = super(stock_warehouse, self)._handle_renaming(cr, uid, ids, name, code, context=context)
+    def _update_name_and_code(self, cr, uid, ids, name, code, context=None):
-        res = super(stock_warehouse, self)._handle_renaming(cr, uid, ids, name, code, context=context)
+    def _update_name_and_code(self, cr, uid, ids, name, code, context=None):
-        res = super(stock_warehouse, self).change_route(cr, uid, ids, context=context)
+    def _update_routes(self, cr, uid, ids, context=None):
-        vals = super(ProcurementOrder, self)._run_move_create()
+    def _get_stock_move_values(self):
-import openerp
+import logging
-    _run_move_create = _get_stock_move_values
+
-    _quant_create = _quant_create_from_move
+
-    move_quants_write = _quant_update_from_move
+
-    _get_inter_wh_route = _get_inter_warehouse_route_values  # compatibility
+
-        return self._get_crossdock_route_values()
+    def _get_crossdock_route(self, route_name):
-    def _get_push_pull_rules(self, active, values, new_route_id):  # compatibility
+    def _get_mto_pull_rule(self, route_values):
-    _check_resupply = _update_reception_delivery_resupply
+
-    change_route = _update_routes
+
-    _handle_renaming = _update_name_and_code
+
-        'Quantity On Hand', compute='_compute_quantities', search='_search_quantities',
+        'Quantity On Hand', compute='_compute_quantities', search='_search_qty_available',
-        'Forecasted Quantity', compute='_compute_quantities', search='_search_quantities',
+        'Forecasted Quantity', compute='_compute_quantities', search='_search_virtual_available',
-        'Incoming', compute='_compute_quantities', search='_search_quantities',
+        'Incoming', compute='_compute_quantities', search='_search_incoming_qty',
-        'Outgoing', compute='_compute_quantities', search='_search_quantities',
+        'Outgoing', compute='_compute_quantities', search='_search_outgoing_qty',
-        domain = []  # TDE ADDED
+    def _search_qty_available(self, operator, value):
-        ], ['employee_id'])
+        ])
-        # get the last ir_model_data record corresponding to self
+        # get the first ir_model_data record corresponding to self
-        for data in self.env['ir.model.data'].search_read(domain, ['res_id']):
+        for data in self.env['ir.model.data'].search_read(domain, ['res_id'], order='id desc'):
-        return super(View, self).create(self._compute_defaults(values))
+
-            'cache': cPickle.dumps(res),
+            'cache': base64.encodestring(cPickle.dumps(res)),
-        return cPickle.loads(self.cache)
+        cache = base64.decodestring(self.cache)
-        result['domain'] = "[('id','in',[" + ','.join(map(str, self.ids)) + "])]"
+        result['domain'] = [('partner_id', 'in', self.ids)]
-                        total += self.pool.get('product.uom')._compute_qty_obj(po_line.product_uom, po_line.product_qty, line.product_uom_id)
+                        total += self.pool.get('product.uom')._compute_qty_obj(
-            elif line.product_uom_id != line.product_id.uom_po_id:
+            if line.product_uom_id != line.product_id.uom_po_id:
-            global undeletable
+            undeletable = self.browse()
-        unlink_if_refcount(item for item in to_unlink if item[0] == 'ir.model.constraint')
+        undeletable += unlink_if_refcount(item for item in to_unlink if item[0] not in ('ir.model', 'ir.model.fields', 'ir.model.constraint'))
-        unlink_if_refcount(item for item in to_unlink if item[0] == 'ir.model.fields')
+        undeletable += unlink_if_refcount(item for item in to_unlink if item[0] == 'ir.model.fields')
-        unlink_if_refcount(item for item in to_unlink if item[0] == 'ir.model')
+        undeletable += unlink_if_refcount(item for item in to_unlink if item[0] == 'ir.model')
-            tax_id.sudo().write({'tag_ids': [(6, 0, [tax_template.tag_ids.ids])]})
+            tax_id.sudo().write({'tag_ids': [(6, 0, tax_template.tag_ids.ids)]})
-                    event_attendees_changes = attendees_create and attendees_create[real_ids[0]]
+                    event_attendees_changes = attendees_create and real_ids and attendees_create[real_ids[0]]
-    base = fields.Monetary(string='Base', compute='_compute_base_amount')
+    base = fields.Monetary(string='Base', compute='_compute_base_amount', store=True)
-            tax.base = base
+            key = self.env['account.tax'].browse(tax.tax_id.id).get_grouping_key({
-            price = company_currency.with_context(date=self.invoice_id.date_invoice).compute(price_unit * self.quantity, self.invoice_id.currency_id.id)
+            price = company_currency.with_context(date=self.invoice_id.date_invoice).compute(price_unit * self.quantity, self.invoice_id.currency_id)
-                'name': usb.util.get_string(printer, 256, printer.iManufacturer) + " " + usb.util.get_string(printer, 256, printer.iProduct)
+                'name': description
-            records.message_subscribe(self.act_followers.ids)
+            followers = self.env['mail.followers'].sudo().search([
-            res[blog_post.id] = blog_post.visits * (0.5 + random.random()) / max(3, age.days)
+            if blog_post.id:  # avoid to rank one post not yet saved and so withtout post_date in case of an onchange.
-                }
+                val = self._prepare_tax_line_vals(line, tax)
-            if all(getattr(value, '_ids', ())):
+            if not (self.relational and not all(value)):
-                if self.prorata and self.category_id.type == 'purchase':
+                if self.prorata:
-        if self.prorata and self.category_id.type == 'purchase':
+        if self.prorata:
-                    break
+                    return True
-            self.phantom_poll(phantom, timeout)
+            result = self.phantom_poll(phantom, timeout)
-                        'ref': expense.employee_id.address_home_id.ref or False
+                        'ref': expense.employee_id.address_home_id.ref or False,
-        return super(account_invoice_line, self)._anglo_saxon_sale_move_lines(cr, uid, i_line, res, context=context)
+
-                    info += ' ' + move.product_uom.name
+            if self.pool.get('res.users').has_group(cr, uid, 'product.group_uom'):
-        if stock_settings.group_stock_tracking_owner:
+        if self.pool.get('res.users').has_group(cr, uid, 'stock.group_tracking_owner'):
-        if stock_settings.group_stock_production_lot:
+        if self.pool.get('res.users').has_group(cr, uid, 'stock.group_production_lot'):
-        if stock_settings.group_stock_tracking_lot:
+        if self.pool.get('res.users').has_group(cr, uid, 'stock.group_tracking_lot'):
-            self.config_file or opt.config or os.environ.get('OPENERP_SERVER') or rcfilepath)
+            self.config_file or opt.config or os.environ.get('ODOO_RC') or os.environ.get('OPENERP_SERVER') or rcfilepath)
-        return record._BaseModel__export_rows([f.split('/') for f in fields])
+        return record._export_rows([f.split('/') for f in fields])
-        return record._BaseModel__export_rows([f.split('/') for f in fields])
+        return record._export_rows([f.split('/') for f in fields])
-    def __export_rows(self, fields):
+    def _export_rows(self, fields):
-                        lines2 = value.__export_rows(fields2)
+                        lines2 = value._export_rows(fields2)
-        return {'datas': self.__export_rows(fields_to_export)}
+        return {'datas': self._export_rows(fields_to_export)}
-            'lines': [(5,), (4, line.id)],
+            'lines': [(6, 0, [line.id])],
-            # simply write to the database, and update cache
+            # Write to database
-            record._cache[self] = value
+            # Update the cache unless value contains a new record
-        result = [(5,)]
+        result = [(6, 0, [])]
-                result.append((4, record.id))
+                result[0][2].append(record.id)
-              :class:`~openerp.fields.One2many`.
+              ``4`` for each ``id`` in ``ids``.
-                    obj.write(cr, user, ids3, {self._fields_id:False}, context=context or {})
+                    inverse_field = obj._fields.get(self._fields_id)
-        depreciation_ids = self.env['account.asset.depreciation.line'].with_context(depreciation_date=date).search([
+        depreciation_ids = self.env['account.asset.depreciation.line'].search([
-        datas.unlink()
+        (datas - undeletable).unlink()
-            returns templates (which can be active or not)
+            returns templates info (which can be active or not)
-            returns templates (which can be active or not)
+    def _customize_template_get_views(self, key, full=False, bundles=False):
-        user_groups = set(user.groups_id)
+        user_groups = set(self.env.user.groups_id)
-        return result
+    @api.model
-                ``bundles=True`` returns also the asset bundles
+        """ Get inherit view's informations of the template ``key``.
-                ``bundles=True`` returns also the asset bundles
+    def _customize_template_get_views(self, key, full=False, bundles=False):
-        return result_filtered
+        views = super(View, self)._customize_template_get_views(key, full=full, bundles=bundles)
-                    date_ok = False
+        current_datetime_pattern = False
-                        datetime_ok = True
+                        dt.strptime(val, pattern)
-                        datetime_ok = False
+                        match = False
-                break
+                if match:
-            return ['date'] if date_ok else ['datetime']
+            return ['date']
-                    for line in data:
+                server_format = DEFAULT_SERVER_DATE_FORMAT if field['type'] == 'date' else DEFAULT_SERVER_DATETIME_FORMAT
-                                raise ValueError(_("Column %s contains incorrect values (value: %s does not match date format" % (name, line[index])))
+                                line[index] = dt.strftime(dt.strptime(ustr(line[index]).encode('utf-8'), user_format), server_format)
-                        email_from, email_to, message_id, compat_mode and ' (compat mode)' or '', model, thread_id, custom_values, self._uid)
+                        'Routing mail from %s to %s with Message-Id %s: direct reply to msg: model: %s, thread_id: %s, custom_values: %s, uid: %s',
-        frog_groups = self.format_and_process(
+        self.assertRaises(
-                          extra='In-Reply-To: <12321321-openerp-%d-mail.channel@neighbor.com>' % frog_groups.id)
+                          extra='In-Reply-To: <12321321-openerp-%d-mail.channel@neighbor.com>' % self.group_public.id)
-        self.assertEqual(len(self.group_public.message_ids[0].child_ids), 0, 'message_process: msg1 should not have children')
+        self.assertEqual(len(self.group_public.message_ids), 1)
-                if diff:
+                if float_is_zero(diff, precision_rounding=product.currency_id.rounding):
-from openerp import tools
+from openerp import api, tools
-        account_reconcile_models = self.env['account.reconcile.model.template'].search([])
+        account_reconcile_models = self.env['account.reconcile.model.template'].search([
-                'invoice_line_tax_ids': [(6, 0, [x.id for x in self.product_id.taxes_id])],
+                'invoice_line_tax_ids': [(6, 0, tax_ids)],
-                    'tax_id': [(6, 0, self.product_id.taxes_id.ids)],
+                    'tax_id': [(6, 0, tax_ids)],
-            }
+            data = self._prepare_invoice_line_from_po_line(line)
-                data['account_id'] = account.id
+            data = self._prepare_invoice_line_from_po_line(line)
-    @http.route(['/my', '/my/home'], type='http', auth="public", website=True)
+    @http.route(['/my', '/my/home'], type='http', auth="user", website=True)
-    @http.route(['/my/home'], type='http', auth="user", website=True)
+    @http.route()
-    @http.route(['/my', '/my/home'], type='http', auth="user", website=True)
+    @http.route()
-                    if (not move.origin_returned_move_id or move.origin_returned_move_id.location_id.id != rule.location_dest_id.id):
+                    if (not move.origin_returned_move_id or move.origin_returned_move_id.location_dest_id.id != rule.location_dest_id.id):
-        domain=[('model', '=', 'project.task')],
+        domain=lambda self: self._default_domain_rating_template_id(),
-                vals['amount_currency'] = account.company_id.currency_id.with_context(ctx).compute(amount, account.currency_id)
+                if self._context.get('skip_full_reconcile_check') == 'amount_currency_excluded':
-            'name': _('Journal Items'),
+            'name': _('Journal Entries'),
-            'res_model': 'account.move.line',
+            'res_model': 'account.move',
-            'domain': [('statement_id', 'in', self.ids)],
+            'domain': [('id', 'in', self.mapped('move_line_ids').mapped('move_id').ids)],
-                     (sum(l.unit_quantity*l.unit_amount)/sum(case when l.unit_quantity=0 or u.factor=0 then 1 else l.unit_quantity * u.factor end))::decimal(16,2) as price_average,
+                     sum(l.unit_amount/cr.rate*l.unit_quantity)::decimal(16,2) as price_total,
-                vals['amount_currency'] = account.company_id.currency_id.with_context(ctx).compute(amount, account.currency_id)
+                if self._context.get('skip_full_reconcile_check') == 'amount_currency_excluded':
-            return reduce(operator.or_, self.all.todo[field])
+            ids = set(rid for recs in self.all.todo[field] for rid in recs.ids)
-        recs_list.append(records)
+        for i, recs in enumerate(recs_list):
-                'invoice_line_tax_ids': [(6, 0, [x.id for x in self.product_id.taxes_id])],
+                'invoice_line_tax_ids': [(6, 0, tax_ids)],
-                    'tax_id': [(6, 0, self.product_id.taxes_id.ids)],
+                    'tax_id': [(6, 0, tax_ids)],
-        for var, dummy, cook in self.pool['utm.mixin'].tracking_fields():
+
-                self.raise_view_error("Can't validate view: %s" % e.message, vid)
+                self.raise_view_error("Can't validate view:\n%s" % (e.message or repr(e)), vid)
-    _inherit = 'sale.order'
+        for invoice in self.filtered(lambda invoice: invoice.partner_id not in invoice.message_partner_ids):
-            res_id=self.id)[self.partner_id.id]
+        for order in self.filtered(lambda order: order.partner_id not in order.message_partner_ids):
-        'portal_sale',
+        'sale',
-        return super(Mail, self)._postprocess_sent_message(mail_sent=mail_sent)
+        'data/email_template_data_invoice.xml',
-        if self.state in ['draft', 'cancel']:
+        if self.state == 'cancel' or (self.state == 'draft' and not self.env.context.get('mark_so_as_sent')):
-
+    'website',
-            if order_field in groupby_fields:
+            if order_field == 'id' or order_field in groupby_fields:
-
+            # list of values combination
-            context = {}
+        context = dict(context or {})
-            context = {}
+        context = dict(context or {})
-            context = {}
+        context = dict(context or {})
-            context = {}
+        context = dict(context or {})
-            context = {}
+        context = dict(context or {})
-            context = dict()
+        context = dict(context or {})
-            context = {}
+        context = dict(context or {})
-        self.unlink()
+        datas.unlink()
-        nbr_active_users = Users.search_count([("login_date", ">=", limit_date_str)])
+        nbr_users = Users.search_count([('active', '=', True)])
-            nbr_active_share_users = Users.search_count([("share", "=", True), ("login_date", ">=", limit_date_str)])
+            nbr_share_users = Users.search_count([("share", "=", True), ('active', '=', True)])
-                'period': 6,
+            if not self.env.user.company_id.currency_id.is_zero(line_amount):
-                    })
+                if not self.env.user.company_id.currency_id.is_zero(line_amount):
-        action = self.pool[model].read(self._cr, self._uid, action_id, context=self._context)
+        action = self.pool[model].read(self._cr, self._uid, [action_id], context=self._context)[0]
-        action = self.pool[model].read(self._cr, self._uid, action_id, context=self._context)
+        action = self.pool[model].read(self._cr, self._uid, [action_id], context=self._context)[0]
-        action = self.pool[model].read(self._cr, self._uid, action_id, context=self.env.context)
+        action = self.pool[model].read(self._cr, self._uid, [action_id], context=self.env.context)[0]
-        def add_sheet(self, name):
+        def add_sheet(self, name, cell_overwrite_ok=False):
-            return super(PatchedWorkbook, self).add_sheet(name)
+            return super(PatchedWorkbook, self).add_sheet(name, cell_overwrite_ok=cell_overwrite_ok)
-            variant = ", ".join([v.name for v in product.attribute_value_ids if v.attribute_id in variable_attributes])
+            variant = product.attribute_value_ids._variant_name(variable_attributes)
-            'unit_amount': price
+            'unit_amount': price,
-        ftime = ts.strftime(format_time)
+        fdate = ts.strftime(format_date).decode('utf-8')
-        self.options["demo"] = not opt.without_demo and self.options['init'] or {}
+        self.options['demo'] = not opt.without_demo and dict(self.options['init']) or {}
-                for one_date in meeting.get_recurrent_date_by_event():
+                for one_date in meeting._get_recurrent_date_by_event():
-                'price_tax': taxes['total_included'] - taxes['total_excluded'],
+                'price_tax': sum(t.get('amount', 0.0) for t in taxes.get('taxes', [])),
-    price_tax = fields.Monetary(compute='_compute_amount', string='Tax', store=True)
+    price_tax = fields.Float(compute='_compute_amount', string='Tax', store=True)
-                'price_tax': taxes['total_included'] - taxes['total_excluded'],
+                'price_tax': sum(t.get('amount', 0.0) for t in taxes.get('taxes', [])),
-    price_tax = fields.Monetary(compute='_compute_amount', string='Taxes', readonly=True, store=True)
+    price_tax = fields.Float(compute='_compute_amount', string='Taxes', readonly=True, store=True)
-    'auto_install': True,
+    'auto_install': False,
-                    domain = self._domain(obj) if callable(self._domain) else self._domain
+                    domain = (self._domain(original_obj)
-    app.config.html_translator_class = 'odoo.translator.BootstrapTranslator'
+    app.config.html_translator_class = 'odoo_ext.translator.BootstrapTranslator'
-    'odoo',
+    'odoo_ext',
-html_theme = 'odoo'
+html_theme = 'odoo_ext'
-    
+
-        'commercial_partner_id': fields.function(_commercial_partner_id, type='many2one', relation='res.partner', string='Commercial Entity', store=_commercial_partner_store_triggers)
+        'commercial_partner_id': fields.function(_commercial_partner_id, type='many2one', relation='res.partner', string='Commercial Entity', store=_commercial_partner_store_triggers, index=True)
-            del vals['analytic_account_id']
+        if 'analytic_account_id' in first_line_dict:
-        if self.pool.ready:
+        if self.pool.ready and not context.get('import_file', False):
-            cr, uid, import_fields, data, context=context)
+            cr, uid, import_fields, data, context=dict(context, import_file=True))
-            'location_id': self.partner_id.property_stock_supplier.id
+            'location_id': self.partner_id.property_stock_supplier.id,
-                        ('res_id', 'in', similar_res_ids),
+                        ('res_id', 'in', similar_res_ids.ids),
-            if left_model._parent_store and (not left_model.pool._init):
+            if left_model._parent_store and (not left_model.pool._init) and (not context.get('defer_parent_store_computation')):
-            if left_model._parent_store and (not left_model.pool._init):
+            if context is None:
-                dom = HIERARCHY_FUNCS[operator](left, ids2, model)
+                dom = HIERARCHY_FUNCS[operator](left, ids2, model, context=context)
-                    dom = HIERARCHY_FUNCS[operator](left, ids2, comodel, prefix=column._obj)
+                    dom = HIERARCHY_FUNCS[operator](left, ids2, comodel, prefix=column._obj, context=context)
-                    dom = HIERARCHY_FUNCS[operator]('id', ids2, model, parent=left)
+                    dom = HIERARCHY_FUNCS[operator]('id', ids2, model, parent=left, context=context)
-                    dom = HIERARCHY_FUNCS[operator]('id', ids2, comodel)
+                    dom = HIERARCHY_FUNCS[operator]('id', ids2, comodel, context=context)
-                        dom = HIERARCHY_FUNCS[operator](left, ids2, comodel, prefix=column._obj)
+                        dom = HIERARCHY_FUNCS[operator](left, ids2, comodel, prefix=column._obj, context=context)
-                        dom = HIERARCHY_FUNCS[operator]('id', ids2, model, parent=left)
+                        dom = HIERARCHY_FUNCS[operator]('id', ids2, model, parent=left, context=context)
-        unique_templates = [template.id for template in templates if template.product_variant_count == 1]
+        unique_templates = [template.id for template in templates if len(template.product_variant_ids) == 1]
-        if template.product_variant_count == 1:
+        if len(template.product_variant_ids) == 1:
-    with docker('odoo-%s-src-nightly-tests' % version, o.build_dir, o.pub) as wheezy:
+    with docker('odoo-%s-src-nightly-tests' % docker_version, o.build_dir, o.pub) as wheezy:
-    with docker('odoo-%s-debian-nightly-tests' % version, o.build_dir, o.pub) as wheezy:
+    with docker('odoo-%s-debian-nightly-tests' % docker_version, o.build_dir, o.pub) as wheezy:
-    with docker('odoo-%s-fedora-nightly-tests' % version, o.build_dir, o.pub) as fedora24:
+    with docker('odoo-%s-fedora-nightly-tests' % docker_version, o.build_dir, o.pub) as fedora24:
-                values['acquirers'] = list(request.env['payment.acquirer'].sudo(user=request.uid).search([('website_published', '=', True), ('company_id', '=', Order.company_id.id)]))
+            values['acquirers'] = list(request.env['payment.acquirer'].sudo().search([('website_published', '=', True), ('company_id', '=', Order.company_id.id)]))
-version_info = (10, 0, 0, RELEASE_CANDIDATE, 1, 'c')
+version_info = (10, 0, 0, FINAL, 0, '')
-        subprocess.call(["docker", "build", "-t", "odoo-%s-src-nightly-tests" % version, "."],
+        subprocess.call(["docker", "build", "-t", "odoo-%s-src-nightly-tests" % docker_version, "."],
-        subprocess.call(["docker", "build", "-t", "odoo-%s-debian-nightly-tests" % version, "."],
+        subprocess.call(["docker", "build", "-t", "odoo-%s-debian-nightly-tests" % docker_version, "."],
-        subprocess.call(["docker", "build", "-t", "odoo-%s-fedora-nightly-tests" % version, "."],
+        subprocess.call(["docker", "build", "-t", "odoo-%s-fedora-nightly-tests" % docker_version, "."],
-    _order = "sequence"
+    _order = "sequence, id"
-                raise AccessError(_("Invalid 'group by' parameter"))
+        groupby_fields = set([groupby] if isinstance(groupby, basestring) else groupby)
-    _order = "accounting_date desc"
+    _order = "accounting_date desc, id desc"
-                except ValueError, NameError:
+                except (ValueError, NameError):
-        except NameError:
+        except (ValueError, NameError):
-from safe_eval import safe_eval as eval
+from safe_eval import safe_eval as s_eval
-            q = unsafe_eval(f_search, idref2)
+            q = safe_eval(f_search, idref2)
-                return unsafe_eval(a_eval, idref2)
+                return safe_eval(a_eval, idref2)
-            args = unsafe_eval(a_eval, idref)
+            args = safe_eval(a_eval, idref)
-                    ctx_res = unsafe_eval(ctx, eval_dict)
+                    ctx_res = safe_eval(ctx, eval_dict)
-                except NameError:
+                except ValueError, NameError:
-                ids = self.pool[d_model].search(cr, self.uid, unsafe_eval(d_search, idref))
+                ids = self.pool[d_model].search(cr, self.uid, safe_eval(d_search, idref))
-            res['auto'] = eval(rec.get('auto','False'))
+            res['auto'] = safe_eval(rec.get('auto','False'))
-            res['header'] = eval(rec.get('header','False'))
+            res['header'] = safe_eval(rec.get('header','False'))
-        res['multi'] = rec.get('multi') and eval(rec.get('multi','False'))
+        res['multi'] = rec.get('multi') and safe_eval(rec.get('multi','False'))
-        if not rec.get('menu') or eval(rec.get('menu','False')):
+        if not rec.get('menu') or safe_eval(rec.get('menu','False')):
-        elif self.mode=='update' and eval(rec.get('menu','False'))==False:
+        elif self.mode=='update' and safe_eval(rec.get('menu','False'))==False:
-            domain = unsafe_eval(domain, eval_context)
+            domain = safe_eval(domain, eval_context)
-            res['multi'] = eval(rec.get('multi', 'False'))
+            res['multi'] = safe_eval(rec.get('multi', 'False'))
-            q = unsafe_eval(rec_src, eval_dict)
+            q = safe_eval(rec_src, eval_dict)
-                expression_value = unsafe_eval(f_expr, globals_dict)
+                expression_value = safe_eval(f_expr, globals_dict)
-            rec_context = unsafe_eval(rec_context)
+            rec_context = safe_eval(rec_context)
-                q = unsafe_eval(f_search, self.idref)
+                q = safe_eval(f_search, self.idref)
-        convert_action = self._notification_link_helper(cr, uid, ids, 'method', context=context, method='convert_opportunity', partner_id=lead.partner_id.id)
+        won_action = self._notification_link_helper(cr, uid, ids, 'controller', controller='/lead/case_mark_won', context=context)
-        ref_action = '/mail/workflow?%s' % url_encode({'model': self._name, 'res_id': ids[0], 'signal': 'refuse'})
+        app_action = self._notification_link_helper(cr, uid, ids, 'controller', controller='/hr_holidays/validate', context=context)
-    def _redirect_to_messaging(self):
+    @classmethod
-        return werkzeug.utils.redirect(url)
+        return self._redirect_to_record(model, res_id)
-        return werkzeug.utils.redirect('/mail/view?%s' % url_encode({'model': model, 'res_id': res_id}))
+    @http.route('/mail/follow', type='http', auth='user', methods=['GET'])
-        return werkzeug.utils.redirect('/mail/view?%s' % url_encode({'model': model, 'res_id': res_id}))
+    @http.route('/mail/unfollow', type='http', auth='user', methods=['GET'])
-    def mail_action_new(self, model, res_id, **kwargs):
+    def mail_action_new(self, model, res_id, action_id):
-            params['action'] = kwargs['action_id']
+        if action_id:
-        return werkzeug.utils.redirect('/mail/view?%s' % url_encode({'model': model, 'res_id': res_id}))
+    @http.route('/mail/assign', type='http', auth='user', methods=['GET'])
-                'res_id': self.ids[0],
+                'model': kwargs.get('model', self._name),
-            link = '/mail/method?%s' % url_encode(params)
+            base_link = '/mail/%s' % link_type
-            link = '/mail/new?%s' % url_encode(params)
+            params = dict(base_params, action_id=kwargs.get('action_id', ''))
-                'button_unfollow': {'url': '/mail/unfollow?%s' % url_encode({'model': message.model, 'res_id': message.res_id}), 'title': _('Unfollow')},
+                'button_follow': {'url': self._notification_link_helper('follow', model=message.model, res_id=message.res_id), 'title': _('Follow')},
-    value_amount = fields.Float(string='Value', digits=dp.get_precision('Payment Term'), help="For percent enter a ratio between 0-100.")
+    value_amount = fields.Float(string='Value', digits=dp.get_precision('Payment Terms'), help="For percent enter a ratio between 0-100.")
-from safe_eval import safe_eval as eval
+from safe_eval import safe_eval as s_eval
-            q = unsafe_eval(f_search, idref2)
+            q = safe_eval(f_search, idref2)
-                return unsafe_eval(a_eval, idref2)
+                return safe_eval(a_eval, idref2)
-            args = unsafe_eval(a_eval, idref)
+            args = safe_eval(a_eval, idref)
-                    ctx_res = unsafe_eval(ctx, eval_dict)
+                    ctx_res = safe_eval(ctx, eval_dict)
-                except NameError:
+                except ValueError, NameError:
-                ids = self.pool[d_model].search(cr, self.uid, unsafe_eval(d_search, idref))
+                ids = self.pool[d_model].search(cr, self.uid, safe_eval(d_search, idref))
-            res['auto'] = eval(rec.get('auto','False'))
+            res['auto'] = safe_eval(rec.get('auto','False'))
-            res['header'] = eval(rec.get('header','False'))
+            res['header'] = safe_eval(rec.get('header','False'))
-        res['multi'] = rec.get('multi') and eval(rec.get('multi','False'))
+        res['multi'] = rec.get('multi') and safe_eval(rec.get('multi','False'))
-        if not rec.get('menu') or eval(rec.get('menu','False')):
+        if not rec.get('menu') or safe_eval(rec.get('menu','False')):
-        elif self.mode=='update' and eval(rec.get('menu','False'))==False:
+        elif self.mode=='update' and safe_eval(rec.get('menu','False'))==False:
-            domain = unsafe_eval(domain, eval_context)
+            domain = safe_eval(domain, eval_context)
-            res['multi'] = eval(rec.get('multi', 'False'))
+            res['multi'] = safe_eval(rec.get('multi', 'False'))
-            q = unsafe_eval(rec_src, eval_dict)
+            q = safe_eval(rec_src, eval_dict)
-                expression_value = unsafe_eval(f_expr, globals_dict)
+                expression_value = safe_eval(f_expr, globals_dict)
-            rec_context = unsafe_eval(rec_context)
+            rec_context = safe_eval(rec_context)
-                q = unsafe_eval(f_search, self.idref)
+                q = safe_eval(f_search, self.idref)
-        manual_attendance_group = self.env['res.groups'].search([('name', '=', 'Manual Attendance')])
+        manual_attendance_group = self.env.ref('hr.group_hr_attendance')
-        manual_attendance_group = self.env['res.groups'].search([('name', '=', 'Manual Attendances')])
+        manual_attendance_group = self.env['res.groups'].search([('name', '=', 'Manual Attendance')])
-    pin = fields.Char(string="PIN", default=_default_random_pin, help="PIN used for Check In/Out in Attendance.", copy=False)
+    pin = fields.Char(string="PIN", default=_default_random_pin, help="PIN used to Check In/Out in Kiosk Mode (if enabled in Configuration).", copy=False)
-                                       help='The employee will have access to the "My Attendances" menu to perform his check in and out from his session')
+                                       help='The employee will have access to the "My Attendances" menu to check in and out from his session')
-        """ Receive a barcode scanned from the main menu and change the attendances of corresponding employee.
+        """ Receive a barcode scanned from the Kiosk Mode and change the attendances of corresponding employee.
-            next_action defines which menu the check in/out message should return to.
+            next_action defines which menu the check in/out message should return to. ("My Attendances" or "Kiosk Mode")
-        if action == 'check_in':
+        if self.attendance_state != 'checked_in':
-        return employee and employee.attendance_action('hr_attendance.hr_attendance_action_main_menu') or \
+        return employee and employee.attendance_action('hr_attendance.hr_attendance_action_kiosk_mode') or \
-        action_message = self.env.ref('hr_attendance.hr_attendance_action_message').read()[0]
+        action_message = self.env.ref('hr_attendance.hr_attendance_action_greeting_message').read()[0]
-                path = modules.get_module_icon(module.name)
+                path = modules.module.get_module_icon(module.name)
-                    price_uom = self.env['product.uom']._compute_qty(bom_line.product_id.uom_id.id, bom_line.product_id.standard_price, bom_line.product_uom_id.id)
+                    price_uom = bom_line.product_uom_id._compute_quantity(bom_line.product_id.standard_price, bom_line.product_uom_id)
-            factor = self.env['product.uom']._compute_qty(production.product_uom_id.id, production.product_qty - production.qty_produced, production.bom_id.product_uom_id.id) / production.bom_id.product_qty
+            factor = production.product_uom_id._compute_quantity(production.product_qty - production.qty_produced, production.bom_id.product_uom_id) / production.bom_id.product_qty
-                for operation in bom.routing.operation_ids:
+                for operation in bom.routing_id.operation_ids:
-            move = prod.move_finished_ids.filtered(lambda x: x.sub_product_id == sub_product_line and x.state not in ('done', 'cancel'))
+            move = prod.move_finished_ids.filtered(lambda x: x.subproduct_id == sub_product_line and x.state not in ('done', 'cancel'))
-                product_uom_factor = UoM._compute_qty_obj(prod.product_uom_id, prod.product_qty - prod.qty_produced, prod.bom_id.product_uom_id)
+                product_uom_factor = prod.product_uom_id._compute_quantity(prod.product_qty - prod.qty_produced, prod.bom_id.product_uom_id)
-
+import math
-
+                
-            self.bom_id = bom.id
+            if bom.type == 'normal':
-version_info = (10, 0, 0, RELEASE_CANDIDATE, 1, 'c')
+version_info = (11, 0, 0, ALPHA, 1, 'c')
-                                                 (1, 'Employees must enter their PIN to check in manually in the "Company Screen".')],
+    group_attendance_use_pin = fields.Selection([(0, 'Employees do not need to enter their PIN to check in manually in the "Kiosk Mode".'),
-        local_parts = [e.split('@')[0] for e in tools.email_split(rcpt_tos)]
+        local_parts = [e.split('@')[0].lower() for e in tools.email_split(rcpt_tos)]
-            if full:
+            if full or (view.customize_show and view.inherit_id.id != view_theme_id):
-    def customize_template_get(self, key, full=True, bundles=False):
+    def customize_template_get(self, key, full=False, bundles=False):
-    name = fields.Char(string='Task Title', track_visibility='onchange', required=True, index=True)
+    name = fields.Char(string='Task Title', track_visibility='always', required=True, index=True)
-        index=True, track_visibility='onchange')
+        index=True, track_visibility='always')
-        changes = set()
+        changes = set()  # contains always and onchange tracked fields that changed
-        self.assertEqual(set(last_msg.tracking_value_ids.mapped('new_value_char')), set([group_system.name_get()[0][1], 'Everyone']))
+        self.assertEqual(len(last_msg.tracking_value_ids), 3)
-            inv.invoice_line_ids.asset_create()
+            context = dict(self.env.context)
-            response['session_id'] = self.session_id
+            response['session_id'] = self.session.sid
-                lines_rec = cr.dictfetchall()
+                move_ids = tuple(abs(line_id) for line_id in line_ids)
-        return super(MailComposeMessage, self.with_context(mail_post_autofollow=True)).send_mail(auto_commit=auto_commit)
+            self = self.with_context(mail_post_autofollow=True)
-version_info = (9, 'saas~13', 0, FINAL, 0, 'c')
+version_info = (10, 0, 0, RELEASE_CANDIDATE, 1, 'c')
-            (getattr(loglevels, 'LOG_%s' % x), getattr(logging, x)) 
+            (getattr(loglevels, 'LOG_%s' % x), getattr(logging, x))
-        self.options['root_path'] = os.path.abspath(os.path.expanduser(os.path.expandvars(os.path.dirname(odoo.__file__))))
+        self.options['root_path'] = os.path.abspath(os.path.expanduser(os.path.expandvars(os.path.join(os.path.dirname(__file__), '..'))))
-if sys.modules.get("gevent") is not None:
+if len(sys.argv) > 1 and sys.argv[1] == 'gevent':
-        popen = subprocess.Popen([sys.executable] + nargs)
+        cmd = [sys.executable, sys.argv[0], 'gevent'] + nargs[1:]
-        odoo.cli.main()
+        sys.exit('Unknow command. Command available: %r' % (cmds.keys(),))
-    _logger.info("OpenERP version %s", __version__)
+    _logger.info("Odoo version %s", __version__)
-                          help="save configuration to ~/.openerp_serverrc")
+                          help="save configuration to ~/.odoorc (or to ~/.openerp_serverrc if it exists)")
-            rcfilepath = os.path.expanduser('~/.openerp_serverrc')
+            rcfilepath = os.path.expanduser('~/.odoorc')
-            rcfilepath = os.path.join(os.path.abspath(os.path.dirname(sys.argv[0])), 'openerp-server.conf')
+            rcfilepath = os.path.join(os.path.abspath(os.path.dirname(sys.argv[0])), 'odoo.conf')
-        wheezy.system('su odoo -s /bin/bash -c "odoo -c /etc/odoo/openerp-server.conf -d mycompany &"')
+        wheezy.system('su odoo -s /bin/bash -c "odoo -c /etc/odoo/odoo.conf -d mycompany -i base --stop-after-init"')
-        fedora24.system('su odoo -s /bin/bash -c "odoo -c /etc/odoo/openerp-server.conf -d mycompany &"')
+        fedora24.system('su odoo -s /bin/bash -c "odoo -c /etc/odoo/odoo.conf -d mycompany -i base --stop-after-init"')
-        subprocess.call(["cp", "package.dfcentos", os.path.join(o.build_dir, "docker_centos", "Dockerfile")],
+        subprocess.call(["mkdir", "docker_fedora"], cwd=o.build_dir)
-                        cwd=os.path.join(o.build_dir, "docker_centos"))
+        subprocess.call(["docker", "build", "-t", "odoo-%s-fedora-nightly-tests" % version, "."],
-        centos7.release = '*.noarch.rpm'
+    with docker('odoo-%s-fedora-nightly-tests' % version, o.build_dir, o.pub) as fedora24:
-        centos7.system('su postgres -c "createdb mycompany"')
+        fedora24.system('su postgres -c "/usr/bin/pg_ctl -D /var/lib/postgres/data start"')
-        centos7.system('su odoo -s /bin/bash -c "odoo -c /etc/odoo/openerp-server.conf -d mycompany &"')
+        fedora24.system('dnf install -d 0 -e 0 /opt/release/%s -y' % fedora24.release)
-                {'script': 'openerp-server', 'icon_resources': [
+                {'script': 'odoo-bin', 'icon_resources': [
-    scripts=['openerp-server'],
+    scripts=['setup/odoo'],
-        self.ssh('/cygdrive/c/"Program Files"/"Odoo %s"/server/openerp-server.exe -d mycompany -i base --stop-after-init' % setupversion)
+        self.ssh('/cygdrive/c/"Program Files"/"Odoo %s"/server/odoo-bin.exe -d mycompany -i base --stop-after-init' % setupversion)
-        wheezy.system('su odoo -s /bin/bash -c "odoo.py --addons-path=/usr/local/lib/python2.7/dist-packages/odoo/addons -d mycompany &"')
+        wheezy.system('su odoo -s /bin/bash -c "odoo --addons-path=/usr/local/lib/python2.7/dist-packages/odoo/addons -d mycompany -i base --stop-after-init"')
-        wheezy.system('su odoo -s /bin/bash -c "odoo.py -c /etc/odoo/openerp-server.conf -d mycompany &"')
+        wheezy.system('su odoo -s /bin/bash -c "odoo -c /etc/odoo/openerp-server.conf -d mycompany -i base --stop-after-init"')
-        centos7.system('su odoo -s /bin/bash -c "openerp-server -c /etc/odoo/openerp-server.conf -d mycompany &"')
+        centos7.system('su odoo -s /bin/bash -c "odoo -c /etc/odoo/openerp-server.conf -d mycompany -i base --stop-after-init"')
-# wget -O- https://raw.githubusercontent.com/odoo/odoo/9.0/odoo.py | python
+# wget -O- https://raw.githubusercontent.com/odoo/odoo/10.0/setup/setup_dev.py | python
-        server_path = join(server_dir, 'server', 'openerp-server.exe')
+        server_path = join(server_dir, 'server', 'odoo-bin.exe')
-                print 'No environment set, use `odoo.py shell -d dbname` to get one.'
+                print 'No environment set, use `%s shell -d dbname` to get one.' % sys.argv[0]
-    if for some odd reason people use :option`odoo.py --save`` all the time.
+    if for some odd reason people use :option`--save`` all the time.
-    scripts=['openerp-server', 'odoo.py'],
+    scripts=['openerp-server'],
-            f.write("VERSION=%s\n" % self.o.version_full)
+            f.write("VERSION=%s\n" % version)
-    o.work = join(o.build_dir, 'openerp-%s' % o.version_full)
+    o.work = join(o.build_dir, 'openerp-%s' % version)
-        self.ssh('net start odoo-server-%s' % version)
+        self.ssh('net start %s' % nt_service_name)
-lib_name = 'openerp'
+execfile(join(dirname(__file__), 'odoo', 'release.py'))  # Load release variables
-    for root, dirnames, filenames in os.walk('openerp'):
+    for root, dirnames, filenames in os.walk('odoo'):
-                        'openerp',
+                        'odoo',
-    package_dir={'%s' % lib_name: 'openerp'},
+    package_dir={'%s' % lib_name: 'odoo'},
-execfile(join(dirname(__file__), '..', 'openerp', 'release.py'))
+execfile(join(dirname(__file__), '..', 'odoo', 'release.py'))
-                shutil.move(addon_path, join(o.build_dir, 'openerp/addons'))
+                shutil.move(addon_path, join(o.build_dir, 'odoo/addons'))
-        # Thrown when the add-on is already in openerp/addons (if _prepare_build_dir
+        # Thrown when the add-on is already in odoo/addons (if _prepare_build_dir
-        wheezy.system('su odoo -s /bin/bash -c "odoo.py --addons-path=/usr/local/lib/python2.7/dist-packages/openerp/addons -d mycompany &"')
+        wheezy.system('su odoo -s /bin/bash -c "odoo.py --addons-path=/usr/local/lib/python2.7/dist-packages/odoo/addons -d mycompany -i base --stop-after-init"')
-    o.work_addons = join(o.work, 'openerp', 'addons')
+    o.work_addons = join(o.work, 'odoo', 'addons')
-execfile(join(dirname(__file__), '..', 'server', 'openerp', 'release.py'))
+execfile(join(dirname(__file__), '..', 'server', 'odoo', 'release.py'))
-execfile(os.path.join(os.path.dirname(__file__), '..', '..', 'openerp', 'release.py'))
+execfile(os.path.join(os.path.dirname(__file__), '..', '..', 'odoo', 'release.py'))
-
+        order.onchange_partner_shipping_id()
-                    user_portal = self.sudo().with_context(company_id=company_id)._create_user()
+                    user_portal = wizard_user.sudo().with_context(company_id=company_id)._create_user()
-            self.fiscal_position_id = fiscal_position
+        self.fiscal_position_id = self.env['account.fiscal.position'].get_fiscal_position(self.partner_id.id, self.partner_shipping_id.id)
-
+            self.filtered(lambda r: r.state == 'draft').post()
-            fiscal_position = p.property_account_position_id.id
+            addr = self.partner_id.address_get(['delivery'])
-            'journal_id': self.sale_journal.id,
+            'journal_id': self.session_id.config_id.invoice_journal_id.id,
-            if not jid:
+            default_journals = pos_config.with_context(ctx).default_get(['journal_id', 'invoice_journal_id'])
-            pos_config.with_context(ctx).sudo().write({'journal_id': jid})
+            pos_config.with_context(ctx).sudo().write({
-        main_pos_config.write({'journal_ids': [(0, 0, {'name': 'Cash Journal - Test',
+        main_pos_config.write({
-                        'account_analytic_id': False,
+                        'account_analytic_id': i_line.account_analytic_id.id,
-                        'account_analytic_id': False,
+                        'account_analytic_id': i_line.account_analytic_id.id,
-            self.env['ir.property'].set_multi(
+            self.env['ir.property'].sudo().set_multi(
-    ], type='http', auth="public", website=True)
+    @http.route("/quote/<int:order_id>", type='http', auth="user", website=True)
-from odoo import http
+from odoo import http, _
-                        'account_analytic_id': False,
+                        'account_analytic_id': i_line.account_analytic_id.id,
-                        'account_analytic_id': False,
+                        'account_analytic_id': i_line.account_analytic_id.id,
-    @mute_logger('openerp.addons.base.ir.ir_config_parameter')
+    @mute_logger('odoo.addons.base.ir.ir_config_parameter')
-    'author': 'Noviat & Odoo SA',
+    'author': 'Noviat, Odoo SA',
-    'author': 'Uruguay l10n Team & Guillem Barba',
+    'author': 'Uruguay l10n Team, Guillem Barba',
-        model_id = cr.fetchone()[0]
+        model = self.env['ir.model'].browse(cr.fetchone()[0])
-                           (xmlid, self._context['module'], 'ir.model', model_id))
+                           (xmlid, self._context['module'], 'ir.model', model.id))
-                'model_id': model_id,
+                'model_id': model.id,
-        self.invalidate_cache()
+            elif not all(cols[field.name][key] == vals[key] for key in vals):
-
+        IrModelFields = self.env['ir.model.fields']
-            self._add_field(name, Field.by_type[field['ttype']](**attrs))
+        for name, field_data in manual_fields.iteritems():
-        """ Instanciate a model class for the custom model given by parameters ``model_data``. """
+        """ Return a class for the custom model given by parameters ``model_data``. """
-        CustomModel._build_model(self.pool, self._cr)
+        return CustomModel
-            ir_model._instanciate(model_data)
+            model_class = ir_model._instanciate(model_data)
-            menu.web_icon_data = self.read_image(menu.web_icon)
+            if menu.web_icon and len(menu.web_icon.split(',')) == 2:
-        fields = ['name', 'sequence', 'parent_id', 'action', 'web_icon_data']
+        fields = ['name', 'sequence', 'parent_id', 'action', 'web_icon', 'web_icon_data']
-        if not check_group(node):
+        if not self._apply_group(model, node, modifiers, fields):
-    def customize_template_get(self, key, full=False, bundles=False):
+    def customize_template_get(self, key, full=True, bundles=False):
-            ``bundles=True`` returns also the asset bundles
+            :returns ``customize_show`` templates (which can be active or not), if
-            if not user_groups.issuperset(view.groups_id):
+
-        return result
+            result_filtered.append(x)
-    def get_sale_details(self, date_start=False, date_stop=False, company=False):
+    def get_sale_details(self, date_start=False, date_stop=False, configs=False):
-        params: date_start, date_stop string representing the day of order
+        params: date_start, date_stop string representing the datetime of order
-            company = self.env.user.company_id
+        if not configs:
-            date_stop = fields.Datetime.from_string(date_stop) + timedelta(days=1, seconds=-1)
+            date_stop = fields.Datetime.from_string(date_stop)
-                              ('company_id', '=', company.id)])
+
-    def render_html(self, data=None):
+    def render_html(self, docids, data=None):
-        'security/ir.model.access.csv',
+        'security/ir.model.access.csv',
-            if user_is_admin:
+            if self.pool['res.users']._is_admin(cr, uid, [uid]):
-            for registration in filter(lambda item: item not in [mail_reg.registration_id for mail_reg in self.mail_registration_ids], self.event_id.registration_ids):
+            reg_ids = [mail_reg.registration_id for mail_reg in self.mail_registration_ids]
-                path = path[len(mp)+1:]
+                path = path[len(mp):]
-                ics_file = ics_files[attendee.event_id.id]
+                ics_file = ics_files.get(attendee.event_id.id)
-                task.rating_send_request(rating_template, reuse_rating=False)
+                force_send = self.env.context.get('force_send', True)
-        projects._send_rating_mail()
+        projects.with_context(force_send=False)._send_rating_mail()
-            results = self.query(conf, filter)
+            results = self.query(conf, filter.encode('utf-8'))
-    @api.depends('order_ids.workcenter_id', 'order_ids.state', 'order_ids.date_planned_start')
+    @api.depends('order_ids.duration_expected', 'order_ids.workcenter_id', 'order_ids.state', 'order_ids.date_planned_start')
-            ['workcenter_id', 'state'], ['workcenter_id', 'state'],
+            ['workcenter_id', 'state', 'duration_expected'], ['workcenter_id', 'state'],
-                            self.message_post(cr, uid, event.id, body=_("An invitation email has been sent to attendee %s") % (partner.name,), subtype="calendar.subtype_invitation", context=context)
+                        attendees_to_mail.append((att_id, mail_from, partner.name))
-            Quantity should be passed in the UoM of the BoM (don't divide by its quantity)
+            Quantity describes the number of times you need the BoM: so the quantity divided by the number created by the BoM
-            line_quantity = current_qty * current_line.product_qty / current_line.bom_id.product_qty
+            line_quantity = current_qty * current_line.product_qty
-                bom_lines = [(line, current_line.product_id, line_quantity, current_line) for line in bom.bom_line_ids] + bom_lines
+                converted_line_quantity = self.env['product.uom']._compute_qty_obj(current_line.product_uom_id, line_quantity / bom.product_qty, bom.product_uom_id)
-            factor = self.env['product.uom']._compute_qty(production.product_uom_id.id, production.product_qty, production.bom_id.product_uom_id.id)
+            factor = self.env['product.uom']._compute_qty(production.product_uom_id.id, production.product_qty, production.bom_id.product_uom_id.id) / production.bom_id.product_qty
-            quantity = UoM._compute_qty_obj(order.product_uom_id, order.product_qty, order.bom_id.product_uom_id)
+            quantity = UoM._compute_qty_obj(order.product_uom_id, order.product_qty, order.bom_id.product_uom_id) / order.bom_id.product_qty
-        qty = bom_data['qty']
+        bom_qty = bom_data['qty']
-            cycle_number = math.ceil(qty / bom.product_qty / operation.workcenter_id.capacity)  # TODO: float_round UP
+            cycle_number = math.ceil(bom_qty / operation.workcenter_id.capacity)  # TODO: float_round UP
-            boms, lines = unbuild.bom_id.explode(unbuild.product_id, factor / unbuild.bom_id.product_qty, picking_type=unbuild.bom_id.picking_type_id)
+            factor = self.env['product.uom']._compute_qty(unbuild.product_uom_id.id, unbuild.product_qty, unbuild.bom_id.product_uom_id.id) / unbuild.bom_id.product_qty
-            factor = self.env['product.uom']._compute_qty(production.product_uom_id.id, production.product_qty - production.qty_produced, production.bom_id.product_uom_id.id)
+            factor = self.env['product.uom']._compute_qty(production.product_uom_id.id, production.product_qty - production.qty_produced, production.bom_id.product_uom_id.id) / production.bom_id.product_qty
-                # assign moves; last operation receive all unassigned moves (which case ?)
+                # assign moves; last operation receive all unassigned moves
-            product_uom_qty_bom = self.env['product.uom']._compute_qty_obj(self.product_uom, self.product_qty, bom.product_uom_id)
+            product_uom_qty_bom = self.env['product.uom']._compute_qty_obj(self.product_uom, self.product_qty, bom.product_uom_id) / bom.product_qty
-            product_uom_qty_bom = self.env['product.uom']._compute_qty_obj(self.product_uom, self.product_uom_qty, bom.product_uom_id)
+            product_uom_qty_bom = self.env['product.uom']._compute_qty_obj(self.product_uom, self.product_uom_qty, bom.product_uom_id) / bom.product_qty
-                moves_todo |= extra_move
+            moves_todo |= move._create_extra_move()
-            if float_compare(move.quantity_done, move.product_uom_qty, precision_rounding=rounding):
+            rounding = move.product_uom.rounding
-                move.move_lot_ids.filtered(lambda x: not x.done_wo).write({'move_id': new_move})
+                move.move_lot_ids.filtered(lambda x: not x.done_wo or x.quantity_done == 0.0).write({'move_id': new_move})
-
+        original_quantity = self.product_qty - self.qty_produced
-    def _update_raw_move(self, bom_line, quantity, **kw):
+    def _update_raw_move(self, bom_line, line_data):
-            move.write({'product_uom_qty': quantity})
+            if quantity > 0:
-            self._generate_raw_move(bom_line, quantity)
+            self._generate_raw_move(bom_line, line_data)
-        if use_serial:
+        if self.product_id.tracking == 'serial':
-                    production._update_raw_move(line, line_data['qty'])
+            bom_point = production.bom_id
-class Production(models.Model):
+class MrpProduction(models.Model):
-        UoM = self.env['product.uom']
+        res = super(MrpProduction, self)._generate_moves()
-                move.action_confirm()
+                production._create_byproduct_move(sub_product)
-class Stok_Move(models.Model):
+class StockMove(models.Model):
-class change_production_qty(models.TransientModel):
+class ChangeProductionQty(models.TransientModel):
-        # U
+        super(ChangeProductionQty, self)._update_product_to_produce(prod, qty)
-                move.write({'product_uom_qty': qty})
+        UoM = self.env['product.uom']
-                        move.write({'product_uom_qty': subproduct_qty})
+                prod._create_byproduct_move(sub_product_line)
-        self.write({'state': 'done', 'date_finished': fields.datetime.now()})
+        self.write({'state': 'done', 'date_finished': fields.Datetime.now()})
-    date_start = fields.Datetime('Start Date', default=fields.Datetime.now(), required=True)
+    date_start = fields.Datetime('Start Date', default=fields.Datetime.now, required=True)
-        'Quantity to Produce',
+        'Quantity To Produce',
-        'Product Qty',
+        'Quantity To Produce',
-                raise UserError(_("You have already produced %d qty , Please give update quantity more then %d ")%(produced, produced))
+                raise UserError(_("You have already processed %d. Please input a quantity higher than %d ")%(produced, produced))
-                        if move_lot.quantity_done == 0 and qty_todo > move_lot.quantity:
+                        if not move_lot.lot_id and qty_todo >= move_lot.quantity:
-            action['context'] = {}
+        action['domain'] = [('product_id', 'in', product_ids)]
-        help='Blocked hours over the last month')
+        help='Blocked hour(s) over the last month', digits=(16, 2))
-        help='Productive hours over the last month')
+        help='Productive hour(s) over the last month', digits=(16, 2))
-            workcenter.blocked_time = count_data.get(workcenter.id, 0.0)
+            workcenter.blocked_time = count_data.get(workcenter.id, 0.0) / 60.0
-            workcenter.productive_time = count_data.get(workcenter.id, 0.0)
+            workcenter.productive_time = count_data.get(workcenter.id, 0.0) / 60.0
-            self.oee = 0.0
+        for order in self:
-        index=True, required=True, readonly=True,
+        'Deadline Start', copy=False, default=fields.Datetime.now,
-        index=True, readonly=True,
+        'Deadline End', copy=False, default=fields.Datetime.now,
-        self.assertEqual(mnf_product_d.state, 'confirmed', 'Manufacturing order should still be in confirmed state.')
+        self.assertEqual(mnf_product_d.state, 'progress', 'Manufacturing order should still be in progress state.')
-        self.assertEqual(mnf_product_a.state, 'confirmed', 'Manufacturing order should still be in confirmed state.')
+        self.assertEqual(mnf_product_a.state, 'progress', 'Manufacturing order should still be in the progress state.')
-            'origin': self.origin,
+            'origin': self.origin or self.picking_id.name,
-            if not self.partner_id:
+            if not self.partner_id and not self.email_from:
-    @api.depends('invoice_line_ids.price_subtotal', 'tax_line_ids.amount', 'currency_id', 'company_id')
+    @api.depends('invoice_line_ids.price_subtotal', 'tax_line_ids.amount', 'currency_id', 'company_id', 'date_invoice')
-            amount_untaxed_signed = self.currency_id.compute(self.amount_untaxed, self.company_id.currency_id)
+            currency_id = self.currency_id.with_context(date=self.date_invoice)
-            if template.report_template and not 'report_template_in_attachment' in self.env.context:
+            if template.report_template:
-        return self.with_context(report_template_in_attachment=True).send_mail()
+        return self.send_mail()
-    display_start = fields.Date('Date', compute='_compute_display_start', store=True)
+    display_start = fields.Char('Date', compute='_compute_display_start', store=True)
-            self.email_from = self.project_id.partner_id.email
+            if not self.partner_id:
-        menu = self.search(["sequence"], limit=1, order="sequence DESC")
+        menu = self.search([], limit=1, order="sequence DESC")
-    sequence = fields.Integer(defualt=_default_sequence)
+    sequence = fields.Integer(default=_default_sequence)
-        ('factor_gt_zero', 'CHECK (factor!=0)', 'The conversion ratio for a unit of measure cannot be 0!')
+        ('factor_gt_zero', 'CHECK (factor!=0)', _('The conversion ratio for a unit of measure cannot be 0!')),
-        ], "Form Builder")
+    ], "Form Builder")
-        ], "A/B Testing")
+    ], "A/B Testing")
-    
+
-    # when multi-website is implemented 
+    # when multi-website is implemented
-        if self.payment_method_id.code == 'electronic':
+        if self.payment_method_code == 'electronic':
-        self.payment_transaction_id = tx
+        self.payment_transaction_id = tx
-        return request.render('rating.rating_external_page_view')
+        return request.render('rating.rating_external_page_view', {
-            account_move[-1]['tax_ids'] = expense.tax_ids.id
+            account_move[-1]['tax_ids'] = expense.tax_ids.ids
-        (not_reconciled & pre_not_reconciled).filtered(lambda invoice: invoice.state == 'paid').action_invoice_cancel()
+        (not_reconciled & pre_not_reconciled).filtered(lambda invoice: invoice.state == 'paid').action_invoice_re_open()
-            raise UserError(_("Invoice must be in draft or Pro-forma state in order to validate it."))
+            raise UserError(_("Invoice must be in draft,Pro-forma or open state in order to be cancelled."))
-from openerp import SUPERUSER_ID
+from openerp import SUPERUSER_ID, api
-        return super(ir_config_parameter, self).unlink(cr, uid, ids, context=context)
+        return super(ir_config_parameter, self).unlink(cr, uid, ids, context=context)
-        self.partner_ref = '%s%s' % (self.code and '[%s]' % self.code or '', product_name)
+        self.partner_ref = '%s%s' % (self.code and '[%s] ' % self.code or '', product_name)
-            'view_mode': 'tree',
+            'view_mode': 'tree,form',
-        if not record_sudo:
+        RecordModel = request.env[model].sudo(uid)
-        record_action = record_sudo.get_access_action()
+        record_action = record.get_access_action()
-        if not RecordModel.sudo(uid).check_access_rights('read', raise_exception=False):
+        if not RecordModel.check_access_rights('read', raise_exception=False):
-            RecordModel.sudo(uid).browse(res_id).exists().check_access_rule('read')
+            record.check_access_rule('read')
-            'view_id': record_sudo.get_formview_id(),
+            'view_id': record.get_formview_id(),
-        post = self.browse(cr, uid, ids[0], context=context)
+        post = self.browse(cr, SUPERUSER_ID, ids[0], context=context)
-        of the classic form view, redirect to the post on the website directly """
+        """ Instead of the classic form view, redirect to the post on the website directly """
-from odoo import api, models
+from odoo import api, exceptions, models
-        of the classic form view, redirect to the online invoice if exists. """
+        """ Instead of the classic form view, redirect to the online invoice for portal users. """
-        }
+        if self.env.user.share:
-from openerp import api, models
+from openerp import api, exceptions, models
-        of the classic form view, redirect to the online quote if exists. """
+        """ Instead of the classic form view, redirect to the online quote for
-        }
+        if self.env.user.share:
-from odoo import api, models
+from odoo import api, exceptions, models
-        of the classic form view, redirect to the post on the website directly """
+        """ Instead of the classic form view, redirect to website for portal users
-        }
+        if self.env.user.share:
-        of the classic form view, redirect to the post on the website directly """
+        """ Instead of the classic form view, redirect to website for portal users
-        }
+        if self.env.user.share:
-from openerp import api, models
+from openerp import api, exceptions, models
-        of the classic form view, redirect to the post on the website directly """
+        """ Instead of the classic form view, redirect to website for portal users
-        }
+        if self.env.user.share:
-        if it is published. """
+        """ Instead of the classic form view, redirect to website if it is published. """
-                    cid_mapping[info['cid']] = name
+                    cid = info['cid']
-                'datas_fname': name,
+                'datas_fname': cid or name,
-                    attachment = parameter_attachments.filtered(lambda attachment: attachment.name == fname)
+                    cid = node.get('src').split('cid:')[1]
-        action_context = {'show_mode_selector': False, 'account_ids': [self.id,]}
+        if self.internal_type == 'payable':
-    name = fields.Char(string='Memo', required=True)
+    name = fields.Char(string='Label', required=True)
-                        variant.write({'active': False})
+            
-    'depends': ['base'],
+    'depends': ['base_setup'],
-        'views/res_company_views.xml',
+        'views/res_config_views.xml',
-import res_company
+import res_company
-                'payment_term_id': partner.property_payment_term_id.id,
+                'payment_term_id': self.sale_get_payment_term(partner),
-        convert_action = self._notification_link_helper('method', method='convert_opportunity', partner_id=lead.partner_id.id)
+    def _notification_recipients(self, message, groups):
-            }
+        self.ensure_one()
-        return result
+            won_action = self._notification_link_helper('method', method='action_set_won')
-        result = super(Holidays, self)._notification_get_recipient_groups(message, recipients)
+    def _notification_recipients(self, message, groups):
-        actions = []
+        self.ensure_one()
-            actions.append({'url': app_action, 'title': 'Approve'})
+            app_action = self._notification_link_helper('method', method='action_validate')
-            actions.append({'url': ref_action, 'title': 'Refuse'})
+            ref_action = self._notification_link_helper('method', method='action_refuse')
-        return result
+        new_group = (
-    def _notification_group_recipients(self, message, recipients, done_ids, group_data):
+    def _notification_recipients(self, message, groups):
-        return super(Channel, self)._notification_group_recipients(message, recipients, done_ids, group_data)
+        groups = super(Channel, self)._notification_recipients(message, groups)
-         - button unfollow: used to display 'Unfollow' in email, if set
+    def _notification_recipients(self, message, groups):
-        }
+        return groups
-            result[category].update(data)
+        default_groups = [
-        partner_followers = doc_followers.mapped('partner_id')
+        for recipient in recipients:
-                    result[category]['not_followers'] |= recipient
+        for group_name, group_method, group_data in groups:
-                template_fol_values['button_follow'] = False
+                template_fol_values['has_button_follow'] = False
-                template_not_values['button_unfollow'] = False
+                template_not_values['has_button_unfollow'] = False
-        res = super(Note, self)._notification_get_recipient_groups(message, recipients)
+    def _notification_recipients(self, message, groups):
-        return res
+        groups['user']['actions'] = [{'url': new_action, 'title': _('New Note')}]
-        return super(Task, self)._notification_group_recipients(message, recipients, done_ids, group_data)
+    def _notification_recipients(self, message, groups):
-            actions.append({'url': take_action, 'title': _('I take it')})
+            take_action = self._notification_link_helper('assign')
-            actions.append({'url': new_action, 'title': _('New Task')})
+            new_action_id = self.env.ref('project.action_view_task').id
-        return res
+        new_group = (
-        return super(ProjectIssue, self)._notification_group_recipients(message, recipients, done_ids, group_data)
+    def _notification_recipients(self, message, groups):
-            actions.append({'url': take_action, 'title': _('I take it')})
+            project_actions = [{'url': take_action, 'title': _('I take it')}]
-            actions.append({'url': new_action, 'title': _('New Issue')})
+            project_actions = [{'url': new_action, 'title': _('New Issue')}]
-        return res
+        new_group = (
-        return res
+    def _notification_recipients(self, message, groups):
-        return res
+    def _notification_recipients(self, message, groups):
-        return super(AccountInvoice, self)._notification_group_recipients(message, recipients, done_ids, group_data)
+    def _notification_recipients(self, message, groups):
-        return super(Project, self)._notification_group_recipients(message, recipients, done_ids, group_data)
+    def _notification_recipients(self, message, groups):
-        return super(Task, self)._notification_group_recipients(message, recipients, done_ids, group_data)
+    def _notification_recipients(self, message, groups):
-from odoo import api, exceptions, models
+from odoo import api, exceptions, models, _
-        return super(Issue, self)._notification_group_recipients(message, recipients, done_ids, group_data)
+    def _notification_recipients(self, message, groups):
-        return super(SaleOrder, self)._notification_group_recipients(message, recipients, done_ids, group_data)
+    def _notification_recipients(self, message, groups):
-        return res
+    def _notification_recipients(self, message, groups):
-        if not record_sudo:
+        RecordModel = request.env[model].sudo(uid)
-        record_action = record_sudo.get_access_action()
+        record_action = record.get_access_action()
-        if not RecordModel.sudo(uid).check_access_rights('read', raise_exception=False):
+        if not RecordModel.check_access_rights('read', raise_exception=False):
-            RecordModel.sudo(uid).browse(res_id).exists().check_access_rule('read')
+            record.check_access_rule('read')
-            'view_id': record_sudo.get_formview_id(),
+            'view_id': record.get_formview_id(),
-        of the classic form view, redirect to the post on the website directly """
+        """ Instead of the classic form view, redirect to the post on website
-        of the classic form view, redirect to the post on the website directly """
+        """ Instead of the classic form view, redirect to the post on the website directly """
-from odoo import api, models
+from odoo import api, exceptions, models
-        of the classic form view, redirect to the online invoice if exists. """
+        """ Instead of the classic form view, redirect to the online invoice for portal users. """
-        }
+        if self.env.user.share:
-from odoo import api, models
+from odoo import api, exceptions, models
-        of the classic form view, redirect to the online quote if exists. """
+        """ Instead of the classic form view, redirect to the online quote for
-        }
+        if self.env.user.share:
-from odoo import api, models
+from odoo import api, exceptions, models
-        of the classic form view, redirect to the post on the website directly """
+        """ Instead of the classic form view, redirect to website for portal users
-        }
+        if self.env.user.share:
-        of the classic form view, redirect to the post on the website directly """
+        """ Instead of the classic form view, redirect to website for portal users
-        }
+        if self.env.user.share:
-from odoo import api, models
+from odoo import api, exceptions, models
-        of the classic form view, redirect to the post on the website directly """
+        """ Instead of the classic form view, redirect to website for portal users
-        }
+        if self.env.user.share:
-        of the classic form view, redirect to the online quote if exists. """
+        """ Instead of the classic form view, redirect to the online quote if it exists. """
-        if it is published. """
+        """ Instead of the classic form view, redirect to website if it is published. """
-    def mail_action_assign(self, model, res_id, **kwargs):
+    def mail_action_assign(self, model, res_id):
-                'res_id': self.ids[0],
+                'model': kwargs.pop('model', self._name),
-            link = '/mail/view?%s' % url_encode(params)
+            link = '/mail/%s?%s' % (link_type, url_encode(params))
-                'button_unfollow': {'url': '/mail/unfollow?%s' % url_encode({'model': message.model, 'res_id': message.res_id}), 'title': _('Unfollow')},
+                'button_follow': {'url': self._notification_link_helper('follow', model=message.model, res_id=message.res_id), 'title': _('Follow')},
-    asset_end_date = fields.Date(string='Asset Start Date', compute='_get_asset_date', readonly=True, store=True)
+    asset_start_date = fields.Date(string='Asset Start Date', compute='_get_asset_date', readonly=True, store=True)
-            body_html = Template.with_context(template._context).render_template(template.body_html, 'gamification.badge.user', badge_user.ids)
+            body_html = Template.with_context(template._context).render_template(template.body_html, 'gamification.badge.user', badge_user.id)
-    OPTIONAL_BILLING_FIELDS = ["zipcode", "state_id", "vat", "street"]
+    MANDATORY_BILLING_FIELDS = ["name", "phone", "email", "street", "city", "country_id"]
-        partner = request.env['res.users'].browse(request.uid).partner_id
+        partner = request.env.user.partner_id
-                values = {key: post[key] for key in self.MANDATORY_BILLING_FIELDS + self.OPTIONAL_BILLING_FIELDS}
+                values = {key: post[key] for key in self.MANDATORY_BILLING_FIELDS}
-            domain + ['&'] + loc_domain + ['!'] + dest_loc_domain
+            domain + dest_loc_domain + ['!'] + loc_domain if loc_domain else domain + dest_loc_domain,
-            models.add(model)
+            models.add(model._name)
-    return trans.get_done()[5:-6]           # remove tags <div> and </div>
+    try:
-from openerp.tools import misc, config
+from openerp.tools import misc, config, mute_logger
-        Option.write({'line_id': OrderLine})
+        Option.write({'line_id': OrderLine.id})
-    fold = fields.Boolean(string='Folded in Tasks Pipeline',
+    fold = fields.Boolean(string='Folded in Kanban',
-    no_of_days = fields.Integer(string='# of Days', readonly=True)
+    no_of_days = fields.Integer(string='# Working Days', readonly=True)
-    closing_days = fields.Float(string='Days to Close',
+    closing_days = fields.Float(string='# Days to Close',
-    opening_days = fields.Float(string='Days to Assign',
+    opening_days = fields.Float(string='# Days to Assign',
-    delay_endings_days = fields.Float(string='Overpassed Deadline', digits=(16,2), readonly=True)
+    delay_endings_days = fields.Float(string='# Days to Deadline', digits=(16,2), readonly=True)
-    'category': 'Project Management',
+    'category': 'Project',
- #-*- coding: utf-8 -*-
+#-*- coding: utf-8 -*-
-    @api.one
+    @api.multi
-            for variant in variants_to_activate:
+            for variant in variants_to_unlink:
-            col = cols.pop(k, None)
+            col = cols.get(k)
-version = 'master'
+version = '10.0'
-release = 'master'
+release = '10.0'
-# Copyright (c) 2009 Veritos - Jan Verlaan - www.veritos.nl
+# Copyright (C) 2016 ONESTEiN BV (<http://www.onestein.eu>).
-# Copyright (c) 2009 Veritos - Jan Verlaan - www.veritos.nl
+# Copyright (C) 2016 ONESTEiN BV (<http://www.onestein.eu>).
-                 'base_iban',
+    'name': 'Netherlands - Accounting',
-             ],
+    'demo': [],
-from odoo.tests import common
+from odoo.addons.account.tests.account_test_classes import AccountingTestCase
-class TestStockLandedCostsCommon(common.TransactionCase):
+class TestStockLandedCostsCommon(AccountingTestCase):
-        self.assertEqual(account_entry['debit'], 134.336, 'Wrong Account Entry')
+        move_lines = [
-        domain=[('internal_type', '!=', 'view'), ('internal_type', '!=', 'closed'), ('deprecated', '=', False)])
+    account_id = fields.Many2one('account.account', 'Account', domain=[('deprecated', '=', False)])
-            })
+        self.env['crossovered.budget.lines'].create({
-            })
+        if not account_ids:
-            })
+        self.env['crossovered.budget.lines'].create({
-            'code': 'X2020',
+            'code': 'Y2020',
-        groupby = [groupby] if isinstance(groupby, basestring) else groupby
+        groupby = [groupby] if isinstance(groupby, basestring) else list(OrderedSet(groupby))
-        groupby = [groupby] if isinstance(groupby, basestring) else groupby
+        groupby = [groupby] if isinstance(groupby, basestring) else list(OrderedSet(groupby))
-            url=request.httprequest.path,
+            url=request.httprequest.path.partition('/page/')[0],
-
+            if field:
-            (classes, src, options.get('style', ''), ' alt="%s"' % alt if alt else '')
+        src_zoom = None
-        if not pricelists or (partner_pl or partner.property_product_pricelist.id) != website_pl:
+        is_public = self.user_id.id == self.env.user.id
-    def test_get_pricelist_available_show(self):
+    def _test_get_pricelist_available_show(self):
-            'AF': 1 # Public
+            False: ['USD', 'EUR', 'Benelux', 'Canada'],
-                              % (country, len(pls), pls.mapped('name'), result))
+            self.assertEquals(len(set(pls.mapped('name')) & set(result)), len(pls), 'Test failed for %s (%s %s vs %s %s)'
-    def test_get_pricelist_available_not_show(self):
+    def _test_get_pricelist_available_not_show(self):
-            'AF': 1
+            False: ['USD', 'EUR', 'Benelux', 'Christmas', 'Canada'],
-                              % (country, len(pls), pls.mapped('name'), result))
+            self.assertEquals(len(set(pls.mapped('name')) & set(result)), len(pls), 'Test failed for %s (%s %s vs %s %s)'
-    def test_get_pricelist_available_promocode(self):
+    def _test_get_pricelist_available_promocode(self):
-            'AF': False,
+            'US': True,
-        self.env.user.partner_id.country_id = self.env.ref('base.us')  # Add US pricelist auto
+        self.env.user.partner_id.country_id = self.env.ref('base.be')  # Add EUR pricelist auto
-            'AF': 1 # USA
+            False: ['USD', 'EUR', 'Benelux', 'Canada'],
-                              % (country, len(pls), pls.mapped('name'), result))
+            self.assertEquals(len(set(pls.mapped('name')) & set(result)), len(pls), 'Test failed for %s (%s %s vs %s %s)'
-            pricelists |= partner.property_product_pricelist
+            if partner.property_product_pricelist.website_id:
-        if not pl:
+        if not pl:
-        return pricelists.sorted(lambda pl: pl.name).ids
+        return pricelists.ids
-            if not self.env.context.get('fixed_price'):
+
-                value['option_ids'].add(option_line_id.id)
+                'linked_line_id': linked_line.id,
-        value['option_ids'] = list(value['option_ids'])
+        option_lines = self.order_line.filtered(lambda l: l.linked_line_id.id == line.id)
-        self.sudo().message_unsubscribe(partner_ids)
+            [('id', 'child_of', self.env.user.partner_id.commercial_partner_id.id)])
-        self.write(values)
+            values['partner_declined_ids'] = map(lambda p: (4, p, 0), partner_ids.ids)
-                    odoo.registry(db).check_signaling()
+                        odoo.registry(db).check_signaling()
-                response.set_cookie(cook, request.params[var], domain=cls.get_utm_domain_cookies())
+
-                    'picking_id': picking_id.id,
+                    'picking_id': picking_id and picking_id.id or False,
-            timezone = self.env.user.partner_id.tz
+            timezone = self.env.user.partner_id.tz or 'UTC'
-            worksheet.write(y, x, row['indent'] * '     ' + row['title'], header_plain)
+            worksheet.write(y, x, row['indent'] * '     ' + ustr(row['title']), header_plain)
-            name = act_window.read(cr, uid, action_ids[0], ['name'], context=context)['name']
+            name = act_window.read(cr, uid, [action_ids[0]], ['name'], context=context)[0]['name']
-    pin = fields.Char(string="PIN", default=_default_random_pin, help="PIN used for Check In/Out in Attendance.", copy=False, groups='hr_attendance.group_hr_attendance_user')
+    barcode = fields.Char(string="Badge ID", help="ID used for employee identification.", default=_default_random_barcode, copy=False)
-            RegistryManager.new(self._cr.dbname)
+            registry = RegistryManager.new(self._cr.dbname)
-                init_models([model], self._cr, dict(self._context, update_custom_fields=True))
+                # update database schema of model and its descendant models
-            models = [self.pool[name] for name in patched_models]
+            models = self.pool.descendants(patched_models, '_inherits')
-            if k not in cols:
+            col = cols.pop(k, None)
-                    if cols[k][key] != vals[key]:
+                    if col[key] != vals[key]:
-        # recompute attributes of children models
+        # update _inherits_children of parent models
-from collections import Mapping, defaultdict
+from collections import Mapping, defaultdict, deque
-
+        model_names = []
-            mark_loaded(model)
+            model_names.append(model._name)
-        return map(self, loaded_models)
+        return self.descendants(model_names, '_inherit')
-        help="""Share or embbed any screen of Odoo.""")
+        help="""Share or embed any screen of Odoo.""")
-            'phone': customer.phone if customer else self.phone,
+            'email_from': customer and customer.email or self.email_from,
-        SaleOrder = self.env['sale.order']
+        sale_data = self.env['sale.order'].read_group(domain=[('partner_id', 'child_of', self.ids)],
-            ])
+            # let's obtain the partner id and all its child ids from the read up there
-        odoo.tools.config.parse_config(args)
+        config.parse_config(args)
-            Console(locals=local_vars).interact()
+
-            'openerp': odoo
+            'openerp': odoo,
-        self.shell(odoo.tools.config['db_name'])
+        self.shell(config['db_name'])
-            'init', 'save', 'config', 'update', 'stop_after_init', 'dev_mode'
+            'init', 'save', 'config', 'update', 'stop_after_init', 'dev_mode', 'shell_interface'
-                'log_db_level', 'geoip_database', 'dev_mode'
+                'log_db_level', 'geoip_database', 'dev_mode', 'shell_interface'
-            'dev_mode', 'smtp_ssl', 'load_language',
+            'dev_mode', 'shell_interface', 'smtp_ssl', 'load_language',
-        help='Specific team that uses this stage. Other teams will not ne able to see or use this stage.')
+        help='Specific team that uses this stage. Other teams will not be able to see or use this stage.')
-                raise ValidationError(_("Qweb view cannot have 'Groups' define on the record. Use 'groups' atttributes inside the view definition"))
+                raise ValidationError(_("Qweb view cannot have 'Groups' define on the record. Use 'groups' attributes inside the view definition"))
-                raise AccessError(_('Invalid groupby'))
+                raise AccessError(_("Invalid 'group by' parameter"))
-            if order.state != 'sale':
+            if order and order.state != 'sale':
-            return self.render(cr, uid, [], report.report_name, docargs, context=context).encode('utf-8')
+            return self.render(cr, uid, [], report.report_name, docargs, context=context)
-        return u''.join(body)
+        return u''.join(body).encode('utf8')
-        result = self.engine.render(field, {'company': company}).encode('utf-8')
+        result = self.engine.render(field, {'company': company})
-        result = self.engine.render(field, {'company': company}).encode('utf-8')
+        result = self.engine.render(field, {'company': company})
-            self.engine.render(field, {'company': None}).encode('utf-8')
+            self.engine.render(field, {'company': None})
-            self.engine.render(field, {'company': None}).encode('utf-8')
+            self.engine.render(field, {'company': None})
-                qweb.render(template, values=params, load=loader).strip().encode('utf-8'),
+                qweb.render(template, values=params, load=loader).strip(),
-        return super(pad_common, self).create(cr, uid, vals, context=context)
+        res = super(pad_common, self).create(cr, uid, vals, context=context)
-                order.state = 'sent'
+        if self._context.get('default_model') == 'purchase.order' and self._context.get('default_res_id'):
-            'groups', 'foreach', 'if', 'else',
+            'groups', 'foreach', 'if', 'elif', 'else',
-        if next_el is not None and 't-else' in next_el.attrib:
+        if next_el is not None and {'t-else', 't-elif'} & set(next_el.attrib.keys()):
-from collections import defaultdict, MutableMapping
+from collections import defaultdict, MutableMapping, OrderedDict
-                known_values[grouped_value] = left_side
+        # Merge the current results (list of dicts) with all groups (recordset).
-            if not grouped_value in known_values:
+                result[left_id][count_field] = left_side[count_field]
-                append_right(all_groups.pop(0))
+                line['__domain'] = [(groupby, '=', right_id)] + domain
-from odoo import api, fields, models, tools
+from odoo import api, fields, models, tools, SUPERUSER_ID
-        default=lambda self: self._default_stage_id())
+        group_expand='_read_group_stage_ids', default=lambda self: self._default_stage_id())
-            order = "%s desc" % order
+    @api.model
-        # - ('id', 'in', 'ids'): add columns that should be present
+        # - ('id', 'in', stages.ids): add columns that should be present
-            search_domain = ['|', ('id', 'in', self.ids), '|', ('team_id', '=', False), ('team_id', '=', team_id)]
+            search_domain = ['|', ('id', 'in', stages.ids), '|', ('team_id', '=', False), ('team_id', '=', team_id)]
-            search_domain = ['|', ('id', 'in', self.ids), ('team_id', '=', False)]
+            search_domain = ['|', ('id', 'in', stages.ids), ('team_id', '=', False)]
-    }
+        stage_ids = stages._search(search_domain, order=order, access_rights_uid=SUPERUSER_ID)
-from odoo import api, fields, models, tools
+from odoo import api, fields, models, tools, SUPERUSER_ID
-        order = Stage._order
+    @api.model
-    }
+            search_domain = ['|', ('job_id', '=', job_id)] + search_domain
-from odoo import api, fields, models, _
+from odoo import api, fields, models, SUPERUSER_ID, _
-    category_id = fields.Many2one('maintenance.equipment.category', string='Equipment Category', track_visibility='onchange')
+    category_id = fields.Many2one('maintenance.equipment.category', string='Equipment Category',
-            kanban view, even if they are empty
+    @api.model
-        return result, fold
+        category_ids = categories._search([], order=order, access_rights_uid=SUPERUSER_ID)
-    stage_id = fields.Many2one('maintenance.stage', string='Stage', track_visibility='onchange', default=_default_stage)
+    stage_id = fields.Many2one('maintenance.stage', string='Stage', track_visibility='onchange',
-    def _read_group_stage_ids(self, domain, read_group_order=None, access_rights_uid=None):
+    @api.model
-    }
+        stage_ids = stages._search([], order=order, access_rights_uid=SUPERUSER_ID)
-from odoo import api, fields, models, tools, _
+from odoo import api, fields, models, tools, SUPERUSER_ID, _
-            order = '%s desc' % order
+    @api.model
-        return result, {stage.id: stage.fold for stage in stages}
+            search_domain = ['|', ('project_ids', '=', self.env.context['default_project_id'])] + search_domain
-    }
+        stage_ids = stages._search(search_domain, order=order, access_rights_uid=SUPERUSER_ID)
-        default=_get_default_stage_id,
+        default=_get_default_stage_id, group_expand='_read_group_stage_ids',
-            order = "%s desc" % order
+    @api.model
-            search_domain = [('id', 'in', self.ids)]
+            search_domain = ['|', ('project_ids', '=', self.env.context['default_project_id'])] + search_domain
-    }
+        return stages.search(search_domain, order=order)
-from odoo import api, fields, models, tools, _
+from odoo import api, fields, models, tools, SUPERUSER_ID, _
-    stage_id = fields.Many2one('survey.stage', string="Stage", default=_default_stage, ondelete="set null", copy=False)
+    stage_id = fields.Many2one('survey.stage', string="Stage", default=_default_stage,
-    def _read_group_stage_ids(self, domain, read_group_order=None, access_rights_uid=None):
+    @api.model
-    }
+        stage_ids = stages._search([], order=order, access_rights_uid=SUPERUSER_ID)
-    documentation_toc_id = fields.Many2one('forum.documentation.toc', string='Documentation ToC', ondelete='set null')
+    documentation_toc_id = fields.Many2one('forum.documentation.toc', string='Documentation ToC',
-    }
+    @api.model
-from odoo import models, fields, api
+from odoo import models, fields, api, SUPERUSER_ID
-    many2one = fields.Many2one('test_converter.test_model.sub')
+    many2one = fields.Many2one('test_converter.test_model.sub', group_expand='_gbf_m2o')
-    }
+    # `group_expand`; test this feature here...
-
+        field = self._fields[groupby]
-        # should be displayed even if they don't contain any record.
+        # field.group_expand is the name of a method that returns a list of all
-        )
+        group_ids = [x[groupby][0] for x in read_group_result if x[groupby]]
-        if folded:
+        if groups._fold_name in groups._fields:
-                r['__fold'] = folded.get(r[groupby] and r[groupby][0], False)
+                group = groups.browse(r[groupby] and r[groupby][0])
-        if lazy and groupby_fields[0] in self._group_by_full:
+        if lazy:
-                diff_quantity -= min(procurement_qty, diff_quantity)
+                # If the procurement has some moves already, we should deduct their quantity
-        ga_client_id = params.get_param('google_management_client_id', default='')
+        ga_client_id = params.sudo().get_param('google_management_client_id', default='')
-    'depends': ['account', 'hr', 'project'],
+    'depends': ['hr', 'project'],
-        'test/worktask_entry_to_timesheetline_entry.yml',
+        'demo/hr_timesheet_demo.xml',
-        if os.path.exists(opj(adp, module, MANIFEST)) or os.path.exists(opj(adp, '%s.zip' % module)):
+        files = [opj(adp, module, manifest) for manifest in MANIFEST_NAMES] +\
-            'communication': self.type in ('in_invoice', 'in_refund') and self.reference or self.number,
+            'communication': communication,
-                aml_obj.with_context(check_move_validity=False).create(aml_dict)
+                aml_obj.with_context(check_move_validity=False, apply_taxes=True).create(aml_dict)
-                apply taxes in the default fashion (eg. taxes). You can also pass 'dont_create_taxes' in context.
+    def create(self, vals):
-        if apply_taxes and not context.get('dont_create_taxes') and vals.get('tax_ids'):
+        if context.get('apply_taxes') and vals.get('tax_ids'):
-        move = self.env['account.move'].create(vals)
+        move = self.env['account.move'].with_context(apply_taxes=True).create(vals)
-    def create(self, vals, apply_taxes=True):
+    def create(self, vals):
-        return super(AccountMoveLine, self).create(vals, apply_taxes=apply_taxes)
+        return super(AccountMoveLine, self).create(vals)
-            move = self.env['account.move'].with_context(dont_create_taxes=True).create(move_vals)
+            move = self.env['account.move'].create(move_vals)
-            self.env['account.move.line'].create(move_line)
+            self.env['account.move.line'].with_context(apply_taxes=True).create(move_line)
-            move.sudo().with_context(dont_create_taxes=True).write({'line_ids': all_lines})
+            move.sudo().write({'line_ids': all_lines})
-        return self.env['report'].render('point_of_sale.report_saledetails', data)
+        return self.env['report'].render('point_of_sale.report_saledetails', data)
-    def convert_to_onchange(self, value, fnames=None):
+    def convert_to_onchange(self, value, record, fnames=()):
-        return super(Many2one, self).convert_to_onchange(value, fnames)
+        return super(Many2one, self).convert_to_onchange(value, record, fnames)
-        lines = dict([(partner['partner_id'], []) for partner in partners if partner['partner_id']])
+        lines = dict((partner['partner_id'] or False, []) for partner in partners)
-            partner_id = line.partner_id.id or None
+            partner_id = line.partner_id.id or False
-                partner_id = line.partner_id.id or None
+                partner_id = line.partner_id.id or False
-    project_id = fields.Many2one('project.project', 'Project')
+    project_id = fields.Many2one('project.project', 'Project', domain=[('allow_timesheets', '=', True)])
-
+    allow_timesheets = fields.Boolean("Allow timesheets", default=True)
-        if orderpoint.lead_type=='purchase':
+        if orderpoint.lead_type == 'supplier':
-                _message_post_helper(res_model='sale.order', res_id=order.id, message=body, token=token, token_field="access_token", message_type='notification')
+                _message_post_helper(res_model='sale.order', res_id=order.id, message=body, token=token, token_field="access_token", message_type='notification', subtype="mail.mt_note", partner_ids=order.user_id.partner_id.ids)
-            'res_id': post.id,
+            'res_id': self.id,
-            res = taxes.compute_all(amount,
+            res = taxes.with_context(round=True).compute_all(amount,
-        if company_id.tax_calculation_rounding_method == 'round_globally' or not bool(self.env.context.get("round", True)):
+
-            if company_id.tax_calculation_rounding_method == 'round_globally' or not bool(self.env.context.get("round", True)):
+            if not round_tax:
-            'total_included': currency.round(total_included) if bool(self.env.context.get("round", True)) else total_included,
+            'total_excluded': currency.round(total_excluded) if round_total else total_excluded,
-        if os.path.exists(opj(adp, module)) or os.path.exists(opj(adp, '%s.zip' % module)):
+        if os.path.exists(opj(adp, module, MANIFEST)) or os.path.exists(opj(adp, '%s.zip' % module)):
-                values['tokens'] = request.env['payment.token'].search([('partner_id', '=', order.partner_id.id), ('acquirer_id', 'in', acquirers.ids)])
+            values['tokens'] = request.env['payment.token'].search([('partner_id', '=', order.partner_id.id), ('acquirer_id', 'in', acquirers.ids)])
-                                               string='Suggested Products', help='Appear on the product page')
+                                               string='Alternative Products', help='Suggest more expensive alternatives to '
-                                             string='Accessory Products', help='Appear on the shopping cart')
+                                             string='Accessory Products', help='Accessories show up when the customer reviews the '
-                                        help="Those categories are used to group similar products for e-commerce.")
+                                        help="Categories can be published on the Shop page (online catalog grid) to help "
-    ], "Availability", default='empty', help="This field is used to display a availability banner with a message on the ecommerce")
+    ], "Availability", default='empty', help="Adds an availability status on the web product page.")
-        ], "Optional Products", help='Install the module website_sale_options')
+        ], "Optional Products", help='Installs *e-Commerce Optional Products*')
-             'Advanced pricing based on formula: You can have all the rights on pricelist')
+        ], default=0, string="Pricing Strategy")
-             'Advanced pricing based on formula: You can have all the rights on pricelist')
+        help='Specific prices per customer segment, currency, etc.: new pricing table available in product detail form (Sales tab).\n'
-    optional_product_ids = fields.Many2many('product.template', 'product_optional_rel', 'src_id', 'dest_id', string='Optional Products', help="Products to propose when add to cart.")
+    optional_product_ids = fields.Many2many('product.template', 'product_optional_rel', 'src_id', 'dest_id',
-        ('draft', 'To Report'),
+        ('draft', 'To Submit'),
-        retag = hashlib.md5(last_update).hexdigest()
+        retag = '"%s"' % hashlib.md5(last_update).hexdigest()
-        if SUPERUSER_ID != self.env.uid and len(set(partner.email for partner in Partner.browse(partner_ids))) > 1:
+        if SUPERUSER_ID != self.env.uid and len(set(partner.email for partner in partner_ids)) > 1:
-            partner.issue_count = Issue.search_count([('partner_id', 'in', partners[partner.id])])
+            partner.issue_count = Issue.search_count([('partner_id', 'child_of', partner.commercial_partner_id.id)])
-            :param dict message_tree: {[msg.id]: msg browse record}
+            :param dict message_tree: {[msg.id]: msg browse record as super user}
-        partners = self.env['res.partner']
+        partners = self.env['res.partner'].sudo()
-        partners_names = partners.sudo().name_get()
+        # Read partners as SUPERUSER -> message being browsed as SUPERUSER it is already the case
-        message_tree = dict((m.id, m) for m in self)
+        message_tree = dict((m.id, m) for m in self.sudo())
-    manager = fields.Many2one('res.users', string='Workgroup Manager')
+    manager = fields.Many2one('res.users', string='Workgroup Manager', default=lambda self: self.env.uid)
-                                                                                       'qty': 0}, context=context)
+                        stock_operation_obj._copy_remaining_pack_lot_ids(cr, uid, new_operation, operation.id, context=context)
-                value = self.convert_to_cache(record[self.name] | value, record, validate=False)
+                val = self.convert_to_cache(record[self.name] | value, record, validate=False)
-            record._cache[self] = value
+                val = UnionUpdate(self, record, value)
-        record.append(Field(el.get('priority', "16"), name='priority'))
+        if 'priority' in el.attrib:
-    website_description = fields.Html('Description for the website', sanitize=False, translate=True)
+    website_description = fields.Html('Description for the website', sanitize=False, translate=html_translate)
-        visible_attrs_ids = product.mapped('attribute_line_ids.attribute_id').filtered(lambda attr: len(attr.value_ids) > 1).ids
+        visible_attrs_ids = product.attribute_line_ids.filtered(lambda l: len(l.value_ids) > 1).mapped('attribute_id').ids
-        response = super(WebsiteAccount, self).account()
+    def account(self, **kw):
-    def account(self):
+    def account(self, **kw):
-        response = super(website_account, self).account()
+        response = super(website_account, self).account(**kw)
-    @http.route(['/my', '/my/home'], type='http', auth="public", website=True)
+    @http.route(['/my', '/my/home'], type='http', auth="user", website=True)
-                link = "<a id='o_mail_test' href='mailto:%(email)s&subject=Lunch+with+customer%%3A+%%2412.32'>%(email)s</a>" % {
+                link = "<a id='o_mail_test' href='mailto:%(email)s?subject=Lunch%%20with%%20customer%%3A%%20%%2412.32'>%(email)s</a>" % {
-        self.message_subscribe_users(user_ids=user_ids)
+        self.sudo().message_subscribe_users(user_ids=user_ids)
-        default_recipients = self.env['mail.thread'].message_get_default_recipients(res_model=self.model, res_ids=res_ids)
+        default_recipients = {}
-        (0, "Task description is a plain text"),
+        (0, "Task description is plain text"),
-                quant = quant.with_context(force_company=quant.company__id.id)
+                quant = quant.with_context(force_company=quant.company_id.id)
-        ])
+        lead_count = request.env['crm.lead'].search_count(self.get_domain_my_lead(request.env.user))
-        domain = [('partner_assigned_id', '=', request.env.user.partner_id.id), ('type', '=', 'lead')]
+        domain = self.get_domain_my_lead(request.env.user)
-        domain = [('partner_assigned_id', '=', request.env.user.partner_id.id), ('type', '=', 'opportunity')]
+        domain = self.get_domain_my_opp(request.env.user)
-        issue_count = request.env['project.issue'].search_count([('project_id.privacy_visibility','=','portal')])
+        # portal users can't see the privacy_visibility, fetch the domain for them in sudo
-                    partner.commercial_partner_id.write(address_fields)
+                    partner.commercial_partner_id.sudo().write(address_fields)
-                'account_id': emp.account_id.id,
+                'account_id': values.get('account_id') or self.account_id.id or emp.account_id.id,
-                'account_id': emp.account_id,
+                'account_id': emp.account_id.id,
-                        partner_ids.append(res['id'])
+                        partner_ids = Partner.browse([res['id']])
-                moves.action_confirm()
+                moves = moves.action_confirm()
-        return True
+        return self
-        domain = [('project_id.privacy_visibility','=','portal')]
+        # portal users can't see the privacy_visibility, fetch the domain for them in sudo
-    'summary': 'Common Drinks data for point of sales',
+    'summary': 'Common Drinks data for points of sale',
-        Common drinks data for point of sales
+        Common drinks data for points of sale
-        theme_category_id = self.env.ref('base.module_category_theme').id
+        theme_category = self.env.ref('base.module_category_theme', False)
-            '|', ('category_id', 'not in', [self.env.ref('base.module_category_hidden').id, self.env.ref('website_theme_install.module_category_theme_hidden').id]), ('name', '=', 'theme_default'),
+            '|', ('category_id', 'not in', hidden_categories_ids), ('name', '=', 'theme_default'),
-                    country = country_obj.browse(country_ids[0])
+                country = country_obj.search([('code', '=', country_code)], limit=1)
-                quant = quant.with_context(force_company=quant.company__id.id)
+                quant = quant.with_context(force_company=quant.company_id.id)
-        help='The receipt will automatically be p-rinted at the end of each order')
+        help='The receipt will automatically be printed at the end of each order')
-        db_create_date = IrParamSudo('database.create_date')
+        dbuuid = IrParamSudo.get_param('database.uuid')
-        enterprise_code = IrParamSudo('database.enterprise_code')
+        enterprise_code = IrParamSudo.get_param('database.enterprise_code')
-        web_base_url = IrParamSudo('web.base.url')
+        web_base_url = IrParamSudo.get_param('web.base.url')
-            company_id = user.partner_id.company_id.id
+            company_id = user.partner_id.company_id
-            poster = self.env.sudo().ref('mail.channel_all_employees')
+            poster = self.sudo().env.ref('mail.channel_all_employees')
-        self.message_post(body=_("Task created"))
+        msg_body = _("Task Created (%s): <a href=# data-oe-model=project.task data-oe-id=%d>%s</a>") % (self.product_id.name, task.id, task.name)
-            self.sale_line_id.order_id.message_post(body=_("Task created"))
+            self.sale_line_id.order_id.message_post(body=msg_body)
-    @http.route('/payment/paypal/dpn', type='http', auth="none", methods=['POST'])
+    @http.route('/payment/paypal/dpn', type='http', auth="none", methods=['POST', 'GET'])
-                    base += sum((line.invoice_line_tax_ids.filtered(lambda t: t.include_base_amount) - tax.tax_id).mapped('amount'))
+                    price_unit = line.price_unit * (1 - (line.discount or 0.0) / 100.0)
-                countries = env['res.country'].search_read([('code', 'ilike', country_code)], fields=['id'])
+                countries = env['res.country'].search([('code', 'ilike', country_code)])
-        digits=dp.get_precision('Product Price'), inverse='_set_product_price',
+        digits=dp.get_precision('Product Price'), inverse='_set_product_lst_price',
-            done_ids.add(recipient.id)
+                done_ids.add(recipient.id)
-            done_ids.add(recipient.id)
+                done_ids.add(recipient.id)
-            done_ids.add(recipient.id)
+                done_ids.add(recipient.id)
-            done_ids.add(recipient.id)
+                done_ids.add(recipient.id)
-            done_ids.add(recipient.id)
+                done_ids.add(recipient.id)
-    db = request.params.get('db')
+    db = request.params.get('db') and request.params.get('db').strip()
-    quantity = fields.Float(required=True, readonly=True, states={'draft': [('readonly', False)]}, digits=dp.get_precision('Product Unit of Measure'), default=1)
+    name = fields.Char(string='Expense Description', readonly=True, required=True, states={'draft': [('readonly', False)], 'refused': [('readonly', False)]})
-    currency_id = fields.Many2one('res.currency', string='Currency', readonly=True, states={'draft': [('readonly', False)]}, default=lambda self: self.env.user.company_id.currency_id)
+    company_id = fields.Many2one('res.company', string='Company', readonly=True, states={'draft': [('readonly', False)], 'refused': [('readonly', False)]}, default=lambda self: self.env.user.company_id)
-            from itertools import repeat, imap
+        'views/report_saledetails.xml',
-
+from odoo.http import request
-        result['context'] = "{'default_product_id': active_id, 'search_default_product_id': active_id, 'default_product_tmpl_id': %s}" % (len(products) and products.pop() or 'False')
+        result['context'] = "{'default_product_id': active_id, 'default_product_tmpl_id': %s}" % (len(products) and products.pop() or 'False')
-from odoo import http
+from odoo import http, service
-        return request.render('point_of_sale.index')
+
-    def account(self):
+    def account(self, **kw):
-    def account(self):
+    def account(self, **kw):
-                                               string='Suggested Products', help='Appear on the product page')
+                                               string='Alternative Products', help='Suggest more expensive alternatives to '
-                                             string='Accessory Products', help='Appear on the shopping cart')
+                                             string='Accessory Products', help='Accessories show up when the customer reviews the '
-                                        help="Those categories are used to group similar products for e-commerce.")
+                                        help="Categories can be published on the Shop page (online catalog grid) to help "
-    ], "Availability", default='empty', help="This field is used to display a availability banner with a message on the ecommerce")
+    ], "Availability", default='empty', help="Adds an availability status on the web product page.")
-        ], "Optional Products", help='Install the module website_sale_options')
+        ], "Optional Products", help='Installs *e-Commerce Optional Products*')
-             'Advanced pricing based on formula: You can have all the rights on pricelist')
+        ], default=0, string="Pricing Strategy")
-             'Advanced pricing based on formula: You can have all the rights on pricelist')
+        help='Specific prices per customer segment, currency, etc.: new pricing table available in product detail form (Sales tab).\n'
-    optional_product_ids = fields.Many2many('product.template', 'product_optional_rel', 'src_id', 'dest_id', string='Optional Products', help="Products to propose when add to cart.")
+    optional_product_ids = fields.Many2many('product.template', 'product_optional_rel', 'src_id', 'dest_id',
-                values['tokens'] = request.env['payment.token'].search([('partner_id', '=', order.partner_id.id), ('acquirer_id', 'in', acquirers.ids)])
+            values['tokens'] = request.env['payment.token'].search([('partner_id', '=', order.partner_id.id), ('acquirer_id', 'in', acquirers.ids)])
-        if self.asset_category_id and self.asset_category_id.method_number > 1:
+        if self.asset_category_id:
-        if sys.argv[1] == 'gevent':
+        if len(sys.argv) > 1 and sys.argv[1] == 'gevent':
-                'value': self.price_subtotal,
+                'value': self.price_subtotal_signed,
-                'currency_id': self.invoice_id.currency_id.id,
+                'currency_id': self.invoice_id.company_currency_id.id,
-            asset_name = line.asset_id.name + ' (%s/%s)' % (line.sequence, line.asset_id.method_number)
+            asset_name = line.asset_id.name + ' (%s/%s)' % (line.sequence, len(line.asset_id.depreciation_line_ids))
-        #Search in account_move if we have any taxes account move lines
+    def _check_tax_exigible(self, line):
-        for k,v in tax_group.items():
+                #TOCHECK: normal and cash basis taxes shoudn't be mixed together (on the same invoice line for example) as it will
-        for k,v in total_by_cash_basis_account.items():
+        # Create counterpart vals
-        #Create move
+    def create_tax_cash_basis_entry(self, value_before_reconciliation):
-            #Check if company_journal for cash basis is set if not, raise exception
+            # Check if company_journal for cash basis is set if not, raise exception
-            move = self.env['account.move'].create({
+            move_vals = {
-            #post move
+                'tax_cash_basis_rec_id': self.id
-from openerp.exceptions import UserError
+from openerp import fields, models, api
-                                }))
+    def _check_tax_exigible(self, line):
-            move.post()
+    def _get_tax_cash_basis_lines(self, value_before_reconciliation):
-    subtask_project_id = fields.Many2one('project.project', related="project_id.subtask_project_id", string='Sub-task Project')
+    subtask_project_id = fields.Many2one('project.project', related="project_id.subtask_project_id", string='Sub-task Project', readonly=True)
-    type = fields.Selection(selection_add=[('sales_team_dashboard', 'Sales Team Dashboard')])
+        if sys.argv[1] == 'gevent':
-        nargs[0] = cmd
+        cmd = os.path.join(os.path.dirname(nargs[0]), "odoo.py")
-    scripts=['openerp-server', 'openerp-gevent', 'odoo.py'],
+    scripts=['openerp-server', 'odoo.py'],
-            format_number_str = "odoo.web.format_value(arguments[0], {type: 'float', digits: [69,%s]}, 0.00)" % currency.decimal_places
+            format_number_str = "openerp.web.format_value(arguments[0], {type: 'float', digits: [69,%s]}, 0.00)" % currency.decimal_places
-        help='Specific team that uses this stage. Other teams will not ne able to see or use this stage.')
+        help='Specific team that uses this stage. Other teams will not be able to see or use this stage.')
-                raise ValidationError(_("Qweb view cannot have 'Groups' define on the record. Use 'groups' atttributes inside the view definition"))
+                raise ValidationError(_("Qweb view cannot have 'Groups' define on the record. Use 'groups' attributes inside the view definition"))
-                raise AccessError(_('Invalid groupby'))
+                raise AccessError(_('Invalid group by'))
-        order_line = self.order_line.filtered(lambda line: line.product_id == self.product_id)
+        order_line = order.order_line.filtered(lambda line: line.product_id == self.product_id)
-from odoo import api, fields, models, SUPERUSER_ID, _
+from odoo import api, fields, models, tools, SUPERUSER_ID, _
-                _logger.info("_file_delete could not unlink %s", full_path, exc_info=True)
+        # simply add fname to checklist, it will be garbage-collected later
-from openerp.tools import float_compare
+from odoo.tools import float_compare
-from openerp.tools.translate import html_translate
+from odoo.tools.translate import html_translate
-from openerp import models, api
+from odoo import models, api
-
+from odoo.tools.misc import xlwt
-* explicitly imports ``openerp``, so useless for anyone else
+* explicitly imports ``odoo``, so useless for anyone else
-        import openerp
+        import odoo
-        project_root = os.path.join(os.path.dirname(openerp.__file__), '..')
+        project_root = os.path.join(os.path.dirname(odoo.__file__), '..')
-        from openerp.addons.base.res.res_config import get_warning_config
+        from odoo.addons.base.res.res_config import get_warning_config
-# the pre-v8 mapping from openerp.report.render.rml2pdf.customfonts.CustomTTFonts.
+# the pre-v8 mapping from odoo.report.render.rml2pdf.customfonts.CustomTTFonts.
-        This method is called from openerp/addons/base/base_data.xml to load
+        This method is called from odoo/addons/base/base_data.xml to load
-        help="Forces all moves for this account to have this account currency.")
+        help="Forces all moves for this account to have this secondary currency.")
-                    raise ValidationError(_('The selected account of your Journal Entry forces to provide a secondary currency. You should remove the secondary currency on the account.'))
+                if not line.journal_id.currency_id and line.company_id.currency_id.id != line.account_id.currency_id.id or line.journal_id.currency_id.id != line.account_id.currency_id.id:
-            resource = self.env['resource.resource'].sudo().search([('user_id', '=', employee.user_id.id)], limit=1)
+            resource = employee.resource_id
-            rating = self.env['rating.rating'].create({'partner_id': partner.id, 'res_model': self._name, 'res_id': self.id})
+            rating = self.env['rating.rating'].create({'partner_id': partner.id, 'rated_partner_id': rated_partner.id, 'res_model': self._name, 'res_id': self.id})
-        (1, "Use a 'Fixed', 'Real' or 'Average' price costing method")
+        (0, 'Set a standard cost price on each product'),
-        result['context'] = "{}"
+        result['context'] = {'default_product_id': self.mapped('product_variant_ids').id}
-                                           offset, limit, order, context, count)
+        return super(marketing_campaign_activity, self).search(
-version_info = (10, 0, 0, ALPHA, 1, 'c')
+version_info = (9, 'saas~13', 0, FINAL, 0, 'c')
-    pin = fields.Char(string="PIN", default=_default_random_pin, help="PIN used for Check In/Out in Attendance.", copy=False, groups='hr.group_hr_user')
+    barcode = fields.Char(string="Badge ID", help="ID used for employee identification.", default=_default_random_barcode, copy=False, groups='hr_attendance.group_hr_attendance_user')
-        'security/ir.model.access.csv',
+        'security/ir.model.access.csv',
-        'security/ir.model.access.csv',
+        'security/ir.model.access.csv',
-        show_leaves = self.env['res.users'].has_group('hr.group_hr_user')
+        show_leaves = self.env['res.users'].has_group('hr_holidays.group_hr_holidays_user')
-        group_hr_manager = self.env.ref('hr.group_hr_manager')
+        group_hr_manager = self.env.ref('hr_holidays.group_hr_holidays_manager')
-        if vals.get('state') and vals['state'] not in ['draft', 'confirm', 'cancel'] and not self.env['res.users'].has_group('hr.group_hr_user'):
+        if vals.get('state') and vals['state'] not in ['draft', 'confirm', 'cancel'] and not self.env['res.users'].has_group('hr_holidays.group_hr_holidays_user'):
-        if not self.env.user.has_group('hr.group_hr_user'):
+        if not self.env.user.has_group('hr_holidays.group_hr_holidays_user'):
-        if not self.env.user.has_group('hr.group_hr_user'):
+        if not self.env.user.has_group('hr_holidays.group_hr_holidays_user'):
-            if holiday.state == 'validate1' and not holiday.env.user.has_group('hr.group_hr_manager'):
+            if holiday.state == 'validate1' and not holiday.env.user.has_group('hr_holidays.group_hr_holidays_manager'):
-        if not self.env.user.has_group('hr.group_hr_user'):
+        if not self.env.user.has_group('hr_holidays.group_hr_holidays_user'):
-        group_hr_user = self.env.ref('hr.group_hr_user')
+        group_hr_holidays_user = self.env.ref('hr_holidays.group_hr_holidays_user')
-                group_data['group_hr_user'] |= recipient
+            if recipient.user_ids and group_hr_holidays_user in recipient.user_ids[0].groups_id:
-        result['group_hr_user'] = {
+        result['group_hr_holidays_user'] = {
-            'groups_id': [(6, 0, [group_employee_id, self.ref('hr.group_hr_user')])]
+            'groups_id': [(6, 0, [group_employee_id, self.ref('hr_holidays.group_hr_holidays_user')])]
-            'groups_id': [(6, 0, [group_employee_id, self.ref('hr.group_hr_manager')])]
+            'groups_id': [(6, 0, [group_employee_id, self.ref('hr_holidays.group_hr_holidays_manager')])]
-    payslip_count = fields.Integer(compute='_compute_payslip_count', string='Payslips', groups="hr.group_hr_user")
+    payslip_count = fields.Integer(compute='_compute_payslip_count', string='Payslips', groups="hr_payroll.group_hr_payroll_user")
-        if not self.env.user.has_group('hr.group_hr_user'):
+        if not self.env.user.has_group('hr_timesheet.group_hr_timesheet_user'):
-        if not self.env.user.has_group('hr.group_hr_user'):
+        if not self.env.user.has_group('hr_timesheet.group_hr_timesheet_user'):
-        return [[0, False, {'compute_price': 'formula'}]]
+        ProductPricelistItem = self.env['product.pricelist.item']
-            self.assertEquals(len(pls), result)
+            self.assertEquals(len(pls), result, 'Test failed for %s (%s [%s] vs %s)'
-            self.assertEquals(len(pls), result)
+            self.assertEquals(len(pls), result, 'Test failed for %s (%s [%s] vs %s)'
-                self.assertTrue(available)
+                self.assertTrue(available, 'AssertTrue failed for %s' % country)
-                self.assertFalse(available)
+                self.assertFalse(available, 'AssertFalse failed for %s' % country)
-from odoo import fields, models
+from odoo import fields, models, api
-        'product.pricelist', 'Sale Pricelist', company_dependent=True,
+        'product.pricelist', 'Sale Pricelist', compute='_compute_product_pricelist',
-    def set_multi(self, name, model, values):
+    def set_multi(self, name, model, values, default_value=None):
-        default_value = clean(self.get(name, model))
+        if not default_value:
-    _order = 'name'
+    _order = "sequence asc, id desc"
-            cart_values = order.with_context(event_ticket_id=ticket.id)._cart_update(product_id=ticket.product_id.id, add_qty=1, registration_data=[registration])
+            cart_values = order.with_context(event_ticket_id=ticket.id, fixed_price=True)._cart_update(product_id=ticket.product_id.id, add_qty=1, registration_data=[registration])
-                self = self.with_context(event_ticket_id=ticket.id)
+                self = self.with_context(event_ticket_id=ticket.id, fixed_price=1)
-            values['price_unit'] = order_line._get_display_price(order_line.product_id)
+
-                                            string='Price list available for this Ecommerce/Website')
+    pricelist_ids = fields.One2many('product.pricelist', compute="_compute_pricelist_ids",
-                        pricelists |= group_pricelists.pricelist_id
+                for group_pricelists in cgroup.pricelist_ids:
-            pricelists |= all_pl.filtered(lambda pl: not show_visible or pl.selectable or pl.pricelist_id.id in (current_pl, order_pl)).mapped('pricelist_id')
+        if not pricelists and not country_code:  # no pricelist for this country, or no GeoIP
-                                                   website.website_pricelist_ids,
+                                                   website.pricelist_ids,
-            self.website.website_pricelist_ids
+            self.website.pricelist_ids
-            'AF': 2
+            False: 4, # Benelux, Europe, US, Public
-            'AF': 3
+            False: 5, # all
-            'current_pl': christmas_pl,
+            'show': False,
-            'IT': False,
+            'IT': True,
-        return product.price
+            from_currency = self.order_id.company_id.currency_id
-        return super(SaleOrderLine, self)._get_display_price(product)
+import product_pricelist
-        ('without_discount', 'Show discount in the sale order')],
+        ('without_discount', 'Show public price & discount to the customer')],
-    'name': 'e-Commerce',
+    'name': 'eCommerce',
-    'name': 'e-Commerce Delivery',
+    'name': 'eCommerce Delivery',
-    'name': 'e-Commerce Optional Products',
+    'name': 'eCommerce Optional Products',
-    payumoney_merchant_salt = fields.Char(string='Merchant Salt', required_if_provider='payumoney')
+    payumoney_merchant_key = fields.Char(string='Merchant Key', required_if_provider='payumoney', groups='base.group_user')
-    stripe_publishable_key = fields.Char(required_if_provider='stripe')
+    stripe_secret_key = fields.Char(required_if_provider='stripe', groups='base.group_user')
-        "Checkout Image URL",
+        "Checkout Image URL", groups='base.group_user',
-        payment_form = acquirer.render(reference, float(amount), currency.id, values={'return_url': '/website_payment/confirm', 'partner_id': partner_id})
+        payment_form = acquirer.sudo().render(reference, float(amount), currency.id, values={'return_url': '/website_payment/confirm', 'partner_id': partner_id})
-from itertools import islice, izip, groupby
+from collections import defaultdict, Iterable, Mapping, MutableSet, OrderedDict
-class OrderedSet(OrderedDict):
+class OrderedSet(MutableSet):
-
+    __slots__ = ['_map']
-
+        self._map[elem] = None
-        return OrderedSet(e for e in self.keys() if e in other)
+        self._map.pop(elem, None)
-                return vals[0].browse(ids)
+                return vals[0].union(*vals)         # union of all recordsets
-        return self.browse(self._ids + other._ids)
+        return self.concat(other)
-        """ Return the recordset of all the records in ``self`` that are not in ``other``. """
+        """ Return the recordset of all the records in ``self`` that are not in
-            Note that recordset order is not preserved.
+            Note that first occurrence order is preserved.
-        return self.browse(OrderedSet(self._ids) & OrderedSet(other._ids))
+        other_ids = set(other._ids)
-            Note that recordset order is not preserved.
+            Note that first occurrence order is preserved.
-        return self.browse(OrderedSet(self._ids) | OrderedSet(other._ids))
+        return self.union(other)
-        request.env['link.tracker.click'].add_click(code, request.httprequest.remote_addr, request.session['geoip'].get('country_code'), stat_id=False)
+        country_code = request.session.geoip and request.session.geoip.get('country_code') or False
-
+    @api.multi
-        'adyen_skin_hmac_key': fields.char('Skin HMAC Key', required_if_provider='adyen'),
+        'adyen_merchant_account': fields.char('Merchant Account', required_if_provider='adyen', groups='base.group_user'),
-    authorize_transaction_key = fields.Char(string='API Transaction Key', required_if_provider='authorize')
+    authorize_login = fields.Char(string='API Login Id', required_if_provider='authorize', groups='base.group_user')
-        'brq_secretkey': fields.char('SecretKey', required_if_provider='buckaroo'),
+        'brq_websitekey': fields.char('WebsiteKey', required_if_provider='buckaroo', groups='base.group_user'),
-        'ogone_shakey_out': fields.char('SHA Key OUT', size=32, required_if_provider='ogone'),
+        'ogone_pspid': fields.char('PSPID', required_if_provider='ogone', groups='base.group_user'),
-        'paypal_email_account': fields.char('Paypal Email ID', required_if_provider='paypal'),
+        'paypal_email_account': fields.char('Paypal Email ID', required_if_provider='paypal', groups='base.group_user'),
-            'Paypal Merchant ID',
+            'Paypal Merchant ID', groups='base.group_user',
-        'paypal_use_ipn': fields.boolean('Use IPN', help='Paypal Instant Payment Notification'),
+        'paypal_use_ipn': fields.boolean('Use IPN', help='Paypal Instant Payment Notification', groups='base.group_user'),
-        'paypal_api_access_token_validity': fields.datetime('Access Token Validity'),
+        'paypal_api_username': fields.char('Rest API Username', groups='base.group_user'),
-        security = sips._sips_generate_shasign(post)
+        security = sips.sudo()._sips_generate_shasign(post)
-    sips_secret = fields.Char('SIPS Secret', size=64, required_if_provider='sips')
+                                   required_if_provider='sips', groups='base.group_user')
-                    cr, uid, this.name, this.amount_total, this.pricelist_id.currency_id.id,
+                    cr, SUPERUSER_ID, this.name, this.amount_total, this.pricelist_id.currency_id.id,
-                    cr, uid, this.number, this.residual, this.currency_id.id,
+                    cr, SUPERUSER_ID, this.number, this.residual, this.currency_id.id,
-        lang_objs = env['res.lang'].search([('code', '=', 'en_US')])
+        lang_objs = env['res.lang'].search([], limit=1)
-                for one_date in current_event._get_recurrent_date_by_event():
+                for one_date in meeting._get_recurrent_date_by_event():
-                for one_date in current_event.get_recurrent_date_by_event():
+                for one_date in meeting.get_recurrent_date_by_event():
-                meeting.write({'attendee_ids': [(4, attendee.id) for attendee in meeting_attendees]})
+                meeting.write({'attendee_ids': [(4, meeting_attendee.id) for meeting_attendee in meeting_attendees]})
-    _order = 'sequence'
+    _order = 'sequence, id'
-        max_sequence = PickingType.search_read([], ['sequence'], limit=1, order='sequence desc')
+        max_sequence = PickingType.search_read([('sequence', '!=', False)], ['sequence'], limit=1, order='sequence desc')
-        'views/tech_template.xml',
+        'views/odoo_template.xml',
-        'views/theme_list.xml',
+        if 'css' not in kwargs:
-        action['domain'] = [('product_id.product_tmpl_id', 'in', products.ids)]
+        action['domain'] = [('product_id.product_tmpl_id', 'in', self.ids)]
-    body_html = fields.Html('Body', translate=True, sanitize_attributes=False)
+    body_html = fields.Html('Body', translate=True, sanitize=False)
-                'product_uom_id': uom.id
+                'product_uom_id': uom.id,
-        if self.env['res.users'].browse(SUPERUSER_ID).has_group('hr_attenance.group_hr_attendance_use_pin') and (self.user_id and self.user_id.id != self._uid or not self.user_id):
+        if self.env['res.users'].browse(SUPERUSER_ID).has_group('hr_attendance.group_hr_attendance_use_pin') and (self.user_id and self.user_id.id != self._uid or not self.user_id):
-                                                string='Employee PIN', help='Enable or disable employee PIN identification at check in', implied_group="hr_attenance.group_hr_attendance_use_pin")
+                                                string='Employee PIN', help='Enable or disable employee PIN identification at check in', implied_group="hr_attendance.group_hr_attendance_use_pin")
-    channel = fields.Char(string='Channel', help="Communication channel.")
+    channel = fields.Char(string='Channel', help="Communication channel.")  # TDE note: is it still used somewhere ?
-                    (SELECT count(id) FROM mail_message WHERE model='project.issue' AND res_id=c.id) AS email
+                    (SELECT count(id) FROM mail_message WHERE model='project.issue' AND message_type IN ('email', 'comment') AND res_id=c.id) AS email
-        'report/project_issue_report_view.xml',
+        'report/project_issue_report_views.xml',
-        'views/project_dashboard.xml',
+        'views/project_issue_views.xml',
-                ids = set(itertools.chain(*[rec._ids for rec in vals]))
+                ids = OrderedSet(itertools.chain(*[rec._ids for rec in vals]))
-        return self.browse(set(self._ids) & set(other._ids))
+        return self.browse(OrderedSet(self._ids) & OrderedSet(other._ids))
-        return self.browse(set(self._ids) | set(other._ids))
+        return self.browse(OrderedSet(self._ids) | OrderedSet(other._ids))
-
+import itertools
-from odoo.modules.module import get_module_root, MANIFEST
+from odoo.modules.module import get_module_root, MANIFEST_NAMES
-        mods = glob.glob(os.path.join(path, '*/%s' % MANIFEST))
+        mods = itertools.chain.from_iterable(
-
+from os.path import join as opj
-                    if os.path.isfile(manifest_path) and os.path.isdir(path_static):
+                    mod_path = opj(addons_path, module)
-MANIFEST = '__openerp__.py'
+MANIFEST_NAMES = ('__manifest__.py', '__openerp__.py')
-        new_path = os.path.abspath(os.path.join(path, os.pardir))
+    while not module_manifest(path):
-    _logger.debug('module %s: no %s file found.', module, MANIFEST)
+    manifest_file = module_manifest(mod_path)
-            return os.path.isfile(manifest_name)
+            for mname in MANIFEST_NAMES:
-                if hasfile('__init__.py') and (hasfile('__openerp__.py') or hasfile('__terp__.py')):
+                if hasfile('__init__.py') and any(hasfile(mname) for mname in MANIFEST_NAMES):
-                info.update(safe_eval(f.read()))
+                info.update(ast.literal_eval(f.read()))
-        return action
+        return action
-        ], string='Multi Image', implied_group='website_sale.group_website_multi_image', group='base.group_portal,base.group_user,base.group_public')
+        ], string='Multi Images', implied_group='website_sale.group_website_multi_image', group='base.group_portal,base.group_user,base.group_public')
-    order_mail_template = fields.Many2one('mail.template', string='Order Confirmation Mail', readonly=True, default=_default_order_mail_template, help="Email sent to customer at the end of the checkout process")
+    order_mail_template = fields.Many2one('mail.template', string='Order Confirmation Email', readonly=True, default=_default_order_mail_template, help="Email sent to customer at the end of the checkout process")
-    'name': 'eCommerce',
+    'name': 'e-Commerce',
-    'name': 'eCommerce Delivery',
+    'name': 'e-Commerce Delivery',
-    'name': 'eCommerce Optional Products',
+    'name': 'e-Commerce Optional Products',
-        ('website', 'Shipping methods available in the customer checkout (adds shipping costs to orders)'),
+        ('internal', "Delivery methods are only used internally: the customer doesn't pay for shipping costs"),
-    group_website_multiimage = fields.Boolean('Multi Image', implied_group='website_sale.group_website_multi_image', group='base.group_portal,base.group_user,base.group_public')
+    group_website_multiimage = fields.Selection([
-    order_mail_template = fields.Many2one('mail.template', string='Order Confirmation Mail', readonly=True, default=_default_order_mail_template)
+    order_mail_template = fields.Many2one('mail.template', string='Order Confirmation Mail', readonly=True, default=_default_order_mail_template, help="Email sent to customer at the end of the checkout process")
-from odoo.tools.safe_eval import safe_eval as eval
+import operator as py_operator
-            if eval(str(product[field]) + operator + str(value)):
+            if OPERATORS[operator](product[field], value):
-            if eval('%s %s %s' % (quant['qty'], operator, value)):
+            if OPERATORS[operator](quant['qty'], value):
-            kwargs['record_name'] = kwargs.get('record_name') or self.parent_id and self.parent_id.name
+            if not kwargs.get('record_name') and self.parent_id:
-paths. For the code to manage those addons, see openerp.modules.
+This module serves to contain all Odoo addons, across all configured addons
-openerp.tools.config.parse_config() is called (so that the addons paths are
+Addons are made available under `odoo.addons` after
-This module also conveniently reexports some symbols from openerp.modules.
+This module also conveniently reexports some symbols from odoo.modules.
-    from openerp.addons.base.ir.ir_config_parameter import _default_parameters
+    from odoo import api, SUPERUSER_ID
-        callable taking a record-ish (a dictionary representing an openerp
+        callable taking a record-ish (a dictionary representing an odoo
-        records matching what :meth:`openerp.osv.orm.Model.write` expects.
+        records matching what :meth:`odoo.osv.orm.Model.write` expects.
-        :param model: :class:`openerp.osv.orm.Model` for the conversion base
+        :param model: :class:`odoo.osv.orm.Model` for the conversion base
-        :type field: :class:`openerp.fields.Field`
+        :type field: :class:`odoo.fields.Field`
-        :param context: openerp request context
+        :param context: odoo request context
-        :raises openerp.exceptions.UserError: if there is an existing default and
+        :raises odoo.exceptions.UserError: if there is an existing default and
-from openerp.tools import safe_eval, html_escape as escape
+from odoo.tools import safe_eval, html_escape as escape
-from openerp.http import request
+from odoo.http import request
-from openerp.tools import func, misc
+from odoo.tools import func, misc
-from openerp.tools import html_escape as escape, posix_to_ldml, safe_eval, float_utils
+from odoo.tools import html_escape as escape, posix_to_ldml, safe_eval, float_utils
-from openerp.http import request
+from odoo import api, models, tools
-            safe_eval._SAFE_OPCODES,
+        assert_valid_codeobj(
-        return Contextifier(safe_eval._BUILTINS).visit(st).body
+        return Contextifier(_BUILTINS).visit(st).body
-            from openerp.addons.base.ir.ir_qweb.qweb import escape, unicodifier, foreach_iterator
+            from odoo.addons.base.ir.ir_qweb.qweb import escape, unicodifier, foreach_iterator
-                # copy all modules in the SERVER/openerp/addons directory to the new "openerp" module (except base itself)
+                # copy all modules in the SERVER/odoo/addons directory to the new "odoo" module (except base itself)
-                        destdir = os.path.join(tmp, OPENERP, 'addons', d)    # XXX 'openerp' subdirectory ?
+                        destdir = os.path.join(tmp, OPENERP, 'addons', d)    # XXX 'odoo' subdirectory ?
-                _logger.info('Copy downloaded module `openerp` to `%s`', server_dir)
+                _logger.info('Copy downloaded module `odoo` to `%s`', server_dir)
-        return tools.config.get('apps_server', 'https://apps.openerp.com/apps')
+        return tools.config.get('apps_server', 'https://apps.odoo.com/apps')
-from openerp.report import report_sxw
+from odoo.report import report_sxw
-            format_number_str = "openerp.web.format_value(arguments[0], {type: 'float', digits: [69,%s]}, 0.00)" % currency.decimal_places
+            format_number_str = "odoo.web.format_value(arguments[0], {type: 'float', digits: [69,%s]}, 0.00)" % currency.decimal_places
-import openerp
+from odoo.tests import common
-        resized = openerp.tools.image_get_resized_images(prop.value_binary, return_big=True, avoid_resize_medium=True)['image_small']
+        resized = odoo.tools.image_get_resized_images(prop.value_binary, return_big=True, avoid_resize_medium=True)['image_small']
-from openerp.tools.mimetypes import guess_mimetype
+from odoo.tools.mimetypes import guess_mimetype
-from openerp.modules.registry import Registry
+from odoo import api, registry, SUPERUSER_ID
-    `openerp.tests` which should be present in the addons-path.
+    `odoo.tests` which should be present in the addons-path.
-from openerp import report, tools
+from odoo import report, tools
-from openerp import models, api
+from odoo import models, api
-from openerp.tools.mimetypes import guess_mimetype
+from odoo.tools.mimetypes import guess_mimetype
-from openerp.exceptions import AccessError
+from odoo import models, fields, api, _
-from openerp.tests import common
+from odoo.tests import common
-from openerp.tests import common
+from odoo.tests import common
-from openerp.tools import mute_logger
+from odoo.exceptions import AccessError, except_orm
-from openerp.tests import common
+from odoo.tests import common
-from openerp import fields, models
+from odoo import fields, models
-from openerp.tests import common
+from odoo.tests import common
-from openerp.tests import common
+from odoo.tests import common
-from openerp import models, fields
+from odoo import models, fields
-    @mute_logger('openerp.addons.base_import.models.base_import')
+    @mute_logger('odoo.addons.base_import.models.base_import')
-    @mute_logger('openerp.addons.base_import.models.base_import')
+    @mute_logger('odoo.addons.base_import.models.base_import')
-            with tools.mute_logger('openerp.sql_db'):
+            with tools.mute_logger('odoo.sql_db'):
-                    with mute_logger('openerp.sql_db'), self._cr.savepoint():
+                    with mute_logger('odoo.sql_db'), self._cr.savepoint():
-                with mute_logger('openerp.sql_db'), self._cr.savepoint():
+                with mute_logger('odoo.sql_db'), self._cr.savepoint():
-    @mute_logger('openerp.addons.base.ir.ir_model', 'openerp.models')
+    @mute_logger('odoo.addons.base.ir.ir_model', 'odoo.models')
-    @mute_logger('openerp.addons.base.ir.ir_model', 'openerp.models')
+    @mute_logger('odoo.addons.base.ir.ir_model', 'odoo.models')
-    @mute_logger('openerp.addons.base.ir.ir_model', 'openerp.models')
+    @mute_logger('odoo.addons.base.ir.ir_model', 'odoo.models')
-    @mute_logger('openerp.addons.base.ir.ir_model', 'openerp.models')
+    @mute_logger('odoo.addons.base.ir.ir_model', 'odoo.models')
-    @mute_logger('openerp.addons.mail.models.mail_mail')
+    @mute_logger('odoo.addons.mail.models.mail_mail')
-    @mute_logger('openerp.addons.base.ir.ir_model', 'openerp.models')
+    @mute_logger('odoo.addons.base.ir.ir_model', 'odoo.models')
-    @mute_logger('openerp.addons.base.ir.ir_model', 'openerp.models')
+    @mute_logger('odoo.addons.base.ir.ir_model', 'odoo.models')
-    @mute_logger('openerp.addons.mail.models.mail_mail')
+    @mute_logger('odoo.addons.mail.models.mail_mail')
-    @mute_logger('openerp.addons.mail.models.mail_mail')
+    @mute_logger('odoo.addons.mail.models.mail_mail')
-    # @mute_logger('openerp.addons.mail.models.mail_mail')
+    # @mute_logger('odoo.addons.mail.models.mail_mail')
-    @mute_logger('openerp.addons.mail.models.mail_mail')
+    @mute_logger('odoo.addons.mail.models.mail_mail')
-    @mute_logger('openerp.addons.mail.models.mail_mail')
+    @mute_logger('odoo.addons.mail.models.mail_mail')
-    @mute_logger('openerp.addons.mail.models.mail_mail')
+    @mute_logger('odoo.addons.mail.models.mail_mail')
-    @mute_logger('openerp.addons.mail.models.mail_mail')
+    @mute_logger('odoo.addons.mail.models.mail_mail')
-    @mute_logger('openerp.addons.mail.models.mail_mail')
+    @mute_logger('odoo.addons.mail.models.mail_mail')
-    @mute_logger('openerp.addons.mail.models.mail_mail')
+    @mute_logger('odoo.addons.mail.models.mail_mail')
-    @mute_logger('openerp.addons.mail.models.mail_mail')
+    @mute_logger('odoo.addons.mail.models.mail_mail')
-    @mute_logger('openerp.addons.mail.models.mail_mail')
+    @mute_logger('odoo.addons.mail.models.mail_mail')
-    @mute_logger('openerp.addons.mail.models.mail_thread')
+    @mute_logger('odoo.addons.mail.models.mail_thread')
-    @mute_logger('openerp.addons.mail.models.mail_thread')
+    @mute_logger('odoo.addons.mail.models.mail_thread')
-    @mute_logger('openerp.addons.mail.models.mail_thread', 'openerp.models')
+    @mute_logger('odoo.addons.mail.models.mail_thread', 'odoo.models')
-    @mute_logger('openerp.addons.mail.models.mail_thread', 'openerp.models')
+    @mute_logger('odoo.addons.mail.models.mail_thread', 'odoo.models')
-    @mute_logger('openerp.addons.mail.models.mail_thread', 'openerp.models')
+    @mute_logger('odoo.addons.mail.models.mail_thread', 'odoo.models')
-    @mute_logger('openerp.addons.mail.models.mail_thread', 'openerp.models')
+    @mute_logger('odoo.addons.mail.models.mail_thread', 'odoo.models')
-    @mute_logger('openerp.addons.mail.models.mail_thread', 'openerp.models', 'openerp.addons.mail.models.mail_mail')
+    @mute_logger('odoo.addons.mail.models.mail_thread', 'odoo.models', 'odoo.addons.mail.models.mail_mail')
-    @mute_logger('openerp.addons.mail.models.mail_thread', 'openerp.models', 'openerp.addons.mail.models.mail_mail')
+    @mute_logger('odoo.addons.mail.models.mail_thread', 'odoo.models', 'odoo.addons.mail.models.mail_mail')
-    @mute_logger('openerp.addons.mail.models.mail_thread', 'openerp.models')
+    @mute_logger('odoo.addons.mail.models.mail_thread', 'odoo.models')
-    @mute_logger('openerp.addons.mail.models.mail_thread', 'openerp.models')
+    @mute_logger('odoo.addons.mail.models.mail_thread', 'odoo.models')
-    @mute_logger('openerp.addons.mail.models.mail_thread', 'openerp.models', 'openerp.addons.mail.models.mail_mail')
+    @mute_logger('odoo.addons.mail.models.mail_thread', 'odoo.models', 'odoo.addons.mail.models.mail_mail')
-    @mute_logger('openerp.addons.mail.models.mail_thread', 'openerp.models')
+    @mute_logger('odoo.addons.mail.models.mail_thread', 'odoo.models')
-    @mute_logger('openerp.addons.mail.models.mail_thread', 'openerp.models')
+    @mute_logger('odoo.addons.mail.models.mail_thread', 'odoo.models')
-    @mute_logger('openerp.addons.mail.models.mail_thread', 'openerp.models')
+    @mute_logger('odoo.addons.mail.models.mail_thread', 'odoo.models')
-    @mute_logger('openerp.addons.mail.models.mail_thread', 'openerp.models')
+    @mute_logger('odoo.addons.mail.models.mail_thread', 'odoo.models')
-    @mute_logger('openerp.addons.mail.models.mail_thread', 'openerp.models')
+    @mute_logger('odoo.addons.mail.models.mail_thread', 'odoo.models')
-    @mute_logger('openerp.addons.mail.models.mail_thread', 'openerp.models')
+    @mute_logger('odoo.addons.mail.models.mail_thread', 'odoo.models')
-    @mute_logger('openerp.addons.mail.models.mail_thread', 'openerp.models')
+    @mute_logger('odoo.addons.mail.models.mail_thread', 'odoo.models')
-    @mute_logger('openerp.addons.mail.models.mail_thread', 'openerp.models')
+    @mute_logger('odoo.addons.mail.models.mail_thread', 'odoo.models')
-    @mute_logger('openerp.addons.mail.models.mail_thread', 'openerp.models')
+    @mute_logger('odoo.addons.mail.models.mail_thread', 'odoo.models')
-    @mute_logger('openerp.addons.mail.models.mail_thread', 'openerp.models')
+    @mute_logger('odoo.addons.mail.models.mail_thread', 'odoo.models')
-    @mute_logger('openerp.addons.mail.models.mail_thread', 'openerp.models')
+    @mute_logger('odoo.addons.mail.models.mail_thread', 'odoo.models')
-    @mute_logger('openerp.addons.mail.models.mail_thread', 'openerp.models', 'openerp.addons.mail.models.mail_mail')
+    @mute_logger('odoo.addons.mail.models.mail_thread', 'odoo.models', 'odoo.addons.mail.models.mail_mail')
-    @mute_logger('openerp.addons.mail.models.mail_thread', 'openerp.models', 'openerp.addons.mail.models.mail_mail')
+    @mute_logger('odoo.addons.mail.models.mail_thread', 'odoo.models', 'odoo.addons.mail.models.mail_mail')
-    @mute_logger('openerp.addons.mail.models.mail_mail')
+    @mute_logger('odoo.addons.mail.models.mail_mail')
-    @mute_logger('openerp.addons.base.ir.ir_model', 'openerp.models')
+    @mute_logger('odoo.addons.base.ir.ir_model', 'odoo.models')
-    @mute_logger('openerp.models')
+    @mute_logger('odoo.models')
-    @mute_logger('openerp.addons.base.ir.ir_model')
+    @mute_logger('odoo.addons.base.ir.ir_model')
-    @mute_logger('openerp.models')
+    @mute_logger('odoo.models')
-    @mute_logger('openerp.models')
+    @mute_logger('odoo.models')
-    @mute_logger('openerp.addons.mail.models.mail_mail')
+    @mute_logger('odoo.addons.mail.models.mail_mail')
-    @mute_logger('openerp.addons.mail.models.mail_mail')
+    @mute_logger('odoo.addons.mail.models.mail_mail')
-    @mute_logger('openerp.addons.mail.models.mail_mail')
+    @mute_logger('odoo.addons.mail.models.mail_mail')
-    @mute_logger('openerp.addons.payment_buckaroo.models.payment', 'ValidationError')
+    @mute_logger('odoo.addons.payment_buckaroo.models.payment', 'ValidationError')
-    @mute_logger('openerp.addons.payment_ogone.models.payment', 'ValidationError')
+    @mute_logger('odoo.addons.payment_ogone.models.payment', 'ValidationError')
-    @mute_logger('openerp.addons.payment_paypal.models.payment', 'ValidationError')
+    @mute_logger('odoo.addons.payment_paypal.models.payment', 'ValidationError')
-        with mute_logger('openerp.addons.payment_stripe.models.payment'):
+        with mute_logger('odoo.addons.payment_stripe.models.payment'):
-    @mute_logger('openerp.addons.mail.models.mail_mail')
+    @mute_logger('odoo.addons.mail.models.mail_mail')
-                with tools.mute_logger('openerp.sql_db'):
+                with tools.mute_logger('odoo.sql_db'):
-                    with self._cr.savepoint(), tools.mute_logger('openerp.sql_db'):
+                    with self._cr.savepoint(), tools.mute_logger('odoo.sql_db'):
-    @mute_logger('openerp.addons.base.ir.ir_model')
+    @mute_logger('odoo.addons.base.ir.ir_model')
-    @mute_logger('openerp.addons.base.ir.ir_model')
+    @mute_logger('odoo.addons.base.ir.ir_model')
-    @mute_logger('openerp.addons.mail.mail_thread')
+    @mute_logger('odoo.addons.mail.mail_thread')
-    @mute_logger('openerp.addons.mail.mail_thread')
+    @mute_logger('odoo.addons.mail.mail_thread')
-    @mute_logger('odoo.addons.base.ir.ir_model', 'openerp.osv.orm')
+    @mute_logger('odoo.addons.base.ir.ir_model', 'odoo.osv.orm')
-    @mute_logger('openerp.addons.base.ir.ir_model', 'openerp.models')
+    @mute_logger('odoo.addons.base.ir.ir_model', 'odoo.models')
-    @mute_logger('openerp.addons.base.ir.ir_model', 'openerp.models')
+    @mute_logger('odoo.addons.base.ir.ir_model', 'odoo.models')
-    @mute_logger('openerp.addons.base.ir.ir_model', 'openerp.models')
+    @mute_logger('odoo.addons.base.ir.ir_model', 'odoo.models')
-    @mute_logger('openerp.addons.base.ir.ir_model', 'openerp.models')
+    @mute_logger('odoo.addons.base.ir.ir_model', 'odoo.models')
-    @mute_logger('openerp.addons.base.ir.ir_model', 'openerp.models')
+    @mute_logger('odoo.addons.base.ir.ir_model', 'odoo.models')
-    @mute_logger('openerp.addons.base.ir.ir_model')
+    @mute_logger('odoo.addons.base.ir.ir_model')
-    @mute_logger('openerp.addons.base.ir.ir_model', 'openerp.models')
+    @mute_logger('odoo.addons.base.ir.ir_model', 'odoo.models')
-_test_logger = logging.getLogger('openerp.tests')
+_test_logger = logging.getLogger('odoo.tests')
-    @mute_logger('openerp.models')
+    @mute_logger('odoo.models')
-    @mute_logger('openerp.models')
+    @mute_logger('odoo.models')
-            with mute_logger('openerp.models'):
+            with mute_logger('odoo.models'):
-    @mute_logger('openerp.models')
+    @mute_logger('odoo.models')
-    @mute_logger('openerp.models')
+    @mute_logger('odoo.models')
-    @mute_logger('openerp.models')
+    @mute_logger('odoo.models')
-    @mute_logger('openerp.models')
+    @mute_logger('odoo.models')
-    @mute_logger('openerp.models')
+    @mute_logger('odoo.models')
-    @mute_logger('openerp.models')
+    @mute_logger('odoo.models')
-    @mute_logger('openerp.models')
+    @mute_logger('odoo.models')
-    @mute_logger('openerp.models')
+    @mute_logger('odoo.models')
-    @mute_logger('openerp.models')
+    @mute_logger('odoo.models')
-    @mute_logger('openerp.models')
+    @mute_logger('odoo.models')
-    @mute_logger('openerp.addons.base.ir.ir_model')
+    @mute_logger('odoo.models')
-    @mute_logger('openerp.models')
+    @mute_logger('odoo.models')
-    @mute_logger('openerp.models')
+    @mute_logger('odoo.models')
-    @mute_logger('openerp.models')
+    @mute_logger('odoo.models')
-    @mute_logger('openerp.models')
+    @mute_logger('odoo.models')
-    @mute_logger('openerp.models')
+    @mute_logger('odoo.models')
-    @mute_logger('openerp.models')
+    @mute_logger('odoo.models')
-    @mute_logger('openerp.models')
+    @mute_logger('odoo.models')
-    @mute_logger('openerp.models')
+    @mute_logger('odoo.models')
-    @mute_logger('openerp.models')
+    @mute_logger('odoo.models')
-    @mute_logger('openerp.models')
+    @mute_logger('odoo.models')
-    @mute_logger('openerp.tools.safe_eval')
+    @mute_logger('odoo.tools.safe_eval')
-    @mute_logger('openerp.sql_db')
+    @mute_logger('odoo.sql_db')
-    @mute_logger('openerp.sql_db')
+    @mute_logger('odoo.sql_db')
-    @mute_logger('openerp.addons.base.ir.ir_model', 'openerp.models')
+    @mute_logger('odoo.addons.base.ir.ir_model', 'odoo.models')
-    @mute_logger('openerp.models')
+    @mute_logger('odoo.models')
-    @mute_logger('openerp.models')
+    @mute_logger('odoo.models')
-    @mute_logger('openerp.models')
+    @mute_logger('odoo.models')
-    @mute_logger('openerp.models')
+    @mute_logger('odoo.models')
-    @mute_logger('openerp.models')
+    @mute_logger('odoo.models')
-    @mute_logger('openerp.models')
+    @mute_logger('odoo.models')
-    @mute_logger('openerp.addons.base.ir.ir_ui_view')
+    @mute_logger('odoo.addons.base.ir.ir_ui_view')
-    @mute_logger('openerp.addons.base.ir.ir_ui_view')
+    @mute_logger('odoo.addons.base.ir.ir_ui_view')
-    @mute_logger('openerp.addons.base.ir.ir_ui_view')
+    @mute_logger('odoo.addons.base.ir.ir_ui_view')
-    @mute_logger('openerp.sql_db')
+    @mute_logger('odoo.sql_db')
-    @mute_logger('openerp.sql_db')
+    @mute_logger('odoo.sql_db')
-    @mute_logger('openerp.sql_db', 'openerp.models')
+    @mute_logger('odoo.sql_db', 'odoo.models')
-    @mute_logger('openerp.sql_db', 'openerp.models')
+    @mute_logger('odoo.sql_db', 'odoo.models')
-    @mute_logger('openerp.sql_db', 'openerp.models')
+    @mute_logger('odoo.sql_db', 'odoo.models')
-    @mute_logger('openerp.sql_db')
+    @mute_logger('odoo.sql_db')
-    @mute_logger('openerp.sql_db')
+    @mute_logger('odoo.sql_db')
-    @mute_logger('openerp.addons.base.ir.ir_model')
+    @mute_logger('odoo.addons.base.ir.ir_model')
-    @mute_logger('openerp.addons.base.ir.ir_model')
+    @mute_logger('odoo.addons.base.ir.ir_model')
-            release_py = os.path.join(path, 'openerp/release.py')
+            release_py = os.path.join(path, 'odoo/release.py')
-        openerp.cli.main()
+        import odoo
-# in openerp.cli.server was working.
+# in odoo.cli.server was working.
-from openerp.tools.translate import _
+from odoo.tools.translate import _
-from openerp.tools import safe_eval
+import openerp.tools.safe_eval as safe_eval
-from openerp.tools import frozendict, classproperty
+from odoo.tools import frozendict, classproperty
-    Should raise :class:`~openerp.exceptions.ValidationError` if the
+    Should raise :class:`~odoo.exceptions.ValidationError` if the
-            is a single record with :meth:`~openerp.models.Model.ensure_one`.
+            is a single record with :meth:`~odoo.models.Model.ensure_one`.
-        from openerp.fields import SpecialValue
+        from odoo.fields import SpecialValue
-from openerp.modules.registry import Registry
+from odoo import SUPERUSER_ID
-import openerp
+import odoo
-from openerp.modules import get_modules, get_module_path
+import odoo
-    """Subclass this class to define new openerp subcommands """
+    """Subclass this class to define new odoo subcommands """
-        openerp.tools.config._parse_config([args[0]])
+        odoo.tools.config._parse_config([args[0]])
-                __import__('openerp.addons.' + module)
+                __import__('odoo.addons.' + module)
-from openerp.modules.module import (get_module_root, MANIFEST, load_information_from_description_file as load_manifest)
+from odoo.modules.module import (get_module_root, MANIFEST, load_information_from_description_file as load_manifest)
-import openerp
+import odoo
-__version__ = openerp.release.version
+__author__ = odoo.release.author
-_logger = logging.getLogger('openerp')
+# Also use the `odoo` logger for the main script.
-    config = openerp.tools.config
+    config = odoo.tools.config
-    config = openerp.tools.config
+    config = odoo.tools.config
-    _logger.info('addons paths: %s', openerp.modules.module.ad_paths)
+    _logger.info('addons paths: %s', odoo.modules.module.ad_paths)
-    config = openerp.tools.config
+    config = odoo.tools.config
-    if not openerp.evented and config['pidfile']:
+    config = odoo.tools.config
-    config = openerp.tools.config
+    config = odoo.tools.config
-        with openerp.api.Environment.manage():
+        registry = odoo.modules.registry.Registry.new(dbname)
-                openerp.tools.trans_export(config["language"],
+                odoo.tools.trans_export(config["language"],
-    config = openerp.tools.config
+    config = odoo.tools.config
-    with openerp.api.Environment.manage():
+    registry = odoo.modules.registry.Registry.new(dbname)
-            openerp.tools.trans_load(
+            odoo.tools.trans_load(
-    openerp.tools.config.parse_config(args)
+    odoo.tools.config.parse_config(args)
-    config = openerp.tools.config
+    config = odoo.tools.config
-            except openerp.service.db.DatabaseExists:
+                odoo.service.db._create_empty_database(db_name)
-        openerp.multi_process = True
+        odoo.multi_process = True
-    rc = openerp.service.server.start(preload=preload, stop=stop)
+    rc = odoo.service.server.start(preload=preload, stop=stop)
-import openerp
+import odoo
-        openerp.service.server.start(preload=[], stop=True)
+        odoo.tools.config.parse_config(args)
-            'openerp': openerp
+            'openerp': odoo
-        with openerp.api.Environment.manage():
+        with odoo.api.Environment.manage():
-                registry = openerp.registry(dbname)
+                registry = odoo.registry(dbname)
-                    env = openerp.api.Environment(cr, uid, ctx)
+                    uid = odoo.SUPERUSER_ID
-        self.shell(openerp.tools.config['db_name'])
+        self.shell(odoo.tools.config['db_name'])
-from openerp.service.db import _create_empty_database, DatabaseExists
+from odoo.modules.module import get_module_root, MANIFEST
-from openerp.tools.translate import html_translate, _
+from odoo.sql_db import LazyCursor
-        recordset. The decorator :meth:`openerp.api.depends` must be applied on
+        recordset. The decorator :meth:`odoo.api.depends` must be applied on
-        is extended (see :class:`~openerp.models.Model`), one can also extend
+        is extended (see :class:`~odoo.models.Model`), one can also extend
-from openerp import SUPERUSER_ID
+from odoo import SUPERUSER_ID
-from openerp.tools import ustr, consteq, frozendict
+import odoo
-                 openerp.exceptions.RedirectWarning)
+NO_POSTMORTEM = (odoo.osv.orm.except_orm,
-                openerp.netsvc.log(rpc_request, logging.DEBUG, '%s.%s' % (service_name, method), replace_request_password(params))
+                odoo.netsvc.log(rpc_request, logging.DEBUG, '%s.%s' % (service_name, method), replace_request_password(params))
-            dispatch = openerp.service.common.dispatch
+            dispatch = odoo.service.common.dispatch
-            dispatch = openerp.service.db.dispatch
+            dispatch = odoo.service.db.dispatch
-            dispatch = openerp.service.model.dispatch
+            dispatch = odoo.service.model.dispatch
-            dispatch = openerp.service.report.dispatch
+            dispatch = odoo.service.report.dispatch
-                openerp.netsvc.log(rpc_response, logging.DEBUG, logline, result)
+                odoo.netsvc.log(rpc_response, logging.DEBUG, logline, result)
-                openerp.netsvc.log(rpc_request, logging.DEBUG, logline, replace_request_password(params), depth=1)
+                odoo.netsvc.log(rpc_request, logging.DEBUG, logline, replace_request_password(params), depth=1)
-        openerp.tools.debugger.post_mortem(openerp.tools.config, e.traceback)
+    except odoo.exceptions.DeferredException, e:
-        openerp.tools.debugger.post_mortem(openerp.tools.config, sys.exc_info())
+        _logger.exception(odoo.tools.exception_to_unicode(e))
-        # dispatching phase in openerp.service.wsgi_server.application
+        # dispatching phase in odoo.service.wsgi_server.application
-        """ :class:`~openerp.sql_db.Cursor` initialized for the current method call.
+        """ :class:`~odoo.sql_db.Cursor` initialized for the current method call.
-        """ The :class:`~openerp.api.Environment` bound to current request. """
+        """ The :class:`~odoo.api.Environment` bound to current request. """
-            self._env = openerp.api.Environment(self.cr, self.uid, self.context)
+            self._env = odoo.api.Environment(self.cr, self.uid, self.context)
-                openerp.tools.config, sys.exc_info())
+            odoo.tools.debugger.post_mortem(
-        return openerp.registry(self.db) if self.db else None
+        return odoo.registry(self.db) if self.db else None
-          :data:`~openerp.http.request` object is available by default
+          <odoo.http.WebRequest.csrf_token`, the
-            if not isinstance(exception, (openerp.exceptions.Warning, SessionExpiredException, openerp.exceptions.except_orm)):
+            if not isinstance(exception, (odoo.exceptions.Warning, SessionExpiredException, odoo.exceptions.except_orm)):
-    if isinstance(e, openerp.exceptions.UserError):
+    if isinstance(e, odoo.exceptions.UserError):
-    elif isinstance(e, openerp.exceptions.Warning):
+    elif isinstance(e, odoo.exceptions.Warning):
-    elif isinstance(e, openerp.exceptions.RedirectWarning):
+    elif isinstance(e, odoo.exceptions.RedirectWarning):
-    elif isinstance(e, openerp.exceptions.AccessError):
+    elif isinstance(e, odoo.exceptions.AccessError):
-    elif isinstance(e, openerp.exceptions.MissingError):
+    elif isinstance(e, odoo.exceptions.MissingError):
-    elif isinstance(e, openerp.exceptions.AccessDenied):
+    elif isinstance(e, odoo.exceptions.AccessDenied):
-    elif isinstance(e, openerp.exceptions.ValidationError):
+    elif isinstance(e, odoo.exceptions.ValidationError):
-    elif isinstance(e, openerp.exceptions.except_orm):
+    elif isinstance(e, odoo.exceptions.except_orm):
-        if not class_path[:2] == ["openerp", "addons"]:
+        if not class_path[:2] == ["odoo", "addons"]:
-            return c.__module__.startswith('openerp.addons.') and c.__module__.split(".")[2] in modules
+            return c.__module__.startswith('odoo.addons.') and c.__module__.split(".")[2] in modules
-        env = request.env(user=self.uid or request.uid or openerp.SUPERUSER_ID)
+        env = request.env(user=self.uid or request.uid or odoo.SUPERUSER_ID)
-        path = openerp.tools.config.session_dir
+        path = odoo.tools.config.session_dir
-        return routing_map([''] + openerp.conf.server_wide_modules, True)
+        return routing_map([''] + odoo.conf.server_wide_modules, True)
-        for addons_path in openerp.modules.module.ad_paths:
+        for addons_path in odoo.modules.module.ad_paths:
-                            m = __import__('openerp.addons.' + module)
+                        if 'odoo.addons' in sys.modules:
-                    openerp.registry(db).check_signaling()
+                    odoo.registry(db).check_signaling()
-                        with openerp.tools.mute_logger('openerp.sql_db'):
+                        with odoo.tools.mute_logger('odoo.sql_db'):
-    dbs = openerp.service.db.list_dbs(force)
+    dbs = odoo.service.db.list_dbs(force)
-    r = openerp.tools.config['dbfilter'].replace('%h', h).replace('%d', d)
+    r = odoo.tools.config['dbfilter'].replace('%h', h).replace('%d', d)
-            server_format = openerp.tools.misc.DEFAULT_SERVER_DATETIME_FORMAT
+            server_format = odoo.tools.misc.DEFAULT_SERVER_DATETIME_FORMAT
-    filename = openerp.tools.ustr(filename)
+    filename = odoo.tools.ustr(filename)
-    # str subclasses such as `openerp.tools.unquote`
+    # str subclasses such as `odoo.tools.unquote`
-import openerp
+import odoo
-    """ Check if the given name is a valid openerp object name.
+    """ Check if the given name is a valid model name.
-        # The (OpenERP) module name can be in the ``openerp.addons`` namespace
+        # The (OpenERP) module name can be in the ``odoo.addons`` namespace
-        # ``openerp.addons.sale`` (the right way) or ``sale`` (for backward
+        # ``odoo.addons.sale`` (the right way) or ``sale`` (for backward
-        if len(module_parts) > 2 and module_parts[:2] == ['openerp', 'addons']:
+        if len(module_parts) > 2 and module_parts[:2] == ['odoo', 'addons']:
-            record[self.CONCURRENCY_CHECK_FIELD] = openerp.fields.Datetime.now()
+            record[self.CONCURRENCY_CHECK_FIELD] = odoo.fields.Datetime.now()
-                record.write_date or record.create_date or openerp.fields.Datetime.now()
+                record.write_date or record.create_date or odoo.fields.Datetime.now()
-        from openerp.fields import Char, Integer
+        from odoo.fields import Char, Integer
-        from openerp.http import request
+        from odoo.http import request
-            access_rights_uid=openerp.SUPERUSER_ID,
+            access_rights_uid=odoo.SUPERUSER_ID,
-        from openerp import workflow
+        from odoo import workflow
-        from openerp import workflow
+        from odoo import workflow
-        from openerp import workflow
+        from odoo import workflow
-        from openerp import workflow
+        from odoo import workflow
-        from openerp import workflow
+        from odoo import workflow
-          :class:`~openerp.fields.Float`) the value should be of the
+        * For numeric fields (:class:`~odoo.fields.Integer`,
-        * For :class:`~openerp.fields.Boolean`, the value should be a
+        * For :class:`~odoo.fields.Boolean`, the value should be a
-        * For :class:`~openerp.fields.Selection`, the value should match the
+        * For :class:`~odoo.fields.Selection`, the value should match the
-        * For :class:`~openerp.fields.Many2one`, the value should be the
+        * For :class:`~odoo.fields.Many2one`, the value should be the
-              :class:`~openerp.fields.Datetime` fields use strings as values
+              :class:`~odoo.fields.Date` and
-              :const:`openerp.tools.misc.DEFAULT_SERVER_DATETIME_FORMAT`
+              :const:`odoo.tools.misc.DEFAULT_SERVER_DATE_FORMAT` and
-          :class:`~openerp.fields.Many2many` use a special "commands" format to
+          :class:`~odoo.fields.One2many` and
-              :class:`~openerp.fields.One2many`. Can not be used in
+              :class:`~odoo.fields.One2many`. Can not be used in
-              used on :class:`~openerp.fields.One2many`.
+              used on :class:`~odoo.fields.One2many`.
-              :class:`~openerp.fields.One2many`. Can not be used in
+              :class:`~odoo.fields.One2many`. Can not be used in
-              :class:`~openerp.fields.One2many`.
+              :class:`~odoo.fields.One2many`.
-        :type env: :class:`~openerp.api.Environment`
+        :type env: :class:`~odoo.api.Environment`
-from openerp.modules.loading import load_modules
+from odoo.modules.loading import load_modules
-from openerp.modules.module import (
+from odoo.modules.module import (
-import openerp.modules
+import odoo.modules
-    f = openerp.modules.get_module_resource('base', 'base.sql')
+    f = odoo.modules.get_module_resource('base', 'base.sql')
-    base_sql_file = openerp.tools.misc.file_open(f)
+    base_sql_file = odoo.tools.misc.file_open(f)
-        mod_path = openerp.modules.get_module_path(i)
+    for i in odoo.modules.get_modules():
-        info = openerp.modules.load_information_from_description_file(i)
+        info = odoo.modules.load_information_from_description_file(i)
-import openerp
+import odoo
-from openerp.tools.translate import _
+import odoo.osv as osv
-import openerp.release as release
+import odoo.release as release
-            info = openerp.modules.module.load_information_from_description_file(module)
+            info = odoo.modules.module.load_information_from_description_file(module)
-import openerp.tools as tools
+import odoo
-                                   load_openerp_module, runs_post_install
+from odoo import api, SUPERUSER_ID
-_test_logger = logging.getLogger('openerp.tests')
+_test_logger = logging.getLogger('odoo.tests')
-                openerp.registry(cr.dbname).clear_caches()
+                odoo.registry(cr.dbname).clear_caches()
-    migrations = openerp.modules.migration.MigrationManager(cr, graph)
+    registry = odoo.registry(cr.dbname)
-    t0_sql = openerp.sql_db.sql_counter
+    t0_sql = odoo.sql_db.sql_counter
-            py_module = sys.modules['openerp.addons.%s' % (module_name,)]
+            py_module = sys.modules['odoo.addons.%s' % (module_name,)]
-            overwrite = openerp.tools.config["overwrite_existing_translations"]
+            overwrite = odoo.tools.config["overwrite_existing_translations"]
-                    report.record_result(openerp.modules.module.run_unit_tests(module_name, cr.dbname))
+                    report.record_result(odoo.modules.module.run_unit_tests(module_name, cr.dbname))
-    _logger.log(25, "%s modules loaded in %.2fs, %s queries", len(graph), time.time() - t0, openerp.sql_db.sql_counter - t0_sql)
+    _logger.log(25, "%s modules loaded in %.2fs, %s queries", len(graph), time.time() - t0, odoo.sql_db.sql_counter - t0_sql)
-        if not openerp.modules.db.is_initialized(cr):
+        if not odoo.modules.db.is_initialized(cr):
-            openerp.modules.db.initialize(cr)
+            odoo.modules.db.initialize(cr)
-        registry = openerp.registry(cr.dbname)
+        # odoo.modules.registry.Registry.new().
-        graph = openerp.modules.graph.Graph()
+        graph = odoo.modules.graph.Graph()
-                        py_module = sys.modules['openerp.addons.%s' % (pkg.name,)]
+                        py_module = sys.modules['odoo.addons.%s' % (pkg.name,)]
-                return openerp.modules.registry.Registry.new(cr.dbname, force_demo, status, update_module)
+                return odoo.modules.registry.Registry.new(cr.dbname, force_demo, status, update_module)
-        if openerp.tools.config['test_enable']:
+        t0_sql = odoo.sql_db.sql_counter
-            _logger.log(25, "All post-tested in %.2fs, %s queries", time.time() - t0, openerp.sql_db.sql_counter - t0_sql)
+                report.record_result(odoo.modules.module.run_unit_tests(module_name[0], cr.dbname, position=runs_post_install))
-from openerp.tools.parse_version import parse_version
+import odoo
-            get_module_filetree = openerp.modules.module.get_module_filetree
+            get_module_filetree = odoo.modules.module.get_module_filetree
-from openerp.tools.safe_eval import safe_eval
+import odoo
-    """
+    """ Makes modules accessible through openerp.addons.* and odoo.addons.* """
-        new_mod = types.ModuleType(openerp_name)
+        # create empty odoo.addons.* module, set name
-        new_mod.__package__ = openerp_name
+        new_mod.__package__ = odoo_name
-        sys.modules[openerp_name] = sys.modules[odoo_name] = new_mod
+        sys.modules[odoo_name] = sys.modules[openerp_name] = new_mod
-        setattr(openerp.addons, addon_name, new_mod)
+        setattr(odoo.addons, addon_name, new_mod)
-    """
+    """ Makes odoo package also available as openerp """
-        if re.match(r'^odoo\b', name):
+        if re.match(r'^openerp\b', name):
-        canonical = re.sub(r'^odoo(.*)', r'openerp\g<1>', name)
+        canonical = re.sub(r'^openerp(.*)', r'odoo\g<1>', name)
-    ``import openerp.addons.crm``) works even if the addons are not in the
+    ``import odoo.addons.crm``) works even if the addons are not in the
-    files = openerp.tools.osutil.listdir(path, True)
+    files = odoo.tools.osutil.listdir(path, True)
-        __import__('openerp.addons.' + module_name)
+        __import__('odoo.addons.' + module_name)
-            getattr(sys.modules['openerp.addons.' + module_name], info['post_load'])()
+            getattr(sys.modules['odoo.addons.' + module_name], info['post_load'])()
-    modpath = 'openerp.addons.' + module
+    modpath = 'odoo.addons.' + module
-    def __init__(self, logger_name='openerp.tests'):
+    def __init__(self, logger_name='odoo.tests'):
-            t0_sql = openerp.sql_db.sql_counter
+            t0_sql = odoo.sql_db.sql_counter
-                _logger.log(25, "%s tested in %.2fs, %s queries", m.__name__, time.time() - t0, openerp.sql_db.sql_counter - t0_sql)
+                _logger.log(25, "%s tested in %.2fs, %s queries", m.__name__, time.time() - t0, odoo.sql_db.sql_counter - t0_sql)
-import openerp
+import odoo
-from openerp.tools import assertion_report, lazy_classproperty, config, \
+from odoo.tools import assertion_report, lazy_classproperty, config, \
-from openerp.tools.lru import LRU
+from odoo.tools.lru import LRU
-                # openerp.service.wsgi_server.application
+                # odoo.service.wsgi_server.application
-            with openerp.api.Environment.manage():
+            with odoo.api.Environment.manage():
-                    openerp.modules.load_modules(registry._db, force_demo, status, update_module)
+                    odoo.modules.load_modules(registry._db, force_demo, status, update_module)
-        self._db = openerp.sql_db.db_connect(db_name)
+        self._db = odoo.sql_db.db_connect(db_name)
-        # Inter-process signaling (used only when openerp.multi_process is True):
+        # Inter-process signaling (used only when odoo.multi_process is True):
-            if openerp.tools.config['unaccent'] and not has_unaccent:
+            has_unaccent = odoo.modules.db.has_unaccent(cr)
-            self.has_unaccent = openerp.tools.config['unaccent'] and has_unaccent
+            self.has_unaccent = odoo.tools.config['unaccent'] and has_unaccent
-        env = openerp.api.Environment(cr, SUPERUSER_ID, {})
+        env = odoo.api.Environment(cr, SUPERUSER_ID, {})
-        env = openerp.api.Environment(cr, SUPERUSER_ID, {})
+        env = odoo.api.Environment(cr, SUPERUSER_ID, {})
-        env = openerp.api.Environment(cr, SUPERUSER_ID, context)
+        env = odoo.api.Environment(cr, SUPERUSER_ID, context)
-        if not openerp.multi_process:
+        if not odoo.multi_process:
-        if not openerp.multi_process:
+        if not odoo.multi_process:
-        if openerp.multi_process:
+        if odoo.multi_process:
-        if openerp.multi_process and self.cache_cleared:
+        if odoo.multi_process and self.cache_cleared:
-import openerp
+import odoo
-    The openerp.netsvc.LocalService() function is deprecated. It still works
+    The odoo.netsvc.LocalService() function is deprecated. It still works
-    openerp.report.render_report() should be used (methods on the Model should
+    LocalService('workflow'), odoo.workflow should be used (better yet,
-    assert openerp.conf.deprecation.allow_local_service
+    assert odoo.conf.deprecation.allow_local_service
-        return openerp.workflow
+        return odoo.workflow
-        report = openerp.report.interface.report_int._reports.get(name)
+        report = odoo.report.interface.report_int._reports.get(name)
-                registry = openerp.registry(dbname)
+                registry = odoo.registry(dbname)
-        with tools.ignore(Exception), tools.mute_logger('openerp.sql_db'), sql_db.db_connect(dbname, allow_uri=True).cursor() as cr:
+        with tools.ignore(Exception), tools.mute_logger('odoo.sql_db'), sql_db.db_connect(dbname, allow_uri=True).cursor() as cr:
-    'openerp.sql_db:INFO',
+    'odoo.workflow.workitem:WARNING',
-    'debug_sql': ['openerp.sql_db:DEBUG'],
+    'debug_rpc_answer': ['odoo:DEBUG','odoo.http.rpc.request:DEBUG', 'odoo.http.rpc.response:DEBUG'],
-    'critical': ['openerp:CRITICAL', 'werkzeug:CRITICAL'],
+    'warn': ['odoo:WARNING', 'werkzeug:WARNING'],
-import openerp.modules
+import odoo.modules
-import openerp.tools as tools
+import odoo.tools as tools
-    if openerp.registry(cr.dbname).has_unaccent:
+    if odoo.registry(cr.dbname).has_unaccent:
-from openerp.tools.safe_eval import safe_eval
+from odoo.tools.safe_eval import safe_eval
-# openerp.osv.orm.modifiers_tests()
+# import odoo
-        from openerp.osv.expression import get_alias_from_query
+        from odoo.osv.expression import get_alias_from_query
-        from openerp.osv.expression import get_alias_from_query
+        from odoo.osv.expression import get_alias_from_query
-        from openerp.osv.expression import generate_table_alias
+        from odoo.osv.expression import generate_table_alias
-        from openerp.osv.expression import get_alias_from_query
+        from odoo.osv.expression import get_alias_from_query
-from openerp import api
+from odoo import api
-from openerp.tools.translate import _
+import odoo
-        env = openerp.api.Environment(cr, uid, context or {})
+        env = odoo.api.Environment(cr, uid, context or {})
-        env = openerp.api.Environment(cr, uid, context or {})
+        env = odoo.api.Environment(cr, uid, context or {})
-        env = openerp.api.Environment(cr, uid, context or {})
+        env = odoo.api.Environment(cr, uid, context or {})
-import openerp.tools as tools
+import odoo
-from openerp.modules import get_module_resource
+from odoo.modules import get_module_resource
-            assert openerp.conf.deprecation.allow_report_int_registration
+            assert odoo.conf.deprecation.allow_report_int_registration
-        env = openerp.api.Environment(cr, uid, context or {})
+        env = odoo.api.Environment(cr, uid, context or {})
-        env = openerp.api.Environment(cr, uid, context or {})
+        env = odoo.api.Environment(cr, uid, context or {})
-import openerp.tools as tools
+import odoo
-from openerp.tools.safe_eval import safe_eval
+from odoo.models import BaseModel
-        env = openerp.api.Environment(self.cr, self.uid, {})
+        env = odoo.api.Environment(self.cr, self.uid, {})
-        env = openerp.api.Environment(self.cr, self.uid, context or {})
+        env = odoo.api.Environment(self.cr, self.uid, context or {})
-from openerp.report.interface import report_int
+import odoo
-        env = openerp.api.Environment(cr, uid, context)
+        env = odoo.api.Environment(cr, uid, context)
-from openerp.tools.safe_eval import safe_eval
+import odoo
-        env = openerp.api.Environment(cr, uid, context)
+        env = odoo.api.Environment(cr, uid, context)
-        env = openerp.api.Environment(self.cr, uid, {})
+        env = odoo.api.Environment(self.cr, uid, {})
-from openerp.report.render.rml2pdf import utils
+from odoo.report.render.rml2pdf import utils
-from openerp.report.render.rml2pdf import utils
+from odoo.report.render.rml2pdf import utils
-from openerp.report.render.rml2pdf import utils
+from odoo.report.render.rml2pdf import utils
-from openerp.tools.safe_eval import safe_eval
+from odoo.tools.misc import file_open
-from openerp.tools.misc import ustr
+import odoo.tools as tools
-from openerp.tools.safe_eval import safe_eval
+from odoo.tools.safe_eval import safe_eval
-import openerp.tools as tools
+import odoo
-from openerp.tools.translate import _
+from odoo import fields
-        env = openerp.api.Environment(cr, uid, context)
+        env = odoo.api.Environment(cr, uid, context)
-            env = openerp.api.Environment(self.cr, self.uid, {})
+            env = odoo.api.Environment(self.cr, self.uid, {})
-        env = openerp.api.Environment(self.cr, self.uid, {})
+        env = odoo.api.Environment(self.cr, self.uid, {})
-            env = openerp.api.Environment(self.cr, self.uid, {})
+            env = odoo.api.Environment(self.cr, self.uid, {})
-            env = openerp.api.Environment(self.cr, self.uid, {})
+            env = odoo.api.Environment(self.cr, self.uid, {})
-    openerp.report.interface.report_int._reports dictionary:
+    odoo.netsvc.LocalService() indirection and the related
-        env = openerp.api.Environment(cr, uid, context or {})
+        env = odoo.api.Environment(cr, uid, context or {})
-        env = openerp.api.Environment(cr, uid, context)
+        env = odoo.api.Environment(cr, uid, context)
-        env = openerp.api.Environment(cr, uid, context)
+        env = odoo.api.Environment(cr, uid, context)
-from openerp.tools.translate import _
+import odoo.release
-        'server_serie': openerp.release.serie,
+        'server_version': odoo.release.version,
-    res_users = openerp.registry(db)['res.users']
+    res_users = odoo.registry(db)['res.users']
-        return info, openerp.release.version
+        return info, odoo.release.version
-    # `openerp.netsvc.Logger` class.
+    # `odoo.netsvc.Logger` class.
-import openerp.tools
+import odoo
-    if passwd and passwd == openerp.tools.config['admin_passwd']:
+    if passwd and passwd == odoo.tools.config['admin_passwd']:
-    raise openerp.exceptions.AccessDenied()
+    raise odoo.exceptions.AccessDenied()
-# This should be moved to openerp.modules.db, along side initialize().
+# This should be moved to odoo.modules.db, along side initialize().
-        db = openerp.sql_db.db_connect(db_name)
+        db = odoo.sql_db.db_connect(db_name)
-            openerp.tools.config['load_language'] = lang
+            odoo.modules.db.initialize(cr)
-        registry = openerp.modules.registry.Registry.new(db_name, demo, None, update_module=True)
+        registry = odoo.modules.registry.Registry.new(db_name, demo, None, update_module=True)
-            env = openerp.api.Environment(cr, SUPERUSER_ID, {})
+            env = odoo.api.Environment(cr, SUPERUSER_ID, {})
-                emails = openerp.tools.email_split(login)
+                emails = odoo.tools.email_split(login)
-    db = openerp.sql_db.db_connect('postgres')
+    db = odoo.sql_db.db_connect('postgres')
-        chosen_template = openerp.tools.config['db_template']
+        chosen_template = odoo.tools.config['db_template']
-    db = openerp.sql_db.db_connect('postgres')
+    odoo.sql_db.close_db(db_original_name)
-    registry = openerp.modules.registry.Registry.new(db_name)
+    registry = odoo.modules.registry.Registry.new(db_name)
-        env = openerp.api.Environment(cr, SUPERUSER_ID, {})
+        env = odoo.api.Environment(cr, SUPERUSER_ID, {})
-    to_fs = openerp.tools.config.filestore(db_name)
+    from_fs = odoo.tools.config.filestore(db_original_name)
-    openerp.sql_db.close_db(db_name)
+    odoo.modules.registry.Registry.delete(db_name)
-    db = openerp.sql_db.db_connect('postgres')
+    db = odoo.sql_db.db_connect('postgres')
-    fs = openerp.tools.config.filestore(db_name)
+    fs = odoo.tools.config.filestore(db_name)
-        'major_version': openerp.release.major_version,
+        'version': odoo.release.version,
-            filestore = openerp.tools.config.filestore(db_name)
+        with odoo.tools.osutil.tempdir() as dump_dir:
-                db = openerp.sql_db.db_connect(db_name)
+                db = odoo.sql_db.db_connect(db_name)
-            openerp.tools.exec_pg_command(*cmd)
+            odoo.tools.exec_pg_command(*cmd)
-                openerp.tools.osutil.zip_dir(dump_dir, stream, include_dir=False, fnct_sort=lambda file_name: file_name != 'dump.sql')
+                odoo.tools.osutil.zip_dir(dump_dir, stream, include_dir=False, fnct_sort=lambda file_name: file_name != 'dump.sql')
-                openerp.tools.osutil.zip_dir(dump_dir, t, include_dir=False, fnct_sort=lambda file_name: file_name != 'dump.sql')
+                odoo.tools.osutil.zip_dir(dump_dir, t, include_dir=False, fnct_sort=lambda file_name: file_name != 'dump.sql')
-        stdin, stdout = openerp.tools.exec_pg_command_pipe(*cmd)
+        stdin, stdout = odoo.tools.exec_pg_command_pipe(*cmd)
-    with openerp.tools.osutil.tempdir() as dump_dir:
+    with odoo.tools.osutil.tempdir() as dump_dir:
-        if openerp.tools.exec_pg_command(pg_cmd, *pg_args):
+        if odoo.tools.exec_pg_command(pg_cmd, *pg_args):
-        registry = openerp.modules.registry.Registry.new(db)
+        registry = odoo.modules.registry.Registry.new(db)
-            env = openerp.api.Environment(cr, SUPERUSER_ID, {})
+            env = odoo.api.Environment(cr, SUPERUSER_ID, {})
-            if openerp.tools.config['unaccent']:
+            if odoo.tools.config['unaccent']:
-    openerp.sql_db.close_db(old_name)
+    odoo.modules.registry.Registry.delete(old_name)
-    db = openerp.sql_db.db_connect('postgres')
+    db = odoo.sql_db.db_connect('postgres')
-    new_fs = openerp.tools.config.filestore(new_name)
+    old_fs = odoo.tools.config.filestore(old_name)
-    openerp.tools.config.save()
+    odoo.tools.config['admin_passwd'] = new_password
-        openerp.modules.registry.Registry.new(db, force_demo=False, update_module=True)
+        odoo.tools.config['update']['base'] = True
-@openerp.tools.mute_logger('openerp.sql_db')
+@odoo.tools.mute_logger('odoo.sql_db')
-    return bool(openerp.sql_db.db_connect(db_name))
+    return bool(odoo.sql_db.db_connect(db_name))
-    chosen_template = openerp.tools.config['db_template']
+    if not odoo.tools.config['list_db'] and not force:
-    db = openerp.sql_db.db_connect('postgres')
+    db = odoo.sql_db.db_connect('postgres')
-            db_user = openerp.tools.config["db_user"]
+            db_user = odoo.tools.config["db_user"]
-                cr.execute("select usename from pg_user where usesysid=(select datdba from pg_database where datname=%s)", (openerp.tools.config["db_name"],))
+                cr.execute("select usename from pg_user where usesysid=(select datdba from pg_database where datname=%s)", (odoo.tools.config["db_name"],))
-            res = [openerp.tools.ustr(name) for (name,) in cr.fetchall()]
+            res = [odoo.tools.ustr(name) for (name,) in cr.fetchall()]
-        raise openerp.exceptions.AccessDenied()
+    if not odoo.tools.config['list_db']:
-    return openerp.tools.scan_languages()
+    return odoo.tools.scan_languages()
-    root = ET.parse(os.path.join(openerp.tools.config['root_path'], 'addons/base/res/res_country_data.xml')).getroot()
+    root = ET.parse(os.path.join(odoo.tools.config['root_path'], 'addons/base/res/res_country_data.xml')).getroot()
-    return openerp.release.version
+    return odoo.release.version
-from openerp.tools.translate import _
+import odoo
-    # dispatching phase in openerp.service.wsgi_server.application
+    # dispatching phase in odoo.service.wsgi_server.application
-    registry = openerp.registry(db).check_signaling()
+    registry = odoo.registry(db).check_signaling()
-                    cr = openerp.sql_db.db_connect(dbname).cursor()
+                    cr = odoo.sql_db.db_connect(dbname).cursor()
-                cr = openerp.sql_db.db_connect(dbname).cursor()
+                cr = odoo.sql_db.db_connect(dbname).cursor()
-                    raise openerp.exceptions.Warning('Currently, this database is not fully loaded and can not be used.')
+                if odoo.registry(dbname)._init and not odoo.tools.config['test_enable']:
-                registry = openerp.registry(dbname)
+                registry = odoo.registry(dbname)
-    recs = openerp.api.Environment(cr, uid, {}).get(obj)
+    recs = odoo.api.Environment(cr, uid, {}).get(obj)
-    return openerp.api.call_kw(recs, method, args, kw)
+    return odoo.api.call_kw(recs, method, args, kw)
-    with openerp.registry(db).cursor() as cr:
+    with odoo.registry(db).cursor() as cr:
-    with openerp.registry(db).cursor() as cr:
+    with odoo.registry(db).cursor() as cr:
-from openerp.exceptions import UserError
+import odoo
-    registry = openerp.registry(db).check_signaling()
+    registry = odoo.registry(db).check_signaling()
-    cr = openerp.registry(db).cursor()
+    cr = odoo.registry(db).cursor()
-        result, format = openerp.report.render_report(cr, uid, ids, object, datas, context)
+        result, format = odoo.report.render_report(cr, uid, ids, object, datas, context)
-            self_reports[id]['exception'] = openerp.exceptions.DeferredException('RML is not available at specified location or not enough data to print!', tb)
+            self_reports[id]['exception'] = odoo.exceptions.DeferredException('RML is not available at specified location or not enough data to print!', tb)
-            self_reports[id]['exception'] = openerp.exceptions.DeferredException(tools.ustr(exception.name), tools.ustr(exception.value))
+            self_reports[id]['exception'] = odoo.exceptions.DeferredException(tools.ustr(exception.name), tools.ustr(exception.value))
-            self_reports[id]['exception'] = openerp.exceptions.DeferredException(tools.exception_to_unicode(exception), tb)
+            self_reports[id]['exception'] = odoo.exceptions.DeferredException(tools.exception_to_unicode(exception), tb)
-            cr = openerp.registry(db).cursor()
+        with odoo.api.Environment.manage():
-                result, format = openerp.report.render_report(cr, uid, ids, object, datas, context)
+                result, format = odoo.report.render_report(cr, uid, ids, object, datas, context)
-                    self_reports[id]['exception'] = openerp.exceptions.DeferredException('RML is not available at specified location or not enough data to print!', tb)
+                    self_reports[id]['exception'] = odoo.exceptions.DeferredException('RML is not available at specified location or not enough data to print!', tb)
-                    self_reports[id]['exception'] = openerp.exceptions.DeferredException(tools.ustr(exception.name), tools.ustr(exception.value))
+                    self_reports[id]['exception'] = odoo.exceptions.DeferredException(tools.ustr(exception.name), tools.ustr(exception.value))
-                    self_reports[id]['exception'] = openerp.exceptions.DeferredException(tools.exception_to_unicode(exception), tb)
+                    self_reports[id]['exception'] = odoo.exceptions.DeferredException(tools.exception_to_unicode(exception), tb)
-import openerp.exceptions
+import odoo
-    res_users = openerp.registry(db)['res.users']
+    res_users = odoo.registry(db)['res.users']
-    res_users = openerp.registry(db)['res.users']
+    res_users = odoo.registry(db)['res.users']
-from openerp.tools import stripped_sys_argv, dumpstacks, log_ormcache_stats
+import odoo
-        me.name = 'openerp.service.http.request.%s' % (me.ident,)
+        me.name = 'odoo.service.http.request.%s' % (me.ident,)
-        for path in openerp.modules.module.ad_paths:
+        for path in odoo.modules.module.ad_paths:
-            openerp.phoenix = True
+            odoo.phoenix = True
-            registries = openerp.modules.registry.Registry.registries
+            registries = odoo.modules.registry.Registry.registries
-                    acquired = openerp.addons.base.ir.ir_cron.ir_cron._acquire_job(db_name)
+                    acquired = odoo.addons.base.ir.ir_cron.ir_cron._acquire_job(db_name)
-        for i in range(openerp.tools.config['max_cron_threads']):
+        for i in range(odoo.tools.config['max_cron_threads']):
-            t = threading.Thread(target=target, name="openerp.service.cron.cron%d" % i)
+            t = threading.Thread(target=target, name="odoo.service.cron.cron%d" % i)
-        t = threading.Thread(target=self.http_thread, name="openerp.service.httpd")
+        t = threading.Thread(target=self.http_thread, name="odoo.service.httpd")
-        openerp.modules.registry.Registry.delete_all()
+        odoo.modules.registry.Registry.delete_all()
-                openerp.phoenix = True
+                odoo.phoenix = True
-        openerp.sql_db.close_all()
+        odoo.sql_db.close_all()
-        setproctitle('openerp: %s %s %s' % (self.__class__.__name__, self.pid, title))
+        setproctitle('odoo: %s %s %s' % (self.__class__.__name__, self.pid, title))
-                         len(openerp.modules.registry.Registry.registries))
+                         len(odoo.modules.registry.Registry.registries))
-            db_names = openerp.service.db.list_dbs(True)
+            db_names = odoo.service.db.list_dbs(True)
-        rpc_request = logging.getLogger('openerp.netsvc.rpc.request')
+        rpc_request = logging.getLogger('odoo.netsvc.rpc.request')
-            import openerp.addons.base as base
+            import odoo.addons.base as base
-            openerp.modules.registry.Registry.delete(db_name)
+            odoo.modules.registry.Registry.delete(db_name)
-                openerp.sql_db.close_db(db_name)
+                odoo.sql_db.close_db(db_name)
-    for m in openerp.conf.server_wide_modules:
+    for m in odoo.conf.server_wide_modules:
-            openerp.modules.module.load_openerp_module(m)
+            odoo.modules.module.load_openerp_module(m)
-    if openerp.tools.osutil.is_running_as_nt_service():
+    if odoo.tools.osutil.is_running_as_nt_service():
-        openerp.tools.convert_yaml_import(cr, 'base', file(test_file), 'test', {}, 'init')
+        odoo.tools.convert_yaml_import(cr, 'base', file(test_file), 'test', {}, 'init')
-                stream = openerp.modules.module.TestStream()
+                stream = odoo.modules.module.TestStream()
-    config = openerp.tools.config
+    config = odoo.tools.config
-                with openerp.api.Environment.manage():
+                with odoo.api.Environment.manage():
-    """ Start the openerp http server and cron processor.
+    """ Start the odoo http server and cron processor.
-        server = GeventServer(openerp.service.wsgi_server.application)
+    if odoo.evented:
-        server = PreforkServer(openerp.service.wsgi_server.application)
+        server = PreforkServer(odoo.service.wsgi_server.application)
-        server = ThreadedServer(openerp.service.wsgi_server.application)
+        server = ThreadedServer(odoo.service.wsgi_server.application)
-    if getattr(openerp, 'phoenix', False):
+    if getattr(odoo, 'phoenix', False):
-import openerp.tools.config as config
+import odoo
-# User code must use the exceptions defined in ``openerp.exceptions`` (not
+# User code must use the exceptions defined in ``odoo.exceptions`` (not
-    # defined in ``openerp.exceptions`` are mapped to specific fault codes;
+    # defined in ``odoo.exceptions`` are mapped to specific fault codes;
-        result = openerp.http.dispatch_rpc(service, method, params)
+        result = odoo.http.dispatch_rpc(service, method, params)
-        fault = xmlrpclib.Fault(RPC_FAULT_CODE_WARNING, openerp.tools.ustr(e.value))
+    if isinstance(e, odoo.exceptions.UserError):
-    elif isinstance(e, openerp.exceptions.RedirectWarning):
+    elif isinstance(e, odoo.exceptions.RedirectWarning):
-    elif isinstance(e, openerp.exceptions.MissingError):
+    elif isinstance(e, odoo.exceptions.MissingError):
-    elif isinstance (e, openerp.exceptions.AccessError):
+    elif isinstance (e, odoo.exceptions.AccessError):
-    elif isinstance(e, openerp.exceptions.AccessDenied):
+    elif isinstance(e, odoo.exceptions.AccessDenied):
-    elif isinstance(e, openerp.exceptions.DeferredException):
+    elif isinstance(e, odoo.exceptions.DeferredException):
-        #formatted_info = openerp.tools.exception_to_unicode(e) + '\n' + info
+        #formatted_info = odoo.tools.exception_to_unicode(e) + '\n' + info
-            #formatted_info = openerp.tools.exception_to_unicode(e) + '\n' + info
+            #formatted_info = odoo.tools.exception_to_unicode(e) + '\n' + info
-    if isinstance(e, openerp.exceptions.UserError):
+    if isinstance(e, odoo.exceptions.UserError):
-    elif isinstance(e, openerp.exceptions.RedirectWarning):
+    elif isinstance(e, odoo.exceptions.RedirectWarning):
-    elif isinstance(e, openerp.exceptions.MissingError):
+    elif isinstance(e, odoo.exceptions.MissingError):
-    elif isinstance(e, openerp.exceptions.AccessError):
+    elif isinstance(e, odoo.exceptions.AccessError):
-    elif isinstance(e, openerp.exceptions.AccessDenied):
+    elif isinstance(e, odoo.exceptions.AccessDenied):
-    elif isinstance(e, openerp.exceptions.DeferredException):
+    elif isinstance(e, odoo.exceptions.DeferredException):
-        fault = xmlrpclib.Fault(openerp.tools.ustr(e.message), formatted_info)
+        fault = xmlrpclib.Fault(odoo.tools.ustr(e.message), formatted_info)
-        fault = xmlrpclib.Fault(openerp.tools.exception_to_unicode(e), formatted_info)
+        fault = xmlrpclib.Fault(odoo.tools.exception_to_unicode(e), formatted_info)
-    # openerp.service.web_services.objects_proxy.dispatch().
+    # odoo.service.web_services.objects_proxy.dispatch().
-    with openerp.api.Environment.manage():
+    with odoo.api.Environment.manage():
-        for handler in [wsgi_xmlrpc, openerp.http.root]:
+        for handler in [wsgi_xmlrpc, odoo.http.root]:
-            from openerp import registry
+            from odoo import registry
-    """ You might want to call openerp.modules.registry.Registry.delete(db_name) along this function."""
+    """ You might want to call odoo.modules.registry.Registry.delete(db_name) along this function."""
-from openerp import models, fields, _
+from odoo import models, fields, _
-from openerp.tests import common
+import odoo
-        openerp.tools.trans_load(self.cr, 'test_translation_import/i18n/fr.po', 'fr_FR', verbose=False)
+        odoo.tools.trans_load(self.cr, 'test_translation_import/i18n/fr.po', 'fr_FR', verbose=False)
-The module :mod:`openerp.tests.common` provides unittest test cases and a few
+The module :mod:`odoo.tests.common` provides unittest test cases and a few
-from openerp import api
+import odoo
-ADDONS_PATH = openerp.tools.config['addons_path']
+# The odoo library is supposed already configured.
-PORT = openerp.tools.config['xmlrpc_port']
+PORT = odoo.tools.config['xmlrpc_port']
-ADMIN_USER_ID = openerp.SUPERUSER_ID
+ADMIN_USER_ID = odoo.SUPERUSER_ID
-    db = openerp.tools.config['db_name']
+    db = odoo.tools.config['db_name']
-        :returns: :class:`~openerp.models.BaseModel`
+        :returns: :class:`~odoo.models.BaseModel`
-        self.registry = openerp.registry(get_db_name())
+        self.registry = odoo.registry(get_db_name())
-        #: :class:`~openerp.api.Environment` for the current test case
+        self.uid = odoo.SUPERUSER_ID
-        cls.registry = openerp.registry(get_db_name())
+        cls.registry = odoo.registry(get_db_name())
-        cls.uid = openerp.SUPERUSER_ID
+        cls.uid = odoo.SUPERUSER_ID
-        self.session = openerp.http.root.session_store.new()
+        self.session = odoo.http.root.session_store.new()
-        openerp.http.root.session_store.save(self.session)
+        odoo.http.root.session_store.save(self.session)
-        openerp.http.root.session_store.save(session)
+        odoo.http.root.session_store.save(session)
-            if thread.name.startswith('openerp.service.http.request.'):
+            if thread.name.startswith('odoo.service.http.request.'):
-                        openerp.tools.misc.dumpstacks()
+                        odoo.tools.misc.dumpstacks()
-    import openerp.loglevels as loglevels
+    import odoo.loglevels as loglevels
-# this is important for the openerp.api.guess() that relies on signatures
+# this is important for the odoo.api.guess() that relies on signatures
-    from openerp.modules.registry import Registry
+    from odoo.modules.registry import Registry
-#openerp.loggers.handlers. -*- coding: utf-8 -*-
+#odoo.loggers.handlers. -*- coding: utf-8 -*-
-import openerp.loglevels as loglevels
+import odoo
-import openerp.release as release
+import odoo.release as release
-        group.add_option('--log-sql', action="append_const", dest="log_handler", const="openerp.sql_db:DEBUG", help='shortcut for --log-handler=openerp.sql_db:DEBUG')
+        group.add_option('--log-handler', action="append", default=[], my_default=DEFAULT_LOG_HANDLER, metavar="PREFIX:LEVEL", help='setup a handler at LEVEL for a given PREFIX. An empty PREFIX indicates the root logger. This option can be repeated. Example: "odoo.orm:DEBUG" or "werkzeug:CRITICAL" (default: ":INFO")')
-        This method initializes openerp.tools.config and openerp.conf (the
+        This method initializes odoo.tools.config and openerp.conf (the
-            openerp.tools.config.parse_config(sys.argv[1:])
+            odoo.tools.config.parse_config(sys.argv[1:])
-        openerp.modules.module.initialize_sys_path()
+        odoo.netsvc.init_logger()
-        self.options['root_path'] = os.path.abspath(os.path.expanduser(os.path.expandvars(os.path.dirname(openerp.__file__))))
+        self.options['root_path'] = os.path.abspath(os.path.expanduser(os.path.expandvars(os.path.dirname(odoo.__file__))))
-        openerp.conf.addons_paths = self.options['addons_path'].split(',')
+        odoo.conf.addons_paths = self.options['addons_path'].split(',')
-            openerp.conf.server_wide_modules = map(lambda m: m.strip(), opt.server_wide_modules.split(','))
+            odoo.conf.server_wide_modules = map(lambda m: m.strip(), opt.server_wide_modules.split(','))
-            openerp.conf.server_wide_modules = ['web','web_kanban']
+            odoo.conf.server_wide_modules = ['web','web_kanban']
-import openerp.release
+import odoo
-from openerp import SUPERUSER_ID
+from odoo import SUPERUSER_ID
-                  version=openerp.release.major_version,
+                  version=odoo.release.major_version,
-                logging.getLogger('openerp.tools.convert.init').error(
+                logging.getLogger('odoo.tools.convert.init').error(
-        return openerp.api.call_kw(model, method, args, {})
+        return odoo.api.call_kw(model, method, args, {})
-        self.env = openerp.api.Environment(cr, SUPERUSER_ID, {})
+        self.env = odoo.api.Environment(cr, SUPERUSER_ID, {})
-    env = openerp.api.Environment(cr, SUPERUSER_ID, context)
+    env = odoo.api.Environment(cr, SUPERUSER_ID, context)
-from openerp.loglevels import ustr
+import odoo
-            local_cr = cr = openerp.registry(db_name).cursor()
+            local_cr = cr = odoo.registry(db_name).cursor()
-        mail_server_pool = openerp.registry(cr.dbname)['ir.mail_server']
+        mail_server_pool = odoo.registry(cr.dbname)['ir.mail_server']
-import openerp
+import odoo
-from openerp.loglevels import get_encodings, ustr, exception_to_unicode     # noqa
+from odoo.loglevels import get_encodings, ustr, exception_to_unicode     # noqa
-        env['PGPASSWORD'] = openerp.tools.config['db_password']
+    if odoo.tools.config['db_host']:
-    import openerp.modules as addons
+    import odoo.modules as addons
-    csvpath = openerp.modules.module.get_resource_path('base', 'res', 'res.lang.csv')
+    csvpath = odoo.modules.module.get_resource_path('base', 'res', 'res.lang.csv')
-        @mute_logger('openerp.plic.ploc')
+        @mute_logger('odoo.plic.ploc')
-        with mute_logger('openerp.foo.bar'):
+        with mute_logger('odoo.foo.bar'):
-    if openerp.evented:
+    if odoo.evented:
-    from openerp.release import nt_service_name
+    from odoo.release import nt_service_name
-import openerp
+import odoo
-    except openerp.exceptions.except_orm:
+    except odoo.exceptions.except_orm:
-    except openerp.exceptions.Warning:
+    except odoo.exceptions.Warning:
-    except openerp.exceptions.RedirectWarning:
+    except odoo.exceptions.RedirectWarning:
-    except openerp.exceptions.AccessDenied:
+    except odoo.exceptions.AccessDenied:
-    except openerp.exceptions.AccessError:
+    except odoo.exceptions.AccessError:
-    except openerp.http.AuthenticationError:
+    except odoo.http.AuthenticationError:
-    except openerp.exceptions.MissingError:
+    except odoo.exceptions.MissingError:
-import openerp.tools as tools
+import odoo
-from openerp.tools.safe_eval import safe_eval
+from odoo.tools.safe_eval import safe_eval
-_test_logger = logging.getLogger('openerp.tests')
+_test_logger = logging.getLogger('odoo.tests')
-    res = openerp.report.render_report(cr, uid, ids, rname_s, data, context=context)
+    res = odoo.report.render_report(cr, uid, ids, rname_s, data, context=context)
-    env = openerp.api.Environment(cr, uid, context)
+    env = odoo.api.Environment(cr, uid, context)
-from openerp import sql_db, SUPERUSER_ID
+import odoo
-            from openerp.http import request
+            from odoo.http import request
-                    from openerp.http import request
+                    from odoo.http import request
-                    env = openerp.api.Environment(cr, uid, {})
+                    env = odoo.api.Environment(cr, uid, {})
-                    env = openerp.api.Environment(cr, SUPERUSER_ID, {})
+                    env = odoo.api.Environment(cr, SUPERUSER_ID, {})
-        import openerp.release as release
+        import odoo.release as release
-    env = openerp.api.Environment(cr, SUPERUSER_ID, {})
+    env = odoo.api.Environment(cr, SUPERUSER_ID, {})
-    path_list = [(path, True) for path in openerp.modules.module.ad_paths]
+    path_list = [(path, True) for path in odoo.modules.module.ad_paths]
-                    babel_extract_terms(fname, path, root, 'openerp.tools.translate:babel_extract_qweb',
+                    babel_extract_terms(fname, path, root, 'odoo.tools.translate:babel_extract_qweb',
-    env = openerp.api.Environment(cr, SUPERUSER_ID, context or {})
+    env = odoo.api.Environment(cr, SUPERUSER_ID, context or {})
-    env = openerp.api.Environment(cr, SUPERUSER_ID, {})
+    env = odoo.api.Environment(cr, SUPERUSER_ID, {})
-import openerp
+import odoo
-from openerp import SUPERUSER_ID
+from odoo import SUPERUSER_ID
-        self.env = openerp.api.Environment(self.cr, self.uid, self.context)
+        self.env = odoo.api.Environment(self.cr, self.uid, self.context)
-        self.env = openerp.api.Environment(self.cr, self.uid, self.context)
+        self.env = odoo.api.Environment(self.cr, self.uid, self.context)
-            'openerp': openerp,
+            'openerp': odoo,
-        return openerp.api.call_kw(model, function.name, args, {})
+        return odoo.api.call_kw(model, function.name, args, {})
-from openerp.workflow.service import WorkflowService
+from odoo.workflow.service import WorkflowService
-# The new API is in openerp.workflow.workflow_service
+# The new API is in odoo.workflow.workflow_service
-import openerp.sql_db
+import odoo.sql_db
-        assert isinstance(cr, openerp.sql_db.Cursor)
+        assert isinstance(cr, odoo.sql_db.Cursor)
-from openerp.workflow.workitem import WorkflowItem
+from odoo.workflow.helpers import Session
-from openerp.workflow.instance import WorkflowInstance
+from odoo.workflow.instance import WorkflowInstance
-from openerp.workflow.helpers import WorkflowActivity
+from odoo.workflow.helpers import Session
-from openerp.tools.safe_eval import safe_eval
+import odoo
-        env = openerp.api.Environment(self.cr, self.uid, {})
+        env = odoo.api.Environment(self.cr, self.uid, {})
-        env = openerp.api.Environment(self.session.cr, self.session.uid, context)
+        env = odoo.api.Environment(self.session.cr, self.session.uid, context)
-            env = openerp.api.Environment(self.session.cr, self.session.uid, {})
+        if self.session.uid != odoo.SUPERUSER_ID and transition['group_id']:
-#   $ gunicorn openerp:service.wsgi_server.application -c openerp-wsgi.py
+#   $ gunicorn odoo:service.wsgi_server.application -c openerp-wsgi.py
-import openerp
+import odoo
-openerp.multi_process = True # Nah!
+odoo.multi_process = True # Nah!
-conf = openerp.tools.config
+odoo.conf.server_wide_modules = ['web']
-application = openerp.service.wsgi_server.application
+application = odoo.service.wsgi_server.application
-openerp.service.server.load_server_wide_modules()
+odoo.service.server.load_server_wide_modules()
-            if pack_operation_id.owner_id:
+            if pack_operation.owner_id:
-        self.group_hr_user_id = self.ref('base.group_hr_user')
+        self.group_hr_manager_id = self.ref('hr.group_hr_manager')
-    pin = fields.Char(string="PIN", default=_default_random_pin, help="PIN used for Check In/Out in Attendance.", copy=False, groups='base.group_hr_user')
+    barcode = fields.Char(string="Badge ID", help="ID used for employee identification.", default=_default_random_barcode, copy=False, groups='hr.group_hr_user')
-            employee.manual_attendance = employee.user_id.has_group('base.group_hr_attendance') if employee.user_id else False
+            employee.manual_attendance = employee.user_id.has_group('hr.group_hr_attendance') if employee.user_id else False
-        if self.env['res.users'].browse(SUPERUSER_ID).has_group('base.group_hr_attendance_use_pin') and (self.user_id and self.user_id.id != self._uid or not self.user_id):
+        if self.env['res.users'].browse(SUPERUSER_ID).has_group('hr_attenance.group_hr_attendance_use_pin') and (self.user_id and self.user_id.id != self._uid or not self.user_id):
-                                                string='Employee PIN', help='Enable or disable employee PIN identification at check in', implied_group="base.group_hr_attendance_use_pin")
+                                                string='Employee PIN', help='Enable or disable employee PIN identification at check in', implied_group="hr_attenance.group_hr_attendance_use_pin")
-        show_leaves = self.env['res.users'].has_group('base.group_hr_user')
+        show_leaves = self.env['res.users'].has_group('hr.group_hr_user')
-        group_hr_manager = self.env.ref('base.group_hr_manager')
+        group_hr_manager = self.env.ref('hr.group_hr_manager')
-        if vals.get('state') and vals['state'] not in ['draft', 'confirm', 'cancel'] and not self.env['res.users'].has_group('base.group_hr_user'):
+        if vals.get('state') and vals['state'] not in ['draft', 'confirm', 'cancel'] and not self.env['res.users'].has_group('hr.group_hr_user'):
-        if not self.env.user.has_group('base.group_hr_user'):
+        if not self.env.user.has_group('hr.group_hr_user'):
-        if not self.env.user.has_group('base.group_hr_user'):
+        if not self.env.user.has_group('hr.group_hr_user'):
-            if holiday.state == 'validate1' and not holiday.env.user.has_group('base.group_hr_manager'):
+            if holiday.state == 'validate1' and not holiday.env.user.has_group('hr.group_hr_manager'):
-        if not self.env.user.has_group('base.group_hr_user'):
+        if not self.env.user.has_group('hr.group_hr_user'):
-        group_hr_user = self.env.ref('base.group_hr_user')
+        group_hr_user = self.env.ref('hr.group_hr_user')
-            'groups_id': [(6, 0, [group_employee_id, self.ref('base.group_hr_user')])]
+            'groups_id': [(6, 0, [group_employee_id, self.ref('hr.group_hr_user')])]
-            'groups_id': [(6, 0, [group_employee_id, self.ref('base.group_hr_manager')])]
+            'groups_id': [(6, 0, [group_employee_id, self.ref('hr.group_hr_manager')])]
-    payslip_count = fields.Integer(compute='_compute_payslip_count', string='Payslips', groups="base.group_hr_user")
+    payslip_count = fields.Integer(compute='_compute_payslip_count', string='Payslips', groups="hr.group_hr_user")
-        if not self.env.user.has_group('base.group_hr_user'):
+        if not self.env.user.has_group('hr.group_hr_user'):
-        if not self.env.user.has_group('base.group_hr_user'):
+        if not self.env.user.has_group('hr.group_hr_user'):
-        res_manager = self.env.ref('base.group_equipment_manager')
+        res_manager = self.env.ref('maintenance.group_equipment_manager')
-        (group_survey_user, group_employee) = (self.ref('base.group_survey_user'), self.ref('base.group_user'))
+        (group_survey_user, group_employee) = (self.ref('survey.group_survey_user'), self.ref('base.group_user'))
-            'groups_id': [(6, 0, [self.ref('base.group_survey_manager'), group_survey_user, group_employee])]})
+            'groups_id': [(6, 0, [self.ref('survey.group_survey_manager'), group_survey_user, group_employee])]})
-                elif request.env.user.has_group('base.group_website_publisher'):
+                elif request.env.user.has_group('website.group_website_publisher'):
-        if self.env.user.has_group('base.group_website_publisher') and self.website_url != '#':
+        if self.env.user.has_group('website.group_website_publisher') and self.website_url != '#':
-        if not request.env.user.has_group('base.group_website_designer'):
+        if not request.env.user.has_group('website.group_website_designer'):
-        if request.env.user.has_group('base.group_website_designer'):
+        if request.env.user.has_group('website.group_website_designer'):
-        if not request.env.user.has_group('base.group_website_designer'):
+        if not request.env.user.has_group('website.group_website_designer'):
-        publish = request.env.user.has_group('base.group_website_publisher')
+        publish = request.env.user.has_group('website.group_website_publisher')
-        publish = request.env.user.has_group('base.group_website_publisher')
+        publish = request.env.user.has_group('website.group_website_publisher')
-        group_blog_manager_id = self.ref('base.group_website_designer')
+        group_blog_manager_id = self.ref('website.group_website_designer')
-        if not request.env['res.users'].has_group('base.group_website_publisher'):
+        if not request.env['res.users'].has_group('website.group_website_publisher'):
-            is_website_publisher = request.env['res.users'].has_group('base.group_website_publisher')
+            is_website_publisher = request.env['res.users'].has_group('website.group_website_publisher')
-        if not self.env['res.users'].has_group('base.group_website_designer'):
+        if not self.env['res.users'].has_group('website.group_website_designer'):
-    GROUPS = ['base.group_website_designer', 'base.group_website_publisher']
+    GROUPS = ['website.group_website_designer', 'website.group_website_publisher']
-        if not request.env['res.users'].has_group('base.group_website_publisher'):
+        if not request.env['res.users'].has_group('website.group_website_publisher'):
-            is_website_publisher = request.env['res.users'].has_group('base.group_website_publisher')
+            is_website_publisher = request.env['res.users'].has_group('website.group_website_publisher')
-        if not self.user_has_groups('base.group_website_publisher'):
+        if not self.user_has_groups('website.group_website_publisher'):
-            '|', ('category_id', 'not in', [self.env.ref('base.module_category_hidden').id, self.env.ref('base.module_category_theme_hidden').id]), ('name', '=', 'theme_default'),
+            '|', ('category_id', 'not in', [self.env.ref('base.module_category_hidden').id, self.env.ref('website_theme_install.module_category_theme_hidden').id]), ('name', '=', 'theme_default'),
-        debug = request.env['res.users'].has_group('base.group_website_publisher')
+        debug = request.env['res.users'].has_group('website.group_website_publisher')
-            if field.type == 'text':
+            elif field.type in ('one2many', 'many2many', 'text', 'html'):
-        return E.form(group, string=self._description)
+        return E.form(E.sheet(group, string=self._description))
-        of the current model except the m2m and o2m ones.
+        of the current model.
-            if field.automatic or field.type in ('one2many', 'many2many'):
+            if field.automatic:
-        of the current model except the m2m and o2m ones.
+        of the current model.
-            if field.automatic or field.type in ('one2many', 'many2many'):
+            if field.automatic:
-    @api.multi
+import models   # noqa
-    manager_id = fields.Many2one('res.users', string='Project Manager', related='project_id.user_id')
+    manager_id = fields.Many2one('res.users', string='Project Manager', related='project_id.user_id', readonly=True)
-    legend_normal = fields.Char(related='stage_id.legend_normal', string='Kanban Ongoing Explanation')
+    legend_blocked = fields.Char(related='stage_id.legend_blocked', string='Kanban Blocked Explanation', readonly=True)
-    legend_normal = fields.Char(related="stage_id.legend_normal", string='Kanban Ongoing Explanation')
+    legend_blocked = fields.Char(related="stage_id.legend_blocked", string='Kanban Blocked Explanation', readonly=True)
-            'res_id': template_id,
+            'res_id': template_id.id,
-    code_digits = fields.Integer(string='# of Digits', related='company_id.accounts_code_digits', help="No. of digits to use for account code")
+    use_anglo_saxon = fields.Boolean(string='Use Anglo-Saxon Accounting *', related='company_id.anglo_saxon_accounting')
-        ], related='company_id.tax_calculation_rounding_method', string='Tax calculation rounding method',
+        ], related='company_id.tax_calculation_rounding_method', string='Tax calculation rounding method *',
-    cash_account_code_prefix = fields.Char(string='Cash Accounts Prefix', related='company_id.cash_account_code_prefix', help='Define the code prefix for the cash accounts')
+    bank_account_code_prefix = fields.Char(string='Bank Accounts Prefix *', related='company_id.bank_account_code_prefix', help='Define the code prefix for the bank accounts', oldname='bank_account_code_char')
-    'depends' : ['base'],
+    'depends' : ['base', 'base_setup'],
-        'views/res_company_views.xml',
+        'views/auth_ldap_config_settings_views.xml',
-            default=0.0)
+        'views/l10n_fr_hr_payroll_config_settings_views.xml',
-        'views/res_company_views.xml',
+    company_id = fields.Many2one('res.company', string='Company', required=True,
-    'depends': ['web'],
+    'depends': ['web', 'base_setup'],
-        'views/res_company.xml',
+        'views/res_config_view.xml',
-        'views/res_company_views.xml',
+    company_id = fields.Many2one('res.company', string='Company', required=True,
-        'views/res_company_views.xml',
+    company_id = fields.Many2one('res.company', string='Company', required=True,
-    'depends': ['base', 'web'],
+    'depends': ['base', 'web', 'base_setup'],
-        'views/res_company_views.xml',
+        'views/base_config_settings_views.xml',
-        'views/res_company_views.xml',
+    security_lead = fields.Float(related='company_id.security_lead', string="Sales Safety Days *")
-        ratings = self.rating_ids.filtered(lambda x: x.partner_id == partner.id and not x.consumed)
+        ratings = self.rating_ids.filtered(lambda x: x.partner_id.id == partner.id and not x.consumed)
-        return val.lower() not in ('0', 'false', 'off')
+        return str2bool(val)
-    stage_ids = fields.Many2many('note.stage', 'note_stage_rel', 'note_id', 'stage_id', string='Stages of Users')
+        inverse='_inverse_stage_id', string='Stage')
-    balance_cash_basis = fields.Monetary(compute='_compute_cash_basis', store=True, currency_field='company_currency_id', default=0.0, help="Technical field holding the debit_cash_basis - credit_cash_basis in order to open meaningful graph views from reports")
+    balance = fields.Monetary(compute='_store_balance', store=True, currency_field='company_currency_id',
-                                       help='The employee will have access to the "My Attendances" menu to perform his check in and out from his session', default=False)
+                                       help='The employee will have access to the "My Attendances" menu to perform his check in and out from his session')
-    progress = fields.Float(compute='_hours_get', store=True, string='Working Time Recorded', group_operator="avg", default=0.0)
+    progress = fields.Float(compute='_hours_get', store=True, string='Working Time Recorded', group_operator="avg")
-                             'Status', readonly=True, index=True, copy=False, default='new',
+                             'Status', readonly=True, index=True, copy=False,
-        ], string='Invoice Status', compute='_get_invoiced', store=True, readonly=True, default='no')
+        ], string='Invoice Status', compute='_get_invoiced', store=True, readonly=True)
-        digits=dp.get_precision('Product Unit of Measure'), default=0.0)
+        digits=dp.get_precision('Product Unit of Measure'))
-        digits=dp.get_precision('Product Unit of Measure'), default=0.0)
+        digits=dp.get_precision('Product Unit of Measure'))
-            journal_dict[jrn].append(expense)
+            journal_dict.setdefault(jrn, self.env['hr.expense'])
-        ], compute='_compute_state', string='Status', copy=False, default="draft", index=True, readonly=True, required=True, store=True,
+        ], compute='_compute_state', string='Status', copy=False, index=True, readonly=True, store=True,
-                                        required=True, string='Next Number', default=1,
+                                        string='Next Number',
-                                        required=True, string='Next Number', default=1,
+                                        string='Next Number',
-        default=_get_journal, index=True, store=True, copy=False)  # related is required
+        index=True, store=True, copy=False)  # related is required
-        if ('account_id' in vals) and AccountObj.browse(vals['account_id']).deprecated:
+        move = self.env['account.move'].browse(vals['move_id'])
-            context['date'] = m.date
+        if 'journal_id' not in context:
-                    raise UserError(_('Cannot create an automatic sequence for this piece.\nPut a sequence in the journal definition for automatic numbering or create a sequence manually for this piece.'))
+        journal = vals.get('journal_id') and self.env['account.journal'].browse(vals['journal_id']) or move.journal_id
-                vals['amount_currency'] = account.company_id.currency_id.with_context(ctx).compute(amount, account.currency_id)
+
-        default=_get_journal, required=True, index=True, store=True, copy=False)
+        default=_get_journal, index=True, store=True, copy=False)  # related is required
-    date = fields.Date(related='move_id.date', string='Date', required=True, index=True, default=fields.Date.context_today, store=True, copy=False)
+    date = fields.Date(related='move_id.date', string='Date', index=True, store=True, copy=False)  # related is required
-                _message_post_helper(res_model='sale.order', res_id=Order.id, message=body, token=token, token_field="access_token", message_type='notification')
+                _message_post_helper(res_model='sale.order', res_id=Order.id, message=body, token=token, token_field="access_token", message_type='notification', subtype="mail.mt_note", partner_ids=Order.user_id.partner_id.ids)
-        ('generate_and_pay_invoice', 'On acquirer confirmation, confirm the SO, generate the invoice and pay it')],
+        ('authorize', 'Authorize the amount and confirm the SO on acquirer confirmation (capture manually)'),
-        'views/account_invoice_workflow.xml',
+    @api.multi
-    def action_cancel_draft(self):
+    def action_invoice_draft(self):
-        self.create_workflow()
+    def action_invoice_proforma2(self):
-        self.account_invoice_customer0.signal_workflow('invoice_proforma2')
+        self.account_invoice_customer0.action_invoice_proforma2()
-        self.account_invoice_customer0.signal_workflow('invoice_open')
+        self.account_invoice_customer0.action_invoice_open()
-        invoice.signal_workflow('invoice_open')
+        invoice.action_invoice_open()
-        invoice.signal_workflow('invoice_open')
+        invoice.action_invoice_open()
-        invoice.signal_workflow('invoice_open')
+        invoice.action_invoice_open()
-        invoice.signal_workflow('invoice_open')
+        invoice.action_invoice_open()
-        invoice.signal_workflow('invoice_open')
+        invoice.action_invoice_open()
-                    refund.signal_workflow('invoice_open')
+                    refund.action_invoice_open()
-            record.signal_workflow('invoice_open')
+            record.action_invoice_open()
-            record.signal_workflow('invoice_cancel')
+            record.action_invoice_cancel()
-        self.invoice.signal_workflow('invoice_open')
+        self.invoice.action_invoice_open()
-        self.invoice.signal_workflow('invoice_open')
+        self.invoice.action_invoice_open()
-        invoice.signal_workflow('invoice_open')
+        invoice.action_invoice_open()
-        invoice.signal_workflow('invoice_cancel')
+        invoice.action_invoice_cancel()
-            new_invoice.sudo().signal_workflow('validate')
+            # this workflow signal didn't exist on account.invoice -> should it have been 'invoice_open' ? (and now method .action_invoice_open())
-                pos_order.invoice_id.sudo().signal_workflow('invoice_open')
+                pos_order.invoice_id.sudo().action_invoice_open()
-        res = super(AccountInvoice, self).confirm_paid()
+    def action_invoice_paid(self):
-        inv.signal_workflow('invoice_open')
+        inv.action_invoice_open()
-        self.inv_1.signal_workflow('invoice_open')
+        self.inv_1.action_invoice_open()
-            created_invoice.signal_workflow('invoice_open')
+            created_invoice.action_invoice_open()
-                    leave.signal_workflow(signal)
+                leave.action_approve()
-        linked_requests.unlink()
+    def action_draft(self):
-        return self.write({'state': 'validate1', 'manager_id': manager.id if manager else False})
+    def action_confirm(self):
-    def holidays_validate(self):
+    def action_approve(self):
-        self.write({'state': 'validate'})
+        for holiday in self:
-                    leaves.signal_workflow(signal)
+                leaves.action_approve()
-        return self.write({'state': 'confirm'})
+    def action_refuse(self):
-    def holidays_refuse(self):
+            if self.state not in ['confirm', 'validate', 'validate1']:
-            holiday.linked_request_ids.signal_workflow('refuse')
+            holiday.linked_request_ids.action_refuse()
-        ref_action = '/mail/workflow?%s' % url_encode({'model': self._name, 'res_id': self.id, 'signal': 'refuse'})
+        app_action = '/mail/method?%s' % url_encode({'model': self._name, 'res_id': self.id, 'method': 'action_validate'})
-
+import test_holidays_flow
-from odoo.exceptions import AccessError, ValidationError
+from odoo.exceptions import AccessError, ValidationError, UserError
-        hol1_employee_group.signal_workflow('validate')
+        with self.assertRaises(UserError):
-        hol1_user_group.signal_workflow('validate')
+        hol1_user_group.action_approve()
-        aloc1_user_group.signal_workflow('second_validate')
+        # HrUser validates the first step
-        hol2_user_group.signal_workflow('validate')
+        hol2_user_group.action_approve()
-        hol2_user_group.signal_workflow('second_validate')
+        # HrManager validates the second step
-        hol2.sudo(self.user_hrmanager_id).signal_workflow('refuse')
+        hol2.sudo(self.user_hrmanager_id).action_refuse()
-        hol2_user_group.signal_workflow('reset')
+        with self.assertRaises(UserError):
-        hol2_manager_group.signal_workflow('reset')
+        hol2_manager_group.action_draft()
-            hol2_manager_group.signal_workflow('confirm')
+            hol2_manager_group.action_confirm()
-        hol3.signal_workflow('refuse')
+        hol3.action_refuse()
-        hol3.signal_workflow('reset')
+        hol3.action_draft()
-        hol3.signal_workflow('confirm')
+        hol3.action_confirm()
-        hol3.signal_workflow('validate')
+        hol3.action_approve()
-    def budget_confirm(self):
+    def action_budget_confirm(self):
-    def budget_draft(self):
+    def action_budget_draft(self):
-    def budget_validate(self):
+    def action_budget_validate(self):
-    def budget_cancel(self):
+    def action_budget_cancel(self):
-    def budget_done(self):
+    def action_budget_done(self):
-        budget.signal_workflow('confirm')
+        # Performing an action confirm on module crossovered.budget
-        budget.signal_workflow('validate')
+        # Performing an action validate on module crossovered.budget
-        budget.signal_workflow('done')
+        # Performing an action done on module crossovered.budget
-        'views/hr_payroll_workflow.xml',
+    # this is chaos: 4 states are defined, 3 are used ('verify' isn't) and 5 exist ('confirm' seems to have existed)
-        return self.write({'state': 'cancel'})
+    def action_payslip_draft(self):
-        return self.write({'paid': True, 'state': 'done'})
+    def action_payslip_done(self):
-        return self.write({'state': 'verify'})
+    def action_payslip_cancel(self):
-            copied_payslip.signal_workflow('process_sheet')
+            copied_payslip.action_payslip_done()
-        richard_payslip.signal_workflow('hr_verify_sheet')
+        richard_payslip.action_payslip_done()
-    def cancel_sheet(self):
+    def action_payslip_cancel(self):
-        return super(HrPayslip, self).cancel_sheet()
+        return super(HrPayslip, self).action_payslip_cancel()
-    def process_sheet(self):
+    def action_payslip_done(self):
-        return super(HrPayslip, self).process_sheet()
+        return super(HrPayslip, self).action_payslip_done()
-        self.hr_payslip.cancel_sheet()
+        self.hr_payslip.action_payslip_cancel()
-        self.hr_payslip.signal_workflow('draft')
+        self.hr_payslip.action_payslip_draft()
-        self.hr_payslip.signal_workflow('hr_verify_sheet')
+        self.hr_payslip.action_payslip_done()
-                slip.signal_workflow('process_sheet')
+                slip.action_payslip_done()
-    def button_confirm(self):
+    def action_timesheet_confirm(self):
-                return super(HrTimesheetSheet, self).button_confirm()
+                return super(HrTimesheetSheet, self).action_timesheet_confirm()
-            self.test_timesheet_sheet.button_confirm()
+            self.test_timesheet_sheet.action_timesheet_confirm()
-        self.test_timesheet_sheet.button_confirm()
+        self.test_timesheet_sheet.action_timesheet_confirm()
-        'data/hr_timesheet_workflow.xml',
+    # state is created in 'new', automatically goes to 'draft' when created. Then 'new' is never used again ...
-        return super(HrTimesheetSheet, self).create(vals)
+        res = super(HrTimesheetSheet, self).create(vals)
-    def button_confirm(self):
+    def action_timesheet_draft(self):
-            sheet.signal_workflow('confirm')
+        self.write({'state': 'confirm'})
-        return True
+    def action_timesheet_done(self):
-        'data/marketing_campaign_workflow.xml',
+    def state_draft_set(self):
-        partner_channel.signal_workflow('state_running_set')
+        partner_channel.state_running_set()
-        segment0.signal_workflow('state_running_set')
+        segment0.state_running_set()
-        segment0.signal_workflow('state_cancel_set')
+        segment0.state_cancel_set()
-        segment0.signal_workflow('state_running_set')
+        segment0.state_draft_set()
-        segment0.signal_workflow('state_done_set')
+        segment0.state_done_set()
-        partner_channel.signal_workflow('state_done_set')
+        partner_channel.state_done_set()
-        self.current_session_id.signal_workflow('cashbox_control')
+        if self.current_session_id.cash_control:
-            new_session.signal_workflow('open')
+            new_session.action_pos_session_open()
-    def action_invoice(self):
+    def action_pos_order_paid(self):
-            new_invoice.message_post(body=message)            
+            new_invoice.message_post(body=message)
-            order.sudo().signal_workflow('invoice')
+            order.sudo().write({'state': 'invoiced'})
-        self.write({'state': 'cancel'})
+    def action_pos_order_cancel(self):
-        self._create_account_move_line()
+    def action_pos_order_done(self):
-                pos_order.signal_workflow('paid')
+                pos_order.action_pos_order_paid()
-                pos_order.action_invoice()
+                pos_order.action_pos_order_invoice()
-                return True
+                continue
-                picking_id.message_post(body=message)                
+                picking_id.message_post(body=message)
-        ('closing_control', 'Closing Control'),  # Signal close
+        ('opening_control', 'Opening Control'),  # method action_pos_session_open
-                order.signal_workflow('done')
+                order.action_pos_order_done()
-        index=True, copy=False, default='opening_control')        
+        index=True, copy=False, default='opening_control')
-        return super(PosSession, self.with_context(ctx).sudo(uid)).create(values)
+        res = super(PosSession, self.with_context(ctx).sudo(uid)).create(values)
-    def wkf_action_open(self):
+    @api.multi
-        for session in self:
+        # we only open sessions that haven't already been opened
-    def wkf_action_closing_control(self):
+    @api.multi
-    def wkf_action_close(self):
+    @api.multi
-        self.invoice = self.pos_order_pos1.action_invoice()
+        self.invoice = self.pos_order_pos1.action_pos_order_invoice()
-            order.signal_workflow('paid')
+            order.action_pos_order_paid()
-    def action_cancel_draft(self):
+    def action_repair_cancel_draft(self):
-        return self.create_workflow()
+        return self.write({'state': 'draft'})
-    def action_confirm(self):
+    def action_repair_confirm(self):
-    def action_cancel(self):
+    def action_repair_cancel(self):
-    def wkf_invoice_create(self):
+    def action_repair_invoice_create(self):
-        return True
+        return self.write({'state': 'ready'})
-        return True
+        return self.write({'state': 'under_repair'})
-            vals = {'repaired': True}
+            vals = {'repaired': True, 'state': 'done'}
-    @api.multi
+
-        self.mrp_repair_rmrp0.sudo(self.res_mrp_repair_user.id).signal_workflow('repair_confirm')
+        self.mrp_repair_rmrp0.sudo(self.res_mrp_repair_user.id).action_repair_confirm()
-        self.mrp_repair_rmrp0.signal_workflow('repair_ready')
+        self.mrp_repair_rmrp0.action_repair_start()
-        self.mrp_repair_rmrp2.action_repair_ready()
+        # I confirm Repair order for Invoice Method 'Before Repair'.
-        self.mrp_repair_rmrp2.signal_workflow('action_invoice_create')
+        self.mrp_repair_rmrp2.action_repair_invoice_create()
-        self.mrp_repair_rmrp2.signal_workflow('repair_ready')
+        self.mrp_repair_rmrp2.action_repair_start()
-        self.mrp_repair_rmrp2.signal_workflow('action_repair_end')
+        self.mrp_repair_rmrp2.action_repair_end()
-        self.mrp_repair_rmrp1.sudo(self.res_mrp_repair_user.id).signal_workflow('repair_confirm')
+        self.mrp_repair_rmrp1.sudo(self.res_mrp_repair_user.id).action_repair_confirm()
-        self.mrp_repair_rmrp1.signal_workflow('repair_ready')
+        self.mrp_repair_rmrp1.action_repair_start()
-        self.mrp_repair_rmrp1.signal_workflow('action_repair_end')
+        self.mrp_repair_rmrp1.action_repair_end()
-        self.assertEqual(self.mrp_repair_rmrp1.amount_total, 112, "Amount_total should be 100")
+        self.assertEqual(self.mrp_repair_rmrp1.amount_total, 112, "Amount_total should be 100")
-            # Note that the signal 'action_invoice_create' will trigger another call to the method 'action_invoice_create',
+            # We have to udpate the state of the given repairs, otherwise they remain 'to be invoiced'.
-            repairs.signal_workflow('action_invoice_create')
+            repairs.action_repair_invoice_create()
-            for virtual_id in self.env[doc_model].get_recurrent_ids(doc_dict.keys(), [], order=order):
+            for virtual_id in self.env[doc_model].browse(doc_dict.keys()).get_recurrent_ids([], order=order):
-    @api.depends('order_line.move_ids.picking_id')
+    @api.depends('order_line.move_ids')
-                moves = line.move_ids.filtered(lambda r: r.state != 'cancel')
+                # We keep a limited scope on purpose. Ideally, we should also use move_orig_ids and
-        ], string='Status', readonly=True)
+        ], string='Kanban State', readonly=True)
-    stage_id = fields.Many2one('project.task.type', string='Stage')
+    stage_id = fields.Many2one('project.task.type', string='Stage', readonly=True)
-        if report_invoice:
+        if report_invoice and report_invoice.attachment:
-        return [REPLACE_WITH(ids)], warnings
+
-    fees_implemented = fields.Boolean('Fees Computation Supported', compute='_compute_fees_implemented')
+    save_token = fields.Selection([
-        self.fees_implemented = hasattr(self, '%s_compute_fees' % self.provider)
+    @api.multi
-        ('form_save', 'Form with credentials storage')], 'Type',
+        ('form_save', 'Form with tokenization')], 'Type',
-        :param str transaction_id: the id of the authorized transaction in the
+        :param str transaction_id: id of the authorized transaction in the
-            })
+            if data.get('x_type').lower() in ['auth_capture', 'prior_auth_capture']:
-                                                           keep his payment data""")
+    ogone_alias_usage = fields.Char('Alias Usage', default="Allow saving my payment data",
-        if values.get('type') == 'form_save':
+        if self.save_token in ['ask', 'always']:
-            Method = self.env['payment.token']
+        if alias and tx.type == 'form_save':
-            if not Method.search_count(domain):
+            if not Token.search_count(domain):
-                tx.write({'payment_token_id': ref})
+                ref = Token.create({'name': data.get('CARDNO') + (' - ' + cardholder if cardholder else ''),
-            if data.get('ALIAS') and self.partner_id and self.type == 'form_save' and not self.payment_token_id:
+            if data.get('ALIAS') and self.partner_id and \
-            if tree.get('ALIAS') and self.partner_id and self.type == 'form_save' and not self.payment_token_id:
+            if tree.get('ALIAS') and self.partner_id and \
-    def payment_transaction(self, acquirer_id, token=None):
+    def payment_transaction(self, acquirer_id, tx_type='form', token=None):
-                tx.write(dict(Transaction.on_change_partner_id(order.partner_id.id).get('value', {}), amount=order.amount_total))
+                tx.write(dict(Transaction.on_change_partner_id(order.partner_id.id).get('value', {}), amount=order.amount_total, type=tx_type))
-                'type': 'form',
+                'type': tx_type,
-    payment_token_id = fields.Many2one('payment.token', string="Saved payment token")
+    payment_token_id = fields.Many2one('payment.token', string="Saved payment token", domain=[('acquirer_id.auto_confirm', '!=', 'authorize')],
-            res['domain'] = {'payment_token_id': [('partner_id', '=', self.partner_id.id)]}
+            res['domain'] = {'payment_token_id': [('partner_id', '=', self.partner_id.id), ('acquirer_id.auto_confirm', '!=', 'authorize')]}
-            self.payment_token_id = self.env['payment.token'].search([('partner_id', '=', self.partner_id.id)], limit=1)
+            self.payment_token_id = self.env['payment.token'].search([('partner_id', '=', self.partner_id.id), ('acquirer_id.auto_confirm', '!=', 'authorize')], limit=1)
-
+# -*- coding: utf-8 -*-
-            'x_type': 'AUTH_CAPTURE',
+            'x_type': 'AUTH_CAPTURE' if self.auto_confirm != 'authorize' else 'AUTH_ONLY',
-            _logger.error(error_msg)
+            _logger.info(error_msg)
-            _logger.error(error_msg)
+            _logger.info(error_msg)
-                'state': 'done',
+                'state': 'done' if data.get('x_type').lower() in ['auth_capture', 'prior_auth_capture'] else 'authorized',
-    @mute_logger('openerp.addons.payment_authorize.models.payment', 'ValidationError')
+    @mute_logger('odoo.addons.payment_authorize.models.payment', 'ValidationError')
-            'x_email': u'norbert.buyer@exampl',
+            'x_email': u'norbert.buyer@example.com',
-        return super(PaymentToken, self).create(values)
+                # remove all non-model fields used by (provider)_create method to avoid warning
-
+    @api.multi
-                if not s2s_result or tx.state != 'done':
+                valid_state = 'authorized' if tx.acquirer_id.auto_confirm == 'authorize' else 'done'
-        if (not order.amount_total and not tx) or tx.state in ['pending', 'done']:
+        if (not order.amount_total and not tx) or tx.state in ['pending', 'done', 'authorized']:
-                inv.paypal_url = "https://www.paypal.com/cgi-bin/webscr?" + werkzeug.url_encode(params)
+    active_move_lot_ids = fields.One2many('stock.move.lots', 'move_id', domain=[('done_wo', '=', True)], string='Lots')
-                move.quantity_done = sum(move.move_lot_ids.mapped('quantity_done'))
+                move.quantity_done = sum(move.move_lot_ids.filtered(lambda x: x.done_wo).mapped('quantity_done')) #TODO: change with active_move_lot_ids?
-            move.quants_unreserve()
+            moves_to_unreserve |= move
-
+        
-                move.reserved_quant_ids.sudo().write({'reservation_id': False})
+        self.filtered(lambda x: x.partially_available).write({'partially_available': False})
-import werkzeug.urls
+from openerp import models, fields
-                inv.paypal_url = "https://www.paypal.com/cgi-bin/webscr?" + werkzeug.url_encode(params)
+    paypal_url = fields.Char('Paypal Url', store=False)     # dummy field
-            request.session.authenticate(name, 'admin', password)
+            request.session.proxy("db").create_database(master_pwd, name, bool(post.get('demo')), lang, password, post['login'], country_code)
-    name = fields.Char(string='Category Name', required=True, translate=True)
+    name = fields.Char(string='Tag Name', required=True, translate=True)
-    field_id = fields.One2many('ir.model.fields', 'model_id', string='Fields', required=True, copy=True)
+    field_id = fields.One2many('ir.model.fields', 'model_id', string='Fields', required=True, copy=True,
-from odoo.modules.registry import RegistryManager
+from odoo.modules.registry import Registry
-            RegistryManager.signal_registry_change(self._cr.dbname)
+            registry = Registry.new(self._cr.dbname)
-        registry = odoo.modules.registry.RegistryManager.get(dbname)
+        registry = odoo.registry(dbname)
-
+import odoo
-    registry = RegistryManager.get(cr.dbname)
+    registry = odoo.registry(cr.dbname)
-from odoo.modules.registry import RegistryManager
+# -*- coding: utf-8 -*-
-    registry = RegistryManager.get(cr.dbname)
+    registry = odoo.registry(cr.dbname)
-from odoo.modules.registry import RegistryManager
+# -*- coding: utf-8 -*-
-    registry = RegistryManager.get(cr.dbname)
+    registry = odoo.registry(cr.dbname)
-from odoo.modules.registry import RegistryManager
+# -*- coding: utf-8 -*-
-    registry = RegistryManager.get(cr.dbname)
+    registry = odoo.registry(cr.dbname)
-from odoo.modules.registry import RegistryManager
+# -*- coding: utf-8 -*-
-    registry = RegistryManager.get(cr.dbname)
+    registry = odoo.registry(cr.dbname)
-from odoo.modules.registry import RegistryManager
+# -*- coding: utf-8 -*-
-    registry = RegistryManager.get(cr.dbname)
+    registry = odoo.registry(cr.dbname)
-from odoo.modules.registry import RegistryManager
+# -*- coding: utf-8 -*-
-    registry = RegistryManager.get(cr.dbname)
+    registry = odoo.registry(cr.dbname)
-from odoo.modules.registry import RegistryManager
+# -*- coding: utf-8 -*-
-    registry = RegistryManager.get(cr.dbname)
+    registry = odoo.registry(cr.dbname)
-from odoo.modules.registry import RegistryManager
+# -*- coding: utf-8 -*-
-    registry = RegistryManager.get(cr.dbname)
+    registry = odoo.registry(cr.dbname)
-from odoo.modules.registry import RegistryManager
+# -*- coding: utf-8 -*-
-    registry = RegistryManager.get(cr.dbname)
+    registry = odoo.registry(cr.dbname)
-from odoo.modules.registry import RegistryManager
+# -*- coding: utf-8 -*-
-    registry = RegistryManager.get(cr.dbname)
+    registry = odoo.registry(cr.dbname)
-from odoo.modules.registry import RegistryManager
+# -*- coding: utf-8 -*-
-    registry = RegistryManager.get(cr.dbname)
+    registry = odoo.registry(cr.dbname)
-from odoo.modules.registry import RegistryManager
+# -*- coding: utf-8 -*-
-    registry = RegistryManager.get(cr.dbname)
+    registry = odoo.registry(cr.dbname)
-from odoo.modules.registry import RegistryManager
+# -*- coding: utf-8 -*-
-    registry = RegistryManager.get(cr.dbname)
+    registry = odoo.registry(cr.dbname)
-from odoo.modules.registry import RegistryManager
+# -*- coding: utf-8 -*-
-    registry = RegistryManager.get(cr.dbname)
+    registry = odoo.registry(cr.dbname)
-from odoo.modules.registry import RegistryManager
+# -*- coding: utf-8 -*-
-    registry = RegistryManager.get(cr.dbname)
+    registry = odoo.registry(cr.dbname)
-from odoo.modules.registry import RegistryManager
+# -*- coding: utf-8 -*-
-    registry = RegistryManager.get(cr.dbname)
+    registry = odoo.registry(cr.dbname)
-from odoo.modules.registry import RegistryManager
+# -*- coding: utf-8 -*-
-    registry = RegistryManager.get(cr.dbname)
+    registry = odoo.registry(cr.dbname)
-from odoo.modules.registry import RegistryManager
+# -*- coding: utf-8 -*-
-    registry = RegistryManager.get(cr.dbname)
+    registry = odoo.registry(cr.dbname)
-from odoo.modules.registry import RegistryManager
+# -*- coding: utf-8 -*-
-    registry = RegistryManager.get(cr.dbname)
+    registry = odoo.registry(cr.dbname)
-from odoo.modules.registry import RegistryManager
+# -*- coding: utf-8 -*-
-    registry = RegistryManager.get(cr.dbname)
+    registry = odoo.registry(cr.dbname)
-from odoo.modules.registry import RegistryManager
+# -*- coding: utf-8 -*-
-    registry = RegistryManager.get(cr.dbname)
+    registry = odoo.registry(cr.dbname)
-from odoo.modules.registry import RegistryManager
+# -*- coding: utf-8 -*-
-    registry = RegistryManager.get(cr.dbname)
+    registry = odoo.registry(cr.dbname)
-from odoo.modules.registry import RegistryManager
+# -*- coding: utf-8 -*-
-    registry = RegistryManager.get(cr.dbname)
+    registry = odoo.registry(cr.dbname)
-        registry = odoo.modules.registry.RegistryManager.get(dbname)
+        registry = odoo.registry(dbname)
-    return modules.registry.RegistryManager.get(database_name)
+    return modules.registry.Registry(database_name)
-            odoo.modules.registry.RegistryManager.check_registry_signaling(self._cr.dbname)
+            if self.pool != self.pool.check_signaling():
-                    odoo.modules.registry.RegistryManager.signal_caches_change(self._cr.dbname)
+                    self.pool.signal_caches_change()
-from odoo.modules.registry import RegistryManager
+from odoo.modules.registry import Registry
-            RegistryManager.signal_registry_change(self._cr.dbname)
+            registry = Registry.new(self._cr.dbname)
-            RegistryManager.signal_registry_change(self._cr.dbname)
+            self.pool.signal_registry_change()
-            RegistryManager.signal_registry_change(self._cr.dbname)
+            registry = Registry.new(self._cr.dbname)
-                RegistryManager.signal_registry_change(self._cr.dbname)
+                self.pool.signal_registry_change()
-            RegistryManager.signal_registry_change(self._cr.dbname)
+            self.pool.signal_registry_change()
-        modules.registry.RegistryManager.new(self._cr.dbname, update_module=True)
+        modules.registry.Registry.new(self._cr.dbname, update_module=True)
-        odoo.modules.registry.RegistryManager.new(self._cr.dbname, update_module=True)
+        odoo.modules.registry.Registry.new(self._cr.dbname, update_module=True)
-        RegistryManager.signal_caches_change(self._cr.dbname)
+        self.pool.signal_caches_change()
-from openerp.modules.registry import RegistryManager
+from openerp.modules.registry import Registry
-        RegistryManager.new(common.get_db_name(), update_module=True)
+        Registry.new(common.get_db_name(), update_module=True)
-        RegistryManager.new(common.get_db_name(), update_module=True)
+        Registry.new(common.get_db_name(), update_module=True)
-        self.registry = RegistryManager.get(cr.dbname)
+        self.registry = Registry(cr.dbname)
-from openerp.modules.registry import RegistryManager
+from openerp.modules.registry import Registry
-        registry = openerp.modules.registry.RegistryManager.new(dbname)
+        registry = openerp.modules.registry.Registry.new(dbname)
-    registry = openerp.modules.registry.RegistryManager.new(dbname)
+    registry = openerp.modules.registry.Registry.new(dbname)
-                registry = openerp.modules.registry.RegistryManager.get(dbname)
+                registry = openerp.registry(dbname)
-                    openerp.modules.registry.RegistryManager.check_registry_signaling(db)
+                    openerp.registry(db).check_signaling()
-                        openerp.modules.registry.RegistryManager.signal_caches_change(db)
+                        ir_http.pool.signal_caches_change()
-        pool.add(ModelClass._name, ModelClass)
+        pool[name] = ModelClass
-            cls.pool._any_cache_cleared = True
+            cls.pool.cache_cleared = True
-                openerp.modules.registry.RegistryManager.clear_caches(cr.dbname)
+                openerp.registry(cr.dbname).clear_caches()
-        # openerp.modules.registry.RegistryManager.new().
+        # openerp.modules.registry.Registry.new().
-                return openerp.modules.registry.RegistryManager.new(cr.dbname, force_demo, status, update_module)
+                return openerp.modules.registry.Registry.new(cr.dbname, force_demo, status, update_module)
-from openerp.tools import assertion_report, classproperty, config, \
+from openerp.tools import assertion_report, lazy_classproperty, config, \
-        super(Registry, self).__init__()
+    @classmethod
-        self.base_cache_signaling_sequence = None
+        self.registry_sequence = None
-        self._any_cache_cleared = False
+        self.cache_cleared = False
-        cr.close()
+    @classmethod
-        return RegistryManager.model_cache
+    def __setitem__(self, model_name, model):
-        This clears the caches associated to methods decorated with
+        """ Clear the caches associated to methods decorated with
-    def setup_multi_process_signaling(cls, cr):
+    def setup_signaling(self):
-        return r, c
+            return
-        RegistryManager.enter_test_mode()
+        assert Registry._saved_lock is None
-        RegistryManager.leave_test_mode()
+        assert Registry._saved_lock is not None
-        registries (essentially database connection/model registry pairs).
+    This is deprecated, use :class:`Registry` instead.
-                threading.current_thread().dbname = db_name
+        return Registry(db_name)
-        return registry
+    def new(cls, db_name, force_demo=False, status=None, update_module=False):
-                del cls.registries[db_name]
+        return Registry.delete(db_name)
-                cls.delete(db_name)
+        return Registry.delete_all()
-                cls.registries[db_name].clear_caches()
+        return Registry(db_name).clear_caches()
-        return changed
+        registry = Registry(db_name)
-                registry.reset_any_cache_cleared()
+        return Registry(db_name).signal_caches_change()
-            registry.base_registry_signaling_sequence = r
+        return Registry(db_name).signal_registry_change()
-                registry = openerp.modules.registry.RegistryManager.get(dbname)
+                registry = openerp.registry(dbname)
-    if openerp.modules.registry.RegistryManager.get(cr.dbname).has_unaccent:
+    if openerp.registry(cr.dbname).has_unaccent:
-            # TODO this should be removed as it is done by RegistryManager.new().
+            # TODO this should be removed as it is done by Registry.new().
-            db_name, demo, None, update_module=True)
+        registry = openerp.modules.registry.Registry.new(db_name, demo, None, update_module=True)
-    registry = openerp.modules.registry.RegistryManager.new(db_name)
+    registry = openerp.modules.registry.Registry.new(db_name)
-    openerp.modules.registry.RegistryManager.delete(db_name)
+    openerp.modules.registry.Registry.delete(db_name)
-        registry = openerp.modules.registry.RegistryManager.new(db)
+        registry = openerp.modules.registry.Registry.new(db)
-    openerp.modules.registry.RegistryManager.delete(old_name)
+    openerp.modules.registry.Registry.delete(old_name)
-        openerp.modules.registry.RegistryManager.new(db, force_demo=False, update_module=True)
+        openerp.modules.registry.Registry.new(db, force_demo=False, update_module=True)
-    openerp.modules.registry.RegistryManager.check_registry_signaling(db)
+    registry = openerp.registry(db).check_signaling()
-    openerp.modules.registry.RegistryManager.signal_caches_change(db)
+    registry.signal_caches_change()
-    openerp.modules.registry.RegistryManager.check_registry_signaling(db)
+    registry = openerp.registry(db).check_signaling()
-    openerp.modules.registry.RegistryManager.signal_caches_change(db)
+    registry.signal_caches_change()
-from openerp.modules.registry import RegistryManager
+from openerp.modules.registry import Registry
-            registries = openerp.modules.registry.RegistryManager.registries
+            registries = openerp.modules.registry.Registry.registries
-        openerp.modules.registry.RegistryManager.delete_all()
+        openerp.modules.registry.Registry.delete_all()
-                         len(openerp.modules.registry.RegistryManager.registries))
+                         len(openerp.modules.registry.Registry.registries))
-            openerp.modules.registry.RegistryManager.delete(db_name)
+            openerp.modules.registry.Registry.delete(db_name)
-            registry = RegistryManager.new(dbname, update_module=update_module)
+            registry = Registry.new(dbname, update_module=update_module)
-    """ You might want to call openerp.modules.registry.RegistryManager.delete(db_name) along this function."""
+    """ You might want to call openerp.modules.registry.Registry.delete(db_name) along this function."""
-        self.registry = RegistryManager.get(get_db_name())
+        self.registry = openerp.registry(get_db_name())
-        cls.registry = RegistryManager.get(get_db_name())
+        cls.registry = openerp.registry(get_db_name())
-        model.pool._any_cache_cleared = True
+        model.pool.cache_cleared = True
-    from openerp.modules.registry import RegistryManager
+    from openerp.modules.registry import Registry
-    for dbname, reg in RegistryManager.registries.iteritems():
+    for dbname, reg in Registry.registries.iteritems():
-    return get_db_and_pool(db_name, force_demo, status, update_module)[1]
+                            price_before = line.get('price', 0.0)
-                                'price': round((price_unit - valuation_price_unit) * line['quantity'], account_prec),
+                                'price': round(price_before - line.get('price', 0.0), account_prec),
-        partner_id = self.env.user.partner_id.id
+        return self._action_unfollow(self.env.user.partner_id)
-        self.env['bus.bus'].sendone((self._cr.dbname, 'res.partner', partner_id), channel_info)
+        result = self.write({'channel_partner_ids': [(3, partner.id)]})
-            self.sudo().message_post(body=notification, message_type="notification", subtype="mail.mt_comment", author_id=partner_id)
+            self.sudo().message_post(body=notification, message_type="notification", subtype="mail.mt_comment", author_id=partner.id)
-        self.write({'channel_ids': [(6, 0, channels.ids)], 'needaction_partner_ids': [(6, 0, partners.ids)]})
+        # update message, with maybe custom values
-    def _find_partner_from_emails(self, emails, res_model=None, res_id=None, check_followers=True, force_create=False):
+    def _find_partner_from_emails(self, emails, res_model=None, res_id=None, check_followers=True, force_create=False, exclude_aliases=True):
-                    break
+            partner_id = next((partner.id for partner in followers if partner.email == email_address), False)
-                    partner_id = partners[0].id
+                partner_id = partners.id
-                    partner_id = partners[0].id
+                partner_id = partners.id
-        for record_id in self.ids:
+        for record in self:
-                ('res_id', '=', record_id),
+                ('res_id', '=', record.id),
-    def _notify(self, force_send=False, user_signature=True):
+    def _notify(self, force_send=False, send_after_commit=True, user_signature=True):
-        partners._notify(self, force_send=force_send, user_signature=user_signature)
+        partners._notify(self, force_send=force_send, send_after_commit=send_after_commit, user_signature=user_signature)
-from odoo import _, api, fields, models
+from odoo import _, api, fields, models, registry, SUPERUSER_ID
-    def _notify(self, message, force_send=False, user_signature=True):
+    def _notify(self, message, force_send=False, send_after_commit=True, user_signature=True):
-            ('notify_email', '!=', 'none')])._notify_by_email(message, force_send=force_send, user_signature=user_signature)
+            ('notify_email', '!=', 'none')])._notify_by_email(message, force_send=force_send, send_after_commit=send_after_commit, user_signature=user_signature)
-    def _notify_by_email(self, message, force_send=False, user_signature=True):
+    def _notify_by_email(self, message, force_send=False, send_after_commit=True, user_signature=True):
-        the recordset on which this method is called. """
+        the recordset on which this method is called.
-            emails.send()
+                (not self.pool._init or test_mode):
-                new_partners.with_context(auto_delete=True)._notify(message, force_send=True, user_signature=True)
+                new_partners.with_context(auto_delete=True)._notify(message, force_send=True, send_after_commit=False, user_signature=True)
-        elif self.env.user.email:
+        if self.env.user.email:
-        raise UserError(_("Unable to send email, please configure the sender's email address or alias."))
+        raise UserError(_("Unable to send email, please configure the sender's email address."))
-    _inherit = ['mail.alias.mixin', 'res.users']
+    _inherit = ['res.users']
-    alias_id = fields.Many2one('mail.alias', 'Alias', ondelete="restrict", required=True,
+    alias_id = fields.Many2one('mail.alias', 'Alias', ondelete="set null", required=False,
-        type(self).SELF_READABLE_FIELDS.extend(['notify_email', 'alias_domain', 'alias_name'])
+        type(self).SELF_READABLE_FIELDS.extend(['notify_email'])
-        self.assertEqual(user_barty.alias_name, 'b4r+_-_r3wl-', 'Disallowed chars should be replaced by hyphens')
+        alias = self.env['mail.alias'].with_context(alias_model_name='mail.channel').create({'alias_name': 'b4r+_#_R3wl$$'})
-                         'message_post: notification email wrong email_from: should use alias of sender')
+                         set(['%s <%s>' % (self.user_employee.name, self.user_employee.email)]),
-        self.assertEqual(msg.email_from, '%s <%s@%s>' % (self.user_employee.name, self.user_employee.alias_name, alias_domain))
+        self.assertEqual(msg.reply_to, '%s <%s>' % (self.user_employee.name, self.user_employee.email))
-        self.assertEqual(msg.email_from, '%s <%s@%s>' % (self.user_employee.name, self.user_employee.alias_name, alias_domain))
+        self.assertEqual(msg.email_from, '%s <%s>' % (self.user_employee.name, self.user_employee.email))
-        self.assertEqual(msg.email_from, '%s <%s@%s>' % (self.user_employee.name, self.user_employee.alias_name, alias_domain))
+        self.assertEqual(msg.email_from, '%s <%s>' % (self.user_employee.name, self.user_employee.email))
-        self.assertEqual(msg.email_from, '%s <%s@%s>' % (self.user_employee.name, self.user_employee.alias_name, alias_domain))
+        self.assertEqual(msg.email_from, '%s <%s>' % (self.user_employee.name, self.user_employee.email))
-            'name': 'Gustave DorÃ©', 'login': 'Gustav', 'alias_name': 'gustav', 'email': 'gustav.dore@example.com',
+            'name': 'Gustave DorÃ©', 'login': 'Gustav','email': 'gustav.dore@example.com',
-            'name': 'Lukas Peeters', 'login': 'Lukas', 'alias_name': 'lukas', 'email': 'lukas.petters@example.com',
+            'name': 'Lukas Peeters', 'login': 'Lukas', 'email': 'lukas.petters@example.com',
-            'name': 'Wout Janssens', 'login': 'Wout', 'alias_name': 'wout', 'email': 'wout.janssens@example.com',
+            'name': 'Wout Janssens', 'login': 'Wout', 'email': 'wout.janssens@example.com',
-            'alias_name': 'cedric',
+import re
-from odoo import api, models
+from odoo import api, models, tools
-    in message_process. """
+    """ Update MailThread to add the support of bounce management in mass mailing statistics. """
-        return False to end the routing process. """
+    @api.model
-        email_from = decode_message_header(message, 'From')
+        email_to_localpart = (tools.email_split(email_to) or [''])[0].split('@', 1)[0].lower()
-            # group(1) = the mail ID; group(2) = the model (if any); group(3) = the record ID
+        if bounce_alias and bounce_alias in email_to_localpart:
-        return True
+                self.env['mail.mail.statistics'].set_bounced(mail_mail_ids=[bounced_mail_id])
-
+import mail_notification
-        my_messages = self.sudo().filtered(lambda msg: self.env.user.partner_id in msg.needaction_partner_ids)
+        my_messages = self.env['mail.notification'].sudo().search([
-        return [('needaction_partner_ids', 'not in', self.env.user.partner_id.id)]
+            return ['&', ('notification_ids.res_partner_id', '=', self.env.user.partner_id.id), ('notification_ids.is_read', '=', False)]
-        if domain is None:
+        delete_mode = not self.env.user.share  # delete employee notifs, keep customer ones
-            unread_messages.sudo().write({'needaction_partner_ids': [(3, partner_id)]})
+            notifications = self.env['mail.notification'].sudo().search([
-        if not len(messages):
+        delete_mode = not self.env.user.share  # delete employee notifs, keep customer ones
-        messages.sudo().write({'needaction_partner_ids': [(3, partner_id.id)]})
+        messages = notifications.mapped('mail_message_id')
-                             ON rel.mail_message_id = msg.id AND rel.res_partner_id = %s
+                             ON rel.mail_message_id = msg.id AND rel.res_partner_id = %s AND (rel.is_read = false OR rel.is_read IS NULL)
-
+                # update notifications
-                WHERE R.res_partner_id = %s """, (self.env.user.partner_id.id,))
+                WHERE R.res_partner_id = %s AND (R.is_read = false OR R.is_read IS NULL)""", (self.env.user.partner_id.id,))
-        self.assertEqual(len(self.group_public.message_ids), 3, 'message_process: group should contain 6 messages')
+        self.assertEqual(len(self.group_public.message_ids), 2, 'message_process: group should contain 6 messages')
-                        headers['Return-Path'] = '%s-%d-%s-%d@%s' % (bounce_alias, mail.id, mail.model, mail.res_id, catchall_domain)
+                        headers['Return-Path'] = '%s+%d-%s-%d@%s' % (bounce_alias, mail.id, mail.model, mail.res_id, catchall_domain)
-                        headers['Return-Path'] = '%s-%d@%s' % (bounce_alias, mail.id, catchall_domain)
+                        headers['Return-Path'] = '%s+%d@%s' % (bounce_alias, mail.id, catchall_domain)
-            bounce_re = re.compile("%s-(\d+)-?([\w.]+)?-?(\d+)?" % re.escape(bounce_alias), re.UNICODE)
+            bounce_re = re.compile("%s\+(\d+)-?([\w.]+)?-?(\d+)?" % re.escape(bounce_alias), re.UNICODE)
-                    dest_aliases = Alias.search([('alias_name', '=', email_to_localpart)], limit=1)
+                    dest_aliases = Alias.search([('alias_name', 'in', rcpt_tos_localparts)], limit=1)
-from odoo import api, models
+from odoo import api, models, _
-        res = super(MailThread, self).message_route_verify(message, message_dict, route, update_author, assert_model, create_fallback, allow_private)
+    def message_route_verify(self, message, message_dict, route,
-                    _create_bounce_email(mail_template.body_html)
+                    self._routing_warn(_('alias %s does not accept unknown employees') % alias.alias_name, _('skipping'), message_id, route, False)
-    def message_route_verify(self, message, message_dict, route, update_author=True, assert_model=True, create_fallback=True, allow_private=False):
+    def message_route_verify(self, message, message_dict, route,
-                         message_id, route, message)
+        _generic_bounce_body_html = """<div>
-            _warn('unknown target model %s' % model)
+            self._routing_warn(_('unknown target model %s') % model, '', message_id, route, assert_model)
-            return False
+        # Private message
-                _warn('reply to missing document (%s,%s), fall back on new document creation' % (model, thread_id))
+        # Existing Document: check if exists and model accepts the mailgateway; if not, fallback on create if allowed
-                _warn('model %s does not accept document update, fall back on document creation' % model)
+            elif not hasattr(record_set, 'message_update') and create_fallback:
-                _warn('model %s does not accept document update, skipping' % model)
+
-            _warn('model %s does not accept document creation, skipping' % model)
+            self._routing_warn(_('model %s does not accept document creation') % model, _('skipping'), message_id, route, assert_model)
-        # We do it now because we need it for aliases (contact settings)
+        # Update message author if asked. We do it now because we need it for aliases (contact settings)
-                _create_bounce_email()
+                self._routing_warn(_('alias %s restricted to internal followers') % alias.alias_name, _('skipping'), message_id, route, False)
-            _create_bounce_email()
+            self._routing_warn(_('alias %s does not accept unknown author') % alias.alias_name, _('skipping'), message_id, route, False)
-            return ()
+            return False
-        return (model, thread_id, route[2], route[3], None if self._context.get('drop_alias', False) else route[4])
+        return (model, thread_id, route[2], route[3], None if drop_alias else route[4])
-        """Attempt to figure out the correct target model, thread_id,
+        """ Attempt to figure out the correct target model, thread_id,
-           :return: list of [model, thread_id, custom_values, user_id, alias]
+
-        Alias = self.env['mail.alias']
+        Alias, dest_aliases = self.env['mail.alias'], self.env['mail.alias']
-        # Get email.message.Message variables for future processing
+        # get email.message.Message variables for future processing
-        email_to = tools.decode_message_header(message, 'To')
+
-                         email_from, email_to, message_id)
+        if message.get_content_type() == 'multipart/report' or email_from_localpart == 'mailer-daemon':
-                return []
+        # 1. message is a reply to an existing message (exact match of message_id or compat-mode)
-            local_hostname = socket.gethostname()
+            # message is a reply to an existing thread (6.1 compatibility)
-            if mail_message_ids:
+            if not mail_messages and local_hostname == reply_hostname and reply_thread_id and reply_model in self.env:
-                    update_author=True, assert_model=True, create_fallback=True, allow_private=True)
+                    (model, thread_id, custom_values, self._uid, dest_aliases),
-                        email_from, email_to, message_id, mail_message_ids.id, custom_values, self._uid)
+                        'Routing mail from %s to %s with Message-Id %s%s: direct reply to msg: model: %s, thread_id: %s, custom_values: %s, uid: %s',
-            if aliases:
+        if rcpt_tos_localparts:
-                for alias in aliases:
+                for alias in dest_aliases:
-            return [route]
+        if fallback_model:
-    ref_match, model, thread_id, hostname = False, False, False, False
+    ref_match, model, thread_id, hostname, is_private = False, False, False, False, False
-    return (ref_match, model, thread_id, hostname)
+    else:
-
+from odoo import api, fields, models, _
-from odoo.tools import email_split
+from odoo.tools import decode_message_header, email_split
-            email_from = decode_header(message, 'From')
+            email_from = decode_message_header(message, 'From')
-                bounce_to = decode_header(message, 'Return-Path') or email_from
+                bounce_to = decode_message_header(message, 'Return-Path') or email_from
-        s = ', '.join([decode(message.get(h)) for h in header_fields if message.get(h)])
+        s = ', '.join([tools.decode_smtp_header(message.get(h)) for h in header_fields if message.get(h)])
-        email_from = decode_header(message, 'From')
+        email_from = tools.decode_message_header(message, 'From')
-            bounce_to = decode_header(message, 'Return-Path') or email_from
+            bounce_to = tools.decode_smtp_header(message.get('Return-Path')) or email_from
-        in_reply_to = decode_header(message, 'In-Reply-To').strip()
+        email_from = tools.decode_message_header(message, 'From')
-        msg_references = mail_header_msgid_re.findall(thread_references)
+        ref_match, reply_model, reply_thread_id, reply_hostname = tools.email_references(thread_references)
-                       decode_header(message, 'Resent-Cc')])
+             ','.join([tools.decode_message_header(message, 'Delivered-To'),
-            match = tools.res_re.search(decode_header(message, 'Subject'))
+            match = tools.res_re.search(tools.decode_message_header(message, 'Subject'))
-                        filename = decode(filename)
+                        filename = tools.decode_smtp_header(filename)
-            msg_dict['subject'] = decode(message.get('Subject'))
+            msg_dict['subject'] = tools.decode_smtp_header(message.get('Subject'))
-        msg_dict['email_from'] = decode(message.get('from'))
+        msg_dict['from'] = tools.decode_smtp_header(message.get('from'))
-                date_hdr = decode(message.get('Date'))
+                date_hdr = tools.decode_smtp_header(message.get('Date'))
-            parent_ids = self.env['mail.message'].search([('message_id', '=', decode(message['In-Reply-To'].strip()))], limit=1)
+            parent_ids = self.env['mail.message'].search([('message_id', '=', tools.decode_smtp_header(message['In-Reply-To'].strip()))], limit=1)
-            msg_list = mail_header_msgid_re.findall(decode(message['References']))
+            msg_list = tools.mail_header_msgid_re.findall(tools.decode_smtp_header(message['References']))
-
+from odoo.tools import decode_smtp_header, decode_message_header
-        email_to = decode_header(message, 'To')
+        email_from = decode_message_header(message, 'From')
-            message_ids = [x.strip() for x in decode(message['References']).split()]
+            message_ids = [x.strip() for x in decode_smtp_header(message['References']).split()]
-import lxml.html
+
-from openerp.tools.translate import _
+# legacy behavior: match [ID] in the Subject, used with the fallback model of the mail gateway
-    'category': 'Website',
+    'category': 'Theme',
-    'category': 'Hidden',
+    'category': 'Theme/Hidden',
-        """ Incoming email using in-rely-to should go into the right destination event with a wrong destination """
+        """ Incoming email using in-rely-to should go into the right destination even with a wrong destination """
-        """ Incoming email using in-rely-to should go into the right destination event with a wrong destination """
+        """ Incoming email using references should go into the right destination even with a wrong destination """
-        msg = self.env['mail.message'].browse(msg1.id)
+    @mute_logger('openerp.addons.mail.models.mail_thread', 'openerp.models', 'openerp.addons.mail.models.mail_mail')
-            self.assertFalse(msg_fw.parent_id)
+        fw_msg_id = '<THIS.IS.A.FW.MESSAGE.1@bert.fr>'
-        user_id = super(Users, self)._login(db, login, password)
+    @classmethod
-            env = api.Environment(cr, SUPERUSER_ID, {})
+            env = api.Environment(cr, SUPERUSER_ID, {})
-                    user_id = Ldap.sudo().get_or_create_user(conf, login, entry)
+                    user_id = Ldap.get_or_create_user(conf, login, entry)
-            self.registry('base_import.import')._match_headers(
+            self.env['base_import.import']._match_headers(
-    def _auth_method_calendar(self):
+    @classmethod
-    def get_utm_domain_cookies(self):
+    @classmethod
-        response = super(IrHttp, self)._dispatch()
+    @classmethod
-                response.set_cookie(cook, request.params[var], domain=self.get_utm_domain_cookies())
+                response.set_cookie(cook, request.params[var], domain=cls.get_utm_domain_cookies())
-    def _dispatch(self):
+    @classmethod
-        return super(IrHttp, self)._dispatch()
+        return super(IrHttp, cls)._dispatch()
-    def _get_converters(self):
+    @classmethod
-            super(Http, self)._get_converters(),
+            super(Http, cls)._get_converters(),
-    def _auth_method_public(self):
+    @classmethod
-    def is_a_bot(self):
+    @classmethod
-            return any(bot in user_agent for bot in self.bots)
+            return any(bot in user_agent for bot in cls.bots)
-            return any(bot in user_agent.encode('ascii', 'ignore') for bot in self.bots)
+            return any(bot in user_agent.encode('ascii', 'ignore') for bot in cls.bots)
-    def get_nearest_lang(self, lang):
+    @classmethod
-        if self._geoip_resolver is None:
+    @classmethod
-                    self._geoip_resolver = GeoIP.open(geofile, GeoIP.GEOIP_STANDARD)
+                    cls._geoip_resolver = GeoIP.open(geofile, GeoIP.GEOIP_STANDARD)
-                    self._geoip_resolver = False
+                    cls._geoip_resolver = False
-                self._geoip_resolver = False
+                cls._geoip_resolver = False
-    def _geoip_resolve(self):
+    @classmethod
-                record = self._geoip_resolver.record_by_addr(request.httprequest.remote_addr) or {}
+            if cls._geoip_resolver and request.httprequest.remote_addr:
-        return (self._name, "cache", request.uid, request.lang, request.httprequest.full_path)
+    @classmethod
-    def _dispatch(self):
+    @classmethod
-            func, arguments = self._find_handler()
+            func, arguments = cls._find_handler()
-        self._geoip_resolve()
+        cls._geoip_setup_resolver()
-                    self._authenticate(func.routing['auth'])
+                    cls._authenticate(func.routing['auth'])
-                    self._auth_method_public()
+                    cls._auth_method_public()
-                return self._handle_exception(e)
+                return cls._handle_exception(e)
-                nearest_lang = not func and self.get_nearest_lang(path[1])
+                nearest_lang = not func and cls.get_nearest_lang(path[1])
-                                  or self.get_nearest_lang(request.lang)
+                                  or cls.get_nearest_lang(request.lang)
-                is_a_bot = self.is_a_bot()
+                is_a_bot = cls.is_a_bot()
-                    return self.reroute('/'.join(path) or '/')
+                    return cls.reroute('/'.join(path) or '/')
-        resp = super(Http, self)._dispatch()
+        resp = super(Http, cls)._dispatch()
-    def reroute(self, path):
+    @classmethod
-        if len(request.rerouting) > self.rerouting_limit:
+        if len(request.rerouting) > cls.rerouting_limit:
-        return self._dispatch()
+        return cls._dispatch()
-        super(Http, self)._postprocess_args(arguments, rule)
+    @classmethod
-            return self._handle_exception(e, code=404)
+            return cls._handle_exception(e, code=404)
-    def _handle_exception(self, exception, code=500):
+    @classmethod
-            return super(Http, self)._handle_exception(exception)
+            return super(Http, cls)._handle_exception(exception)
-                response = super(Http, self)._handle_exception(exception)
+                response = super(Http, cls)._handle_exception(exception)
-                self._auth_method_public()
+                cls._auth_method_public()
-    def binary_content(self, xmlid=None, model='ir.attachment', id=None, field='datas', unique=False, filename=None, filename_field='datas_fname', download=False, mimetype=None, default_mimetype='application/octet-stream', env=None):
+    @classmethod
-        return super(Http, self).binary_content(xmlid=xmlid, model=model, id=id, field=field, unique=unique, filename=filename, filename_field=filename_field, download=download, mimetype=mimetype, default_mimetype=default_mimetype, env=env)
+        return super(Http, cls).binary_content(xmlid=xmlid, model=model, id=id, field=field, unique=unique, filename=filename, filename_field=filename_field, download=download, mimetype=mimetype, default_mimetype=default_mimetype, env=env)
-    def _dispatch(self):
+    @classmethod
-        return super(IrHttp, self)._dispatch()
+        return super(IrHttp, cls)._dispatch()
-    def _process_job(self, job_cr, job, cron_cr):
+    @classmethod
-                cron = api.Environment(job_cr, job['user_id'], {})[self._name]
+                cron = api.Environment(job_cr, job['user_id'], {})[cls._name]
-    def _get_converters(self):
+    @classmethod
-        return self.routing_map().bind_to_environ(request.httprequest.environ).match(return_rule=return_rule)
+    @classmethod
-    def _auth_method_user(self):
+    @classmethod
-    def _auth_method_none(self):
+    @classmethod
-    def _auth_method_public(self):
+    @classmethod
-    def _authenticate(self, auth_method='user'):
+    @classmethod
-                getattr(self, "_auth_method_%s" % auth_method)()
+                getattr(cls, "_auth_method_%s" % auth_method)()
-    def _serve_attachment(self):
+    @classmethod
-    def _handle_exception(self, exception):
+    @classmethod
-            attach = self._serve_attachment()
+            attach = cls._serve_attachment()
-    def _dispatch(self):
+    @classmethod
-            rule, arguments = self._find_handler(return_rule=True)
+            rule, arguments = cls._find_handler(return_rule=True)
-            return self._handle_exception(e)
+            return cls._handle_exception(e)
-            auth_method = self._authenticate(func.routing["auth"])
+            auth_method = cls._authenticate(func.routing["auth"])
-            return self._handle_exception(e)
+            return cls._handle_exception(e)
-        processing = self._postprocess_args(arguments, rule)
+        processing = cls._postprocess_args(arguments, rule)
-            return self._handle_exception(e)
+            return cls._handle_exception(e)
-    def _postprocess_args(self, arguments, rule):
+    @classmethod
-                    return self._handle_exception(werkzeug.exceptions.NotFound())
+                    return cls._handle_exception(werkzeug.exceptions.NotFound())
-        if not hasattr(self, '_routing_map'):
+    @classmethod
-            # Note : when routing map is generated, we put it on the class `type(self)`
+            # Note : when routing map is generated, we put it on the class `cls`
-        return self._routing_map
+            cls._routing_map = http.routing_map(mods, False, converters=cls._get_converters())
-            del type(self)._routing_map
+    @classmethod
-    def content_disposition(self, filename):
+    @classmethod
-    def binary_content(self, xmlid=None, model='ir.attachment', id=None, field='datas', unique=False, filename=None, filename_field='datas_fname', download=False, mimetype=None, default_mimetype='application/octet-stream', env=None):
+    @classmethod
-            headers.append(('Content-Disposition', self.content_disposition(filename)))
+            headers.append(('Content-Disposition', cls.content_disposition(filename)))
-    __cache_clearing_methods = []
+    __cache_clearing_methods = set()
-        self.__cache_clearing_methods.append((model, method))
+    @classmethod
-            pass
+    @classmethod
-    def clear_caches(self):
+    @classmethod
-        return super(ResFont, self).clear_caches()
+        return super(ResFont, cls).clear_caches()
-    def _login(self, db, login, password):
+    @classmethod
-                    self._update_last_login(cr, user_id)
+            with cls.pool.cursor() as cr:
-    def authenticate(self, db, login, password, user_agent_env):
+    @classmethod
-        uid = self._login(db, login, password)
+        uid = cls._login(db, login, password)
-                    with self.pool.cursor() as cr:
+                    with cls.pool.cursor() as cr:
-                            ICP.set_param(cr, uid, 'web.base.url', base)
+                        ICP = api.Environment(cr, uid, {})['ir.config_parameter']
-    def check(self, db, uid, passwd):
+    @classmethod
-        if self.__uid_cache[db].get(uid) == passwd:
+        if cls.__uid_cache[db].get(uid) == passwd:
-        cr = self.pool.cursor()
+        cr = cls.pool.cursor()
-            self.__uid_cache[db][uid] = passwd
+            self = api.Environment(cr, uid, {})[cls._name]
-from .tools import frozendict, lazy_property, ormcache, Collector, LastOrderedSet, OrderedSet
+from .tools import frozendict, lazy_classproperty, lazy_property, ormcache, \
-            ModelClass = type(pool[name])
+            ModelClass = pool[name]
-            parent_class = type(pool[parent])
+            parent_class = pool[parent]
-        # instantiate the model, and initialize it
+        check_pg_name(ModelClass._table)
-        return model
+
-            child_class = type(pool[child_name])
+            child_class = pool[child_name]
-                "in order to implement their access rights policy"
+        """ Deprecated method to initialize the model. """
-        ModelData = self.env['ir.model.data'].clear_caches()
+        ModelData = self.env['ir.model.data']
-    def clear_caches(self):
+    @classmethod
-            self.pool._any_cache_cleared = True
+            cls.pool.cache.clear()
-    instances. There is one registry instance per database.
+    The registry is essentially a mapping between model names and model classes.
-        models = [env[model_name] for model_name in self.models]
+        models = env.values()
-                            model_name = model_obj._description or model_obj._name
+                            model_class = registry[model]
-__all__ = ['synchronized', 'lazy_property', 'classproperty', 'conditional']
+__all__ = ['synchronized', 'lazy_classproperty', 'lazy_property',
-            record = self.env[python.model]._model
+            record = self.env[python.model]
-            'model': record._model,
+            'model': record,
-            ctx = request.context
+            ctx = dict(request.context)
-            action = env[action_type].browse([action_id]).read()
+            request.context = ctx
-            request.context['translatable'] = True
+        context = dict(request.context)
-            request.context['website_id'] = request.website.id
+            context = dict(request.context)
-                request.lang = request.context['lang'] = nearest_lang or preferred_lang
+                request.lang = context['lang'] = nearest_lang or preferred_lang
-                request.context['tz'] = request.session.get('geoip', {}).get('time_zone')
+                context['edit_translations'] = False
-            request.website = request.website.with_context(request.context)
+            request.context = context
-        request.context['website_id'] = website_id
+        request.context = dict(request.context, website_id=website_id)
-        return request.env['event.event'].with_context(context).create(vals)
+        return request.env['event.event'].with_context(context or {}).create(vals)
-            context['default_event_ticket_ids'] = [[0, 0, {
+            context = dict(context or {}, default_event_ticket_ids=[[0, 0, {
-            }]]
+            }]])
-        request.env = request.env(context=dict(request.env.context, pricelist=pricelist.id, partner=request.env.user.partner_id))
+        request.context = dict(request.context, pricelist=pricelist.id, partner=request.env.user.partner_id)
-from openerp.tools import ustr, consteq
+from openerp.tools import ustr, consteq, frozendict
-        self.uid = None
+        self._uid = None
-        to a database.
+    @property
-        return openerp.api.Environment(self.cr, self.uid, self.context)
+        if not self._cr:
-    @lazy_property
+    @property
-        return dict(self.session.context)
+        """ :class:`~collections.Mapping` of context values for the current request """
-        return self.context["lang"]
+        context = dict(self.context)
-        a :class:`OpenERPSession` holding the HTTP session data for the
+        """ :class:`OpenERPSession` holding the HTTP session data for the
-        return request.httpsession.save_action(the_action)
+        return request.session.save_action(the_action)
-        return request.httpsession.get_action(key)
+        return request.session.get_action(key)
-            "session_id": request.session_id,
+            "session_id": request.session.sid,
-            request.session[request.session_id].append(blog_post.id)
+        request.session[request.session.sid] = request.session.get(request.session.sid, [])
-        slide_key = '%s_%s' % (view_mode, request.session_id)
+        slide_key = '%s_%s' % (view_mode, request.session.sid)
-        return openerp.modules.registry.RegistryManager.get(self.db) if self.db else None
+        return openerp.registry(self.db) if self.db else None
-        config = ResConfig.browse(self._cr, self._uid, [], self._context).next() or {}
+        if to_install or to_uninstall_modules:
-    _constraints = [(osv.osv._check_recursion, 'Circular references are not permitted between tasks and sub-tasks', ['parent_id'])]
+    _constraints = [(models.BaseModel._check_recursion, 'Circular references are not permitted between tasks and sub-tasks', ['parent_id'])]
-from odoo.http import request, serialize_exception as _serialize_exception, content_disposition
+from odoo.http import content_disposition, dispatch_rpc, request, \
-    actions = ir_values.get_actions(action_slot=action_slot, model=model, res_id=res_id, context=request.context)
+    actions = request.env['ir.values'].get_actions(action_slot, model, res_id)
-            request.session.proxy("db").create_database(master_pwd, name, bool(post.get('demo')), lang, password, post.get('login'), country_code)
+            dispatch_rpc('db', 'create_database', [master_pwd, name, bool(post.get('demo')), lang, password, post.get('login'), country_code])
-            request.session.proxy("db").duplicate_database(master_pwd, name, new_name)
+            dispatch_rpc('db', 'duplicate_database', [master_pwd, name, new_name])
-            request.session.proxy("db").drop(master_pwd, name)
+            dispatch_rpc('db','drop', [master_pwd, name])
-            request.session.proxy("db").restore(master_pwd, name, data, str2bool(copy))
+            dispatch_rpc('db', 'restore', [master_pwd, name, data, str2bool(copy)])
-            request.session.proxy("db").change_admin_password(master_pwd, master_pwd_new)
+            dispatch_rpc('db', 'change_admin_password', [master_pwd, master_pwd_new])
-                old_password, new_password):
+            if request.env['res.users'].change_password(old_password, new_password):
-            return request.session.proxy("db").list_lang() or []
+            return dispatch_rpc('db', 'list_lang', []) or []
-        request.session.assert_valid()
+        request.session.check_security()
-        return request.session.model('ir.ui.menu').get_needaction_data(menu_ids, request.context)
+        return request.env['ir.ui.menu'].browse(menu_ids).get_needaction_data()
-        Model = request.session.model(model)
+        Model = request.env[model]
-                           request.context)
+        records = Model.search_read(domain, fields,
-            length = Model.search_count(domain, request.context)
+            length = Model.search_count(domain)
-        r = m.read([id], False, request.context)
+        r = request.env[model].browse([id]).read()
-        return request.session.exec_workflow(model, id, signal)
+        request.session.check_security()
-        m = request.session.model(model)
+        m = request.env[model]
-            m.write(id, { field: i + offset })
+        for i, record in enumerate(m.browse(ids)):
-        CustomView = request.session.model('ir.ui.view.custom')
+        CustomView = request.env['ir.ui.view.custom']
-        }, request.context)
+        })
-        Model = request.session.model('ir.attachment')
+        Model = request.env['ir.attachment']
-            attachment_id = Model.create({
+            attachment = Model.create({
-            }, request.context)
+            })
-                'id':  attachment_id
+                'id':  attachment.id
-        Actions = request.session.model('ir.actions.actions')
+        Actions = request.env['ir.actions.actions']
-                assert model.startswith('ir.actions.')
+                action = request.env.ref(action_id)
-        base_action = Actions.read([action_id], ['type'], context=request.context)
+        base_action = Actions.browse([action_id]).read(['type'])
-            action = request.session.model(action_type).read([action_id], False, context=ctx)
+            env = request.env(context=ctx)
-            return False
+        result = request.env['ir.actions.server'].browse([action_id]).run()
-            export['export_fields'])
+        export = request.env['ir.exports'].browse([export_id]).read()[0]
-                params)
+            operator.itemgetter('model', 'fields', 'ids', 'domain', 'import_compat')(params)
-        ids = ids or Model.search(domain, offset=0, limit=False, order=False, context=context)
+        Model = request.env[model].with_context(**params.get('context', {}))
-        if not request.env[model]._is_an_ordinary_table():
+        if not Model._is_an_ordinary_table():
-        import_data = Model.export_data(ids, field_names, self.raw_data, context=context).get('datas',[])
+        import_data = records.export_data(field_names, self.raw_data).get('datas',[])
-        report_id = report_srv.report(
+        report_id = dispatch_rpc('report', 'report', [
-            report_data, context)
+            action["report_name"], report_ids, report_data, context])
-                request.session.db, request.session.uid, request.session.password, report_id)
+            report_struct = dispatch_rpc('report', 'report_get', [
-                file_name = reports.read(res_id[0], ['name'], context)['name']
+            reports = request.env['ir.actions.report.xml']
-            action = act_window_obj.read(action_id, ['name', 'type', 'res_model', 'view_mode', 'view_type', 'context', 'views', 'domain'])
+            record = request.env.ref('base.open_module_tree')
-            app_id = ir_model_data.get_object_reference('base', 'module_%s' % app)[1]
+            app_id = request.env.ref('base.module_%s' % app).id
-            'menu_data': request.registry['ir.ui.menu'].load_menus(request.cr, request.uid, request.debug, context=request.context),
+            'menu_data': request.env['ir.ui.menu'].load_menus(request.debug),
-            (140, 180), req.session.context)
+        ir_view = http.request.env['ir.ui.view']
-        data_connectors =connector_tr.read(connector_ids, connector_fields, req.session.context)
+        connector_model = http.request.env[connector]
-        data_acts = node_act.read(search_acts, invisible_node_fields + visible_node_fields, req.session.context)
+        fields = http.request.env['ir.model.fields']
-        _id, name = req.session.model(model).name_get([id], req.session.context)[0]
+        _id, name = http.request.env[model].browse([id]).name_get()[0]
-            tag = request.registry['blog.tag'].browse(request.cr, request.uid, int(tag_id), context=request.context)
+            tag = request.env['blog.tag'].browse(int(tag_id))
-        self.assertTrue(ids)
+        # partners is a collection of browse records
-        count1 = self.registry('res.partner').search(self.cr, self.uid, [], count=True)
+        self.cr.execute("SELECT COUNT(*) FROM res_partner WHERE active")
-
+    def test_env_uid(self):
-            Users.has_group(self.cr, self.test_user.id, self.group0),
+            Users.has_group(self.group0),
-            Users.has_group(self.cr, self.test_user.id, self.group1),
+            Users.has_group(self.group1),
-    def test_new_api(self):
+    def test_record(self):
-                                          spec, None)
+        self.View.apply_inheritance_specs(self.base_arch, spec, None)
-        self.context = request.registry.get('res.users').context_get(request.cr, request.uid) or {}
+        self.context = request.env['res.users'].context_get() or {}
-        uid = self.uid or request.uid or openerp.SUPERUSER_ID
+        env = request.env(user=self.uid or request.uid or openerp.SUPERUSER_ID)
-                                        self.qcontext, context=request.context)
+        return env["ir.ui.view"].render_template(self.template, self.qcontext)
-        for fun, msg, names in self._constraints:
+        for func, msg, names in self._constraints:
-                # validation must be context-independent; call ``fun`` without context
+                # validation must be context-independent; call ``func`` without context
-                valid = valid or fun(self._model, cr, uid, ids)
+                valid = valid or func(self)
-                    res_msg = msg(self._model, cr, uid, ids, context=context)
+                    res_msg = msg(self)
-                method_res = getattr(self._model, method)(*args)
+            # invoke onchange method
-        return id
+        return self.browse_ref(xid).id
-        return self.registry('ir.model.data').get_object(self.cr, self.uid, module, xid)
+        return self.env.ref(xid)
-        uid = Users.authenticate(db, user, password, None)
+        uid = self.registry['res.users'].authenticate(db, user, password, None)
-        session.context = Users.context_get(self.cr, uid) or {}
+        session.context = env['res.users'].context_get() or {}
-        model = env[node.get('model', '')]._model
+        model = env[node.get('model', '')]
-        return res
+        return openerp.api.call_kw(model, method, args, {})
-        context = context.copy() # keep it local
+    context = dict(context or {})
-    registry = openerp.registry(cr.dbname)
+    env = openerp.api.Environment(cr, uid, context)
-            act_module, act_xmlid = action_id.split('.', 1)
+            _, act_xmlid = action_id.split('.', 1)
-        act_model, act_id = registry['ir.model.data'].get_object_reference(cr, uid, act_module, act_xmlid)
+            action_id = '%s.%s' % (our_module, action_id)
-    def _exec_action(action, datas, context):
+    def _exec_action(action, datas, env):
-            context1 = safe_eval(context1, context.copy())
+            context1 = safe_eval(context1, dict(context))
-            view_res = registry[datas['res_model']].fields_view_get(cr, uid, view_id, action['view_type'], context)
+            view_res = env[datas['res_model']].fields_view_get(view_id, action['view_type'])
-                view_data = registry[datas['res_model']].default_get(cr, uid, view_res['fields'].keys(), context)
+            if view_res.get('fields'):
-                                })
+                    buttons.append({
-                datas['res_id'] = registry[datas['res_model']].create(cr, uid, view_data, context)
+                datas['res_id'] = env[datas['res_model']].create(view_data).id
-                    if not fn:
+                    rec = env[datas['res_model']].browse(datas['res_id'])
-                    res = fn(cr, uid, [datas['res_id'],], context)
+                    res = func()
-    assert action, "Could not read action %s[%s]" %(act_model, act_id)
+    action = env[act_model].browse(act_id).read()[0]
-        result = _exec_action(action, datas, context)
+        result = _exec_action(action, datas, env)
-        model = self.env[function.model]._model
+        model = self.env[function.model]
-        getattr(model, method)(self.cr, self.uid, *args)
+        return openerp.api.call_kw(model, function.name, args, {})
-        records = self.obj.browse(self.cr, self.uid, self.ids)
+        env = openerp.api.Environment(self.cr, self.uid, {})
-
+        env = openerp.api.Environment(self.session.cr, self.session.uid, context)
-            if transition['group_id'] not in user_groups:
+            env = openerp.api.Environment(self.session.cr, self.session.uid, {})
-from odoo.api import Environment
+from odoo.api import call_kw, Environment
-        return getattr(request.registry.get(model), method)(request.cr, request.uid, *args, **kwargs)
+        check_method_name(method)
-    if object is None:
+    recs = openerp.api.Environment(cr, uid, {}).get(obj)
-    return getattr(object, method)(cr, uid, *args, **kw)
+    return openerp.api.call_kw(recs, method, args, kw)
-            raise UserError(_('Private methods (such as %s) cannot be called remotely.') % (method,))
+        check_method_name(method)
-        return method
+def attrsetter(attr, value):
-    """ Propagate decorators from ``from_method`` to ``to_method``, and return the
+def propagate(method1, method2):
-    if from_method:
+    if method1:
-    return to_method
+            if hasattr(method1, attr) and not hasattr(method2, attr):
-    return lambda method: decorate(method, '_constrains', args)
+    return attrsetter('_constrains', args)
-    return lambda method: decorate(method, '_onchange', args)
+    return attrsetter('_onchange', args)
-    return lambda method: decorate(method, '_depends', args)
+    return attrsetter('_depends', args)
-    return wrapper
+    return attrsetter('_returns', (model, downgrade, upgrade))
-    """
+def downgrade(method, value, self, args, kwargs):
-            return lambda self, *args, **kwargs: args[0].ids
+    if not spec:
-        return lambda self, *args, **kwargs: args[0]
+        return value.ids
-    """
+def aggregate(method, value, self):
-            return lambda self, value: sum(value, self.browse())
+            return sum(value, self.browse())
-    return lambda self, value: value
+            return sum(value, self.env[model])
-            context, args, kwargs = split(args, kwargs)
+def split_context(method, args, kwargs):
-    return split
+    if pos < len(args):
-    return make_wrapper(model, method, old_api, method)
+    method._api = 'model'
-    return make_wrapper(multi, method, old_api, method)
+    method._api = 'multi'
-    def new_api(self, *args, **kwargs):
+    def loop(method, self, *args, **kwargs):
-        return aggregate(self, result)
+        return aggregate(method, result, self)
-    return make_wrapper(one, method, old_api, new_api)
+    wrapper = decorator(loop, method)
-    return make_wrapper(model_cr, method, old_api, method)
+    method._api = 'model_cr'
-    return make_wrapper(model_cr_context, method, old_api, method)
+    method._api = 'model_cr_context'
-    return make_wrapper(cr, method, method, new_api)
+    method._api = 'cr'
-    return make_wrapper(cr_context, method, method, new_api)
+    method._api = 'cr_context'
-    return make_wrapper(cr_uid, method, method, new_api)
+    method._api = 'cr_uid'
-    return make_wrapper(cr_uid_context, method, method, new_api)
+    method._api = 'cr_uid_context'
-    return make_wrapper(cr_uid_id, method, method, new_api)
+    method._api = 'cr_uid_id'
-    return make_wrapper(cr_uid_id_context, method, method, new_api)
+    method._api = 'cr_uid_id_context'
-    return make_wrapper(cr_uid_ids, method, method, new_api)
+    method._api = 'cr_uid_ids'
-    return make_wrapper(cr_uid_ids_context, method, method, new_api)
+    method._api = 'cr_uid_ids_context'
-    return make_wrapper(cr_uid_records, method, method, new_api)
+    method._api = 'cr_uid_records'
-    return make_wrapper(cr_uid_records_context, method, method, new_api)
+    method._api = 'cr_uid_records_context'
-    return wrapper
+    return frame.f_locals.get(method_v7.__name__, method_v7)
-    return wrapper
+    if method_v8.__name__ == 'read':
-    method._api = False
+    method._api = None
-        for (question_type, text) in self.env['survey.question']._columns['type'].selection:
+        for (question_type, text) in self.env['survey.question']._fields['type'].selection:
-        for (question_type, text) in self.env['survey.question']._columns['type'].selection:
+        for (question_type, text) in self.env['survey.question']._fields['type'].selection:
-            elif attr.startswith('_related_'):
+            if attr.startswith('_related_'):
-        return bool(self.store or self.search or (self.column and self.column._fnct_search))
+        return bool(self.store or self.search)
-        if self.column and not (self.compute and env.in_onchange):
+        if self.store and not (self.compute and env.in_onchange):
-    _column_strip_classes = property(attrgetter('strip_classes'))
+
-                raise UserError(_('Invalid group_by specification: "%s".\nA group_by specification must be a list of valid fields.') % (gb,))
+            gb_field = self._fields[gb].base_field
-            if getattr(self._fields[f].base_field.column, '_classic_write', False)
+            for field in [self._fields.get(f)]
-        cls._columns = {}
+        # set up fields
-            if field.base_field.column._classic_write
+            if field.base_field.store and field.base_field.column_type
-                _logger.warning('Field %s.%s is deprecated: %s', self._name, f, column.deprecated)
+            field = self._fields[f]
-                if field.column or field.inherited:
+                if field.store or field.inherited:
-            elif not field.column:
+            elif not field.store:
-            column = field.column
+            field = field.base_field
-        if not (column and column._classic_write):
+        if not field.store:
-                elif column and column._type == 'many2one':
+                if field.store and field.type == 'many2one':
-            elif not column and path[0] in MAGIC_COLUMNS:
+            elif path[0] in MAGIC_COLUMNS:
-            elif len(path) > 1 and column and column._type == 'many2one' and column._auto_join:
+            elif len(path) > 1 and field.store and field.type == 'many2one' and field.auto_join:
-            elif len(path) > 1 and column and column._type == 'one2many' and column._auto_join:
+            elif len(path) > 1 and field.store and field.type == 'one2many' and field.auto_join:
-                leaf.add_join_context(comodel, 'id', column._fields_id, path[0])
+                leaf.add_join_context(comodel, 'id', field.inverse_name, path[0])
-                raise NotImplementedError('_auto_join attribute not supported on many2many column %s' % left)
+            elif len(path) > 1 and field.store and field.auto_join:
-            elif len(path) > 1 and column and column._type == 'many2one':
+            elif len(path) > 1 and field.store and field.type == 'many2one':
-            elif len(path) > 1 and column and column._type in ['many2many', 'one2many']:
+            # Making search easier when there is a left operand as one2many or many2many
-            elif not column:
+            elif not field.store:
-            elif column._type == 'one2many' and operator in HIERARCHY_FUNCS:
+            elif field.type == 'one2many' and operator in HIERARCHY_FUNCS:
-                    dom = HIERARCHY_FUNCS[operator](left, ids2, comodel, prefix=column._obj)
+                if field.comodel_name != model._name:
-            elif column._type == 'one2many':
+            elif field.type == 'one2many':
-                        domain = column._domain
+                        domain = field.domain
-                            ids1 = select_from_where(cr, column._fields_id, comodel._table, 'id', ids2, operator)
+                        # determine ids1 <-- field.inverse_name --- ids2
-                            ids1 = recs.mapped(column._fields_id).ids
+                            ids1 = recs.mapped(field.inverse_name).ids
-                    push(create_substitution_leaf(leaf, ('id', o2m_op, select_distinct_from_where_not_null(cr, column._fields_id, comodel._table)), model))
+                    push(create_substitution_leaf(leaf, ('id', o2m_op, select_distinct_from_where_not_null(cr, field.inverse_name, comodel._table)), model))
-            elif column._type == 'many2many':
+            elif field.type == 'many2many':
-                            domain = column._domain
+                            domain = field.domain
-            elif column._type == 'many2one':
+            elif field.type == 'many2one':
-                        dom = HIERARCHY_FUNCS[operator](left, ids2, comodel, prefix=column._obj)
+                    if field.comodel_name != model._name:
-            elif column._type == 'binary' and column.attachment:
+            elif field.type == 'binary' and field.attachment:
-                                  column.string, left, operator, right)
+                                  field.string, left, operator, right)
-                if column._type == 'datetime' and right and len(right) == 10:
+                if field.type == 'datetime' and right and len(right) == 10:
-        elif (left in model._columns) and model._columns[left]._type == "boolean" and ((operator == '=' and right is False) or (operator == '!=' and right is True)):
+        elif left in model and model._fields[left].type == "boolean" and ((operator == '=' and right is False) or (operator == '!=' and right is True)):
-        elif (left in model._columns) and model._columns[left]._type == "boolean" and ((operator == '!=' and right is False) or (operator == '==' and right is True)):
+        elif left in model and model._fields[left].type == "boolean" and ((operator == '!=' and right is False) or (operator == '==' and right is True)):
-            if left in model._columns:
+            if left in model:
-            elif left in model._columns:
+            elif left in model:
-        super(serialized, self).__init__(*args, **kwargs)
+from openerp import fields
-                isinstance(obj._field, float_field) and\
+                obj._field.type == 'float' and\
-                                                        context=self.localcontext)
+                record = self.env['base'].with_context(self.localcontext)
-    """
+from openerp import models, fields, _
-    }
+    name = fields.Char('1XBUO5PUYH2RYZSA1FTLRYS8SPCNU1UYXMEYMM25ASV7JC2KTJZQESZYRV9L8CGB',
-            if (f_name in _cols) and _cols[f_name]._type=='many2many':
+            _fields = env[f_model]._fields
-    index_content = fields.Text('Indexed Content', readonly=True, _prefetch=False)
+    index_content = fields.Text('Indexed Content', readonly=True, prefetch=False)
-        if self._context.get('prefetch_fields', True) and field.column._prefetch:
+        if self._context.get('prefetch_fields', True) and field.prefetch:
-                if f.store and f.column._prefetch
+                # select fields that can be prefetched
-        translate = options.get('edit_translations') and options.get('translatable') and getattr(field, 'translate', False)
+        translate = options.get('edit_translations') and options.get('translatable') and field.translate
-        if not callable(getattr(field, 'translate', None)):
+        if not callable(field.translate):
-            if not getattr(fld, 'translate', False):
+            if not fld.translate:
-        if self.translate and not callable(self.translate) and self.sanitize:
+        if self.translate is True and self.sanitize:
-                'translate': bool(getattr(field, 'translate', False)),
+                'translate': bool(field.translate),
-        if translate and not callable(translate):
+        if field.translate is True:
-            if not (field.inherited and callable(field.base_field.column.translate))
+            if not (field.inherited and callable(field.base_field.translate))
-                    if not field.inherited and callable(field.column.translate):
+                    if not field.inherited and callable(field.translate):
-                    if single_lang or not (has_trans and getattr(field, 'translate', None) and not callable(field.translate)):
+                    if single_lang or not (has_trans and field.translate is True):
-                if callable(translate):
+                if callable(field.translate):
-                elif has_trans and translate:
+                elif has_trans and field.translate:
-                if column._classic_write and column.translate and not callable(column.translate):
+                field = self._fields[name]
-            elif getattr(field, 'translate', False):
+            elif field.translate:
-                elif column.translate and not callable(column.translate) and right:
+                elif field.translate is True and right:
-            if getattr(field, 'translate', None):
+            if field.translate:
-from openerp.tools.translate import html_translate
+from openerp.tools.translate import html_translate, _
-        elif self.store:
+        if self.store:
-from .exceptions import AccessError, MissingError
+from .exceptions import AccessError, MissingError, UserError
-                    if res and field.compute:
+                if not field.column_type:
-                    elif field.column_type:
+                    else:
-                rel_table, rel_id1, rel_id2 = column._sql_names(model)
+                rel_table, rel_id1, rel_id2 = field.relation, field.column1, field.column2
-            return process(res_model, int(res_id))
+            if record.env[res_model].browse(int(res_id)).exists():
-                        vals[f] = []
+            for f in field_names:
-                                           self._uid, context=rel_context) or []
+        # call the 'write' method of fields which are not columns
-                                           self._uid, context=rel_context) or []
+            # call the 'write' method of fields which are not columns
-                          html_sanitize, pg_varchar, ustr, OrderedSet
+from openerp.tools import float_precision, float_repr, float_round, frozendict, \
-        return value or {}
+        # cache format: dict
-            value = setf(value)
+            value = field.convert_to_column(value, self)
-                self._table, column_name, setc, column_name)
+                self._table, column_name, field.column_format, column_name)
-                if hasattr(column, 'selection') and val:
+            if field.store:
-                    if single_lang or not (has_trans and column.translate and not callable(column.translate)):
+                if field.column_type:
-                        updates.append((name, setc, setf(val)))
+                        val = field.convert_to_column(val, self)
-                if callable(column.translate):
+                field = self._fields[name]
-                elif has_trans and column.translate:
+                elif has_trans and translate:
-                    val = column._symbol_set[1](vals[name])
+                    val = field.convert_to_column(vals[name], self)
-                updates.append((name, setc, setf(val)))
+            field = self._fields[name]
-            if hasattr(column, 'selection') and val:
+            if hasattr(field, 'selection') and val:
-                        params = map(ss[1], params)
+                        field = model._fields[left]
-                format = need_wildcard and '%s' or model._columns[left]._symbol_set[0]
+                format = need_wildcard and '%s' or model._fields[left].column_format
-                params = model._columns[left]._symbol_set[1](right)
+                params = model._fields[left].convert_to_column(right, model)
-        fields = fields or self._columns.keys()
+        fields = fields or [f.name for f in self._fields.itervalues() if f.store]
-        cols = list(self._columns)
+        cols = [name for name, field in self._fields.iteritems()
-        - report on database columns no more existing in ``self._columns``,
+        - report on database columns no more existing in ``self._fields``,
-        - add database indices to match ``self._columns``,
+        - alter existing database columns to match ``self._fields``,
-            _logger.error('add a field parent_left on model %s: parent_left = fields.Integer(\'Left Parent\', index=True)', self._name)
+        if 'parent_left' not in self._fields:
-        elif not self._columns['parent_left'].select:
+        elif not self._fields['parent_left'].index:
-            _logger.error('add a field parent_right on model %s: parent_right = fields.Integer(\'Left Parent\', index=True)', self._name)
+        if 'parent_right' not in self._fields:
-        if self._columns[self._parent_name].ondelete not in ('cascade', 'restrict'):
+        elif not self._fields['parent_right'].index:
-                if field.inherited and field.base_field.column:
+            field = self._fields.get(name)
-        name_fields = [(name, self._fields[name]) for name in (stored + computed)]
+        name_fields = [(name, self._fields[name]) for name in (stored + inherited + computed)]
-                if field.column or field.inherited:
+                if field.store or field.inherited:
-    return list(enumerate(["Corge", "Grault", "Wheee", "Moog"]))
+    return [(str(key), val) for key, val in enumerate(["Corge", "Grault", "Wheee", "Moog"])]
-    ('selection.function', fields.Selection(selection_fn, size=-1)),
+    ('selection.function', fields.Selection(selection_fn)),
-        # FIXME: selection functions export the *value* itself
+        # selection functions export the *value* itself
-            [[1]])
+            self.export('1'),
-        # fucking hell
+            self.export('3'),
-            [['']])
+            self.export('0'),
-            values(self.read()))
+        self.assertEqual(values(self.read()), ['3', '1'])
-        self.assertEqual(values(self.read()), [1, 2])
+        self.assertEqual(values(self.read()), ['1', '2'])
-from openerp.tools import float_precision, float_round, frozendict, html_sanitize, ustr, OrderedSet
+from openerp.tools import float_precision, float_round, frozendict, \
-            "Reference field %s with non-integer size %r" % (self, self.size)
+    @property
-from .tools.misc import CountingStream, DEFAULT_SERVER_DATETIME_FORMAT, DEFAULT_SERVER_DATE_FORMAT, pickle
+from .tools.misc import CountingStream, DEFAULT_SERVER_DATETIME_FORMAT, DEFAULT_SERVER_DATE_FORMAT
-            for name, column in self._columns.iteritems():
+            for name, field in self._fields.iteritems():
-                if column.manual and not update_custom_fields:
+                if not field.store:
-                    self._o2m_raise_on_missing_reference(column)
+                if field.type == 'one2many':
-                        stored_fields.append(self._fields[name])
+                elif field.type == 'many2many':
-                        res = column_data.get(column.oldname)
+                    if not res and hasattr(field, 'oldname'):
-                            cr.execute('ALTER TABLE "%s" RENAME "%s" TO "%s"' % (self._table, column.oldname, name))
+                            cr.execute('ALTER TABLE "%s" RENAME "%s" TO "%s"' % (self._table, field.oldname, name))
-                            _schema.debug("Table '%s': renamed column '%s' to '%s'", self._table, column.oldname, name)
+                            _schema.debug("Table '%s': renamed column '%s' to '%s'", self._table, field.oldname, name)
-                        f_obj_type = get_pg_type(column) and get_pg_type(column)[0]
+                        column_type = field.column_type
-                        if f_obj_type:
+                        if column_type:
-                                ('text', 'char', pg_varchar(column.size), '::%s' % pg_varchar(column.size)),
+                                ('text', 'char', column_type[1], '::' + column_type[1]),
-                                ('int4', 'float', get_pg_type(column)[1], '::'+get_pg_type(column)[1]),
+                                ('int4', 'float', column_type[1], '::' + column_type[1]),
-                                ('float8', 'monetary', get_pg_type(column)[1], '::'+get_pg_type(column)[1]),
+                                ('numeric', 'float', column_type[1], '::' + column_type[1]),
-                            if f_pg_type == 'varchar' and column._type in ('char', 'selection') and f_pg_size and (column.size is None or f_pg_size < column.size):
+                            if f_pg_type == 'varchar' and field.type == 'char' and f_pg_size and (field.size is None or f_pg_size < field.size):
-                                        cr.execute('ALTER TABLE "%s" ALTER COLUMN "%s" TYPE %s' % (self._table, name, pg_varchar(column.size)), log_exceptions=False)
+                                        cr.execute('ALTER TABLE "%s" ALTER COLUMN "%s" TYPE %s' % (self._table, name, column_type[1]), log_exceptions=False)
-                                    cr.execute('UPDATE "%s" SET "%s"=temp_change_size::%s' % (self._table, name, pg_varchar(column.size)))
+                                    cr.execute('ALTER TABLE "%s" ADD COLUMN "%s" %s' % (self._table, name, column_type[1]))
-                                              self._table, name, f_pg_size or 'unlimited', column.size or 'unlimited')
+                                              self._table, name, f_pg_size or 'unlimited', field.size or 'unlimited')
-                                    if f_pg_type != f_obj_type:
+                                if (f_pg_type == c[0]) and (field.type == c[1]):
-                            if f_pg_type != f_obj_type:
+                            if f_pg_type != column_type[0]:
-                                    cr.execute("COMMENT ON COLUMN %s.\"%s\" IS %%s" % (self._table, name), (column.string,))
+                                    cr.execute('ALTER TABLE "%s" ADD COLUMN "%s" %s' % (self._table, name, column_type[1]))
-                                                    self._table, name, f_pg_type, column._type, newname)
+                                                    self._table, name, f_pg_type, field.type, newname)
-                            if column.required and f_pg_notnull == 0:
+                            if field.required and f_pg_notnull == 0:
-                            elif not column.required and f_pg_notnull == 1:
+                            elif not field.required and f_pg_notnull == 1:
-                            if not res2 and column.select:
+                            if not res2 and field.index:
-                                if column._type == 'text':
+                                if field.type == 'text':
-                            if res2 and not column.select:
+                                    _schema.warning(msg, self._table, field.type, name)
-                                _schema.debug(msg, self._table, name, column._type)
+                                _schema.debug(msg, self._table, name, field.type)
-                                    self._m2o_fix_foreign_key(self._table, name, dest_model, column.ondelete)
+                            if field.type == 'many2one':
-                    elif column._classic_write:
+                    elif field.column_type:
-                        cr.execute("COMMENT ON COLUMN %s.\"%s\" IS %%s" % (self._table, name), (column.string,))
+                        cr.execute('ALTER TABLE "%s" ADD COLUMN "%s" %s' % (self._table, name, field.column_type[1]))
-                                      self._table, name, get_pg_type(column)[1])
+                                      self._table, name, field.column_type[1])
-                            stored_fields.append(self._fields[name])
+                        if field.compute:
-                            dest_model = self.env[column._obj]
+                        if field.type == 'many2one' and field.store:
-                        if column.select:
+                            if comodel._auto and comodel._table != 'ir_actions':
-                        if column.required:
+                        if field.required:
-            partners._store_set_values(['membership_state'])
+        # used to recompute 'membership_state'; should no longer be necessary
-                if not (isinstance(column, fields.function) and not column.store)]
+        cols = list(self._columns)
-                            f_obj_type = get_pg_type(column) and get_pg_type(column)[0]
+                        f_obj_type = get_pg_type(column) and get_pg_type(column)[0]
-                            if isinstance(column, fields.many2one) or (isinstance(column, fields.function) and column._type == 'many2one' and column.store):
+                            if isinstance(column, fields.many2one):
-                                vals[f] = []
+                res2 = self._columns[f].get(cr, self._model, ids, f, user, context=context, values=result)
-        result_store = self._store_get_values(self._fields)
+        # for recomputing fields
-
+        result_store = []
-                # comment for further explanations.
+            else:
-from openerp.osv.fields import float as float_field, function as function_field, datetime as datetime_field
+from openerp.osv.fields import float as float_field, datetime as datetime_field
-                isinstance(obj._field, (float_field, function_field)) and\
+                isinstance(obj._field, float_field) and\
-    """ Minimal support for existing sparse and serialized fields. """
+    """ Serialized fields provide the storage for sparse fields. """
-        return value
+        raise TypeError("Dead method")
-        return True
+        raise TypeError("Dead method")
-        return results
+        raise TypeError("Dead method")
-            attrs['store'] = attrs.get('store', False)
+            attrs['store'] = False
-        if not self.store and (self.compute or not self.origin) and not self.company_dependent:
+        if not self.store and (self.compute or not self.origin):
-        elif self.origin:
+        if self.origin:
-            # 4. look up field.default
+            # 3. look up field.default
-            # 5. delegate to parent model
+            # 4. delegate to parent model
-        return result
+        raise TypeError("Dead method")
-        return True
+        raise TypeError("Dead method")
-        return res
+        raise TypeError("Dead method")
-            default_compute = self._defaults.get(column_name)
+            default_compute = self._fields[column_name].default
-        # Note: explicitly implemented in default_get() instead of _defaults,
+        # Note: explicitly implemented in default_get() instead of field default,
-                type_ = self._defaults['type']
+                type_ = self._fields['type'].default(self)
-                return
+        # self.default must be a callable
-           This method is *not* meant for use as a _defaults initializer,
+           This method is *not* meant for use as a default initializer,
-           display on client side. For _defaults you :meth:`fields.datetime.now`
+           display on client side. For default values :meth:`fields.datetime.now`
-                cls._defaults.pop(name, None)
+                # regular fields are shared, while related fields are setup from scratch
-            if (key in model._columns or key in model._inherit_fields or model._fields[key].inverse)
+            for field in [model._fields[key].base_field]
-        if self._context.get('default_type') not in self._all_columns['message_type'].column.selection:
+        if self._context.get('default_type') not in type(self).message_type.base_field.selection:
-            self.parent_model, self.parent_column, self.original_parent)
+        for f in self._get_mandatory_billing_fields():
-        'account.journal', 'Accounting Journal',
+        'account.journal', 'Payment Journal',
-    provider = fields.Selection(selection_add=[('transfer', 'Wire Transfer')])
+    provider = fields.Selection(selection_add=[('transfer', 'Wire Transfer')], default='transfer')
-        ('formula', 'Advanced pricing based on formula')
+        ('percentage', 'Specific prices per customer segment, currency, etc.'),
-    module_website_version = fields.Boolean("A/B testing and versioning")
+    module_website_form_editor = fields.Boolean("Form builder")
-    default_lang_id = fields.Many2one('res.lang', string="Default language", default=_default_language)
+    default_lang_id = fields.Many2one('res.lang', string="Default Language", default=_default_language)
-from odoo import models, fields
+
-                        <section class="mt16 mb16">
+        return '''
-                    </div> '''
+                        </div>
-    'category': 'Website',
+    'category': 'Theme',
-    'category': 'Hidden',
+    'category': 'Theme/Hidden',
-        if (event_date.date() - today.date()).days == 1:
+        diff = (event_date.date() - today.date())
-        elif event_date.month - today.month == 1:
+            return _('This month')
-            return format_tz(self.event_begin_date, tz='UTC', format='%Y%m%dT%H%M%SZ')
+            return format_tz(self.env, self.event_begin_date, tz='UTC', format='%Y%m%dT%H%M%SZ')
-
+import unittest
-@odoo.tests.common.at_install(True)
+@odoo.tests.common.at_install(False)
-@odoo.tests.common.at_install(True)
+@odoo.tests.common.at_install(False)
-    def payment_method(self):
+    def payment_method(self, **kwargs):
-            acquirer.form = acquirer.sudo()._registration_render(request.env.user.partner_id.id, {'error': {}, 'error_message': [], 'return_url': '/my/payment_method', 'json': False, 'bootstrap_formatting': True})
+            acquirer.form = acquirer.sudo()._registration_render(request.env.user.partner_id.id, {'error': {}, 'error_message': [], 'return_url': return_url, 'json': False, 'bootstrap_formatting': True})
-                acquirer.tokens = request.env['payment.token'].search([('acquirer_id', '=', acquirer.id)])
+                values['tokens'] = request.env['payment.token'].search([('partner_id', '=', order.partner_id.id), ('acquirer_id', 'in', acquirers.ids)])
-        self.assertEqual(mimetype, 'application/octet-stream')
+        # odoo implementation returns application/octet-stream by default
-        self.assertEqual(mimetype, 'test')
+        # if available, python-magic returns application/x-empty
-        self.assertEqual(mimetype, 'image/bmp')
+        # mimetype should match image/bmp, image/x-ms-bmp, ...
-        guess_mimetype = lambda bin_data: magic.from_buffer(bin_data, mime=True)
+        guess_mimetype = lambda bin_data, default=None: magic.from_buffer(bin_data, mime=True)
-        guess_mimetype = ms.buffer
+        guess_mimetype = lambda bin_data, default=None: ms.buffer(bin_data)
-        models.check_pg_name(self.relation_table)
+        if self.relation_table:
-            domain += [('owner_id', '=', ops.owner_id.id)]
+            if ops.owner_id:
-            domain += [('owner_id', '=', move.restrict_partner_id.id)]
+            if move.restrict_partner_id:
-        return False
+        return self.env['account.journal']
-            numlgn += 1
+            if round(amounts[0], 0) == 0:
-        if today.month == event_date.month:
+        if (event_date.date() - today.date()).days == 1:
-    end_date = fields.Date(string='End Date')
+    end_date = fields.Date(string='End Date', compute=None, readonly=True)
-        return {}
+                values['partner_id'] = project.partner_id.id
-        return self.stage_find(cr, uid, [], context.get('default_project_id'), [('fold', '=', False)], context=context)
+        default_project_id = context.get('default_project_id')
-        return {}
+                    values['partner_id'] = project.partner_id.id
-    group_website_multiimage = fields.Boolean('Multi Image', implied_group='website_sale.group_website_multi_image')
+    group_website_multiimage = fields.Boolean('Multi Image', implied_group='website_sale.group_website_multi_image', group='base.group_portal,base.group_user,base.group_public')
-        return werkzeug.utils.redirect(post.get('return_url', '/'))
+        error = ''
-    def payment_transaction(self, acquirer_id):
+    def payment_transaction(self, acquirer_id, token=None):
-            tx = Transaction.create({
+            tx_values = {
-            })
+            }
-    _order = 'sequence'
+    _order = 'sequence, id'
-                product_line = {'name': product.name, 'lines': [], 'total': 0.0,
+                product_line = {'bom': bom, 'name': product.name, 'lines': [], 'total': 0.0,
-                    price_uom = self.env['product.uom']._compute_qty(line_product.uom_id.id, line_product.standard_price, bom_line.product_uom_id.id)
+                    price_uom = self.env['product.uom']._compute_qty(bom_line.product_id.uom_id.id, bom_line.product_id.standard_price, bom_line.product_uom_id.id)
-                        'product_uom_qty': line_data['qty'],
+                        'product_id': bom_line.product_id,
-        string='Description', oldname='note', translate=html_translate, sanitize=False,
+        string='Description', oldname='note', translate=html_translate, sanitize_attributes=False,
-    body = fields.Html('Contents', default='', strip_classes=True)
+    body = fields.Html('Contents', default='', sanitize_style=True, strip_classes=True)
-    body_html = fields.Html('Body', translate=True, sanitize=False)
+    body_html = fields.Html('Body', translate=True, sanitize_attributes=False)
-    body_html = fields.Html(string='Body', translate=html_translate, sanitize=False)
+    body_html = fields.Html(string='Body', translate=html_translate, sanitize_attributes=False)
-    content = fields.Html('Content', default=_default_content, translate=html_translate, sanitize=False)
+    content = fields.Html('Content', default=_default_content, translate=html_translate, sanitize_attributes=False)
-    description = fields.Html('Track Description', translate=html_translate, sanitize=False)
+    description = fields.Html('Track Description', translate=html_translate, sanitize_attributes=False)
-            'body': tools.html_sanitize(self.content, strict=True, strip_style=True, strip_classes=True),
+            'body': tools.html_sanitize(self.content, sanitize_attributes=True, strip_style=True, strip_classes=True),
-    website_description = fields.Html('Website description', translate=html_translate, sanitize=False, default=_get_default_website_description)
+    website_description = fields.Html('Website description', translate=html_translate, sanitize_attributes=False, default=_get_default_website_description)
-    website_description = fields.Html("Website description", default=False, help="Description of the channel displayed on the website page", sanitize=False, translate=html_translate)
+    website_description = fields.Html("Website description", default=False, help="Description of the channel displayed on the website page", sanitize_attributes=False, translate=html_translate)
-    popup_content = fields.Html(string="Website Popup Content", translate=True, sanitize=False,
+    popup_content = fields.Html(string="Website Popup Content", translate=True, sanitize_attributes=False,
-    quote_description = fields.Html('Description for the quote', sanitize=False)
+    website_description = fields.Html('Description for the website', sanitize_attributes=False) # hack, if website_sale is not installed
-    website_description = fields.Html('Description', sanitize=False, translate=html_translate)
+    website_description = fields.Html('Description', sanitize_attributes=False, translate=html_translate)
-    website_description = fields.Html('Line Description', sanitize=False, translate=html_translate)
+    website_description = fields.Html('Line Description', sanitize_attributes=False, translate=html_translate)
-    website_description = fields.Html('Description', translate=html_translate, sanitize=False)
+    website_description = fields.Html('Description', translate=html_translate, sanitize_attributes=False)
-    website_description = fields.Html('Option Description', translate=html_translate, sanitize=False)
+    website_description = fields.Html('Option Description', translate=html_translate, sanitize_attributes=False)
-    website_description = fields.Html('Description for the website', sanitize=False, translate=True)
+    website_description = fields.Html('Description for the website', sanitize_attributes=False, translate=True)
-    description = fields.Html('Description', translate=html_translate, sanitize=False)
+    description = fields.Html('Description', translate=html_translate, sanitize_attributes=False)
-        default="<p>This channel is private and its content is restricted to some users.</p>", translate=html_translate, sanitize=False)
+        default="<p>This channel is private and its content is restricted to some users.</p>", translate=html_translate, sanitize_attributes=False)
-            new_html = html_sanitize(test, strict=False, strip_style=False, strip_classes=False)
+            new_html = html_sanitize(test, sanitize_attributes=False, sanitize_style=True, strip_style=False, strip_classes=False)
-        new_html = html_sanitize(test_data[0][0], strict=False, strip_style=True, strip_classes=False)
+        new_html = html_sanitize(test_data[0][0], sanitize_attributes=False, strip_style=True, strip_classes=False)
-        html = html_sanitize(test_mail_examples.REMOVE_CLASS, strict=True, strip_style=False, strip_classes=True)
+        html = html_sanitize(test_mail_examples.REMOVE_CLASS, sanitize_attributes=True, sanitize_style=True, strip_classes=True)
-    comment4 = fields.Html(sanitize=True, strip_style=True)
+    comment2 = fields.Html(sanitize_attributes=True, strip_classes=False)
-        self.assertEqual(self.model._fields['comment2'].sanitize, True)
+        self.assertEqual(self.model._fields['comment2'].sanitize_attributes, True)
-        self.assertEqual(self.model._fields['comment3'].sanitize, True)
+        self.assertEqual(self.model._fields['comment3'].sanitize_attributes, True)
-        'strip_style': False,           # whether to strip style attributes (otherwise: sanitized)
+        'sanitize_tags': True,          # whether to sanitize tags (only a white list of attributes is accepted)
-            return html_sanitize(value, silent=True, strict=True, strip_style=self.strip_style, strip_classes=self.strip_classes)
+            return html_sanitize(
-    __slots__ = ['_sanitize', '_strip_style', '_strip_classes', '_symbol_f', '_symbol_set']
+    __slots__ = ['_sanitize', '_sanitize_tags', '_sanitize_attributes', '_sanitize_style', '_strip_style', '_strip_classes', '_symbol_f', '_symbol_set']
-    def __init__(self, string='unknown', sanitize=True, strip_style=False, strip_classes=False, **args):
+        return html_sanitize(
-        if not self.style:
+        if not self.style and self.sanitize_style:
-def html_sanitize(src, silent=True, strict=False, strip_style=False, strip_classes=False):
+def html_sanitize(src, silent=True, sanitize_tags=True, sanitize_attributes=False, sanitize_style=False, strip_style=False, strip_classes=False):
-        'forms': True,              # remove form tags
+        'style': strip_style,              # True = remove style tags/attrs
-                current_safe_attrs = safe_attrs
+    if sanitize_tags:
-                'safe_attrs': current_safe_attrs,
+                'kill_tags': tags_to_kill,
-        kwargs['safe_attrs_only'] = False    # keep oe-data attributes + style
+        kwargs.update({
-        return self.stage_find(cr, uid, [], context.get('default_project_id'), [('fold', '=', False)], context=context)
+        default_project_id = context.get('default_project_id')
-        boms_done = [(self, {'qty': quantity, 'product': product, 'original_qty': quantity})]
+        boms_done = [(self, {'qty': quantity, 'product': product, 'original_qty': quantity, 'parent_line': False})]
-        bom_lines = [(bom_line, product, quantity) for bom_line in self.bom_line_ids]
+        bom_lines = [(bom_line, product, quantity, False) for bom_line in self.bom_line_ids]
-            current_line, current_product, current_qty = bom_lines[0]
+            current_line, current_product, current_qty, parent_line = bom_lines[0]
-                bom_lines = [(line, current_line.product_id, line_quantity) for line in bom.bom_line_ids] + bom_lines
+                bom_lines = [(line, current_line.product_id, line_quantity, current_line) for line in bom.bom_line_ids] + bom_lines
-                boms_done.append((bom, {'qty': converted_line_quantity, 'product': current_product, 'original_qty': quantity}))
+                boms_done.append((bom, {'qty': converted_line_quantity, 'product': current_product, 'original_qty': quantity, 'parent_line': current_line}))
-                lines_done.append((current_line, {'qty': line_quantity, 'product': current_product, 'original_qty': quantity}))
+                lines_done.append((current_line, {'qty': line_quantity, 'product': current_product, 'original_qty': quantity, 'parent_line': parent_line}))
-            moves += self._generate_raw_move(bom_line, line_data['qty'])
+            moves += self._generate_raw_move(bom_line, line_data)
-    def _generate_raw_move(self, bom_line, quantity):
+    def _generate_raw_move(self, bom_line, line_data):
-            'operation_id': bom_line.operation_id.id,
+            'operation_id': bom_line.operation_id.id or alt_op,
-            workorders += self._workorders_create(bom, bom_data['qty'])
+            # If the routing of the parent BoM and phantom BoM are the same, don't recreate work orders, but use one master routing
-    def _workorders_create(self, bom, qty):
+    def _workorders_create(self, bom, bom_data):
-@odoo.tests.common.post_install(True)
+
-        self.phantom_js("/", "odoo.__DEBUG__.services['web.Tour'].run('shop_customize', 'test')", "odoo.__DEBUG__.services['web.Tour'].tours.shop_customize", login="admin")
+        self.phantom_js("/", "odoo.__DEBUG__.services['web_tour.tour'].run('shop_customize')", "odoo.__DEBUG__.services['web_tour.tour'].tours.shop_customize.ready", login="admin")
-        self.phantom_js("/", "odoo.__DEBUG__.services['web.Tour'].run('shop_buy_product', 'test')", "odoo.__DEBUG__.services['web.Tour'].tours.shop_buy_product", login="admin")
+        self.phantom_js("/", "odoo.__DEBUG__.services['web_tour.tour'].run('shop_buy_product')", "odoo.__DEBUG__.services['web_tour.tour'].tours.shop_buy_product.ready", login="admin")
-        self.phantom_js("/", "odoo.__DEBUG__.services['web.Tour'].run('shop_buy_product', 'test')", "odoo.__DEBUG__.services['web.Tour'].tours.shop_buy_product", login="demo")
+        self.phantom_js("/", "odoo.__DEBUG__.services['web_tour.tour'].run('shop_buy_product')", "odoo.__DEBUG__.services['web_tour.tour'].tours.shop_buy_product.ready", login="demo")
-        self.phantom_js("/", "odoo.__DEBUG__.services['web.Tour'].run('website_hr_recruitment_tour', 'test')", "odoo.__DEBUG__.services['web.Tour'].tours.website_hr_recruitment_tour")
+        self.phantom_js("/", "odoo.__DEBUG__.services['web_tour.tour'].run('website_hr_recruitment_tour')", "odoo.__DEBUG__.services['web_tour.tour'].tours.website_hr_recruitment_tour.ready")
-@odoo.tests.common.post_install(True)
+
-        self.phantom_js("/", "odoo.__DEBUG__.services['web.Tour'].run('forum_question', 'test')", "odoo.__DEBUG__.services['web.Tour'].tours.forum_question", login="demo")
+        self.phantom_js("/", "odoo.__DEBUG__.services['web_tour.tour'].run('forum_question')", "odoo.__DEBUG__.services['web_tour.tour'].tours.forum_question.ready", login="demo")
-@odoo.tests.common.post_install(True)
+
-        self.phantom_js("/", "odoo.__DEBUG__.services['web.Tour'].run('event_buy_tickets', 'test')", "odoo.__DEBUG__.services['web.Tour'].tours.event_buy_tickets", login="admin")
+        self.phantom_js("/", "odoo.__DEBUG__.services['web_tour.tour'].run('event_buy_tickets')", "odoo.__DEBUG__.services['web_tour.tour'].tours.event_buy_tickets.ready", login="admin")
-        self.phantom_js("/", "odoo.__DEBUG__.services['web.Tour'].run('event_buy_tickets', 'test')", "odoo.__DEBUG__.services['web.Tour'].tours.event_buy_tickets", login="demo")
+        self.phantom_js("/", "odoo.__DEBUG__.services['web_tour.tour'].run('event_buy_tickets')", "odoo.__DEBUG__.services['web_tour.tour'].tours.event_buy_tickets.ready", login="demo")
-        self.phantom_js("/", "odoo.__DEBUG__.services['web.Tour'].run('website_crm_tour', 'test')", "odoo.__DEBUG__.services['web.Tour'].tours.website_crm_tour")
+        self.phantom_js("/", "odoo.__DEBUG__.services['web_tour.tour'].run('website_crm_tour')", "odoo.__DEBUG__.services['web_tour.tour'].tours.website_crm_tour.ready")
-        self.phantom_js("/web", "odoo.__DEBUG__.services['web.Tour'].run('rte', 'test')", "odoo.__DEBUG__.services['web.Tour'].tours.rte", login='admin')
+        self.phantom_js("/web", "odoo.__DEBUG__.services['web_tour.tour'].run('rte')", "odoo.__DEBUG__.services['web_tour.tour'].tours.rte.ready", login='admin')
-        self.phantom_js("/web", "odoo.__DEBUG__.services['web.Tour'].run('rte_inline', 'test')", "odoo.__DEBUG__.services['web.Tour'].tours.rte", login='admin')
+        self.phantom_js("/web", "odoo.__DEBUG__.services['web_tour.tour'].run('rte_inline')", "odoo.__DEBUG__.services['web_tour.tour'].tours.rte_inline.ready", login='admin')
-@odoo.tests.common.post_install(True)
+    post_install = True
-        self.phantom_js("/", "odoo.__DEBUG__.services['web.Tour'].run('test_survey', 'test')", "odoo.__DEBUG__.services['web.Tour'].tours.test_survey", login="admin")
+        self.phantom_js("/", "odoo.__DEBUG__.services['web_tour.tour'].run('test_survey')", "odoo.__DEBUG__.services['web_tour.tour'].tours.test_survey.ready", login="admin")
-        self.phantom_js("/", "odoo.__DEBUG__.services['web.Tour'].run('test_survey', 'test')", "odoo.__DEBUG__.services['web.Tour'].tours.test_survey", login="demo")
+        self.phantom_js("/", "odoo.__DEBUG__.services['web_tour.tour'].run('test_survey')", "odoo.__DEBUG__.services['web_tour.tour'].tours.test_survey.ready", login="demo")
-        self.phantom_js("/", "odoo.__DEBUG__.services['web.Tour'].run('test_survey', 'test')", "odoo.__DEBUG__.services['web.Tour'].tours.test_survey")
+        self.phantom_js("/", "odoo.__DEBUG__.services['web_tour.tour'].run('test_survey')", "odoo.__DEBUG__.services['web_tour.tour'].tours.test_survey.ready")
-                        "odoo.__DEBUG__.services['web.Tour'].tours.pos_basic_order",
+                        "odoo.__DEBUG__.services['web_tour.tour'].run('pos_basic_order')",
-        (1, 'Send online quotations based on templates (advanced)')
+        (1, 'Send quotations your customer can approve & pay online (advanced)')
-        ], "Date")
+    module_sale_order_dates = fields.Selection([
-        (1, 'Show incoterms on sale orders and invoices')
+        (1, 'Show incoterms on sales orders and invoices')
-        help="The printed reports will display the incoterms for the sale orders and the related invoices")
+        help="The printed reports will display the incoterms for the sales orders and the related invoices")
-        (1, 'Allow discount policy on sale order line')
+        (0, 'No discount policy on sales order line'),
-        ], "Sale Reports Layout", implied_group='sale.group_sale_layout')
+        (0, 'Do not personalize sales orders and invoice reports'),
-        (0, 'All the products and the customers can be used in sale orders'),
+        (0, 'All the products and the customers can be used in sales orders'),
-        (1, "Never allow to modify a confirmed sale order")
+        (1, "Never allow to modify a confirmed sales order")
-        (1, 'Allow to modify the sale order dates to postpone deliveries and procurements')
+        (0, 'Procurements and deliveries dates are based on the sales order dates'),
-    payment_term_id = fields.Many2one('account.payment.term', string='Payment Term', oldname='payment_term',
+    payment_term_id = fields.Many2one('account.payment.term', string='Payment Terms', oldname='payment_term',
-    name = fields.Char(string='Payment Term', translate=True, required=True)
+    name = fields.Char(string='Payment Terms', translate=True, required=True)
-    payment_id = fields.Many2one('account.payment.term', string='Payment Term', required=True, index=True, ondelete='cascade')
+    payment_id = fields.Many2one('account.payment.term', string='Payment Terms', required=True, index=True, ondelete='cascade')
-            raise ValidationError(_('Percentages for Payment Term Line must be between 0 and 100.'))
+            raise ValidationError(_('Percentages for Payment Terms Line must be between 0 and 100.'))
-        string ='Customer Payment Term',
+        string='Customer Payment Terms',
-         string ='Vendor Payment Term',
+         string='Vendor Payment Terms',
-    payment_term_id = fields.Many2one('account.payment.term', string='Payment Term', oldname='payment_term', readonly=True)
+    payment_term_id = fields.Many2one('account.payment.term', string='Payment Terms', oldname='payment_term', readonly=True)
-    payment_term_id = fields.Many2one('account.payment.term', 'Payment Term')
+    payment_term_id = fields.Many2one('account.payment.term', 'Payment Terms')
-    payment_term_id = fields.Many2one('account.payment.term', string='Payment Term', oldname='payment_term')
+    payment_term_id = fields.Many2one('account.payment.term', string='Payment Terms', oldname='payment_term')
-        ('sale', 'Sale Order'),
+        ('sale', 'Sales Order'),
-            raise "Unknown format '%s'" % (formating,)
+            raise ValueError("Unknown format '%s'" % (formating,))
-from openerp import _, api, models
+from openerp import api, models
-        group_user = self.env.ref('base.group_user')
+            elif all(recipient.user_ids.mapped('share')):
-        'security/ir.model.access.csv',
+        'security/ir.model.access.csv',
-    _name = "account.operation.template"
+class AccountReconcileModel(models.Model):
-        'data/menuitem_data.xml'
+        'data/menuitem_data.xml',
-                for record in ops.linked_move_operation_ids:
+                for record in ops.linked_move_operation_ids.filtered(lambda x: x.move_id.id in main_domain):
-        return 'website_published desc,%s' % post.get('order', 'website_sequence desc')
+        # id is added to be sure that order is a unique sort key
-        pricelist_id = int(request.website.get_current_pricelist())
+        event = event.with_context(pricelist=request.website.get_current_pricelist().id)
-            'main_object': event.with_context(pricelist=pricelist_id),
+            'event': event,
-            ticket = self.env['event.event.ticket'].with_context(pricelist=order.pricelist_id.id).browse(event_ticket_id)
+            ticket = self.env['event.event.ticket'].browse(event_ticket_id)
-            self = self.with_context(event_ticket_id=ticket.id)
+            if ticket.id:
-            'suggested_products': order.with_context(pricelist=order.pricelist_id.id)._cart_accessories()
+            'suggested_products': order._cart_accessories()
-        sale_order = self.env['sale.order'].sudo().browse(sale_order_id).exists() if sale_order_id else None
+        if not self._context.get('pricelist'):
-            product_context['pricelist'] = int(pricelist)
+            product_context['pricelist'] = pricelist.id
-        return super(View, self.with_context(new_context)).render(values, engine=engine)
+        if self._context != new_context:
-            self2 = self
+        context = dict(self._context, pricelist=pricelist.id, partner=partner)
-            website.pricelist_id = website.with_context(website_id=website.id).get_current_pricelist()
+            if website._context.get('website_id') != website.id:
-                    if rule.product_id and not (product.product_variant_count == 1 and product.product_variant_ids[0].id == rule.product_id.id):
+                    if rule.product_id and not (product.product_variant_count == 1 and product.product_variant_id.id == rule.product_id.id):
-            template.standard_price = template.product_variant_ids[0].standard_price
+            template.standard_price = template.product_variant_id.standard_price
-            template.volume = template.product_variant_ids[0].volume
+            template.volume = template.product_variant_id.volume
-            template.weight = template.product_variant_ids[0].weight
+            template.weight = template.product_variant_id.weight
-            template.default_code = template.product_variant_ids[0].default_code
+            template.default_code = template.product_variant_id.default_code
-                return template.product_variant_ids[0].compute_price()
+                return template.product_variant_id.compute_price()
-        to_currency = pl.currency_id
+        to_currency = request.website.get_current_pricelist().currency_id
-                price = variant.currency_id.compute(variant.display_price(pl, public=True), to_currency)
+                price = variant.currency_id.compute(variant.website_public_price, to_currency)
-                price = variant.display_price(pl, public=True)
+                price = variant.website_public_price
-            attribute_value_ids.append([variant.id, visible_attribute_ids, variant.display_price(pl), price])
+            attribute_value_ids.append([variant.id, visible_attribute_ids, variant.website_price, price])
-        products = Product.with_context(pricelist_context).search(domain, limit=ppg, offset=pager['offset'], order=self._get_search_order(post))
+        products = Product.search(domain, limit=ppg, offset=pager['offset'], order=self._get_search_order(post))
-        return {product.id: request.website.get_product_price(product, qty=add_qty) / add_qty for product in products}
+        products = request.env['product.product'].with_context({'quantity': add_qty}).browse(product_ids)
-
+    website_price = fields.Float('Website price', compute='_website_price', digits=dp.get_precision('Product Price'))
-            if self.processed_boolean and self.qty_done == 0:
+            if self.is_done and self.qty_done == 0:
-            if not self.processed_boolean and self.qty_done != 0:
+            if not self.is_done and self.qty_done != 0:
-                'function': 'model_copy',
+                'function': '_cron_model_copy',
-                    # $varset = []
+                    # content = []
-                        ],
+                        targets=[ast.Name(id='content', ctx=ast.Store())],
-                            value=self._values_var(ast.Str(varname), ctx=ast.Load()),
+                            value=ast.Name(id='content', ctx=ast.Load()),
-                            args=[self._values_var(ast.Str(varname), ctx=ast.Load())], keywords=[],
+                            args=[ast.Name(id='content', ctx=ast.Load())], keywords=[],
-    'depends': ['base_setup', 'web', 'web_editor', 'web_planner'],
+    'depends': ['web', 'web_editor', 'web_planner'],
-    'depends': ['web', 'web_editor', 'web_planner'],
+    'depends': ['base_setup', 'web', 'web_editor', 'web_planner'],
-            'partner_data': json.dumps(partner_data)
+            'partner_data': json.dumps(partner_data),
-    'depends': ['web_planner', 'base_setup'],
+    'depends': ['web_planner'],
-    'depends': ['web', 'web_editor', 'web_planner', 'base_setup'],
+    'depends': ['web', 'web_editor', 'web_planner'],
-
+    
-    
+
-        for i in glob.glob(ls_glob):
+        ls_glob2 = os.path.expanduser('~/.local/share/Ofi Labs/PhantomJS/http_%s_%s.*' % (HOST, PORT))
-    'depends': ['web_planner'],
+    'depends': ['web_planner', 'base_setup'],
-    'depends': ['web', 'web_editor', 'web_planner'],
+    'depends': ['web', 'web_editor', 'web_planner', 'base_setup'],
-            domain += [('create_date', '>=', date_begin), ('create_date', '<', date_end)]
+            domain += [('create_date', '>', date_begin), ('create_date', '<=', date_end)]
-            domain += [('create_date', '>=', date_begin), ('create_date', '<', date_end)]
+            domain += [('create_date', '>', date_begin), ('create_date', '<=', date_end)]
-            domain += [('create_date', '>=', date_begin), ('create_date', '<', date_end)]
+            domain += [('create_date', '>', date_begin), ('create_date', '<=', date_end)]
-        implied_group="mass_mailing.group_website_popup_on_exit")
+from . import models
-                values['type'] = etree.fromstring(values['arch']).tag
+
-        if 'arch' in vals and 'install_mode_data' not in context:
+        if ('arch' in vals or 'arch_base' in vals) and 'install_mode_data' not in context:
-                    key = ('product', values['partner_id'], (values['product_id'], values['name']), values['analytic_account_id'], values['debit'] > 0)
+                    key = ('product', values['partner_id'], (values['product_id'], tuple(values['tax_ids'][0][2]), values['name']), values['analytic_account_id'], values['debit'] > 0)
-                    'tax_ids': [(6, 0, line.tax_ids.ids)],
+                    'tax_ids': [(6, 0, line.tax_ids_after_fiscal_position.ids)],
-                result = 0.00
+                if result is None:
-import openerp.tests
+import odoo.tests
-                        login="admin")
+                        "odoo.__DEBUG__.services['web_tour.tour'].run('widget_x2many', 100)",
-    'depends': ['base', 'web'],
+    'depends': ['base', 'web', 'web_tour'],
-        self.phantom_js("/web", "odoo.__DEBUG__.services['web_tour.tour'].run('crm_tour')", "odoo.__DEBUG__.services['web_tour.tour'].tours.crm_tour", login="admin")
+        self.phantom_js("/web", "odoo.__DEBUG__.services['web_tour.tour'].run('crm_tour')", "odoo.__DEBUG__.services['web_tour.tour'].tours.crm_tour.ready", login="admin")
-        self.phantom_js("/web", "odoo.__DEBUG__.services['web_tour.tour'].run('point_of_sale_tour')", "odoo.__DEBUG__.services['web_tour.tour'].tours.point_of_sale_tour", login="admin")
+        self.phantom_js("/web", "odoo.__DEBUG__.services['web_tour.tour'].run('point_of_sale_tour')", "odoo.__DEBUG__.services['web_tour.tour'].tours.point_of_sale_tour.ready", login="admin")
-        self.phantom_js("/web", "odoo.__DEBUG__.services['web_tour.tour'].run('project_tour')", "odoo.__DEBUG__.services['web_tour.tour'].tours.project_tour", login="admin")
+        self.phantom_js("/web", "odoo.__DEBUG__.services['web_tour.tour'].run('project_tour')", "odoo.__DEBUG__.services['web_tour.tour'].tours.project_tour.ready", login="admin")
-        self.phantom_js("/", "odoo.__DEBUG__.services['web_tour.tour'].run('banner')", "odoo.__DEBUG__.services['web_tour.tour'].tours.banner", login='admin')
+        self.phantom_js("/", "odoo.__DEBUG__.services['web_tour.tour'].run('banner')", "odoo.__DEBUG__.services['web_tour.tour'].tours.banner.ready", login='admin')
-        self.phantom_js("/", "odoo.__DEBUG__.services['web_tour.tour'].run('blog')", "odoo.__DEBUG__.services['web_tour.tour'].tours.blog", login='admin')
+        self.phantom_js("/", "odoo.__DEBUG__.services['web_tour.tour'].run('blog')", "odoo.__DEBUG__.services['web_tour.tour'].tours.blog.ready", login='admin')
-        self.phantom_js("/", "odoo.__DEBUG__.services['web_tour.tour'].run('event')", "odoo.__DEBUG__.services['web_tour.tour'].tours.event", login='admin')
+        self.phantom_js("/", "odoo.__DEBUG__.services['web_tour.tour'].run('event')", "odoo.__DEBUG__.services['web_tour.tour'].tours.event.ready", login='admin')
-        self.phantom_js("/", "odoo.__DEBUG__.services['web_tour.tour'].run('question')", "odoo.__DEBUG__.services['web_tour.tour'].tours.question", login="admin")
+        self.phantom_js("/", "odoo.__DEBUG__.services['web_tour.tour'].run('question')", "odoo.__DEBUG__.services['web_tour.tour'].tours.question.ready", login="admin")
-        self.phantom_js("/", "odoo.__DEBUG__.services['web_tour.tour'].run('shop')", "odoo.__DEBUG__.services['web_tour.tour'].tours.shop", login="admin")
+        self.phantom_js("/", "odoo.__DEBUG__.services['web_tour.tour'].run('shop')", "odoo.__DEBUG__.services['web_tour.tour'].tours.shop.ready", login="admin")
-            'res_id': self.id,
+            'res_id': post.id,
-    _items_per_page = 10
+    _items_per_page = 20
-    purchase_ok = fields.Boolean('Can be Purchased', default=True)
+# -*- coding: utf-8 -*-
-    bom_id = fields.Many2one('mrp.bom', 'Bill of Material', domain="[('product_id', '=', product_id)]")
+    bom_id = fields.Many2one('mrp.bom', 'Bill of Material', domain="['|', ('product_id', '=', product_id), ('product_tmpl_id.product_variant_ids','=', product_id)]")
-                        documents to your project.
+                        Click to upload files to your product.
-            moves_finished = self.move_finished_ids.filtered(lambda move: move.operation_id == operation)
+                moves_raw |= self.move_raw_ids.filtered(lambda move: not move.operation_id)
-            new_qty = move.bom_line_id.product_qty * self.qty_producing / move.bom_line_id.bom_id.product_qty
+            new_qty = move.unit_factor * self.qty_producing
-                    while qty_todo > 0:
+                if float_compare(qty_todo, 0.0, precision_rounding=move.product_uom.rounding) > 0:
-                            'quantity_done': 0,
+                            'quantity_done': min(1.0, qty_todo),
-                elif qty_todo < 0.0:
+                elif float_compare(qty_todo, 0.0, precision_rounding=move.product_uom.rounding) < 0:
-            qty = self.qty_producing / move.bom_line_id.bom_id.product_qty * move.bom_line_id.product_qty
+            qty = move.unit_factor * self.qty_producing
-                        'quantity_done': 0,
+                        'quantity_done': min(1, qty),
-                    'quantity_done': 0,
+                    'quantity_done': qty,
-            'tracking': 'lot',
+            'tracking': 'none',
-        if self.partner_id or self.self.order_id.partner_id:
+        if self.partner_id or self.sale_line_id.order_id.partner_id:
-    user_id = fields.Many2one('res.users', 'User', required=True, readonly=True,
+    user_id = fields.Many2one('res.users', 'User', readonly=True,
-                                     ondelete="cascade", readonly=True, copy=True,
+                                     readonly=True, copy=True,
-    user_id = fields.Many2one('res.users', 'User', required=True,
+    user_id = fields.Many2one('res.users', 'User',
-    @api.depends('name')
+    @api.depends('icon')
-            path = modules.get_module_resource(module.name, 'static', 'description', 'icon.png')
+            if module.icon:
-        super(AccountMoveLine, self).compute_full_after_batch_reconcile()
+        aml_id, partial_rec_id = super(AccountMoveLine, self).compute_full_after_batch_reconcile()
-                partial_rec_set |= aml.matched_debit_ids | aml.matched_credit_ids
+            partial_rec_set |= aml.matched_debit_ids | aml.matched_credit_ids
-                'reconciled_line_ids': [(6, 0, self.ids)]})
+                'partial_reconcile_ids': [(4, p_id) for p_id in partial_rec_ids],
-                       '&', ('res_model', '=', self._name), '&', ('res_id', '=', self.id)],
+                       '&', ('res_model', '=', 'product.template'), ('res_id', '=', self.product_tmpl_id.id),
-            'partner_data': json.dumps(partner_data)
+            'partner_data': json.dumps(partner_data),
-            'search_count': count_members
+            'search_count': count_members,
-            'res_id': self.id,
+            'res_id': post.id,
-        ], compute='_compute_state', default="draft", string='Status', index=True, readonly=True, copy=False, required=True, store=True,
+    state = fields.Selection([
-    sheet_id = fields.Many2one('hr.expense.sheet', string="Expense Report", readonly=True)
+    sheet_id = fields.Many2one('hr.expense.sheet', string="Expense Report", readonly=True, copy=False)
-    account_move_id = fields.Many2one('account.move', string='Journal Entry', copy=False, track_visibility="onchange")
+    account_move_id = fields.Many2one('account.move', string='Journal Entry', copy=False)
-
+from werkzeug import url_encode
-        body = (_("A payment of %s %s with the reference %s related to your expense %s has been made.") % (payment.amount, payment.currency_id.symbol, payment.name, expense_sheet.name))
+        body = (_("A payment of %s %s with the reference <a href='/mail/view?%s'>%s</a> related to your expense %s has been made.") % (payment.amount, payment.currency_id.symbol, url_encode({'model': 'account.payment', 'res_id': payment.id}), payment.name, expense_sheet.name))
-        # 'foo <bar>'. We will extract 'bar' from this
+
-            return False
+        employee = self.env['hr.employee'].search([
-    @api.model
+    tax_exigible = fields.Boolean(string='Appears in VAT report', default=True,
-from odoo import models, fields
+from odoo import api, models, fields
-                if line.tax_line_id and line.tax_line_id.use_cash_basis:
+                #TOCHECK: normal and cash basis taxes shoudn't be mixed together (on the same invoice line for example) as it will
-        line_to_create = []
+                    if line.tax_line_id and line.tax_line_id.use_cash_basis:
-        for k, v in total_by_cash_basis_account.items():
+        for key, v in total_by_cash_basis_account.items():
-            move = self.env['account.move'].create({
+            move = self.env['account.move'].with_context(dont_create_taxes=True).create({
-            'name': _('New Job Offer'),
+            'name': _('Job Title'),
-            if recipient.user_ids and group_hr_user in recipient.user_ids[0].groups_id.ids:
+            if recipient.user_ids and group_hr_user in recipient.user_ids[0].groups_id:
-                ('date', '>=', date.today().replace(day=1))
+                ('date', '>=', date.today().replace(day=1)),
-        price_precision = dp.get_precision('Product Price')
+        product_accounts = {product.id: product.product_tmpl_id.get_product_accounts() for product in self}
-                if tools.float_is_zero(diff, precision_digits=price_precision):
+                if diff:
-            credit_aml.payment_id.write({'invoice_ids': [(4, id, None)]})
+            credit_aml.payment_id.write({'invoice_ids': [(4, self.id, None)]})
-        return "%s-%s-%s-%s-%s" % (
+        return "%s-%s-%s-%s-%s-%s" % (
-            res.ir_filter_id = False
+            self.ir_filter_id = False
-                    filename = get_resource_path(*path)
+                    filename = get_resource_path(*path) if path else None
-                        filename = None
+                    path = filter(None, src.split('/'))
-                    node.set('domain', "[('purchase_ok', '=', True)]")
+                    # Hack to fix the stable version 8.0 -> saas-12
-            self._update_user_groups_view()
+        self._update_user_groups_view()
-                line.qty_to_invoice = 0
+import payment
-#import test_uninstall
+#import test_uninstall  # loop
-import common
+from openerp.tests import common
-                mimetype = default_mimetype
+                mimetype = guess_mimetype(base64.b64decode(content), default=default_mimetype)
-    # jpg, jpeg, png, gif
+    # jpg, jpeg, png, gif, bmp
-def guess_mimetype(bin_data):
+def guess_mimetype(bin_data, default='application/octet-stream'):
-    return 'application/octet-stream'
+    return default
-            pdf = request.env['report'].sudo().with_context(set_viewport_size=True).get_pdf(Order.id, 'website_quote.report_quote')
+            pdf = request.env['report'].sudo().with_context(set_viewport_size=True).get_pdf([Order.id], 'website_quote.report_quote')
-            pdf = request.env['report'].sudo().get_pdf(order, 'sale.report_saleorder', data=None)
+            pdf = request.env['report'].sudo().get_pdf([sale_order_id], 'sale.report_saleorder', data=None)
-        return 0.0
+        if start and stop:
-        base_action = Actions.read([action_id], ['type'], request.context)
+        base_action = Actions.read([action_id], ['type'], context=request.context)
-            action = request.session.model(action_type).read([action_id], False, ctx)
+            action = request.session.model(action_type).read([action_id], False, context=ctx)
-            'user_id': self.product_id.product_manager.id,
+            'user_id': self.env.uid,
-    website_description = fields.Html('Website description', translate=html_translate, sanitize=False)
+    def _get_default_website_description(self):
-
+    @api.multi
-            return None
+            raise ValueError("Cannot slug non-existent record %s" % value)
-            event.website_url = '/event/%s' % slug(event)
+            if event.id:  # avoid to perform a slug on a not yet saved record in case of an onchange.
-                channel.website_url = '%s/slides/%s' % (base_url, channel_slug)
+            if channel.id:  # avoid to perform a slug on a not yet saved record in case of an onchange.
-                #link_tracker is not in dependencies, so use it to shorten url only if installed.
+            if slide.id:  # avoid to perform a slug on a not yet saved record in case of an onchange.
-                    url = self.env['link.tracker'].sudo().create({'url': '%s/slides/slide/%s' % (base_url, slide_slug)}).short_url
+                    url = self.env['link.tracker'].sudo().create({'url': '%s/slides/slide/%s' % (base_url, slug(slide))}).short_url
-                    url = '%s/slides/slide/%s' % (base_url, slide_slug)
+                    url = '%s/slides/slide/%s' % (base_url, slug(slide))
-                products = self.search(args + ['|', ('default_code', operator, name), ('name', operator, name)], limit=limit)
+                products = self.search(args + [('default_code', operator, name)], limit=limit)
-                    key = ('product', values['partner_id'], (values['product_id'], values['name']), values['analytic_account_id'], values['debit'] > 0)
+                    key = ('product', values['partner_id'], (values['product_id'], tuple(values['tax_ids'][0][2]), values['name']), values['analytic_account_id'], values['debit'] > 0)
-                    'tax_ids': [(6, 0, line.tax_ids.ids)],
+                    'tax_ids': [(6, 0, line.tax_ids_after_fiscal_position.ids)],
-                            grouped_data[key].append(values)
+                        current_value = grouped_data[key][0]
-        image_base64 = content and base64.b64decode(content) or self.placeholder()
+        if isinstance(value.id, models.NewId):
-            channel.website_url = '%s/slides/%s' % (base_url, slug(channel))
+            channel_slug = slug(channel)
-            slide.website_url = url
+            slide_slug = slug(slide)
-    'depends': ['sale_stock', 'barcodes'],
+    'depends': ['stock_account', 'barcodes'],
-
+        'W0101',  # unreachable code
-            variant_matrix = itertools.product(*(line.value_ids for line in tmpl_id.attribute_line_ids))
+            variant_matrix = itertools.product(*(line.value_ids for line in tmpl_id.attribute_line_ids if line.value_ids and line.value_ids[0].attribute_id.create_variant))
-        request.website.sale_get_order(force_create=1)._cart_update(product_id=int(product_id), add_qty=float(add_qty), set_qty=float(set_qty))
+        request.website.sale_get_order(force_create=1)._cart_update(
-        values = {
+        return {
-            'name': product.display_name,
+
-        return values
+            name += '\n%s' % (product.description_sale)
-    def _cart_update(self, product_id=None, line_id=None, add_qty=0, set_qty=0, **kwargs):
+    def _cart_update(self, product_id=None, line_id=None, add_qty=0, set_qty=0, attributes=None, **kwargs):
-                optional_product_ids=optional_product_ids)
+            value = order._cart_update(
-            order._cart_update(product_id=option_id,
+            order._cart_update(
-                linked_line_id=value.get('line_id'))
+                attributes=attributes,
-            variant = ", ".join([v.name for v in product.attribute_value_ids])
+            # display only the attributes with multiple possible values on the template
-
+from odoo import release
-            deps = ModuleSudo.browse(modules.downstream_dependencies())
+            deps = modules.sudo().downstream_dependencies()
-    'summary': 'Jobs, Recruitment, Applications, Job Interviews, Surveys',
+    'summary': 'Jobs, Recruitment, Applications, Job Interviews',
-It is integrated with the mail gateway to automatically fetch email sent to <jobs@yourcompany.com> in the list of applications. It's also integrated with the document management system to store and search in the CV base and find the candidate that you are looking for. Similarly, it is integrated with the survey module to allow you to define interviews for different jobs.
+It is integrated with the mail gateway to automatically fetch email sent to <jobs@yourcompany.com> in the list of applications. It's also integrated with the document management system to store and search in the CV base and find the candidate that you are looking for. Similarly, it may integrated with the survey module to allow you to define interviews for different jobs.		
-            return self.survey.with_context(survey_token=response.token).action_print_survey()
+
-    def init(self, cr):
+    @api.model_cr
-            url=blog_url(),
+            url=request.httprequest.path,
-        def _get_rec(object, level):
+        def _get_rec(object, level, qty=1.0):
-                res['pqty'] = l.product_qty
+                res['pqty'] = l.product_qty * qty
-                    _get_rec(l.child_line_ids,level)
+                    _get_rec(l.child_line_ids, level, qty=res['pqty'])
-        return self.lead_id.action_set_lost()
+        leads = self.env['crm.lead'].browse(self.env.context.get('active_ids'))
-            raise UserError(_("The found valuation amount for product %s is zero. Which means there is probably a configuration error. Check the costing method and the standard price") % (move.product_id.name,))
+            if move.product_id.cost_method == 'standard':
-            move_obj.post(cr, uid, [new_move], context=context)
+            if move_lines:
-                    products += self.search(args + [('name', operator, name), ('id', 'not in', self.ids)], limit=limit2)
+                products = self.search(args + ['|', ('default_code', operator, name), ('name', operator, name)], limit=limit)
-            '', args=[('id', 'in', templates.ids)],
+            '', args=[('id', 'in', list(set(templates.ids)))],
-    bom_id = fields.Many2one('mrp.bom', 'Bill of Material', domain="[('product_id', '=', product_id)]")
+    bom_id = fields.Many2one('mrp.bom', 'Bill of Material', domain="['|', ('product_id', '=', product_id), ('product_tmpl_id.product_variant_ids','=', product_id)]")
-                        documents to your project.
+                        Click to upload files to your product.
-            domain = [('product_tmpl_id', 'not in', templates.ids)]
+        templates = self.browse([])
-            products = Product.search(name, args+domain, operator=operator)
+            products_ns = Product.name_search(name, args+domain, operator=operator)
-        today = fields.Date.today()
+            date = slip.date or slip.date_to
-                'date': today,
+                'date': date,
-                        'date': today,
+                        'date': date,
-                        'date': today,
+                        'date': date,
-                    'date': today,
+                    'date': date,
-                    'date': today,
+                    'date': date,
-            slip.write({'move_id': move.id, 'date': today})
+            slip.write({'move_id': move.id, 'date': date})
-    'name': 'Sales Management',
+    'name': 'Sales',
-    'name': 'MRP',
+    'name': 'Manufacturing',
-            membership = None
+
-
+            'search_count': count_members
-
+        keep = QueryURL('/shop', category=category and int(category), search=search, attrib=attrib_list, order=post.get('order'))
-            if partner.commercial_company_name:
+            if partner.company_name or partner.parent_id:
-                    name = "%s, %s" % (partner.commercial_company_name, name)
+                    name = "%s, %s" % (partner.commercial_company_name or partner.parent_id.name, name)
-from openerp.http import request, serialize_exception as _serialize_exception
+from openerp.http import request, serialize_exception as _serialize_exception, content_disposition
-from openerp.http import request, STATIC_CACHE
+from openerp.http import request, STATIC_CACHE, content_disposition
-            return "attachment; filename*=UTF-8''%s" % escaped
+        return content_disposition(filename)
-        default='{"background-image": "none", "background-color": "oe_none", "opacity": "0.6", "resize_class": ""}')
+        default='{"background-image": "none", "background-color": "oe_black", "opacity": "0.2", "resize_class": ""}')
-        return node
+        return self.value_to_html(self.env['res.partner'].browse(ids[0]), options=options)
-                            else current_blog_post_index + 1]
+        nb_posts = len(all_post_ids)
-
+    move_name = fields.Char(string='Journal Entry Name', readonly=True,
-                    if st_line.statement_id.name == line.payment_id.name:
+                    if st_line.move_name and line.payment_id.payment_reference == st_line.move_name:
-    def _prepare_reconciliation_move(self, move_name):
+    def _prepare_reconciliation_move(self, move_ref):
-           :param char st_line_number: will be used as the name of the generated account move
+           :param char move_ref: will be used as the reference of the generated account move
-        return {
+        ref = move_ref or ''
-            'ref': self.ref,
+            'ref': ref,
-            move_vals = self._prepare_reconciliation_move(move_name)
+            move_vals = self._prepare_reconciliation_move(self.statement_id.name)
-            payment_id = False
+            payment = False
-                payment_id = self.env['account.payment'].create({
+                payment = self.env['account.payment'].create({
-                }).id
+                })
-                aml_dict['payment_id'] = payment_id
+                aml_dict['payment_id'] = payment and payment.id or False
-                aml_dict['payment_id'] = payment_id
+                aml_dict['payment_id'] = payment and payment.id or False
-            aml_obj.with_context(check_move_validity=False).create(aml_dict)            
+            aml_dict['payment_id'] = payment and payment.id or False
-            rec.state = 'posted'
+            rec.write({'state': 'posted', 'move_name': move.name})
-        name = journal.with_context(ir_sequence_date=self.payment_date).sequence_id.next_by_id()
+        name = self.move_name or journal.with_context(ir_sequence_date=self.payment_date).sequence_id.next_by_id()
-            'name': self.env['ir.sequence'].with_context(ctx).next_by_code('pos.session'),
+            'name': pos_name,
-            if request.env.user.has_group('base.group_user'):
+            if request.env['res.users'].browse(request.uid).has_group('base.group_user'):
-            self.duration_percent = 100 * (self.duration_expected - self.duration) / self.duration
+        if self.duration_expected:
-            domain_move_out += [('date', '<=', to_date)]
+        dates_in_the_past = False
-        moves_out_res = dict((item['product_id'][0], item['product_qty']) for item in Move.read_group(domain_move_out, ['product_id', 'product_qty'], ['product_id']))
+        domain_move_in_todo = [('state', 'not in', ('done', 'cancel', 'draft'))] + domain_move_in
-            res[product.id]['qty_available'] = float_round(quants_res.get(product.id, 0.0), precision_rounding=product.uom_id.rounding)
+            if dates_in_the_past:
-                res[product.id]['qty_available'] + res[product.id]['incoming_qty'] - res[product.id]['outgoing_qty'],
+                qty_available + res[product.id]['incoming_qty'] - res[product.id]['outgoing_qty'],
-            return RuntimeError('request not bound to a database')
+            raise RuntimeError('request not bound to a database')
-            return RuntimeError('request not bound to a database')
+            raise RuntimeError('request not bound to a database')
-            cr.execute(new_query)
+    cr.execute(fp.read())
-from odoo.exceptions import AccessError
+from odoo import api, fields, models
-        if not self.env.user._is_admin():
+        if not self.env.user._is_superuser() and not self.env.user.has_group('base.group_system'):
-            return {'error': _('File is too big. File size cannot exceed 15MB')}
+        if (payload / 1024 / 1024 > 25):
-from openerp.tools.misc import str2bool
+from openerp.tools.misc import str2bool, xlwt
-        worksheet = workbook.add_sheet(jdata['title'][:30])
+        worksheet = workbook.add_sheet(jdata['title'])
