-__version__ = '1.0.1'
+__version__ = '1.0.2.dev'
-__version__ = '1.0.1.dev'
+__version__ = '1.0.1'
-    get_flashed_messages, locked_cached_property, url_for
+from .helpers import (
-        if load_dotenv:
+        if get_load_dotenv(load_dotenv):
-__version__ = '0.12.4'
+__version__ = '0.12.5.dev'
-__version__ = '0.12.4.dev'
+__version__ = '0.12.4'
-        if self.url_prefix:
+        if self.url_prefix is not None:
-from .helpers import get_debug_flag, get_env
+from .helpers import get_debug_flag, get_env, get_load_dotenv
-        if self.load_dotenv and load_dotenv:
+        if get_load_dotenv(self.load_dotenv):
-                ' Do "pip install python-dotenv" to use them',
+                ' Do "pip install python-dotenv" to use them.',
-        if self.load_dotenv:
+        val = os.environ.get('FLASK_DONT_LOAD_ENV')
-        if (trap_bad_request is None and self.debug) or trap_bad_request:
+        # if unset, trap key errors in debug mode
-    @app.route('/fail')
+    @app.route('/key')
-    rv = client.get('/fail')
+    @app.route('/abort')
-
+    app.debug = True
-
+        client.get("/key")
-
+        if url_prefix:
-            rule = self.url_prefix + rule
+            rule = '/'.join((self.url_prefix, rule.lstrip('/')))
-    def foo():
+@pytest.mark.parametrize(('prefix', 'rule', 'url'), (
-    assert client.get('/spam/foo').status_code == 204
+    assert client.get(url).status_code == 204
-        if isinstance(rv, (tuple, list)):
+        if isinstance(rv, tuple):
-    python_requires='>=2.7,!=3.0.*,!=3.1.*,!=3.2.*,!=3.3.*',
+    python_requires='>=2.7,!=3.0.*,!=3.1.*,!=3.2.*,!=3.3.*',
-        if view_func:
+        if view_func and hasattr(view_func, '__name__'):
-    python_requires='>=2.7,!=3.0.*,!=3.1.*,!=3.2.*',
+    python_requires='>=2.7,!=3.0.*,!=3.1.*,!=3.2.*,!=3.3.*',
-__version__ = '1.0'
+__version__ = '1.0.1.dev'
-__version__ = '1.0'
+__version__ = '1.1.dev'
-__version__ = '1.0-dev'
+__version__ = '1.0'
-        ('Issue tracker', 'https://github.com/pallets/pallets-sphinx-themes/issues'),
+        ('Code', 'https://github.com/pallets/flask'),
-__version__ = '1.0-dev'
+__version__ = '1.0'
-__version__ = '0.12.3'
+__version__ = '0.12.4.dev'
-__version__ = '0.12.3-dev'
+__version__ = '0.12.3'
-import sys
+
-from subprocess import Popen, PIPE
+import sys
-_date_clean_re = re.compile(r'(\d+)(st|nd|rd|th)')
+_date_strip_re = re.compile(r'(?<=\d)(st|nd|rd|th)')
-            if lineiter.next().count('-') != len(match.group(0)):
+
-                change_info = lineiter.next().strip()
+                change_info = next(lineiter).strip()
-                              r'(?:, codename (.*))?(?i)', change_info)
+            match = re.search(
-        parts = map(int, version.split('.'))
+        parts = [int(i) for i in version.split('.')]
-    string = _date_clean_re.sub(r'\1', string)
+    string = _date_strip_re.sub('', string)
-                          inject_version, f.read())
+        contents = re.sub(
-    Popen([sys.executable, 'setup.py', 'release', 'sdist', 'bdist_wheel', 'upload']).wait()
+def build():
-    return set(Popen(['git', 'tag'], stdout=PIPE).communicate()[0].splitlines())
+    return set(
-    dev_version = bump_version(version) + '-dev'
+    dev_version = bump_version(version) + '.dev'
-         version, codename, release_date.strftime('%d/%m/%Y'))
+    info(
-             release_date.date(), date.today())
+        fail(
-    build_and_upload()
+    build()
-    },
+    project_urls={
-        ProjectLink('Donate to Pallets', 'https://psfmember.org/civicrm/contribute/transact?id=20'),
+        ProjectLink('Donate to Pallets', 'https://psfmember.org/civicrm/contribute/transact?reset=1&id=20'),
-        ProjectLink('Donate to Pallets', 'https://psfmember.org/civicrm/contribute/transact?id=20'),
+        ProjectLink('Donate to Pallets', 'https://psfmember.org/civicrm/contribute/transact?reset=1&id=20'),
-    app.session_interface.serializer.register(TagOrderedDict, 0)
+    app.session_interface.serializer.register(TagOrderedDict, index=0)
-    def register(self, tag_class, force=False, index=-1):
+    def register(self, tag_class, force=False, index=None):
-            the tag is appended to the end of the order.
+            the new tag is a special case of an existing tag. If ``None``
-        if index == -1:
+        if index is None:
-        cli.show_server_banner(self.env, self.debug, self.name)
+        cli.show_server_banner(self.env, self.debug, self.name, False)
-def show_server_banner(env, debug, app_import_path, eager_loading=True):
+def show_server_banner(env, debug, app_import_path, eager_loading):
-    print(' * Environment: {0}'.format(env))
+        click.echo(message)
-        print(' * Debug mode: {0}'.format('on' if debug else 'off'))
+        click.echo(' * Debug mode: {0}'.format('on' if debug else 'off'))
-__version__ = '0.13-dev'
+__version__ = '1.0-dev'
-    # 'blinker': ('https://pythonhosted.org/blinker/', None),
+    'python': ('https://docs.python.org/3/', None),
-sys.path.append(os.path.dirname(__file__))
+import inspect
-# -- General configuration -----------------------------------------------------
+from pallets_sphinx_themes import ProjectLink, get_version
-#needs_sphinx = '1.0'
+# Project --------------------------------------------------------------
-source_suffix = '.rst'
+project = 'Flask'
-#source_encoding = 'utf-8-sig'
+# General --------------------------------------------------------------
-html_static_path = ['_static']
+extensions = [
-#html_last_updated_fmt = '%b %d, %Y'
+intersphinx_mapping = {
-#html_use_smartypants = True
+# HTML -----------------------------------------------------------------
-# Custom sidebar templates, maps document names to template names.
+html_theme = 'flask'
-        'searchbox.html'
+        'project.html',
-        'searchbox.html'
+        'versions.html',
-# -- Options for LaTeX output --------------------------------------------------
+# LaTeX ----------------------------------------------------------------
-  ('latexindex', 'Flask.tex', u'Flask Documentation', u'Armin Ronacher', 'manual'),
+    (master_doc, 'Flask.tex', 'Flask Documentation', 'Pallets Team', 'manual'),
-    'preamble': r'\usepackage{flaskstyle}'
+    'fontpkg': r'\usepackage{mathpazo}',
-
+# linkcheck ------------------------------------------------------------
-#epub_exclude_files = []
+linkcheck_anchors = False
-#epub_tocdepth = 3
+# Local Extensions -----------------------------------------------------
-# unwrap decorators
+
-import time
+import inspect
-import pkg_resources
+from pallets_sphinx_themes import DocVersion, ProjectLink, get_version
-BUILD_DATE = datetime.datetime.utcfromtimestamp(int(os.environ.get('SOURCE_DATE_EPOCH', time.time())))
+# Project --------------------------------------------------------------
-sys.path.append(os.path.dirname(__file__))
+project = 'Flask'
-# -- General configuration -----------------------------------------------------
+# General --------------------------------------------------------------
-#needs_sphinx = '1.0'
+master_doc = 'index'
-    'flaskdocext'
+    'sphinxcontrib.log_cabinet',
-#html_last_updated_fmt = '%b %d, %Y'
+intersphinx_mapping = {
-#html_use_smartypants = True
+# HTML -----------------------------------------------------------------
-# Custom sidebar templates, maps document names to template names.
+html_theme = 'flask'
-        'searchbox.html'
+        'project.html',
-        'searchbox.html'
+        'versions.html',
-# -- Options for LaTeX output --------------------------------------------------
+# LaTeX ----------------------------------------------------------------
-  ('latexindex', 'Flask.tex', u'Flask Documentation', u'Armin Ronacher', 'manual'),
+    (master_doc, 'Flask.tex', 'Flask Documentation', 'Pallets Team', 'manual'),
-    'preamble': r'\usepackage{flaskstyle}'
+    'fontpkg': r'\usepackage{mathpazo}',
-
+# linkcheck ------------------------------------------------------------
-}
+linkcheck_anchors = False
-}
+# Local Extensions -----------------------------------------------------
-# unwrap decorators
+
-            return
+_internal_mark_re = re.compile(r'^\s*:internal:\s*$(?m)', re.M)
-    app.connect('autodoc-process-docstring', cut_module_meta)
+def skip_internal(app, what, name, obj, skip, options):
-        return [node], []
+def cut_module_meta(app, what, name, obj, options, lines):
-                'Could not import "{name}"."'.format(name=module_name)
+                'Could not import "{name}".'.format(name=module_name)
-    .. versionchanged:: 0.13
+    .. versionchanged:: 1.0
-def show_server_banner(env, debug, app_import_path):
+def show_server_banner(env, debug, app_import_path, eager_loading=True):
-        print(' * Serving Flask app "{0}"'.format(app_import_path))
+        message = ' * Serving Flask app "{0}"'.format(app_import_path)
-    show_server_banner(get_env(), debug, info.app_import_path)
+    show_server_banner(get_env(), debug, info.app_import_path, eager_loading)
-            error = 'User {} is already registered.'.format(username)
+            error = 'User {0} is already registered.'.format(username)
-        s = s.decode(kwargs.pop('encoding', None) or 'utf-8')
+        encoding = kwargs.pop('encoding', None)
-        request_charset = self.mimetype_params.get('charset')
+        data = _get_data(self, cache)
-                rv = json.loads(data)
+            rv = json.loads(data)
-            name = 'python -m ' + this_module
+        this_module = 'flask'
-        sys.argv = ['-m', this_module] + sys.argv[1:]
+        # Python rewrites "python -m flask" to the path to the file in argv.
-
+import codecs
-        s = s.decode(kwargs.pop('encoding', None) or 'utf-8')
+        encoding = kwargs.pop('encoding', None)
-        as the return value.
+        """Parse and return the data as JSON. If the mimetype does not
-        :param cache: Store the parsed JSON to return for subsequent calls.
+        :param silent: Silence parsing errors and return ``None``
-        charset = self.mimetype_params.get('charset')
+        data = self._get_data_for_json(cache=cache)
-            rv = json.loads(data, encoding=charset)
+            rv = json.loads(data)
-from werkzeug.http import http_date, parse_cache_control_header, \
+from werkzeug.http import (
-    _cached_json = Ellipsis
+    _cached_json = (Ellipsis, Ellipsis)
-            return self._cached_json
+        if cache and self._cached_json[silent] is not Ellipsis:
-            self._cached_json = rv
+                if cache:
-from sphinx.application import Sphinx
+import pkg_resources
-def setup(app: Sphinx):
+def setup(app):
-    return 'Hello World!'
+import os
-        tighter control over certain resources under testing environments.
+        """Called after the request is dispatched and the response is
-           current exception information.
+            Added the ``exc`` argument.
-        context.
+        """Called right before the application context is popped.
-        request context is pushed if necessary.
+        """Create an :class:`~flask.ctx.AppContext`. Use as a ``with``
-        Example usage::
+        An application context is automatically pushed by
-                ...
+                init_db()
-        doing exactly the same as this code::
+        """Create a :class:`~flask.ctx.RequestContext` representing a
-                ctx.pop()
+        See :doc:`/reqcontext`.
-           is now passed the ctx object.
+        Typically you should not call this from your own code. A request
-        function accepts the same arguments plus two additional).
+        """Create a :class:`~flask.ctx.RequestContext` for a WSGI
-        Additional arguments (only if ``base_url`` is not specified):
+        See :doc:`/reqcontext`.
-        """
+        Use a ``with`` block to push the context, which will make
-        reference to the class.  So instead of doing this::
+        """The actual WSGI application. This is not implemented in
-           error occurred or not.  See :ref:`callbacks-and-errors`.
+            Teardown events for the request and app contexts are called
-                               exception context to start the response
+        :param environ: A WSGI environment.
-        """Shortcut for :attr:`wsgi_app`."""
+        """The WSGI server calls the Flask application object as the
-    """A plain object."""
+    """A plain object. Used as a namespace for storing data during an
-this set up an application context with app.app_context().  See the
+to interface with the current application object in some way. To solve
-    """Creates a new test builder with some application defaults thrown in."""
+    """Create a :class:`~werkzeug.test.EnvironBuilder`, taking some
-    app = Flask(__name__)
+    app = Flask('flask_test', root_path=os.path.dirname(__file__))
-    assert called == ['conftest', 'TEARDOWN']
+    assert called == ['flask_test', 'TEARDOWN']
-import re
+        if url_prefix and url_prefix[-1] == '/':
-def test_blueprint_url_definitions(app, client):
+def test_blueprint_prefix_slash(app, client):
-       The `host_matching` and `static_host` parameters were added.
+    .. versionadded:: 1.0
-       implicitly enable it.
+       The ``subdomain_matching`` parameter was added. Subdomain
-                        with a ``static_folder`` configured.
+    :param static_host: the host to use when adding the static route.
-        so the request is passed explicitly.
+        """Creates a URL adapter for the given request. The URL adapter
-            return rv
+            # If subdomain matching is disabled (the default), use the
-        client = app.test_client()
+@pytest.mark.parametrize('matching', (False, True))
-            return 'matched without subdomain'
+    @app.route('/')
-            assert rv.data == b'matched without subdomain'
+    # ip address can't match name
-            return self.url_map.bind_to_environ(request.environ,
+            rv = self.url_map.bind_to_environ(request.environ,
-def test_test_app_proper_environ(app, client):
+def test_test_app_proper_environ():
-def test_subdomain_basic_support(app, client):
+def test_subdomain_basic_support():
-def test_subdomain_matching(app, client):
+def test_subdomain_matching():
-def test_subdomain_matching_with_ports(app, client):
+def test_subdomain_matching_with_ports():
-def test_blueprint_with_subdomain(app, client):
+def test_blueprint_with_subdomain():
-def test_subdomain(app, client):
+def test_subdomain():
-
+import click
-from flask.testing import make_test_environ_builder
+from flask.testing import make_test_environ_builder, FlaskCliRunner
-        :class:`werkzeug.test.EnvironBuilder` for more information, this
+        """Creates a :class:`~flask.ctx.RequestContext` from the given values
-    ~~~~~~~~~~~~~~
+Blueprint Example Tests
-    Tests the Blueprint example app
+:copyright: Â© 2010 by the Pallets team.
-    :copyright: (c) 2015 by Armin Ronacher.
+    :copyright: Â© 2010 by the Pallets team.
-    :copyright: (c) 2015 by Armin Ronacher.
+    :copyright: Â© 2010 by the Pallets team.
-    :copyright: (c) 2015 by Armin Ronacher.
+    :copyright: Â© 2010 by the Pallets team.
-    :copyright: (c) 2015 by Armin Ronacher.
+    :copyright: Â© 2010 by the Pallets team.
-    :copyright: (c) 2015 by Armin Ronacher.
+    :copyright: Â© 2010 by the Pallets team.
-    :copyright: (c) 2015 by Armin Ronacher.
+    :copyright: Â© 2010 by the Pallets team.
-    :copyright: (c) 2015 by Armin Ronacher.
+    :copyright: Â© 2010 by the Pallets team.
-    assert b"Hello World!" in rv.data
+    assert b"Hello World!" in rv.data
-    return 'Hello World!'
+    return 'Hello World!'
-    :copyright: (c) 2015 by Armin Ronacher.
+    :copyright: Â© 2010 by the Pallets team.
-    :copyright: (c) 2015 by Armin Ronacher.
+    :copyright: Â© 2010 by the Pallets team.
-    :copyright: (c) 2015 by Armin Ronacher.
+    :copyright: Â© 2010 by the Pallets team.
-    :copyright: (c) 2015 by Armin Ronacher.
+    :copyright: Â© 2010 by the Pallets team.
-    :copyright: (c) 2015 by Armin Ronacher.
+    :copyright: Â© 2010 by the Pallets team.
-    :copyright: (c) 2015 by Armin Ronacher.
+    :copyright: Â© 2010 by the Pallets team.
-    :copyright: (c) 2015 by Armin Ronacher.
+    :copyright: Â© 2010 by the Pallets team.
-    :copyright: (c) 2015 by Armin Ronacher.
+    :copyright: Â© 2010 by the Pallets team.
-    :copyright: (c) 2015 by Armin Ronacher.
+    :copyright: Â© 2010 by the Pallets team.
-    :copyright: (c) 2015 by Armin Ronacher.
+    :copyright: Â© 2010 by the Pallets team.
-    :copyright: (c) 2015 by Armin Ronacher.
+    :copyright: Â© 2010 by the Pallets team.
-    :copyright: (c) 2015 by Armin Ronacher.
+    :copyright: Â© 2010 by the Pallets team.
-    :copyright: (c) 2015 by Armin Ronacher.
+    :copyright: Â© 2010 by the Pallets team.
-    :copyright: (c) 2015 by Armin Ronacher.
+    :copyright: Â© 2010 by the Pallets team.
-    :copyright: (c) 2015 by Armin Ronacher.
+    :copyright: Â© 2010 by the Pallets team.
-    :copyright: (c) 2015 by Armin Ronacher.
+    :copyright: Â© 2010 by the Pallets team.
-    :copyright: (c) 2015 by Armin Ronacher.
+    :copyright: Â© 2010 by the Pallets team.
-    #: because the request was never internally bound. 
+    #: because the request was never internally bound.
-    :copyright: (c) 2015 by the Flask Team, see AUTHORS for more details.
+    :copyright: Â© 2010 by the Pallets team.
-    :copyright: (c) 2015 by Armin Ronacher.
+    :copyright: Â© 2010 by the Pallets team.
-    :copyright: (c) 2015 by Armin Ronacher.
+    :copyright: Â© 2010 by the Pallets team.
-    :copyright: (c) 2015 by Armin Ronacher.
+    :copyright: Â© 2010 by the Pallets team.
-    :copyright: (c) 2016 by the Flask Team, see AUTHORS for more details.
+    :copyright: Â© 2010 by the Pallets team.
-#
+
-    :copyright: (c) 2015 by the Flask Team, see AUTHORS for more details.
+    :copyright: Â© 2010 by the Pallets team.
-    :copyright: (c) 2015 by Armin Ronacher.
+    :copyright: Â© 2010 by the Pallets team.
-    :copyright: (c) 2015 by the Flask Team, see AUTHORS for more details.
+    :copyright: Â© 2010 by the Pallets team.
-    :copyright: (c) 2015 by Armin Ronacher.
+    :copyright: Â© 2010 by the Pallets team.
-    :copyright: (c) 2015 by Armin Ronacher.
+    :copyright: Â© 2010 by the Pallets team.
-    :copyright: (c) 2015 by Armin Ronacher.
+    :copyright: Â© 2010 by the Pallets team.
-    :copyright: (c) 2015 by Armin Ronacher.
+    :copyright: Â© 2010 by the Pallets team.
-    :copyright: (c) 2015 by Armin Ronacher.
+    :copyright: Â© 2010 by the Pallets team.
-    :copyright: (c) 2015 by Armin Ronacher.
+    :copyright: Â© 2010 by the Pallets team.
-    :copyright: (c) 2015 by Armin Ronacher.
+    :copyright: Â© 2010 by the Pallets team.
-import sys
+
-from subprocess import Popen, PIPE
+import sys
-_date_clean_re = re.compile(r'(\d+)(st|nd|rd|th)')
+_date_strip_re = re.compile(r'(?<=\d)(st|nd|rd|th)')
-            if lineiter.next().count('-') != len(match.group(0)):
+
-                change_info = lineiter.next().strip()
+                change_info = next(lineiter).strip()
-                              r'(?:, codename (.*))?(?i)', change_info)
+            match = re.search(
-        parts = map(int, version.split('.'))
+        parts = [int(i) for i in version.split('.')]
-    string = _date_clean_re.sub(r'\1', string)
+    string = _date_strip_re.sub('', string)
-                          inject_version, f.read())
+        contents = re.sub(
-    Popen([sys.executable, 'setup.py', 'release', 'sdist', 'bdist_wheel', 'upload']).wait()
+def build():
-    return set(Popen(['git', 'tag'], stdout=PIPE).communicate()[0].splitlines())
+    return set(
-    dev_version = bump_version(version) + '-dev'
+    dev_version = bump_version(version) + '.dev'
-         version, codename, release_date.strftime('%d/%m/%Y'))
+    info(
-             release_date.date(), date.today())
+        fail(
-    build_and_upload()
+    build()
-"""
+#!/usr/bin/env python
-_version_re = re.compile(r'__version__\s+=\s+(.*)')
+with io.open('README.rst', 'rt', encoding='utf8') as f:
-        f.read().decode('utf-8')).group(1)))
+with io.open('flask/__init__.py', 'rt', encoding='utf8') as f:
-    url='https://github.com/pallets/flask/',
+    url='https://www.palletsprojects.com/p/flask/',
-    long_description=__doc__,
+    description='A simple framework for building complex web applications.',
-            rv = rv.make_conditional(request)
+        try:
-        'click>=4.0',
+        'Werkzeug>=0.14',
-        'Development Status :: 4 - Beta',
+        'Development Status :: 5 - Production/Stable',
-        'Topic :: Software Development :: Libraries :: Python Modules'
+        'Topic :: Internet :: WWW/HTTP :: WSGI :: Application',
-    '''
+    entry_points={
-                if not _called_with_wrong_args(app_factory, sys.exc_info()):
+                if not _called_with_wrong_args(app_factory):
-            if not _called_with_wrong_args(attr, sys.exc_info()):
+            if not _called_with_wrong_args(attr):
-    with open('CHANGES') as f:
+    with open('CHANGES.rst') as f:
-environment variable.
+file. Setting the FLASK_ENV environment variable to 'development' will enable
-  {prefix}{cmd} FLASK_DEBUG=1
+  {prefix}{cmd} FLASK_ENV=development
-        the ``SESSION_COOKIE_SAMESITE`` setting.
+        """Return ``'Strict'`` or ``'Lax'`` if the cookie should use the
-        SESSION_COOKIE_SAMESITE='Strict',
+        SESSION_COOKIE_SAMESITE='Lax',
-    #Â assert excption when samesite is not set to 'Strict', 'Lax' or None
+    app.config.update(SESSION_COOKIE_SAMESITE='invalid')
-        rv = client.get('/', 'http://www.example.com:8080/test/')
+        client.get('/')
-    rv = client.get('/', 'http://www.example.com:8080/test/')
+    rv = client.get('/')
-    rv = client.get('/', 'http://www.example.com:8080/test/')
+    rv = client.get('/')
-    rv = client.get('/', 'http://www.example.com:8080/test/')
+    rv = client.get('/')
-from ._compat import getargspec, iteritems, reraise
+from ._compat import getargspec, iteritems, reraise, text_type
-              help='Enable or disable the reloader.  By default the reloader '
+              help='Enable or disable the reloader. By default the reloader '
-              help='Enable or disable the debugger.  By default the debugger '
+              help='Enable or disable the debugger. By default the debugger '
-              help='Enable or disable eager loading.  By default eager '
+              help='Enable or disable eager loading. By default eager '
-                with_threads):
+                with_threads, cert):
-               threaded=with_threads)
+               threaded=with_threads, ssl_context=cert)
-    find_best_app, get_version, load_dotenv, locate_app, prepare_import,
+    AppGroup, FlaskGroup, NoAppException, ScriptInfo, dotenv, find_best_app,
-            secure=secure
+            secure=secure,
-    #: `production`.
+    #: What environment the app is running in. Flask and extensions may
-        self._set_debug_value(value)
+        self.config['DEBUG'] = value
-    #: detected.
+    #: Whether debug mode is enabled. When using ``flask run`` to start
-    #: otherwise.
+    #: **Do not enable debug mode when deploying in production.**
-    return val
+    """Get the environment the app is running in, indicated by the
-        return False
+        return get_env() == 'development'
-import pytest
+import sys
-    find_best_app, get_version, load_dotenv, locate_app, prepare_import, \
+from flask.cli import (
-           The default port is now picked from the ``SERVER_NAME`` variable.
+            If set, the :envvar:`FLASK_ENV` and :envvar:`FLASK_DEBUG`
-        # command line.  Have a look at cli.py for more information.
+        # command line. Have a look at cli.py for more information.
-            load_dotenv()
+            cli.load_dotenv()
-    """Runs a local development server for the Flask application.
+    """Run a local development server.
-    multithreading.
+    This server is for development purposes only. It does not provide
-    Flask is enabled and disabled otherwise.
+    The reloader and debugger are enabled by default if
-
+
-        reload = bool(debug)
+        reload = debug
-        debugger = bool(debug)
+        debugger = debug
-               use_debugger=debugger, threaded=with_threads)
+    from werkzeug.serving import run_simple
-    _endpoint_from_view_func, find_package, get_debug_flag, \
+    _endpoint_from_view_func, find_package, get_env, get_debug_flag, \
-        'DEBUG':                                get_debug_flag(default=False),
+        'ENV':                                  None,
-        return self.config_class(root_path, self.default_config)
+        defaults = dict(self.default_config)
-        self.debug = debug
+    #: The environment value.  This is typically set from outside the
-    ):
+    def run(self, host=None, port=None, debug=None,
-            self._reconfigure_for_run_debug(bool(debug))
+            self.debug = bool(debug)
-        server_name = self.config.get("SERVER_NAME")
+        server_name = self.config.get('SERVER_NAME')
-    def add_url_rule(self, rule, endpoint=None, view_func=None, provide_automatic_options=None, **options):
+    def add_url_rule(self, rule, endpoint=None, view_func=None,
-from .helpers import get_debug_flag
+from .helpers import get_debug_flag, get_env
-                    )
+                    app = locate_app(self, import_name, None,
-            app._reconfigure_for_run_debug(debug)
+            app.debug = debug
-    ):
+    def __init__(self, add_default_commands=True, create_app=None,
-    banner = 'Python %s on %s\nApp: %s%s\nInstance: %s' % (
+    banner = 'Python %s on %s\nApp: %s [%s]\nInstance: %s' % (
-        app.debug and ' [debug]' or '',
+        app.env,
-def get_debug_flag(default=None):
+def get_env():
-        return default
+        env = get_env()
-from flask.helpers import get_debug_flag
+from flask.helpers import get_debug_flag, get_env
-        ('', None, True),
+        ('', False, False),
-        assert get_debug_flag(default=True) == expected_default_flag
+        assert get_debug_flag() == expected_default_flag
-
+from werkzeug.urls import url_quote
-
+from werkzeug.wsgi import wrap_file
-    from urlparse import urlsplit as url_parse
+from werkzeug.urls import url_parse
-
+from ._compat import string_types, text_type, PY2
-    db_fd, temp_db_location = tempfile.mkstemp()
+def app():
-        'DATABASE': temp_db_location,
+        'DATABASE': db_path,
-
+    os.close(db_fd)
-    return client
+@pytest.fixture
-            if silent and e.errno in (errno.ENOENT, errno.EISDIR):
+            if silent and e.errno in (
-    """
+class SessionMixin(MutableMapping):
-    def _get_permanent(self):
+    @property
-    def _set_permanent(self, value):
+    @permanent.setter
-    #: implementation just hardcodes ``False`` in.
+    #: Some implementations can detect whether a session is newly
-    #: The default mixin implementation just hardcodes ``True`` in.
+    #: Some implementations can detect changes to the session and set
-    #: from being served the same cache.
+    #: Some implementations can detect when session data is read or
-    """Base class for sessions based on signed cookies."""
+    """Base class for sessions based on signed cookies.
-        self.accessed = False
+        assert not flask.session.accessed
-        return flask.session['value']
+        assert not flask.session.accessed
-        (dumps(data, indent=indent, separators=separators), '\n'),
+        dumps(data, indent=indent, separators=separators) + '\n',
-def reset_logging(monkeypatch):
+def reset_logging(pytestconfig):
-    logging.root.handlers = []
+    logging_plugin = pytestconfig.pluginmanager.unregister(
-        pytest.config.pluginmanager.register(logging_plugin, 'logging-plugin')
+        pytestconfig.pluginmanager.register(logging_plugin, 'logging-plugin')
-    pytest.config.pluginmanager.register(logging_plugin, 'logging-plugin')
+    if logging_plugin:
-                file.close()
+                if file is not None:
-        reason="not implement within werkzeug"
+        reason="not implemented within werkzeug"
-        str(exc_value).startswith('%s() takes' % factory.__name__)
+        str(exc_value).startswith((
-@click.option('--with-threads/--without-threads', default=False,
+@click.option('--with-threads/--without-threads', default=True,
-    without having to manually configuring the application.
+    without having to manually configure the application.
-                              is_flag=True, is_eager=True)
+
-The most useful commands are the "run" and "shell" command.
+A general utility script for Flask applications.
-Example usage:
+Provides commands from Flask, extensions, and the application. Loads the
-})
+  {prefix}{cmd} FLASK_APP=hello.py
-            ' one.'.format(module=module.__name__)
+            'Detected multiple Flask applications in module "{module}". Use '
-                app = call_factory(app_factory, script_info)
+                app = call_factory(script_info, app_factory)
-                        function=attr_name, module=module.__name__
+                    'Detected factory "{factory}" in module "{module}", but '
-        'middleware.'.format(module=module.__name__)
+        'Failed to find Flask application or factory in module "{module}". '
-def call_factory(app_factory, script_info, arguments=()):
+def call_factory(script_info, app_factory, arguments=()):
-        name, args = match.groups()
+def find_app_by_string(script_info, module, app_name):
-                                   '"{name}"'.format(name=module))
+            app = call_factory(script_info, attr, args)
-            reraise(NoAppException, new_error, sys.exc_info()[2])
+            raise NoAppException(
-            'or function expression.'.format(string=string))
+        app = attr
-        return find_app_by_string(app_name, script_info, module)
+        return find_app_by_string(script_info, module, app_name)
-            app = call_factory(self.create_app, self)
+            app = call_factory(self, self.create_app)
-    ('cliapp.factory', 'create_app ()'),
+        if view_func:
-    # are always in sync with the session object, which is not true for session
+    # always in sync with the session object, which is not true for session
-@pytest.yield_fixture(autouse=True)
+@pytest.fixture(autouse=True)
-     * Running on http://localhost:5000/
+    * Running on http://localhost:5000/
- Ready for production? `Read this first <http://flask.pocoo.org/docs/deploying/>`.
+Ready for production? `Read this first <http://flask.pocoo.org/docs/deploying/>`.
-    'blinker': ('https://pythonhosted.org/blinker/', None)
+    'blinker': ('https://pythonhosted.org/blinker/', None),
-    BadRequestKeyError
+from werkzeug.datastructures import Headers, ImmutableDict
-    @property
+    @locked_cached_property
-        Here some examples::
+        """The ``'flask.app'`` logger, a standard Python
-            app.logger.error('An error occurred')
+        If there are no handlers configured, a default handler will be added.
-            return rv
+        return create_logger(self)
-
+import logging
-)
+from .globals import request
-    to sys.stderr.
+def wsgi_errors_stream():
-    return sys.stderr
+    return request.environ['wsgi.errors'] if request else sys.stderr
-        return True
+#: Log messages to :func:`~flask.logging.wsgi_errors_stream` with the format
-    logger with the log name before.
+    """Get the ``'flask.app'`` logger and configure it if needed.
-    logger.propagate = False
+    logger = logging.getLogger('flask.app')
-    app.config['LOGGER_HANDLER_POLICY'] = 'never'
+def test_error_handler_after_processor_error(app, client):
-
+import datetime
-from logging import StreamHandler
+import pytest
-from werkzeug.http import http_date
+from werkzeug.http import http_date, parse_cache_control_header, \
-from flask.helpers import get_debug_flag, make_response
+from flask.helpers import get_debug_flag
-
+class TestUrlFor(object):
-        1 // 0
+        raise Exception('test')
-    rv = app.test_client().get('/')
+    rv = app.test_client().get('/', errors_stream=out)
-    assert err == ''
+    assert not out.getvalue()
-def test_template_loader_debugging(test_apps):
+def test_template_loader_debugging(test_apps, monkeypatch):
-            app.config['EXPLAIN_TEMPLATE_LOADING'] = old_load_setting
+        monkeypatch.setitem(app.config, 'EXPLAIN_TEMPLATE_LOADING', True)
-            url_scheme = url.scheme or app.config['PREFERRED_URL_SCHEME']
+            url_scheme = app.config['PREFERRED_URL_SCHEME']
-            url_scheme, url.netloc or http_host, app_root.lstrip('/')
+        url = url_parse(path)
-            url_scheme = app.config['PREFERRED_URL_SCHEME']
+            url_scheme = url.scheme or app.config['PREFERRED_URL_SCHEME']
-    def run(self, host=None, port=None, debug=None, **options):
+    def run(
-        if os.environ.get('FLASK_RUN_FROM_CLI_SERVER') == '1':
+        if os.environ.get('FLASK_RUN_FROM_CLI') == 'true':
-from ._compat import iteritems, reraise
+from ._compat import getargspec, iteritems, reraise
-from ._compat import getargspec
+
-                                 shell commands wil be added.
+        shell commands wil be added.
-                       and returns the loaded app.
+    :param create_app: an optional callback that is passed the script info and
-                 add_version_option=True, **extra):
+    def __init__(
-        return AppGroup.main(self, *args, **kwargs)
+        return super(FlaskGroup, self).main(*args, **kwargs)
-
+        'dotenv': ['python-dotenv'],
-    find_best_app, get_version, locate_app, prepare_import, with_appcontext
+from flask.cli import AppGroup, FlaskGroup, NoAppException, ScriptInfo, dotenv, \
-
+
-                raise RuntimeError('Failed to find application in module '
+                raise NoAppException('Failed to find application in module '
-def prepare_exec_for_file(filename):
+def prepare_import(path):
-    module = []
+    path = os.path.realpath(path)
-        if not os.path.isfile(os.path.join(dirpath, '__init__.py')):
+    if os.path.splitext(path)[1] == '.py':
-        sys.path.insert(0, dirpath)
+    if sys.path[0] != path:
-    return '.'.join(module[::-1])
+    return '.'.join(module_name[::-1])
-def locate_app(script_info, app_id, raise_if_not_found=True):
+def locate_app(script_info, module_name, app_name, raise_if_not_found=True):
-        __import__(module)
+        __import__(module_name)
-                )
+                'While importing "{name}", an ImportError was raised:'
-                    module=module)
+                'Could not import "{name}"."'.format(name=module_name)
-    mod = sys.modules[module]
+    module = sys.modules[module_name]
-        return find_best_app(script_info, mod)
+    if app_name is None:
-    return app
+        return find_app_by_string(app_name, script_info, module)
-        self.app_import_path = app_import_path
+        self.app_import_path = app_import_path or os.environ.get('FLASK_APP')
-            rv = call_factory(self.create_app, self)
+            app = call_factory(self.create_app, self)
-                rv = locate_app(self, self.app_import_path)
+                path, name = (self.app_import_path.split(':', 1) + [None])[:2]
-                        self, import_path, raise_if_not_found=False
+                for path in ('wsgi.py', 'app.py'):
-                    if rv:
+                    if app:
-                )
+        if not app:
-            rv._reconfigure_for_run_debug(debug)
+            app._reconfigure_for_run_debug(debug)
-        return rv
+        self._loaded_app = app
-    return Flask('create_app')
+    return Flask('app')
-    return Flask("_".join(['create_app2', foo, bar]))
+    return Flask('_'.join(['app2', foo, bar]))
-    return Flask("_".join(['create_app3', foo, bar]))
+def create_app3(foo, script_info):
-from __future__ import absolute_import, print_function
+from __future__ import absolute_import
-    find_default_import_path, get_version
+from flask import Flask, current_app
-    the parent directory of given file is added to `sys.path`.
+cwd = os.getcwd()
-    assert dirname in sys.path
+    original_path = sys.path[:]
-        prepare_exec_for_file('/tmp/share/test.txt')
+        locate_app(info, iname, aname)
-    assert find_default_import_path() == expect_rv
+def test_locate_app_suppress_raise():
-                           follow_redirects=follow_redirects)
+        if (
-        is registered, it will handle the exception and the teardown will not
+        it will be passed an error object. If an :meth:`errorhandler` is
-def test_app_tearing_down_with_handled_exception_by_app_handler(app):
+def test_app_tearing_down_with_handled_exception_by_app_handler(app, client):
-        test_client.get('/')
+        client.get('/')
-def test_app_tearing_down_with_unhandled_exception(app):
+def test_app_tearing_down_with_unhandled_exception(app, client):
-            test_client.get('/')
+            client.get('/')
-        be passed an error object.
+        When a teardown function was called because of an unhandled exception
-def test_app_tearing_down_with_handled_exception(app):
+def test_app_tearing_down_with_handled_exception_by_except_block(app):
-        SECRET_KEY='development key',
+        SECRET_KEY=b'_5#y2L"F4Q8z\n\xec]/',
-SECRET_KEY = 'development key'
+SECRET_KEY = b'_5#y2L"F4Q8z\n\xec]/'
-    #: sign cookies and other things.  Set this to a complex random value
+    #: sign cookies and other things. Set this to a complex random value
-    #: ``SECRET_KEY`` configuration key.  Defaults to ``None``.
+    #: :data:`SECRET_KEY` configuration key. Defaults to ``None``.
-        return super(Flask, self).make_response(rv)
+    secret_key = 'test key'
-    app = flask.Flask(__name__)
+def test_missing_session(app):
-SECRET_KEY = 'devkey'
+SECRET_KEY = 'config'
-    assert app.secret_key == 'devkey'
+    assert app.secret_key == 'config'
-        'SECRET_KEY': 'devkey',
+        'SECRET_KEY': 'config',
-        ('SECRET_KEY', 'devkey'),
+        ('SECRET_KEY', 'config'),
-        SECRET_KEY='devkey',
+        SECRET_KEY='config',
-        SECRET_KEY = 'devkey'
+        SECRET_KEY = 'config'
-
+def test_flash_signal(app):
-                ' ensure the extension is .py.'.format(module=module)
+                'The file/path provided ({module}) does not appear to exist.'
-    packages=['flask', 'flask.ext', 'flask.json'],
+    packages=['flask', 'flask.json'],
-        next.tb_frame.f_code.co_filename
+
-                           'executed when application context is available.')
+        raise RuntimeError(
-            elif endpoint.startswith('.'):
+
-                               'the SERVER_NAME config variable.')
+            raise RuntimeError(
-            static_url_path = static_path
+    def __init__(
-                             'absolute.  A relative path was given instead.')
+            raise ValueError(
-                              view_func=self.send_static_file)
+            self.add_url_rule(
-        self.error_handler_spec = {None: self._error_handlers}
+        self.error_handler_spec = {}
-
+
-                                 ' the app (%s):\n%s' % (module, stack_trace))
+            raise NoAppException(
-                                 'ensure the extension is .py' % module)
+            raise NoAppException(
-                                    raise_if_not_found=False)
+                    rv = locate_app(
-                    'http://flask.pocoo.org/docs/latest/quickstart/')
+                    'http://flask.pocoo.org/docs/latest/quickstart/'
-                      raise_if_not_found=False) is None
+    assert locate_app(
-        NoAppException, obj.load_app)
+    pytest.raises(NoAppException, obj.load_app)
-        os.path.join(os.path.dirname(__file__), 'test_apps', 'helloworld')))
+    monkeypatch.chdir(os.path.abspath(os.path.join(
-        os.path.join(os.path.dirname(__file__), 'test_apps', 'cliapp')))
+    monkeypatch.chdir(os.path.abspath(os.path.join(
-    sys.path.insert(0, dirpath)
+    if sys.path[0] != dirpath:
-def locate_app(script_info, app_id):
+def locate_app(script_info, app_id, raise_if_not_found=True):
-        else:
+                                 ' the app (%s):\n%s' % (module, stack_trace))
-            if not self.app_import_path:
+            if self.app_import_path:
-                    'information see '
+                    'the FLASK_APP environment variable, and a wsgi.py or '
-
+from flask import Flask
-def test_scriptinfo(test_apps):
+def test_scriptinfo(test_apps, monkeypatch):
-        tzinfo = datetime.timezone(datetime.timedelta(hours=tz[1]), name=tz[0])
+        tzinfo = FixedOffset(hours=tz[1], name=tz[0])
-        gmt = datetime.timezone(datetime.timedelta(), name='GMT')
+        gmt = FixedOffset(hours=0, name='GMT')
-    def test_jsonify_aware_datetimes(self, tzname):
+    @pytest.mark.parametrize('tz', (('UTC', 0), ('PST', -8), ('KST', 9)))
-        assert flask.json.JSONEncoder().encode(dt_aware) == expected
+        tzinfo = datetime.timezone(datetime.timedelta(hours=tz[1]), name=tz[0])
-from pytz import timezone
+try:
-    def test_jsonify_aware_datetimes(self, tz):
+    @pytest.mark.parametrize('tzname', ('UTC', 'PST8PDT', 'Asia/Seoul'))
-        assert flask.json.JSONEncoder().encode(dt) == expected
+        dt_naive = datetime.datetime(2017, 1, 1, 12, 34, 56)
-    def test_jsonify_aware_datetimes(self, tzname):
+    @pytest.mark.parametrize('tz', (('UTC', 0), ('PST', -8), ('KST', 9)))
-        assert flask.json.JSONEncoder().encode(dt_aware) == expected
+        tzinfo = datetime.timezone(datetime.timedelta(hours=tz[1]), name=tz[0])
-from datetime import date
+from datetime import date, datetime
-    # Mocks werkzeug.serving.run_simple method
+def test_templates_auto_reload_debug_run(app, monkeypatch):
-    assert app.jinja_env.auto_reload is False
+    app.run()
-    assert app.jinja_env.auto_reload is True
+    assert app.templates_auto_reload == True
-                options['auto_reload'] = self.debug
+            options['auto_reload'] = self.templates_auto_reload
-        from werkzeug.serving import run_simple
+        if debug is not None:
-            self.jinja_env.auto_reload = True
+
-            rv.debug = debug
+            rv._reconfigure_for_run_debug(debug)
-    ):
+    def register_blueprint(self, blueprint, **options):
-        """Registers a blueprint on the application.
+    def register_blueprint(
-                (blueprint, self.blueprints[blueprint.name], blueprint.name)
+            assert self.blueprints[blueprint.name] is blueprint, (
-        method in the `options` dictionary.
+        """Called by :meth:`Flask.register_blueprint` to register all views
-                               endpoint='static')
+            state.add_url_rule(
-                          given value. Defaults to False.
+                          value. Defaults to False.
-       
+
-        
+
-
+
-    ''')
+
-    static_url_path = property(_get_static_url_path, _set_static_url_path)
+
-        """Find a registered error handler for a request in this order:
+        """Return a registered error handler for an exception in this order:
-        and returns None if a suitable handler is not found.
+        blueprint handler for an exception class, app handler for an exception
-        def find_handler(handler_map):
+        for name, c in (
-                return
+                continue
-
+def test_errorhandler_precedence(app, client):
-    packages=['flask', 'flask.ext'],
+    packages=['flask', 'flask.ext', 'flask.json'],
-from ._compat import iteritems, reraise, PY2
+from ._compat import iteritems, reraise
-from ._compat import iteritems, reraise
+from ._compat import iteritems, reraise, PY2
-            name = 'python -m ' + this_module
+        this_module = 'flask'
-        sys.argv = ['-m', this_module] + sys.argv[1:]
+        # Python rewrites "python -m flask" to the path to the file in argv.
-    app, path='/', base_url=None, subdomain=None, url_scheme=None, json=None,
+    app, path='/', base_url=None, subdomain=None, url_scheme=None,
-            raise ValueError('Client cannot provide both `json` and `data`')
+        assert 'data' not in kwargs, (
-        kwargs['data'] = json_dumps(kwargs.pop('json'))
+        # push a context so flask.json can use app's json attributes
-        # Only set Content-Type when not explicitly provided
+from warnings import warn
-from werkzeug.wrappers import Request as RequestBase, Response as ResponseBase
+from werkzeug.wrappers import Request as RequestBase, Response as ResponseBase
-from .globals import _app_ctx_stack
+from flask import json
-    .. versionadded:: 0.12
+    .. versionadded:: 1.0
-        default it is considered to include JSON data if the mimetype is
+        """Check if the mimetype indicates JSON data, either
-        .. versionadded:: 1.0
+        .. versionadded:: 0.11
-        return False
+        return (
-        contain the parsed JSON data.  Otherwise it will be ``None``.
+        """This will contain the parsed JSON data if the mimetype indicates
-        The :meth:`get_json` method should be used instead.
+        .. deprecated:: 1.0
-            'json is deprecated.  Use get_json() instead.'), stacklevel=2)
+            "'json' is deprecated. Use 'get_json()' instead."
-        return self.data
+        return self.get_data(cache=cache)
-                      on the object.
+        """Parse and return the data as JSON. If the mimetype does not indicate
-            pass
+        if cache and self._cached_json is not Ellipsis:
-        # been encoded correctly as well.
+        # We accept MIME charset against the specification as certain clients
-                rv = json.loads(data)
+            data = self._get_data_for_json(cache=cache)
-        default implementation just raises a :class:`BadRequest` exception.
+        """Called if :meth:`get_json` parsing fails and isn't silenced. If
-           add it by subclassing.
+           Raise a :exc:`BadRequest` error instead of returning an error
-        if ctx is not None and ctx.app.debug:
+        if current_app is not None and current_app.debug:
-            return ctx.app.config['MAX_CONTENT_LENGTH']
+        if current_app:
-           self.mimetype != 'multipart/form-data' and not self.files:
+        if (
-        return jsonify(flask.request.json)
+        return jsonify(flask.request.get_json())
-
+        # Open the session at the moment that the request context is available.
-            self.session = session_interface.make_null_session(self.app)
+            session_interface = self.app.session_interface
-        parsed JSON data.  Otherwise this will be ``None``.
+        """If the request has a JSON mimetype like :mimetype:`application/json`
-        """Indicates if this request is JSON or not.  By default a request
+        """Indicates if this request is JSON or not. By default a request
-        will be invoked.
+        """Parses the incoming JSON request data and returns it. By default
-                       and return ``None``.
+            and return ``None``.
-                      on the request.
+            on the request.
-        return pickle.dumps(dict(flask.session))
+        flask.session['t'] = (1, 2, 3)
-    assert rv['notadict'] == {' di': 'not-a-dict'}
+    with client:
-        """If the mimetype is :mimetype:`application/json` this will contain the
+        """If self.is_json would return true, this will contain the
-        invoked.
+        this function will return ``None`` if self.is_json would return false,
-    __slots__ = ('serializer',)
+    __slots__ = ()
-    __slots__ = ('serializer',)
+    __slots__ = ()
-    __slots__ = ('serializer',)
+    __slots__ = ()
-    __slots__ = ('serializer',)
+    __slots__ = ()
-    __slots__ = ('serializer',)
+    __slots__ = ()
-    __slots__ = ('serializer',)
+    __slots__ = ()
-    __slots__ = ('serializer',)
+    __slots__ = ()
-    __slots__ = ('serializer',)
+    __slots__ = ()
-    """Serialize anything matching the :class:`~markupsafe.Markup` API by
+    """Serialize anything matching the :class:`~flask.Markup` API by
-    deserializes to an instance of :class:`~markupsafe.Markup`."""
+    deserializes to an instance of :class:`~flask.Markup`."""
-    :class:`itsdangerous.Serializer`."""
+    :class:`itsdangerous.Serializer`.
-    __slots__ = ()
+    """Base class for defining type tags for :class:`TaggedJSONSerializer`."""
-    def to_json(self, serializer, value):
+    def to_json(self, value):
-    def to_python(self, serializer, value):
+    def to_python(self, value):
-        return {self.key: self.to_json(serializer, value)}
+    def tag(self, value):
-    key = ' di'
+    """Tag for 1-item dicts whose only key matches a registered tag.
-        return isinstance(value, dict)
+    Internally, the dict key is suffixed with `__`, and the suffix is removed
-            return {key + '__': serializer._tag(value[key])}
+    __slots__ = ('serializer',)
-        return dict((k, serializer._tag(v)) for k, v in iteritems(value))
+    def to_json(self, value):
-    def to_python(self, serializer, value):
+    def to_python(self, value):
-                return {self.key: self.to_json(serializer, value, key=key)}
+class PassDict(JSONTag):
-        return self.to_json(serializer, value)
+    tag = to_json
-    __slots__ = ()
+    __slots__ = ('serializer',)
-    def check(self, serializer, value):
+    def check(self, value):
-        return [serializer._tag(item) for item in value]
+    def to_json(self, value):
-    def to_python(self, serializer, value):
+    def to_python(self, value):
-    __slots__ = ()
+    __slots__ = ('serializer',)
-    def check(self, serializer, value):
+    def check(self, value):
-        return [serializer._tag(item) for item in value]
+    def to_json(self, value):
-    __slots__ = ()
+    __slots__ = ('serializer',)
-    def check(self, serializer, value):
+    def check(self, value):
-    def to_json(self, serializer, value):
+    def to_json(self, value):
-    def to_python(self, serializer, value):
+    def to_python(self, value):
-    __slots__ = ()
+    """Serialize anything matching the :class:`~markupsafe.Markup` API by
-    def check(self, serializer, value):
+    def check(self, value):
-    def to_json(self, serializer, value):
+    def to_json(self, value):
-    def to_python(self, serializer, value):
+    def to_python(self, value):
-    __slots__ = ()
+    __slots__ = ('serializer',)
-    def check(self, serializer, value):
+    def check(self, value):
-    def to_json(self, serializer, value):
+    def to_json(self, value):
-    def to_python(self, serializer, value):
+    def to_python(self, value):
-    __slots__ = ()
+    __slots__ = ('serializer',)
-    def check(self, serializer, value):
+    def check(self, value):
-    def to_json(self, serializer, value):
+    def to_json(self, value):
-    def to_python(self, serializer, value):
+    def to_python(self, value):
-        TagDateTime(),
+    """Serializer that uses a tag system to compactly represent objects that
-        self._order = []
+        self.tags = {}
-            self.register(tag)
+        for cls in self.default_tags:
-    def register(self, tag, force=False, index=-1):
+    def register(self, tag_class, force=False, index=-1):
-            if not force and key in self._tags:
+            if not force and key in self.tags:
-            self._tags[key] = tag
+            self.tags[key] = tag
-            self._order.append(tag)
+            self.order.append(tag)
-            self._order.insert(index, tag)
+            self.order.insert(index, tag)
-                return tag.tag(self, value)
+    def tag(self, value):
-    def _untag(self, value):
+    def untag(self, value):
-        if key not in self._tags:
+        if key not in self.tags:
-        return self._tags[key].to_python(self, value[key])
+        return self.tags[key].to_python(value[key])
-        return dumps(self._tag(value), separators=(',', ':'))
+        """Tag the value and dump it to a compact JSON string."""
-        return loads(value, object_hook=self._untag)
+        """Load data from a JSON string and deserialized any tagged objects."""
-from ._compat import text_type, PY2
+from flask.globals import current_app, request
-from .helpers import is_ip, total_seconds
+from flask.helpers import is_ip, total_seconds
-        
+
-        
+
-        
+
-        """A decorator that is used to register a function given an
+        """Register a function to handle errors by code or exception class.
-
+    @setupmethod
-                .format(code_or_exception))
+                'Tried to register a handler for an exception instance {0!r}.'
-        exc_class, code = self._get_exc_class_and_code(code_or_exception)
+        try:
-        
+
-        
+
-        
+
-        
+
-                
+
-                
+
-    
+
-            
+
-                
+
-        
+
-            self.debug or self.config['TRAP_BAD_REQUEST_ERRORS']
+            (self.debug or self.config['TRAP_BAD_REQUEST_ERRORS'])
-        # description for key errors in debug mode.
+        # description for key errors in debug mode or when trapping errors.
-            self.debug
+            self.debug or self.config['TRAP_BAD_REQUEST_ERRORS']
-    assert client.get('/fail').status_code == 400
+    rv = client.get('/fail')
-    InternalServerError, MethodNotAllowed, default_exceptions
+    InternalServerError, MethodNotAllowed, default_exceptions, \
-        'TRAP_BAD_REQUEST_ERRORS':              False,
+        'TRAP_BAD_REQUEST_ERRORS':              None,
-        if self.config['TRAP_BAD_REQUEST_ERRORS']:
+
-
+        # MultiDict passes the key to the exception, but that's ignored
-            self.save_session(ctx.session, response)
+            self.session_interface.save_session(self, ctx.session, response)
-        self.session = self.app.open_session(self.request)
+        session_interface = self.app.session_interface
-            self.session = self.app.make_null_session()
+            self.session = session_interface.make_null_session(self.app)
-            sess = app.open_session(c.request)
+            session_interface = app.session_interface
-                app.save_session(sess, resp)
+            if not session_interface.is_null_session(sess):
-            patch_vary_header(response, 'Cookie')
+            response.vary.add('Cookie')
-
+import pickle
-import pickle
+import uuid
-from werkzeug.exceptions import BadRequest, NotFound, Forbidden
+
-import werkzeug.serving
+
-        response.headers['Vary'] = 'Cookie'
+        response.vary.add('Cookie')
-        response.headers['Vary'] = 'Accept-Encoding, Accept-Language'
+        response.vary.update(('Accept-Encoding', 'Accept-Language'))
-        'APPLICATION_ROOT':                     None,
+        'APPLICATION_ROOT':                     '/',
-                script_name=self.config['APPLICATION_ROOT'] or '/',
+                script_name=self.config['APPLICATION_ROOT'],
-               app.config['APPLICATION_ROOT'] or '/'
+        return app.config['SESSION_COOKIE_PATH'] \
-        app_root = app.config.get('APPLICATION_ROOT') or '/'
+        app_root = app.config['APPLICATION_ROOT']
-            url_scheme = app.config.get('PREFERRED_URL_SCHEME') or 'http'
+            url_scheme = app.config['PREFERRED_URL_SCHEME']
-
+    extras_require={
-    arg_names = getargspec(app_factory).args
+    args_spec = getargspec(app_factory)
-    elif not arguments and len(arg_names) == 1:
+    elif not arguments and len(arg_names) == 1 and arg_defaults is None:
-    app = Flask(__name__.split('.')[0])
+    app = Flask('flaskr')
-app = Flask(__name__)
+app = Flask('minitwit')
-app = Flask(__name__)
+app = Flask('yourapplication')
-import yourapplication.views
+import yourapplication.views
-    app = Flask(__name__)
+    app = Flask(__name__.split('.')[0])
-            g.sqlite_db.close()
+            g.sqlite_db.close()
-    arguments. If it is a """
+    """Checks if the given string is a variable name or a function. If it is
-
+html_theme_options = {
-    and returns the result.
+def call_factory(app_factory, script_info, arguments=()):
-        app = app_factory(*arguments, script_info=script_info)
+    arg_names = getargspec(app_factory).args
-        app = app_factory(script_info)
+        return app_factory(*arguments)
-    return app
+        raise NoAppException(
-        app = find_best_app(script_info, mod)
+        return find_best_app(script_info, mod)
-    return app
+        return find_app_by_string(app_obj, script_info, mod)
-import uuid
+import uuid
-from base64 import b64encode, b64decode
+from base64 import b64decode, b64encode
-from werkzeug.http import http_date, parse_date
+
-from itsdangerous import URLSafeTimedSerializer, BadSignature
+from .helpers import is_ip, total_seconds
-            self._patch_vary_cookie_header(response)
+            patch_vary_header(response, 'Cookie')
-        response.headers['Vary'] = updated_header
+def call_factory_from_regex(match, mod, script_info):
-                    app = app_factory()
+                app = call_factory_from_regex(match, mod, script_info)
-    # Search for app factory callables.
+    # Search for app factory functions.
-        if callable(app_factory):
+        if inspect.isfunction(app_factory):
-                    'Auto-detected "{callable}()" in module "{module}", but '
+                    'Auto-detected "{function}()" in module "{module}", but '
-                        callable=attr_name, module=module.__name__
+                        function=attr_name, module=module.__name__
-        app = getattr(mod, app_obj, None)
+        function_regex = r'^([\w_][\w_\d]*)\((.*)\)$'
-                               % module)
+            raise RuntimeError('Failed to find application in module '
-                  script_info, "cliapp.importerrorapp")
+    pytest.raises(
-            response.headers.add('Vary', 'Cookie')
+            self._patch_vary_cookie_header(response)
-    def expect(path, header=True):
+    def expect(path, header_value='Cookie'):
-            assert rv.headers['Vary'] == 'Cookie'
+        if header_value:
-    expect('/no-vary-header', False)
+    expect('/vary-cookie-header-set')
-def test_trapping_of_bad_request_key_errors(app):
+def test_trapping_of_bad_request_key_errors(app, client):
-    assert c.get('/fail').status_code == 400
+    assert client.get('/fail').status_code == 400
-        c.get("/fail")
+        client.get("/fail")
-    with client as c:
+    with client:
-            c.post('/fail', data={'foo': 'index.txt'})
+            client.post('/fail', data={'foo': 'index.txt'})
-
+def test_response_types(app, client):
-    assert c.get('/bytes').data == u'HÃ¤llo WÃ¶rld'.encode('utf-8')
+    assert client.get('/text').data == u'HÃ¤llo WÃ¶rld'.encode('utf-8')
-    rv = c.get('/full_tuple')
+    rv = client.get('/full_tuple')
-    rv = c.get('/text_headers')
+    rv = client.get('/text_headers')
-    rv = c.get('/text_status')
+    rv = client.get('/text_status')
-    rv = c.get('/response_headers')
+    rv = client.get('/response_headers')
-    rv = c.get('/response_status')
+    rv = client.get('/response_status')
-    rv = c.get('/wsgi')
+    rv = client.get('/wsgi')
-        assert rv.mimetype == 'text/html'
+def test_make_response(app, req_ctx):
-        assert rv.mimetype == 'text/html'
+    rv = flask.make_response('Awesome')
-        assert rv.mimetype == 'text/html'
+    rv = flask.make_response('W00t', 404)
-    app = flask.Flask(__name__)
+def test_make_response_with_response_instance(app, req_ctx):
-        }
+    compressed_msg = b'{"msg":{"submsg":"W00t"},"msg2":"foobar"}\n'
-        assert rv.data == compressed_msg
+    rv = flask.make_response(
-    app = flask.Flask(__name__)
+def test_jsonify_prettyprint(app, req_ctx):
-            b'{\n  "msg": {\n    "submsg": "W00t"\n  }, \n  "msg2": "foobar"\n}\n'
+    compressed_msg = {"msg": {"submsg": "W00t"}, "msg2": "foobar"}
-        assert rv.data == pretty_response
+    rv = flask.make_response(
-    app = flask.Flask(__name__)
+def test_jsonify_mimetype(app, req_ctx):
-
+    msg = {
-        assert 'behavior undefined' in str(e.value)
+def test_jsonify_args_and_kwargs_check(app, req_ctx):
-    app = flask.Flask(__name__)
+def test_url_generation(app, req_ctx):
-               'http://localhost/hello/test%20x'
+    assert flask.url_for('hello', name='test x') == '/hello/test%20x'
-
+def test_build_error_handler(app):
-
+def test_build_error_handler_reraise(app):
-
+def test_url_for_passes_special_values_to_build_error_handler(app):
-def test_custom_converters():
+def test_custom_converters(app, client):
-    assert c.get('/1,2,3').data == b'1|2|3'
+    assert client.get('/1,2,3').data == b'1|2|3'
-    rv = app.test_client().get('/static/index.html')
+def test_static_files(app, client):
-    app = flask.Flask(__name__)
+def test_test_app_proper_environ(app, client):
-    rv = app.test_client().get('/')
+    rv = client.get('/')
-    rv = app.test_client().get('/', 'http://localhost.localdomain:5000')
+    rv = client.get('/', 'http://localhost.localdomain:5000')
-    rv = app.test_client().get('/', 'https://localhost.localdomain:5000')
+    rv = client.get('/', 'https://localhost.localdomain:5000')
-    rv = app.test_client().get('/', 'https://localhost.localdomain')
+    rv = client.get('/', 'https://localhost.localdomain')
-        rv = app.test_client().get('/', 'https://localhost.localdomain')
+        rv = client.get('/', 'https://localhost.localdomain')
-        rv = app.test_client().get('/', 'http://foo.localhost')
+        rv = client.get('/', 'http://foo.localhost')
-    rv = app.test_client().get('/', 'http://foo.localhost.localdomain')
+    rv = client.get('/', 'http://foo.localhost.localdomain')
-def test_exception_propagation():
+def test_exception_propagation(app, client):
-                c.get('/')
+                client.get('/')
-            assert c.get('/').status_code == 500
+            assert client.get('/').status_code == 500
-                                     use_reloader, propagate_exceptions):
+                                     use_reloader, propagate_exceptions, app):
-    app = flask.Flask(__name__)
+def test_max_content_length(app, client):
-    rv = c.post('/accept', data={'myfile': 'foo' * 100})
+    rv = client.post('/accept', data={'myfile': 'foo' * 100})
-    app = flask.Flask(__name__)
+def test_url_processors(app, client):
-    c = app.test_client()
+    assert client.get('/de/').data == b'/de/about'
-    app = flask.Flask(__name__)
+def test_inject_blueprint_url_defaults(app):
-
+def test_nonascii_pathinfo(app, client):
-    rv = c.get(u'/ÐºÐ¸ÑÑÐµÑÑ')
+    rv = client.get(u'/ÐºÐ¸ÑÑÐµÑÑ')
-    app = flask.Flask(__name__)
+def test_debug_mode_complains_after_first_request(app, client):
-    assert app.test_client().get('/').data == b'Awesome'
+    assert client.get('/').data == b'Awesome'
-    assert app.test_client().get('/foo').data == b'Meh'
+    assert client.get('/foo').data == b'Meh'
-def test_before_first_request_functions():
+def test_before_first_request_functions(app, client):
-    c.get('/')
+    client.get('/')
-    c.get('/')
+    client.get('/')
-def test_before_first_request_functions_concurrent():
+def test_before_first_request_functions_concurrent(app, client):
-        c.get("/")
+        client.get("/")
-    app = flask.Flask(__name__)
+def test_routing_redirect_debugging(app, client):
-    with app.test_client() as c:
+    with client:
-            c.post('/foo', data={})
+            client.post('/foo', data={})
-        rv = c.get('/foo', data={}, follow_redirects=True)
+        rv = client.get('/foo', data={}, follow_redirects=True)
-        rv = c.post('/foo', data={}, follow_redirects=True)
+    with client:
-    app = flask.Flask(__name__)
+def test_route_decorator_custom_endpoint(app, client):
-    assert c.get('/bar/123').data == b'123'
+    assert client.get('/foo/').data == b'foo'
-    app = flask.Flask(__name__)
+def test_preserve_only_once(app, client):
-            c.get('/fail')
+            client.get('/fail')
-    def test_modified_url_encoding(self, app):
+    def test_modified_url_encoding(self, app, client):
-        rv = app.test_client().get(u'/?foo=ì ìì²ë¦¬'.encode('euc-kr'))
+        rv = client.get(u'/?foo=ì ìì²ë¦¬'.encode('euc-kr'))
-        app = flask.Flask(__name__)
+    def test_debug_log(self, capsys, app, client):
-            c.get('/')
+        with client:
-                c.get('/exc')
+                client.get('/exc')
-    def test_exception_logging(self, app):
+    def test_exception_logging(self, app, client):
-        rv = app.test_client().get('/')
+        rv = client.get('/')
-def test_aborting():
+def test_aborting(app):
-    app = flask.Flask(__name__)
+def test_template_rendered(app, client):
-        app.test_client().get('/')
+        client.get('/')
-def test_context_processing(app):
+def test_context_processing(app, client):
-    rv = app.test_client().get('/')
+    rv = client.get('/')
-def test_template_test_with_template(app):
+def test_template_test_with_template(app, client):
-    rv = app.test_client().get('/')
+    rv = client.get('/')
-        rv = c.get('/')
+    with client:
-        rv = c.get('/getsession')
+    with client:
-        rv = c.get('/')
+        rv = client.get('/')
-        rv = c.post('/', data={}, follow_redirects=True)
+        rv = client.post('/', data={}, follow_redirects=True)
-        if not hasattr(c, 'redirect_client'):
+        if not hasattr(client, 'redirect_client'):
-        rv = c.get('/getsession')
+        rv = client.get('/getsession')
-def test_session_transactions(app):
+def test_session_transactions(app, client):
-        with c.session_transaction() as sess:
+    with client:
-        rv = c.get('/')
+        rv = client.get('/')
-        with c.session_transaction() as sess:
+        with client.session_transaction() as sess:
-    app = flask.Flask(__name__)
+def test_test_client_context_binding(app, client):
-        resp = c.get('/')
+    with client:
-        resp = c.get('/other')
+        resp = client.get('/other')
-    c = app.test_client()
+def test_reuse_client(client):
-        assert c.get('/').status_code == 404
+        assert client.get('/').status_code == 404
-        assert c.get('/').status_code == 404
+        assert client.get('/').status_code == 404
-    app = flask.Flask(__name__)
+def test_test_client_calls_teardown_handlers(app, client):
-    with app.test_client() as c:
+    with client:
-        c.get('/')
+        client.get('/')
-    with app.test_client() as c:
+    with client:
-        c.get('/')
+        client.get('/')
-        c.get('/')
+        client.get('/')
-
+def test_full_url_request(app, client):
-        rv = c.post('http://domain.com/action?vodka=42', data={'gin': 43})
+    with client:
-    app = flask.Flask(__name__)
+def test_subdomain(app, client):
-        response = c.get(url)
+    with client:
-    app = flask.Flask(__name__)
+def test_nosubdomain(app, client):
-        response = c.get(url)
+    with client:
-def test_view_inheritance(app):
+def test_view_inheritance(app, client):
-    meths = parse_set_header(c.open('/', method='OPTIONS').headers['Allow'])
+    meths = parse_set_header(client.open('/', method='OPTIONS').headers['Allow'])
-def test_view_decorators(app):
+def test_view_decorators(app, client):
-    rv = c.get('/')
+    rv = client.get('/')
-def test_implicit_head(app):
+def test_implicit_head(app, client):
-    rv = c.get('/')
+    rv = client.get('/')
-    rv = c.head('/')
+    rv = client.head('/')
-def test_explicit_head(app):
+def test_explicit_head(app, client):
-    rv = c.get('/')
+    rv = client.get('/')
-    rv = c.head('/')
+    rv = client.head('/')
-def test_multiple_inheritance(app):
+def test_multiple_inheritance(app, client):
-    assert c.delete('/').data == b'DELETE'
+    assert client.get('/').data == b'GET'
-def test_remove_method_from_parent(app):
+def test_remove_method_from_parent(app, client):
-    assert c.post('/').status_code == 405
+    assert client.get('/').data == b'GET'
-        'Werkzeug>=0.7',
+        'Werkzeug>=0.9',
-class GreenletContextCopying():
+class TestGreenletContextCopying(object):
-    def test_greenlet_context_copying(app, client):
+    def test_greenlet_context_copying(self, app, client):
-    def test_greenlet_context_copying_api(app, client):
+    def test_greenlet_context_copying_api(self, app, client):
-    greenlets = []
+class GreenletContextCopying():
-        reqctx = flask._request_ctx_stack.top.copy()
+    def test_greenlet_context_copying(app, client):
-            return 42
+        @app.route('/')
-        return 'Hello World!'
+            def g():
-    assert rv.data == b'Hello World!'
+            greenlets.append(greenlet(g))
-    assert result == 42
+        rv = client.get('/?foo=bar')
-    greenlets = []
+    def test_greenlet_context_copying_api(app, client):
-        reqctx = flask._request_ctx_stack.top.copy()
+        @app.route('/')
-            return 42
+            @flask.copy_current_request_context
-        return 'Hello World!'
+            greenlets.append(greenlet(g))
-    assert rv.data == b'Hello World!'
+        rv = client.get('/?foo=bar')
-    assert result == 42
+        result = greenlets[0].run()
-
+def test_default_static_cache_timeout(app):
-    app = flask.Flask(__name__)
+def test_context_processing(app, client):
-    answer_page_bytes = c.get('/bp').data
+    app_page_bytes = client.get('/').data
-    app = flask.Flask(__name__)
+def test_template_global(app):
-    app = flask.Flask(__name__)
+def test_request_processing(app, client):
-    rv = app.test_client().get('/bp')
+    rv = client.get('/bp')
-    app = flask.Flask(__name__)
+def test_app_request_processing(app, client):
-    resp = app.test_client().get('/').data
+    resp = client.get('/').data
-    resp = app.test_client().get('/').data
+    resp = client.get('/').data
-                                                             script_info)
+                app = call_factory(app_factory, script_info)
-    returns the result."""
+def call_factory(func, script_info):
-        result = func(script_info=script_info)
+        return func(script_info=script_info)
-    return result
+        return func(script_info)
-            rv = check_factory_for_script_info_and_call(self.create_app, self)
+            rv = call_factory(self.create_app, self)
-        'click>=2.0',
+        'click>=4.0',
-    '''A tmpdir added to sys.path'''
+    """A tmpdir added to sys.path."""
-    '''Create a fake site-packages'''
+    """Create a fake site-packages."""
-        .mkdir('python{x[0]}.{x[1]}'.format(x=sys.version_info))\
+        .mkdir('lib') \
-    sys.path'''
+    """Generate egg from package name inside base and put the egg into
-    assert not recwarn.list
+    assert not recwarn.list, '\n'.join(str(w.message) for w in recwarn.list)
-    app = flask.Flask(__name__)
+def test_basic_url_generation(app):
-    app = flask.Flask(__name__)
+
-    app = flask.Flask(__name__)
+
-    app = flask.Flask(__name__)
+
-def test_app_tearing_down():
+
-    app = flask.Flask(__name__)
+
-def test_app_tearing_down_with_previous_exception():
+
-    app = flask.Flask(__name__)
+
-def test_app_tearing_down_with_handled_exception():
+
-    app = flask.Flask(__name__)
+
-def test_custom_app_ctx_globals_class():
+
-    app = flask.Flask(__name__)
+
-def test_context_refcounts():
+
-    app = flask.Flask(__name__)
+
-    res = c.get('/')
+
-def test_clean_pop():
+def test_clean_pop(app):
-    assert called == ['test_appctx', 'TEARDOWN']
+    assert called == ['conftest', 'TEARDOWN']
-
+def test_options_work(app, client):
-    rv = app.test_client().open('/', method='OPTIONS')
+
-
+def test_options_on_multiple_rules(app, client):
-    rv = app.test_client().open('/', method='OPTIONS')
+
-
+def test_provide_automatic_options_kwarg(app, client):
-    rv = c.post('/')
+    rv = client.post('/')
-        rv = c.options('/')
+    if hasattr(client, 'options'):
-        rv = c.open('/', method='OPTIONS')
+        rv = client.open('/', method='OPTIONS')
-    rv = c.head('/')
+    rv = client.head('/')
-    assert c.get('/more').data == b'GET'
+    assert client.post('/more').data == b'POST'
-    rv = c.delete('/more')
+    rv = client.delete('/more')
-        rv = c.options('/more')
+    if hasattr(client, 'options'):
-        rv = c.open('/more', method='OPTIONS')
+        rv = client.open('/more', method='OPTIONS')
-
+def test_request_dispatching(app, client):
-    rv = c.post('/')
+    assert client.get('/').data == b'GET'
-    rv = c.head('/')
+    rv = client.head('/')
-    rv = c.delete('/more')
+    assert client.post('/more').data == b'POST'
-    app = flask.Flask(__name__)
+def test_disallow_string_for_allowed_methods(app):
-
+def test_url_mapping(app, client):
-    rv = c.post('/')
+    assert client.get('/').data == b'GET'
-    rv = c.head('/')
+    rv = client.head('/')
-    rv = c.delete('/more')
+    assert client.post('/more').data == b'POST'
-    rv = c.open('/options', method='OPTIONS')
+    rv = client.open('/options', method='OPTIONS')
-def test_werkzeug_routing():
+def test_werkzeug_routing(app, client):
-    app = flask.Flask(__name__)
+
-    assert c.get('/foo/bar').data == b'bar'
+    assert client.get('/foo/').data == b'index'
-def test_endpoint_decorator():
+def test_endpoint_decorator(app, client):
-    assert c.get('/foo/bar').data == b'bar'
+    assert client.get('/foo/').data == b'index'
-    app = flask.Flask(__name__)
+def test_session(app, client):
-    assert c.get('/get').data == b'42'
+    assert client.post('/set', data={'value': '42'}).data == b'value set'
-    app = flask.Flask(__name__)
+def test_session_using_server_name(app, client):
-    rv = app.test_client().get('/', 'http://example.com/')
+
-    app = flask.Flask(__name__)
+def test_session_using_server_name_and_port(app, client):
-    rv = app.test_client().get('/', 'http://example.com:8080/')
+
-    app = flask.Flask(__name__)
+def test_session_using_server_name_port_and_path(app, client):
-    rv = app.test_client().get('/', 'http://example.com:8080/foo')
+
-def test_session_using_application_root():
+def test_session_using_application_root(app, client):
-    rv = app.test_client().get('/', 'http://example.com:8080/')
+
-    app = flask.Flask(__name__)
+def test_session_using_session_settings(app, client):
-    rv = app.test_client().get('/', 'http://www.example.com:8080/test/')
+
-    app = flask.Flask(__name__)
+def test_session_localhost_warning(recwarn, app, client):
-    rv = app.test_client().get('/', 'http://localhost:5000/')
+    rv = client.get('/', 'http://localhost:5000/')
-    app = flask.Flask(__name__)
+def test_session_ip_warning(recwarn, app, client):
-    rv = app.test_client().get('/', 'http://127.0.0.1:5000/')
+    rv = client.get('/', 'http://127.0.0.1:5000/')
-def test_session_expiration():
+def test_session_expiration(app, client):
-    rv = app.test_client().get('/')
+    rv = client.get('/')
-    app = flask.Flask(__name__)
+def test_session_stored_last(app, client):
-    assert c.get('/').data == b'42'
+    assert client.get('/').data == b'None'
-    app = flask.Flask(__name__)
+def test_session_special_types(app, client):
-    rv = pickle.loads(c.get('/').data)
+    client.get('/')
-    app.testing = True
+def test_session_cookie_setting(app):
-    app = flask.Flask(__name__)
+def test_session_vary_cookie(app, client):
-        rv = c.get(path)
+        rv = client.get(path)
-    app = flask.Flask(__name__)
+def test_flashes(app, req_ctx):
-        assert list(flask.get_flashed_messages()) == ['Zap', 'Zip']
+    assert not flask.session.modified
-def test_extended_flashing():
+def test_extended_flashing(app):
-    c.get('/test_with_categories/')
+    client = app.test_client()
-    c.get('/test_filter/')
+    client = app.test_client()
-    c.get('/test_filters/')
+    client = app.test_client()
-    c.get('/test_filters_without_returning_categories/')
+    client = app.test_client()
-    app = flask.Flask(__name__)
+def test_request_processing(app, client):
-    rv = app.test_client().get('/').data
+    rv = client.get('/').data
-    app = flask.Flask(__name__)
+def test_request_preprocessing_early_return(app, client):
-    rv = app.test_client().get('/').data.strip()
+    rv = client.get('/').data.strip()
-
+def test_after_request_processing(app, client):
-    resp = c.get('/')
+
-def test_teardown_request_handler():
+def test_teardown_request_handler(app, client):
-    rv = app.test_client().get('/')
+
-def test_teardown_request_handler_debug_mode():
+def test_teardown_request_handler_debug_mode(app, client):
-    rv = app.test_client().get('/')
+
-def test_teardown_request_handler_error():
+def test_teardown_request_handler_error(app, client):
-    app = flask.Flask(__name__)
+    app.testing = False
-    rv = app.test_client().get('/')
+
-def test_before_after_request_order():
+def test_before_after_request_order(app, client):
-    rv = app.test_client().get('/')
+
-    app = flask.Flask(__name__)
+def test_error_handling(app, client):
-    rv = c.get('/')
+
-    rv = c.get('/error')
+    rv = client.get('/error')
-    rv = c.get('/forbidden')
+    rv = client.get('/forbidden')
-    app = flask.Flask(__name__)
+def test_error_handling_processing(app, client):
-        assert resp.data == b'internal server error'
+    resp = client.get('/')
-    app = flask.Flask(__name__)
+def test_baseexception_error_handling(app, client):
-            c.get('/')
+    with pytest.raises(KeyboardInterrupt):
-
+def test_before_request_and_routing_errors(app, client):
-    rv = app.test_client().get('/')
+
-def test_user_error_handling():
+def test_user_error_handling(app, client):
-    assert c.get('/').data == b'42'
+    assert client.get('/').data == b'42'
-def test_http_error_subclass_handling():
+def test_http_error_subclass_handling(app, client):
-    assert c.get('/3').data == b'apple'
+    assert client.get('/1').data == b'banana'
-
+def test_trapping_of_bad_request_key_errors(app):
-    app.testing = True
+def test_trapping_of_all_http_exceptions(app, client):
-        c.get('/fail')
+        client.get('/fail')
-def test_enctype_debug_helper():
+def test_enctype_debug_helper(app, client):
-    with app.test_client() as c:
+    with client as c:
-            }
+        }
-        pretty_response =\
+        compressed_msg = {"msg": {"submsg": "W00t"}, "msg2": "foobar"}
-            'http://localhost/hello/test%20x'
+               'http://localhost/hello/test%20x'
-
+
-            '/static/index.html'
+               '/static/index.html'
-       assert rv == 'http://example.com/static/index.html'
+        rv = flask.url_for('static', filename='index.html', _external=True)
-           app.url_map.is_endpoint_expecting(endpoint, 'lang_code'):
+                app.url_map.is_endpoint_expecting(endpoint, 'lang_code'):
-    app = flask.Flask(__name__)
+def test_preserve_remembers_exception(app, client):
-        c.get('/fail')
+        client.get('/fail')
-    c.get('/success')
+    client.get('/success')
-    c.get('/success')
+    client.get('/success')
-
+def test_get_method_on_g(app_ctx):
-        assert sorted(flask.g) == ['bar', 'foo']
+def test_g_iteration_protocol(app_ctx):
-    app.config['SERVER_NAME'] = 'localhost'
+def test_subdomain_basic_support(app, client):
-    rv = c.get('/', 'http://localhost/')
+    rv = client.get('/', 'http://localhost.localdomain/')
-    rv = c.get('/', 'http://test.localhost/')
+    rv = client.get('/', 'http://test.localhost.localdomain/')
-    app.config['SERVER_NAME'] = 'localhost'
+def test_subdomain_matching(app, client):
-    rv = c.get('/', 'http://mitsuhiko.localhost/')
+    rv = client.get('/', 'http://mitsuhiko.localhost.localdomain/')
-    app.config['SERVER_NAME'] = 'localhost:3000'
+def test_subdomain_matching_with_ports(app, client):
-    rv = c.get('/', 'http://mitsuhiko.localhost:3000/')
+    rv = client.get('/', 'http://mitsuhiko.localhost.localdomain:3000/')
-
+def test_multi_route_rules(app, client):
-    rv = app.test_client().open('/')
+    rv = client.open('/')
-    rv = app.test_client().open('/b/')
+    rv = client.open('/b/')
-def test_multi_route_class_views():
+def test_multi_route_class_views(app, client):
-    rv = app.test_client().open('/')
+    rv = client.open('/')
-    rv = app.test_client().open('/b/')
+    rv = client.open('/b/')
-def test_run_defaults(monkeypatch):
+def test_run_defaults(monkeypatch, app):
-def test_run_server_port(monkeypatch):
+def test_run_server_port(monkeypatch, app):
-    ('localhost', 80, 'localhost', 80),
+        (None, None, 'pocoo.org', 8080),
-def test_run_from_config(monkeypatch, host, port, expect_host, expect_port):
+def test_run_from_config(monkeypatch, host, port, expect_host, expect_port, app):
-def test_blueprint_specific_error_handling():
+def test_blueprint_specific_error_handling(app, client):
-    c = app.test_client()
+    assert client.get('/frontend-no').data == b'frontend says no'
-def test_blueprint_specific_user_error_handling():
+def test_blueprint_specific_user_error_handling(app, client):
-    c = app.test_client()
+    assert client.get('/decorator').data == b'boom'
-def test_blueprint_app_error_handling():
+def test_blueprint_app_error_handling(app, client):
-    c = app.test_client()
+    assert client.get('/forbidden').data == b'you shall not pass'
-def test_blueprint_url_definitions():
+def test_blueprint_url_definitions(app, client):
-    assert c.get('/2/bar').data == b'19'
+    assert client.get('/1/foo').data == b'23/42'
-def test_blueprint_url_processors():
+
-    c = app.test_client()
+    assert client.get('/de/').data == b'/de/about'
-    c = app.test_client()
+    client = app.test_client()
-    rv = c.get('/')
+    rv = client.get('/')
-    rv = c.get('/admin/')
+    rv = client.get('/admin/')
-    rv = c.get('/admin/index2')
+    rv = client.get('/admin/index2')
-    rv = c.get('/admin/static/test.txt')
+    rv = client.get('/admin/static/test.txt')
-    rv = c.get('/admin/static/css/test.css')
+    rv = client.get('/admin/static/css/test.css')
-        rv = c.get('/admin/static/css/test.css')
+        rv = client.get('/admin/static/css/test.css')
-def test_dotted_names():
+
-    assert c.get('/be').data.strip() == b'/fe'
+    assert client.get('/fe').data.strip() == b'/be'
-    app.testing = True
+
-        assert rv.data == b'/test/'
+    rv = client.get('/')
-def test_empty_url_defaults():
+
-    assert c.get('/page/2').data == b'2'
+    assert client.get('/').data == b'1'
-def test_route_decorator_custom_endpoint():
+def test_route_decorator_custom_endpoint(app, client):
-    assert c.get('/py/bar/foo').data == b'bp.bar_foo'
+    assert client.get('/').data == b'index'
-def test_route_decorator_custom_endpoint_with_dots():
+def test_route_decorator_custom_endpoint_with_dots(app, client):
-    assert c.get('/py/foo').data == b'bp.foo'
+    assert client.get('/py/foo').data == b'bp.foo'
-    rv = c.get('/py/bar')
+    rv = client.get('/py/bar')
-    rv = c.get('/py/bar/123')
+    rv = client.get('/py/bar/123')
-def test_endpoint_decorator():
+def test_endpoint_decorator(app, client):
-    assert c.get('/bp_prefix/bar').status_code == 404
+    assert client.get('/foo').data == b'bar'
-def test_template_filter():
+def test_template_filter(app):
-    app = flask.Flask(__name__)
+
-def test_add_template_filter():
+
-def test_template_filter_with_name():
+
-    app = flask.Flask(__name__)
+
-def test_add_template_filter_with_name():
+
-def test_template_filter_with_template():
+
-    app = flask.Flask(__name__)
+
-    rv = app.test_client().get('/')
+
-    app = flask.Flask(__name__)
+
-    rv = app.test_client().get('/')
+    rv = client.get('/')
-def test_add_template_filter_with_template():
+
-    app = flask.Flask(__name__)
+
-    rv = app.test_client().get('/')
+
-def test_template_filter_with_name_and_template():
+
-    app = flask.Flask(__name__)
+
-    rv = app.test_client().get('/')
+
-def test_add_template_filter_with_name_and_template():
+
-    app = flask.Flask(__name__)
+
-    rv = app.test_client().get('/')
+
-def test_template_test():
+
-    app = flask.Flask(__name__)
+
-def test_add_template_test():
+
-def test_template_test_with_name():
+
-    app = flask.Flask(__name__)
+
-def test_add_template_test_with_name():
+
-def test_template_test_with_template():
+
-    app = flask.Flask(__name__)
+
-    rv = app.test_client().get('/')
+
-    app = flask.Flask(__name__)
+
-    rv = app.test_client().get('/')
+    rv = client.get('/')
-def test_add_template_test_with_template():
+
-    app = flask.Flask(__name__)
+
-    rv = app.test_client().get('/')
+
-def test_template_test_with_name_and_template():
+
-    app = flask.Flask(__name__)
+
-    rv = app.test_client().get('/')
+
-def test_add_template_test_with_name_and_template():
+
-    app = flask.Flask(__name__)
+
-    rv = app.test_client().get('/')
+
-    def test_request_json(self, recwarn):
+    def test_request_json(self, recwarn, app, client):
-        c.post('/', data='{"spam": 42}', content_type='application/json')
+        client.post('/', data='{"spam": 42}', content_type='application/json')
-    def test_request_module(self, recwarn):
+    def test_request_module(self, recwarn, app, client):
-        c.get('/')
+        client.get('/')
-        app = flask.Flask(__name__)
+    def test_ignore_cached_json(self, app):
-        app = flask.Flask(__name__)
+    def test_post_empty_json_adds_exception_to_response_content_in_debug(self, app, client):
-        rv = c.post('/json', data=None, content_type='application/json')
+
-        app = flask.Flask(__name__)
+    def test_post_empty_json_wont_add_exception_to_response_if_no_debug(self, app, client):
-        rv = c.post('/json', data=None, content_type='application/json')
+
-        app = flask.Flask(__name__)
+    def test_json_bad_requests(self, app, client):
-        rv = c.post('/json', data='malformed', content_type='application/json')
+
-        app = flask.Flask(__name__)
+    def test_json_custom_mimetypes(self, app, client):
-        rv = c.post('/json', data='"foo"', content_type='application/x+json')
+
-        app = flask.Flask(__name__)
+    def test_json_body_encoding(self, app, client):
-                     content_type='application/json; charset=iso-8859-15')
+        resp = client.get('/', data=u'"HÃ¤llo WÃ¶rld"'.encode('iso-8859-15'),
-        app = flask.Flask(__name__)
+    @pytest.mark.parametrize('test_value,expected', [(True, '"\\u2603"'), (False, u'"\u2603"')])
-            assert rv == '"\\u2603"'
+        app.config['JSON_AS_ASCII'] = test_value
-        app = flask.Flask(__name__)
+    def test_json_dump_to_file(self, app, app_ctx):
-            assert rv == test_data
+        flask.json.dump(test_data, out)
-    def test_jsonify_basic_types(self, test_value):
+    def test_jsonify_basic_types(self, test_value, app, client):
-        rv = c.get(url)
+        rv = client.get(url)
-    def test_jsonify_dicts(self):
+    def test_jsonify_dicts(self, app, client):
-        app = flask.Flask(__name__)
+        d = {'a': 0, 'b': 23, 'c': 3.14, 'd': 't',
-        c = app.test_client()
+
-            rv = c.get(url)
+            rv = client.get(url)
-    def test_jsonify_arrays(self):
+    def test_jsonify_arrays(self, app, client):
-            {'test':'dict'}
+            {'test': 'dict'}
-        app = flask.Flask(__name__)
+
-        c = app.test_client()
+
-            rv = c.get(url)
+            rv = client.get(url)
-    def test_jsonify_date_types(self):
+    def test_jsonify_date_types(self, app, client):
-            rv = c.get(url)
+            rv = client.get(url)
-    def test_jsonify_uuid_types(self):
+    def test_jsonify_uuid_types(self, app, client):
-        rv = c.get(url)
+        rv = client.get(url)
-        app = flask.Flask(__name__)
+    def test_json_attr(self, app, client):
-                            content_type='application/json')
+
-        app = flask.Flask(__name__)
+    def test_template_escaping(self, app, req_ctx):
-    def test_json_customization(self):
+        rv = flask.json.htmlsafe_dumps('</script>')
-        app = flask.Flask(__name__)
+
-        rv = c.post('/', data=flask.json.dumps({
+
-    def test_blueprint_json_customization(self):
+    def test_blueprint_json_customization(self, app, client):
-        rv = c.post('/bp', data=flask.json.dumps({
+        rv = client.post('/bp', data=flask.json.dumps({
-    def test_modified_url_encoding(self):
+    def test_modified_url_encoding(self, app):
-        app = flask.Flask(__name__)
+
-        app = flask.Flask(__name__)
+    def test_json_key_sorting(self, app, client):
-        rv = c.get('/')
+        rv = client.get('/')
-            rv.close()
+class TestSendfile(object):
-        app = flask.Flask(__name__)
+    def test_send_file_xsendfile(self, app, req_ctx, catch_deprecation_warnings):
-            rv.close()
+        rv = flask.send_file('static/index.html')
-        app = flask.Flask(__name__)
+    def test_send_file_last_modified(self, app, client):
-        rv = c.get('/')
+        rv = client.get('/')
-            flask.send_file(StringIO("LOL"), attachment_filename='filename')
+    def test_send_file_object_without_mimetype(self, app, req_ctx):
-        app = flask.Flask(__name__)
+        flask.send_file(StringIO("LOL"), attachment_filename='filename')
-                rv.close()
+    def test_send_file_object(self, app, req_ctx):
-                rv.close()
+        with open(os.path.join(app.root_path, 'static/index.html')) as f:
-            rv.close()
+        f = StringIO('Test')
-            rv.close()
+        class PyStringIO(object):
-            rv.close()
+            def __getattr__(self, name):
-            rv.close()
+        f = StringIO('Test')
-
+    def test_send_file_range_request(self, app, client):
-        rv = c.get('/', headers={'Range': 'bytes=4-15'})
+        rv = client.get('/', headers={'Range': 'bytes=4-15'})
-        rv = c.get('/', headers={'Range': 'bytes=4-'})
+        rv = client.get('/', headers={'Range': 'bytes=4-'})
-        rv = c.get('/', headers={'Range': 'bytes=4-1000'})
+        rv = client.get('/', headers={'Range': 'bytes=4-1000'})
-        rv = c.get('/', headers={'Range': 'bytes=-10'})
+        rv = client.get('/', headers={'Range': 'bytes=-10'})
-        rv = c.get('/', headers={'Range': 'bytes=1000-'})
+        rv = client.get('/', headers={'Range': 'bytes=1000-'})
-        rv = c.get('/', headers={'Range': 'bytes=-'})
+        rv = client.get('/', headers={'Range': 'bytes=-'})
-        rv = c.get('/', headers={'Range': 'somethingsomething'})
+        rv = client.get('/', headers={'Range': 'somethingsomething'})
-                                 'If-Range': http_date(last_modified)})
+        rv = client.get('/', headers={'Range': 'bytes=4-15',
-        rv = c.get('/', headers={'Range': 'bytes=4-15', 'If-Range': http_date(
+        rv = client.get('/', headers={'Range': 'bytes=4-15', 'If-Range': http_date(
-    def test_attachment(self):
+    def test_attachment(self, app, req_ctx):
-            value, options = parse_options_header(rv.headers['Content-Disposition'])
+        with open(os.path.join(app.root_path, 'static/index.html')) as f:
-            rv.close()
+        rv = flask.send_file('static/index.html', as_attachment=True)
-        app = flask.Flask(__name__)
+        rv = flask.send_file(StringIO('Test'), as_attachment=True,
-            rv.close()
+    def test_attachment_with_utf8_filename(self, app, req_ctx):
-        app = flask.Flask(__name__)
+    def test_static_file(self, app, req_ctx):
-            rv.close()
+
-            rv.close()
+
-        app = flask.Flask(__name__)
+    def test_send_from_directory(self, app, req_ctx):
-            rv.close()
+        rv = flask.send_from_directory('static', 'hello.txt')
-        app = flask.Flask(__name__)
+    def test_send_from_directory_bad_request(self, app, req_ctx):
-class TestLogging(object):
+        with pytest.raises(BadRequest):
-        app = flask.Flask(__name__)
+    def test_debug_log_override(self, app):
-    def test_exception_logging(self):
+    def test_exception_logging(self, app):
-        app = flask.Flask(__name__)
+        app.testing = False
-        app = flask.Flask(__name__)
+    def test_processor_exceptions(self, app, client):
-            rv = app.test_client().get('/')
+            rv = client.get('/')
-        app = flask.Flask(__name__)
+    def test_url_for_with_anchor(self, app, req_ctx):
-        app = flask.Flask(__name__)
+        assert flask.url_for('index', _anchor='x y') == '/#x%20y'
-        app = flask.Flask(__name__)
+        assert flask.url_for('index', _external=True, _scheme='https') == 'https://localhost/'
-        app = flask.Flask(__name__)
+        pytest.raises(ValueError,
-    def test_url_with_method(self):
+        assert flask.url_for('index', _external=True) == 'http://localhost/'
-        app = flask.Flask(__name__)
+
-            assert flask.url_for('myview', _method='POST') == '/myview/create'
+        assert flask.url_for('myview', _method='GET') == '/myview/'
-        app = flask.Flask(__name__)
+    def test_streaming_with_context(self, app, client):
-        rv = c.get('/?name=World')
+
-        app = flask.Flask(__name__)
+    def test_streaming_with_context_as_decorator(self, app, client):
-        rv = c.get('/?name=World')
+
-        app = flask.Flask(__name__)
+    def test_streaming_with_context_and_custom_close(self, app, client):
-        rv = c.get('/?name=World')
+
-            (('/..', ), '/..'),
+            (('/..',), '/..'),
-import flask
+
-def test_teardown_on_pop():
+def test_teardown_on_pop(app):
-    app = flask.Flask(__name__)
+
-def test_teardown_with_previous_exception():
+
-    app = flask.Flask(__name__)
+
-def test_teardown_with_handled_exception():
+
-    app = flask.Flask(__name__)
+
-    app = flask.Flask(__name__)
+
-            'http://localhost.localdomain:5000/'
+               'http://localhost.localdomain:5000/'
-            'http://foo.localhost.localdomain:5000/'
+               'http://foo.localhost.localdomain:5000/'
-    app = flask.Flask(__name__)
+
-    app = flask.Flask(__name__)
+
-    app = flask.Flask(__name__)
+
-    app = flask.Flask(__name__)
+def test_greenlet_context_copying(app, client):
-    rv = app.test_client().get('/?foo=bar')
+    rv = client.get('/?foo=bar')
-    app = flask.Flask(__name__)
+def test_greenlet_context_copying_api(app, client):
-    rv = app.test_client().get('/?foo=bar')
+    rv = client.get('/?foo=bar')
-    app = flask.Flask(__name__)
+def test_context_processing(app):
-    app = flask.Flask(__name__)
+
-    rv = app.test_client().get('/')
+
-    app = flask.Flask(__name__)
+
-        assert rv == 'Hello Special World 42'
+    rv = flask.render_template_string('Hello {{ config.WORLD_NAME }} '
-    app = flask.Flask(__name__)
+
-    rv = app.test_client().get('/?foo=42')
+
-def test_escaping():
+
-    app = flask.Flask(__name__)
+
-    lines = app.test_client().get('/').data.splitlines()
+
-def test_no_escaping():
+
-    app = flask.Flask(__name__)
+
-    lines = app.test_client().get('/').data.splitlines()
+
-        assert macro('World') == 'Hello World!'
+def test_escaping_without_template_filename(app, client, req_ctx):
-    app = flask.Flask(__name__)
+
-    app = flask.Flask(__name__)
+
-    app = flask.Flask(__name__)
+
-    app = flask.Flask(__name__)
+
-    app = flask.Flask(__name__)
+
-    rv = app.test_client().get('/')
+
-    app = flask.Flask(__name__)
+
-    rv = app.test_client().get('/')
+
-    app = flask.Flask(__name__)
+
-    rv = app.test_client().get('/')
+
-    app = flask.Flask(__name__)
+
-    rv = app.test_client().get('/')
+
-    app = flask.Flask(__name__)
+
-    app = flask.Flask(__name__)
+
-    app = flask.Flask(__name__)
+
-    app = flask.Flask(__name__)
+
-    app = flask.Flask(__name__)
+
-    app = flask.Flask(__name__)
+
-    rv = app.test_client().get('/')
+
-    app = flask.Flask(__name__)
+
-    rv = app.test_client().get('/')
+
-    app = flask.Flask(__name__)
+
-    rv = app.test_client().get('/')
+
-    app = flask.Flask(__name__)
+
-def test_custom_template_loader():
+    rv = flask.render_template_string('{{ get_stuff() }}')
-    app = flask.Flask(__name__)
+
-            'context_template.html'],
+             'simple_template.html',  # should render this
-    rv = app.test_client().get('/')
+    rv = client.get('/')
-def test_templates_auto_reload():
+
-    app = flask.Flask(__name__)
+
-    app.testing = True
+def test_environ_defaults_from_config(app, client):
-    app.testing = True
+    rv = client.get('/')
-    app = flask.Flask(__name__)
+
-        assert flask.g.user_agent == 'werkzeug/' + werkzeug.__version__
+    rv = client.get('/')
-    app.testing = True
+
-        assert flask.g.user_agent == 'Foo'
+    client.environ_base['REMOTE_ADDR'] = '0.0.0.0'
-        assert flask.g.user_agent == 'Bar'
+    client.environ_base['REMOTE_ADDR'] = '0.0.0.1'
-    app = flask.Flask(__name__)
+
-    with app.test_client() as c:
+    with client as c:
-    app.testing = True
+
-    app.testing = True
+
-            assert req is flask.request._get_current_object()
+    rv = client.get('/')
-    app.testing = True
+def test_session_transaction_needs_cookies(app):
-    app = flask.Flask(__name__)
+def test_error_handler_no_match(app, client):
-    assert c.get('/keyerror').data == b'KeyError'
+    app.testing = False
-
+def test_error_handler_subclass(app):
-
+def test_error_handler_http_subclass(app):
-def test_error_handler_blueprint():
+def test_error_handler_blueprint(app):
-
+
-    app = flask.Flask(__name__)
+def test_basic_view(app):
-    app = flask.Flask(__name__)
+def test_method_based_view(app):
-    app = flask.Flask(__name__)
+def test_view_patching(app):
-    app = flask.Flask(__name__)
+def test_view_inheritance(app):
-    app = flask.Flask(__name__)
+def test_view_decorators(app):
-    app = flask.Flask(__name__)
+def test_implicit_head(app):
-    app = flask.Flask(__name__)
+def test_explicit_head(app):
-    app = flask.Flask(__name__)
+
-    app = flask.Flask(__name__)
+def test_multiple_inheritance(app):
-    app = flask.Flask(__name__)
+def test_remove_method_from_parent(app):
-def find_best_app(module):
+def find_best_app(script_info, module):
-
+                app = check_factory_for_script_info_and_call(app_factory,
-def locate_app(app_id):
+def locate_app(script_info, app_id):
-        app = find_best_app(mod)
+        app = find_best_app(script_info, mod)
-            rv = self.create_app(self)
+            rv = check_factory_for_script_info_and_call(self.create_app, self)
-            rv = locate_app(self.app_import_path)
+            rv = locate_app(self, self.app_import_path)
-    assert find_best_app(Module) == Module.app
+    assert find_best_app(script_info, Module) == Module.app
-    assert find_best_app(Module) == Module.application
+    assert find_best_app(script_info, Module) == Module.application
-    assert find_best_app(Module) == Module.myapp
+    assert find_best_app(script_info, Module) == Module.myapp
-    assert find_best_app(Module).name == 'appname'
+    assert isinstance(find_best_app(script_info, Module), Flask)
-    assert find_best_app(Module).name == 'appname'
+    assert isinstance(find_best_app(script_info, Module), Flask)
-    assert find_best_app(Module) == Module.myapp
+    assert find_best_app(script_info, Module) == Module.myapp
-        def create_app(foo):
+        def create_app():
-    assert find_best_app(Module) == Module.myapp
+    assert find_best_app(script_info, Module) == Module.myapp
-    pytest.raises(NoAppException, find_best_app, Module)
+    pytest.raises(NoAppException, find_best_app, script_info, Module)
-    pytest.raises(NoAppException, find_best_app, Module)
+    pytest.raises(NoAppException, find_best_app, script_info, Module)
-        def create_app(foo):
+        def create_app(foo, bar):
-    pytest.raises(NoAppException, find_best_app, Module)
+    pytest.raises(NoAppException, find_best_app, script_info, Module)
-    pytest.raises(NoAppException, locate_app, "cliapp.importerrorapp")
+    script_info = ScriptInfo()
-def client(request):
+def client():
-                          to None.
+                          folder in the root path of the application. Defaults
-        handler is found.
+        """Find a registered error handler for a request in this order:
-            handler = None
+        # check for any in blueprint or app
-        return handler
+            if handler:
-from werkzeug.exceptions import Forbidden, InternalServerError, HTTPException, NotFound
+from werkzeug.exceptions import (
-
+
-        handler is found.
+        """Find a registered error handler for a request in this order:
-            handler = None
+        # check for any in blueprint or app
-        return handler
+            if handler:
-from werkzeug.exceptions import Forbidden, InternalServerError, HTTPException, NotFound
+from werkzeug.exceptions import (
-
+
-        return find_handler(self.error_handler_spec[None].get(code))
+        handler = find_handler(self.error_handler_spec[None].get(code))
-from werkzeug.exceptions import Forbidden, InternalServerError
+from werkzeug.exceptions import Forbidden, InternalServerError, HTTPException, NotFound
-def client(request):
+def client():
-    return client
+    yield client
-    request.addfinalizer(ensure_clean_request_context)
+def leak_detector():
-def disable_extwarnings(request, recwarn):
+def disable_extwarnings(recwarn):
-        recwarn.clear()
+    yield
-    request.addfinalizer(inner)
+    assert set(w.category for w in recwarn.list) \
-def importhook_setup(monkeypatch, request):
+def importhook_setup(monkeypatch):
-            assert '.' not in key
+    yield
-    request.addfinalizer(teardown)
+    from flask import ext
-    @pytest.mark.parametrize("debug, expected_flag, expected_default_flag", [
+    @pytest.mark.parametrize('debug, expected_flag, expected_default_flag', [
-        assert get_debug_flag(default=True) == True
+    @pytest.mark.parametrize("debug, expected_flag, expected_default_flag", [
-        os.environ['FLASK_DEBUG'] = ''
+    def test_get_debug_flag(self, monkeypatch):
-        os.environ['FLASK_DEBUG'] = '0'
+        monkeypatch.setenv('FLASK_DEBUG', '0')
-        os.environ['FLASK_DEBUG'] = 'False'
+        monkeypatch.setenv('FLASK_DEBUG', 'False')
-        os.environ['FLASK_DEBUG'] = 'No'
+        monkeypatch.setenv('FLASK_DEBUG', 'No')
-        os.environ['FLASK_DEBUG'] = 'True'
+        monkeypatch.setenv('FLASK_DEBUG', 'True')
-    def test_make_response_no_args(self):
+    def test_make_response(self):
-        assert rv
+        with app.test_request_context():
-        assert rv.headers['X-Parachutes'] == 'parachutes are cool'
+            rv = flask.helpers.make_response('Hello')
-    return client
+    yield client
-    #: For example this might activate unittest helpers that have an
+    #: For example this might activate test helpers that have an
-    assert evts == ['before', 'after']
+    assert evts == ['before', 'after', 'teardown']
-    assert evts == ['first', 'before', 'after']
+    assert evts == ['first', 'before', 'after', 'teardown']
-    assert evts == ['first', 'before', 'after', 'before', 'after']
+    assert evts == ['first'] + ['before', 'after', 'teardown'] * 2
-    for attr_name in 'app', 'application':
+    for attr_name in ('app', 'application'):
-    for attr_name in 'create_app', 'make_app':
+    for attr_name in ('create_app', 'make_app'):
-               if isinstance(v, Flask)]
+    matches = [
-                            module=module.__name__))
+                    'could not call it without specifying arguments.'.format(
-        .format(module=module.__name__))
+        'Failed to find application in module "{module}". Are you sure '
-        if app is not None and isinstance(app, Flask):
+        if isinstance(app, Flask):
-        if app_factory is not None and callable(app_factory):
+        if callable(app_factory):
-                if app is not None and isinstance(app, Flask):
+                if isinstance(app, Flask):
-                         'using a factory function.' % module.__name__)
+                raise NoAppException(
-    @app.route('/set-session')
+    @app.route('/set')
-        return ''
+    @app.route('/get')
-        return ''
+    @app.route('/getitem')
-    assert rv.headers['Vary'] == 'Cookie'
+    def expect(path, header=True):
-    assert rv.headers['Vary'] == 'Cookie'
+        if header:
-    assert 'Vary' not in rv.headers
+    expect('/set')
-        CallbackDict.__init__(self, initial, on_update)
+
-        This check is usually skipped if sessions get deleted.
+        """Used by session backends to determine if a ``Set-Cookie`` header
-        return save_each and session.permanent
+
-        if session.accessed:
+        # If the session is modified to be empty, remove the cookie.
-                return
+        if not self.should_set_cookie(app, session):
-                            domain=domain, path=path, secure=secure)
+        response.set_cookie(
-__version__ = '0.12.2'
+__version__ = '0.12.3-dev'
-__version__ = '0.12.2-dev'
+__version__ = '0.12.2'
-           filename.startswith('../'):
+
-    return directory
+
-            (('/a/b', 'c/X/..'), '/a/b/c', ),
+            (('a/b/c',), 'a/b/c'),
-            (('/a/b/c', '', ), '/a/b/c/', ),
+            (('/a/b/c', ''), '/a/b/c/'),
-            (('a/b/c', 'X/..'), 'a/b/c/.', ),
+            (('/a/b/c', './'), '/a/b/c/.'),
-            ('/a', '../b/c', ),
+            ('/a', '../b/c'),
-            ('/a', 'b/../b/../../c', ),
+            ('/a', 'b/../b/../../c'),
-            ('/a', 'b/../../c', ),
+            ('/a', 'b/../../c'),
-           filename.startswith('../'):
+
-    return directory
+
-            (('/a/b', 'c/X/..'), '/a/b/c', ),
+            (('a/b/c',), 'a/b/c'),
-            (('/a/b/c', '', ), '/a/b/c/', ),
+            (('/a/b/c', ''), '/a/b/c/'),
-            (('a/b/c', 'X/..'), 'a/b/c/.', ),
+            (('/a/b/c', './'), '/a/b/c/.'),
-            ('/a', '../b/c', ),
+            ('/a', '../b/c'),
-            ('/a', 'b/../b/../../c', ),
+            ('/a', 'b/../b/../../c'),
-            ('/a', 'b/../../c', ),
+            ('/a', 'b/../../c'),
-    :param var_name: the name of the string that is being checked
+def is_ip(value):
-    :rtype: boolean
+    :param value: value to check
-            socket.inet_pton(family, ip)
+            socket.inet_pton(family, value)
-from warnings import warn
+import warnings
-        be used for the session cookie if session cookies are used.
+        """Returns the domain that should be set for the session cookie.
-            return rv
+
-                warnings.warn("IP introduced in SESSION_COOKIE_DOMAIN", RuntimeWarning)
+def test_session_localhost_warning(recwarn):
-from .helpers import total_seconds
+from .helpers import total_seconds, is_ip
-from .ctx import has_request_context
+try:
-from threading import Lock, Thread
+from operator import attrgetter
-from . import __version__
+
-@click.option('-m', 'order_by', flag_value='methods', help='Order by methods')
+@click.command('routes', short_help='Show the routes for the app.')
-    max_meth = max(max_meth, len('Methods'))
+def routes_command(sort, all_methods):
-    click.echo('-' * under_count)
+    click.echo(row.format(*headers).strip())
-        click.echo(columnformat.format(rule.rule, rule.endpoint, methods))
+    for rule, methods in zip(rules, rule_methods):
-    pass
+from functools import partial
-def test_print_exceptions():
+def test_print_exceptions(runner):
-"""
+    @pytest.fixture
-"""
+            @app.route('/get_post/<int:x>/<int:y>', methods=['GET', 'POST'])
-        result = runner.invoke(cli, ['routes'], catch_exceptions=False)
+            return app
-"""
+        self.expect_order(
-        #: function here, use the :meth:`before_request` decorator.
+        #: A dictionary with lists of functions that will be called at the
-        #: the :meth:`before_first_request` decorator.
+        #: A list of functions that will be called at the beginning of the
-        #: Each of these functions has the chance to modify the dictionary
+        #: A dictionary with lists of functions that are called before the
-        request handling is stopped.
+        The function will be called without any arguments. If it returns a
-        are called and can modify the url values provided.
+        """Register a URL value preprocessor function for all view
-        the return value from the view function, and further request handling is stopped.
+        """Called before the request is dispatched. Calls
-from itertools import chain
+from itertools import chain
-from .globals import _request_ctx_stack, request, session, g
+from werkzeug.datastructures import ImmutableDict, Headers
-from ._compat import reraise, string_types, text_type, integer_types
+    _default_template_ctx_processor
-        :param rv: the return value from the view function
+        """Convert the return value from a view function to an instance of
-            raise ValueError('View function did not return a response')
+        status = headers = None
-            headers, status_or_headers = status_or_headers, None
+            # a 3-tuple is unpacked directly
-                headers = status_or_headers = None
+                # let the response class set the status and headers instead of
-                rv.status = status_or_headers
+                # evaluate a WSGI callable, or coerce a different response
-                rv.status_code = status_or_headers
+                rv.status_code = status
-def test_response_creation():
+def test_response_types():
-    def from_unicode():
+    @app.route('/text')
-    def from_string():
+    @app.route('/bytes')
-    def from_tuple():
+    @app.route('/full_tuple')
-    def from_two_args_tuple():
+    @app.route('/text_headers')
-    def from_status_tuple():
+    @app.route('/text_status')
-        return flask.Response('Hello world', 404), {
+    @app.route('/response_headers')
-    rv = c.get('/args')
+
-    assert rv4.status_code == 404
+
-    # Set to None to use the :class:`~flask.app.Flask.json_encoder`.
+    #: Set to ``None`` to use the app's :class:`~flask.app.Flask.json_encoder`.
-    # Set to None to use the :class:`~flask.app.Flask.json_decoder`.
+    #: Set to ``None`` to use the app's :class:`~flask.app.Flask.json_decoder`.
-                          else current_app.json_encoder)
+        bp = current_app.blueprints.get(request.blueprint) if request else None
-                          else current_app.json_decoder)
+        bp = current_app.blueprints.get(request.blueprint) if request else None
-        @blue.route('/bp', methods=['POST'])
+        bp = flask.Blueprint('bp', __name__)
-        app.register_blueprint(blue)
+        app.register_blueprint(bp)
-        ctx.push()
+                ctx.push()
-
+    """Metaclass for :class:`MethodView` that determines what methods the view
-                if key in http_method_funcs:
+            methods = set()
-            # that does not introduce new methods).
+
-        return rv
+                cls.methods = methods
-    automatically::
+    """A class-based view that dispatches request methods to the corresponding
-
+
-                     provide_automatic_options=None, **options):
+    def add_url_rule(self, rule, endpoint=None, view_func=None, provide_automatic_options=None, **options):
-                                          the view or list of methods.
+        :param provide_automatic_options: controls whether the ``OPTIONS``
-def test_options_handling_disabled():
+def test_provide_automatic_options_attr():
-    assert rv.status_code == 405
+def test_url_for_passes_special_values_to_build_error_handler():
-        # and static_folder iff there is a configured static_folder.
+        # and static_folder if there is a configured static_folder.
-        last_modified = datetime.datetime.fromtimestamp(os.path.getmtime(
+        last_modified = datetime.datetime.utcfromtimestamp(os.path.getmtime(
-        last_modified = datetime.datetime.fromtimestamp(os.path.getmtime(
+        last_modified = datetime.datetime.utcfromtimestamp(os.path.getmtime(
-    :param filename_or_fp: the filename of the file to send in `latin-1`.
+    :param filename_or_fp: the filename of the file to send.
-            normalized.encode('ascii')
+            attachment_filename = attachment_filename.encode('latin-1')
-                'filename': normalized.encode('ascii', 'ignore'),
+                'filename': unicodedata.normalize(
-                assert 'filename*' not in options
+                assert 'filename*' not in rv.headers['Content-Disposition']
-            )
+            rv = flask.send_file('static/index.html', as_attachment=True, attachment_filename=u'ÃandÃºï¼pingÃ¼ino.txt')
-from unicodedata import normalize
+import unicodedata
-        normalized = normalize('NFKD', text_type(attachment_filename))
+
-            }
+            filenames = {'filename': attachment_filename}
-                    **filenames)
+        headers.add('Content-Disposition', 'attachment', **filenames)
-            assert options['filename'] == 'index.html'
+
-                rv.close()
+            rv = flask.send_file(
-import unicodedata
+from unicodedata import normalize
-            'filename*': "UTF-8''%s" % url_quote(attachment_filename)}
+        normalized = normalize('NFKD', text_type(attachment_filename))
-                    **filename_dict)
+                    **filenames)
-                 static_folder='static', template_folder='templates',
+                 static_folder='static', static_host=None,
-        # else when mapped with the .yml file.
+        # Add a static route using the provided static_url_path, static_host,
-                              endpoint='static',
+                              endpoint='static', host=static_host,
-    spaces after separators.
+    This function's response will be pretty printed if the
-test_app = create_app()
+@pytest.fixture
-    with test_app.app_context():
+    app = create_app(config=config)
-        os.unlink(test_app.config['DATABASE'])
+        os.close(app.config['DB_FD'])
-def test_login_logout(client):
+def test_login_logout(client, app):
-               test_app.config['PASSWORD'])
+    rv = login(client, app.config['USERNAME'],
-               test_app.config['PASSWORD'])
+    rv = login(client,app.config['USERNAME'] + 'x',
-               test_app.config['PASSWORD'] + 'x')
+    rv = login(client, app.config['USERNAME'],
-def test_messages(client):
+def test_messages(client, app):
-          test_app.config['PASSWORD'])
+    login(client, app.config['USERNAME'],
-from .flaskr import app
+from flaskr.factory import create_app
-     render_template, flash
+from flask import Blueprint, request, session, g, redirect, url_for, abort, \
-app.config.from_envvar('FLASKR_SETTINGS', silent=True)
+# create our blueprint :)
-    rv = sqlite3.connect(app.config['DATABASE'])
+    rv = sqlite3.connect(current_app.config['DATABASE'])
-    with app.open_resource('schema.sql', mode='r') as f:
+    with current_app.open_resource('schema.sql', mode='r') as f:
-@app.route('/')
+@bp.route('/')
-@app.route('/add', methods=['POST'])
+@bp.route('/add', methods=['POST'])
-    return redirect(url_for('show_entries'))
+    return redirect(url_for('flaskr.show_entries'))
-@app.route('/login', methods=['GET', 'POST'])
+@bp.route('/login', methods=['GET', 'POST'])
-        if request.form['username'] != app.config['USERNAME']:
+        if request.form['username'] != current_app.config['USERNAME']:
-        elif request.form['password'] != app.config['PASSWORD']:
+        elif request.form['password'] != current_app.config['PASSWORD']:
-            return redirect(url_for('show_entries'))
+            return redirect(url_for('flaskr.show_entries'))
-@app.route('/logout')
+@bp.route('/logout')
-    return redirect(url_for('show_entries'))
+    return redirect(url_for('flaskr.show_entries'))
-from setuptools import setup
+from setuptools import setup, find_packages
-    packages=['flaskr'],
+    packages=find_packages(),
-from flaskr import flaskr
+from flaskr.factory import create_app
-        flaskr.init_db()
+    db_fd, test_app.config['DATABASE'] = tempfile.mkstemp()
-        os.unlink(flaskr.app.config['DATABASE'])
+        os.unlink(test_app.config['DATABASE'])
-               flaskr.app.config['PASSWORD'])
+    rv = login(client, test_app.config['USERNAME'],
-               flaskr.app.config['PASSWORD'])
+    rv = login(client,test_app.config['USERNAME'] + 'x',
-               flaskr.app.config['PASSWORD'] + 'x')
+    rv = login(client, test_app.config['USERNAME'],
-          flaskr.app.config['PASSWORD'])
+    login(client, test_app.config['USERNAME'],
-__version__ = '0.12.1'
+__version__ = '0.12.2-dev'
-__version__ = '0.12.1-dev'
+__version__ = '0.12.1'
-        try:
+        with pytest.raises(KeyboardInterrupt):
-            pass
+def test_baseexception_error_handling():
-            'filename': unidecode(text_type(attachment_filename)),
+            'filename': (unicodedata.normalize('NFKD',
-            'filename': unidecode(attachment_filename),
+            'filename': unidecode(text_type(attachment_filename)),
-                assert options == {'filename': 'Nandu/pinguino.txt', 'filename*': "UTF-8''%C3%91and%C3%BA%EF%BC%8Fping%C3%BCino.txt"}
+                                     attachment_filename=u'ÃandÃºï¼pingÃ¼ino.txt')
-                    filename=attachment_filename)
+                    **filename_dict)
-    pytest.raises(ImportError, locate_app, "cliapp.importerrorapp")
+    pytest.raises(NoAppException, locate_app, "cliapp.importerrorapp")
-            raise
+            stack_trace = traceback.format_exc()
-            pass
+import traceback
-                     ``'127.0.0.1'``.
+                     ``'127.0.0.1'`` or the host in the ``SERVER_NAME`` config
-        'JSONIFY_PRETTYPRINT_REGULAR':          True,
+        'JSONIFY_PRETTYPRINT_REGULAR':          False,
-    if current_app.config['JSONIFY_PRETTYPRINT_REGULAR'] and not request.is_xhr:
+    if current_app.config['JSONIFY_PRETTYPRINT_REGULAR'] or current_app.debug:
-        assert rv.data == b'{\n  "msg": "W00t"\n}\n'
+        assert rv.data == b'{"msg":"W00t"}\n'
-# The unique identifier of the text. This can be a ISBN number
+# The unique identifier of the text. This can be an ISBN number
-        #: To register a error handler, use the :meth:`errorhandler`
+        #: To register an error handler, use the :meth:`errorhandler`
-        When a teardown function was called because of a exception it will
+        When a teardown function was called because of an exception it will
-    output an unified diff with all the changes that are necessary to easily
+    output a unified diff with all the changes that are necessary to easily
-    elif isinstance(value, str):
+class TaggedJSONSerializer(object):
-    """
+    def _tag_dict_used_with_key(self, value):
-    }
+        return json.dumps(self._tag(value), separators=(',', ':'))
-        return json.loads(value, object_hook=object_hook)
+        return json.loads(value, object_hook=self._untag)
-    ~~~~~~~~~~~~~~
+    flask.json
-    'sqlalchemy': ('http://docs.sqlalchemy.org/en/latest/', None),
+    'sqlalchemy': ('https://docs.sqlalchemy.org/en/latest/', None),
-    return 'http://www.gravatar.com/avatar/%s?d=identicon&s=%d' % \
+    return 'https://www.gravatar.com/avatar/%s?d=identicon&s=%d' % \
-  <http://github.com/pallets/flask/zipball/master#egg=Flask-dev>`_
+  <https://github.com/pallets/flask/zipball/master#egg=Flask-dev>`_
-    url='http://github.com/pallets/flask/',
+    url='https://github.com/pallets/flask/',
-                port = 5000
+        _host = '127.0.0.1'
-    return val not in ('0', 'false', 'no')
+    return val.lower() not in ('0', 'false', 'no')
-from datetime import datetime
+import time
-copyright = u'2010 - {0}, Armin Ronacher'.format(datetime.utcnow().year)
+copyright = u'2010 - {0}, Armin Ronacher'.format(BUILD_DATE.year)
-    match = re.search(r'\bexpires=([^;]+)(?i)', rv.headers['set-cookie'])
+    match = re.search(r'(?i)\bexpires=([^;]+)', rv.headers['set-cookie'])
-    assert excinfo.type is ImportError
+    # python3.6 raises a subclass of ImportError: 'ModuleNotFoundError'
-def client(request):
+def client():
-                             'is .py' % module)
+        # Reraise the ImportError if it occurred within the imported module.
-            with open(filename) as config_file:
+            with open(filename, mode='rb') as config_file:
-import os
+import os
-__version__ = '0.12'
+__version__ = '0.12.1-dev'
-__version__ = '0.12'
+__version__ = '0.13-dev'
-__version__ = '0.11.2-dev'
+__version__ = '0.12'
-        if rv is not _missing:
+        # We return cached JSON only when the cache is enabled.
-                return parse_date(the_value)
+            # Check the key for a corresponding function
-from minitwit import app
+from .minitwit import app
-html_theme_path = ['_themes']
+# html_theme_path = ['_themes']
-    pygments_style = 'flask_theme_support.FlaskyStyle'
+    __import__('flask_sphinx_themes')
-    print('-' * 74)
+    print('Flask theme unavailable; using the default theme.')
-    def test_jsonify_basic_types(self):
+    @pytest.mark.parametrize('test_value', [0, -1, 1, 23, 3.14, 's', "longer string", True, False, None])
-            assert flask.json.loads(rv.data) == d
+
-
+        test_uuid = uuid.UUID(bytes=b'\xDE\xAD\xBE\xEF' * 4)
-# This was the only thing that flask used to export at one point and it had
+# This was the only thing that Flask used to export at one point and it had
-    """Special application that dispatches to a flask application which
+    """Special application that dispatches to a Flask application which
-    it is is recorded and shows as part of the WSGI handling which in case
+    it is recorded and shown as part of the WSGI handling which in case
-    #: This can be used by flask extensions to make a decision in regards
+    #: This can be used by Flask extensions to make a decision in regards
-# The namespace for code signals.  If you are not flask code, do
+# The namespace for code signals.  If you are not Flask code, do
-                done.add(cls)
+            for cls in exc_class.__mro__:
-        :param code: the code as integer for the handler
+        :param code_or_exception: the code as integer for the handler, or
-from flaskr import app
+from .flaskr import app
-from flaskr import app
+from flaskr.flaskr import app
-It loads the application configured (either through the FLASK_APP environment
+It loads the application configured (through the FLASK_APP environment
-from werkzeug.exceptions import BadRequest, NotFound
+from werkzeug.datastructures import Headers, Range
-        headers['Content-Length'] = os.path.getsize(filename)
+        fsize = os.path.getsize(filename)
-            headers['Content-Length'] = os.path.getsize(filename)
+            fsize = os.path.getsize(filename)
-        if conditional:
+    if conditional:
-                rv.headers.pop('x-sendfile', None)
+        # make sure we don't send x-sendfile for servers that
-        #:            return ','.join(BaseConverter.to_url(value)
+        #:            return ','.join(super(ListConverter, self).to_url(value)
-    if add_etags and filename is not None and file is None:
+    if add_etags and filename is not None:
-    :meth:`get` it means you will response to ``'GET'`` requests and
+    :meth:`get` it means it will respond to ``'GET'`` requests and
-from ._compat import string_types, text_type, PY2
+from ._compat import string_types, text_type
-        the request by converting it into a repsonse and invoking the
+        the request by converting it into a response and invoking the
-        with the `from_error_handler` flag.  If enabled failures in
+        with the `from_error_handler` flag.  If enabled, failures in
-            mimetype = mimetypes.guess_type(attachment_filename)[0]
+            mimetype = mimetypes.guess_type(attachment_filename)[0] \
-            assert "Unable to infer MIME-type from filename 'filename'" in str(excinfo)
+            flask.send_file(StringIO("LOL"), attachment_filename='filename')
-        """A decorator that is used to register a function give a given
+        """A decorator that is used to register a function given an
-        return handler(e)
+        return self.finalize_request(handler(e), from_error_handler=True)
-        request_finished.send(self, response=response)
+        try:
-                response = self.make_response(self.handle_exception(e))
+                response = self.handle_exception(e)
-               passthrough_errors=app.config['PROPAGATE_EXCEPTIONS'])
+               use_debugger=debugger, threaded=with_threads)
-                    self._authentication = authentication
+                def __init__(self, *args, **kwargs):
-                    'pass one explicitly.'.format(mimetype_filename)
+                    'Unable to infer MIME-type from filename {0!r}, please '
-
+        with app.test_request_context():
-            # resetted normally.  This makes it possible to restart the server
+            # reset normally.  This makes it possible to restart the server
-        options.setdefault('passthrough_errors', True)
+        options.setdefault('passthrough_errors',
-               passthrough_errors=True)
+               passthrough_errors=app.config['PROPAGATE_EXCEPTIONS'])
-    assert rv['passthrough_errors']
+    # make sure werkzeug passes errors through if PROPAGATE_EXCEPTIONS
-    You must explicitly provide the mimetype for the filename or file object.
+    By default it will try to guess the mimetype for you, but you can
-       will be used.
+       The filename is no longer automatically inferred from file objects. If
-                     auto detection happens.
+    :param mimetype: the mimetype of the file if provided. If a file path is
-        filename = getattr(file, 'name', None)
+        filename = None
-        mimetype = 'application/octet-stream'
+        if attachment_filename is not None:
-            attachment_filename = os.path.basename(filename)
+            raise TypeError('filename unavailable, required for '
-            return flask.send_file(StringIO("party like it's"), last_modified=last_modified)
+            return flask.send_file(StringIO("party like it's"),
-                rv = flask.send_file(f)
+                rv = flask.send_file(f, mimetype='text/html')
-                rv = flask.send_file(f)
+                rv = flask.send_file(f, mimetype='text/html')
-                    os.path.join(app.root_path, 'static/index.html')
+                assert 'x-sendfile' not in rv.headers
-            rv = flask.send_file(f)
+            rv = flask.send_file(f, mimetype='application/octet-stream')
-            rv = flask.send_file(f)
+            rv = flask.send_file(f, attachment_filename=f.name)
-            rv = flask.send_file(f)
+            rv = flask.send_file(f, mimetype='text/html')
-                rv = flask.send_file(f, as_attachment=True)
+                rv = flask.send_file(f, as_attachment=True,
-import pytest
+import pytest
-from context import flaskr
+from minitwit import app
-import minitwit
+from minitwit import minitwit
-from flask._compat import StringIO, text_type, PY2
+from flask._compat import StringIO, text_type
-        test_data = {'lol': 'wut'}
+        test_data = {'name': 'Flask'}
-            rv = flask.json.load(t_fh)
+            flask.json.dump(test_data, out)
-            os.remove('test_json_dump_file')
+
-        app.add_url_rule(url, 'uuid_test', lambda val=test_uuid: flask.jsonify(x=val))
+        app.add_url_rule(url, url, lambda: flask.jsonify(x=test_uuid))
-        assert flask.json.loads(rv.data)['x'] == str(test_uuid)
+
-    find_default_import_path
+    find_default_import_path, get_version
-        kwargs['data'] = json_dumps(kwargs['json'])
+        kwargs['data'] = json_dumps(kwargs.pop('json'))
-def make_test_environ_builder(app, path='/', base_url=None, json=None, *args, **kwargs):
+def make_test_environ_builder(app, path='/', base_url=None, *args, **kwargs):
-    if json is not None:
+    if 'json' in kwargs:
-        kwargs['data'] = json_dumps(json)
+        kwargs['data'] = json_dumps(kwargs['json'])
-    capabilities.
+    """Common mixin for both request and response objects to provide JSON
-        is considered to include JSON data if the mimetype is
+        """Indicates if this request/response is in JSON format or not.  By
-        parsed JSON data.  Otherwise this will be ``None``.
+        """If this request/response is in JSON format then this property will
-                                'Use get_json() instead.'), stacklevel=2)
+        warn(DeprecationWarning(
-                      on the request.
+                      on the object.
-            return rv
+        try:
-        # We accept a request charset against the specification as certain
+        # We accept MIME charset header against the specification as certain
-        """Parses the incoming JSON request data and returns it.  By default
+        """Parses the JSON request/response data and returns it.  By default
-from .globals import _request_ctx_stack
+from .globals import _app_ctx_stack
-        ctx = _request_ctx_stack.top
+        ctx = _app_ctx_stack.top
-        ctx = _request_ctx_stack.top
+        ctx = _app_ctx_stack.top
-        getter = getattr(req, 'get_data', None)
+    def _get_data_for_json(self, cache):
-        return req.data
+        return self.data
-        getter = getattr(req, 'get_data', None)
+    def _get_data_for_json(self, cache):
-        return req.data
+        return self.data
-
+    def _get_data_for_json(req, cache):
-            data = _get_data(self)
+            data = self._get_data_for_json(cache)
-def _get_data(req, cache):
+def _get_data(req):
-        return getter(cache=cache)
+        return getter()
-            data = _get_data(self, cache)
+            data = _get_data(self)
-    return False
+class JSONMixin(object):
-class Request(RequestBase):
+
-class Response(ResponseBase):
+class Response(ResponseBase, JSONMixin):
-        return rv
+def _is_mimetype_json(mimetype):
-        return False
+        return _is_mimetype_json(self.mimetype)
-def test_json_request():
+def test_json_request_and_response():
-        return ''
+    @app.route('/echo', methods=['POST'])
-        assert rv.status_code == 200
+        rv = c.post('/echo', json=json_data)
-            raise RuntimeError('Client cannot provide both `json` and `data`')
+            raise ValueError('Client cannot provide both `json` and `data`')
-    if json:
+    if json is not None:
-            kwargs['headers'] = new_headers
+        if 'content_type' not in kwargs:
-def make_test_environ_builder(app, path='/', base_url=None, *args, **kwargs):
+def make_test_environ_builder(app, path='/', base_url=None, json=None, *args, **kwargs):
-    __import__(module)
+    try:
-    return 'OK'
+from setuptools import setup
-import flaskr
+from context import flaskr
-    class mod:
+    """Test if `find_best_app` behaves as expected with different combinations of input."""
-    assert find_best_app(mod) == mod.app
+    assert find_best_app(Module) == Module.app
-    class mod:
+    class Module:
-    assert find_best_app(mod) == mod.application
+    assert find_best_app(Module) == Module.application
-    class mod:
+    class Module:
-    assert find_best_app(mod) == mod.myapp
+    assert find_best_app(Module) == Module.myapp
-        myapp2 = Flask('appname2')
+    class Module:
-    pytest.raises(NoAppException, find_best_app, mod)
+    class Module:
-            methods = set(rv.methods or [])
+            methods = set(m for b in bases for m in get_methods(b))
-        This also triggers the :meth:`url_value_processor` functions before
+        This also triggers the :meth:`url_value_preprocessor` functions before
-import sys, os
+from datetime import datetime
-sys.path.append(os.path.abspath('.'))
+sys.path.append(os.path.join(os.path.dirname(__file__), '_themes'))
-copyright = u'2015, Armin Ronacher'
+copyright = u'2010 - {0}, Armin Ronacher'.format(datetime.utcnow().year)
-    release = release.split('dev')[0] + 'dev'
+    release = ''.join(release.partition('dev')[:2])
-html_theme = 'flask'
+# html_theme = 'default'
-}
+# html_theme_options = {}
-html_favicon = "flask-favicon.ico"
+html_favicon = '_static/flask-favicon.ico'
-                 'sourcelink.html', 'searchbox.html']
+    'index': [
-   u'Armin Ronacher', 'manual'),
+  ('latexindex', 'Flask.tex', u'Flask Documentation', u'Armin Ronacher', 'manual'),
-    'preamble':     r'\usepackage{flaskstyle}'
+    'fontpkg': r'\usepackage{mathpazo}',
-    'https://pythonhosted.org/blinker/': None
+    'python': ('https://docs.python.org/3/', None),
-except ImportError as e:
+    pygments_style = 'flask_theme_support.FlaskyStyle'
-    :param add_version_option: adds the :option:`--version` option.
+    :param add_version_option: adds the ``--version`` option.
-    # Extra startup messages.  This depends a but on Werkzeug internals to
+    # Extra startup messages.  This depends a bit on Werkzeug internals to
-def test_with_appcontext():
+def test_with_appcontext(runner):
-def test_appgroup():
+def test_appgroup(runner):
-def test_flaskgroup():
+def test_flaskgroup(runner):
-    def test_no_route(self, monkeypatch):
+    def test_no_route(self, runner, monkeypatch):
-    def test_simple_route(self, monkeypatch):
+    def test_simple_route(self, runner, monkeypatch):
-    def test_only_POST_route(self, monkeypatch):
+    def test_only_POST_route(self, runner, monkeypatch):
-        runner = CliRunner()
+    max_rule = max(max_rule, len('Route'))
-from flask.cli import AppGroup, FlaskGroup, NoAppException, ScriptInfo, \
+from flask.cli import cli, AppGroup, FlaskGroup, NoAppException, ScriptInfo, \
-               use_debugger=debugger, threaded=with_threads)
+               use_debugger=debugger, threaded=with_threads,
-    from itsdangerous import json as _json
+from itsdangerous import json as _json
-        rv['passthrough_errors'] = kwargs.get('passthrough_errors')
+        pass
-        :param root_path: set an alternate root path for this blueprint
+        """Registers a blueprint on the application.
-# happened until the next bytecode instruction?
+# breaks the __exit__ function in a very peculiar way.  The second level of
-            sys.exc_clear()
+            if hasattr(sys, 'exc_clear'):
-        kwargs.setdefault('cls', bp.json_encoder if bp else current_app.json_encoder)
+        bp = current_app.blueprints.get(request.blueprint,
-        kwargs.setdefault('cls', bp.json_decoder if bp else current_app.json_decoder)
+        bp = current_app.blueprints.get(request.blueprint,
-        with app.test_request_context():
+        with app.app_context():
-        with app.test_request_context():
+        with app.app_context():
-        kwargs.setdefault('cls', current_app.json_encoder)
+        bp = current_app.blueprints.get(request.blueprint, None)
-        kwargs.setdefault('cls', current_app.json_decoder)
+        bp = current_app.blueprints.get(request.blueprint, None)
-        with app.app_context():
+        with app.test_request_context():
-        with app.app_context():
+        with app.test_request_context():
-__version__ = '0.11.1'
+__version__ = '0.11.2-dev'
-__version__ = '0.12-dev'
+__version__ = '0.11.1'
-    find_best_app, locate_app, with_appcontext, prepare_exec_for_file
+    find_best_app, locate_app, with_appcontext, prepare_exec_for_file, \
-                          the input file was last modified.
+    :param last_modified: set the ``Last-Modified`` header to this value,
-            rv.last_modified = last_modified.timestamp()
+        rv.last_modified = last_modified
-        rv.last_modified = int(mtime)
+        rv.last_modified = mtime
-            rv.close()
+        last_modified = datetime.datetime(1999, 1, 1)
-from ._compat import string_types, text_type
+from ._compat import string_types, text_type, PY2
-              cache_timeout=None, conditional=False):
+              cache_timeout=None, conditional=False, last_modified=None):
-    if mtime is not None:
+    if last_modified is not None:
-from flask._compat import StringIO, text_type
+from flask._compat import StringIO, text_type, PY2
-    assert prepare_exec_for_file('/usr/share/__init__.py') == 'share'
+    """Expect the correct path to be set and the correct module name to be returned.
-        prepare_exec_for_file('test.txt')
+        prepare_exec_for_file('/tmp/share/test.txt')
-from werkzeug.exceptions import BadRequest
+from werkzeug.exceptions import BadRequest, NotFound
-    """Safely join `directory` and `filename`.
+def safe_join(directory, *pathnames):
-             would fall out of `directory`.
+    :param directory: the trusted base directory.
-        if sep in filename:
+    for filename in pathnames:
-    return os.path.join(directory, filename)
+        directory = os.path.join(directory, filename)
-    elif os.path.split(filename)[1] == '__init__.py':
+    if os.path.split(filename)[1] == '__init__.py':
-    find_best_app, locate_app, with_appcontext
+    find_best_app, locate_app, with_appcontext, prepare_exec_for_file
-    elif os.path.split(filename)[1] == '__init__.py':
+    if os.path.split(filename)[1] == '__init__.py':
-    find_best_app, locate_app, with_appcontext
+    find_best_app, locate_app, with_appcontext, prepare_exec_for_file
-    provided.
+    You must explicitly provide the mimetype for the filename or file object.
-    if add_etags and filename is not None:
+    if add_etags and filename is not None and file is None:
-    def test_send_file_object(self, recwarn):
+    def test_send_file_object(self):
-    def test_attachment(self, recwarn):
+    def test_attachment(self):
-
+import gc
-            rv.close()
+            with open(os.path.join(app.root_path, 'static/index.html'), mode='rb') as f:
-            rv.close()
+            with open(os.path.join(app.root_path, 'static/index.html')) as f:
-            rv.close()
+            with open(os.path.join(app.root_path, 'static/index.html')) as f:
-        recwarn.clear()
+        recwarn.pop(DeprecationWarning)
-        recwarn.pop()
+        recwarn.pop(DeprecationWarning)
-            recwarn.pop()
+            recwarn.pop(DeprecationWarning)
-            recwarn.pop()
+            a = recwarn.pop(DeprecationWarning)
-            recwarn.pop()
+            recwarn.pop(DeprecationWarning)
-        recwarn.pop()
+        recwarn.pop(DeprecationWarning)
-    return lambda: warnings.catch_warnings(record=True)
+@pytest.yield_fixture(autouse=True)
-        app = flask.Flask(__name__, static_path='/foo')
+def test_static_path_deprecated(recwarn):
-    def test_request_json(self, catch_deprecation_warnings):
+    def test_request_json(self, recwarn):
-            c.post('/', data='{"spam": 42}', content_type='application/json')
+        c = app.test_client()
-    def test_request_module(self, catch_deprecation_warnings):
+    def test_request_module(self, recwarn):
-        assert len(captured) == 1
+        c = app.test_client()
-    def test_send_file_xsendfile(self):
+    def test_send_file_xsendfile(self, catch_deprecation_warnings):
-    def test_send_file_object(self, catch_deprecation_warnings):
+    def test_send_file_object(self, recwarn):
-            assert len(captured) == 2
+
-            assert len(captured) == 2
+
-                rv.close()
+            f = StringIO('Test')
-                rv.close()
+            recwarn.pop()
-                rv.close()
+            recwarn.pop()
-            assert len(captured) == 1
+            recwarn.pop()
-            assert len(captured) == 2
+
-        Objects are usually either modules or classes.
+        Objects are usually either modules or classes. :meth:`from_object`
-        Example usage::
+        Example of module-based configuration::
-
+ Ready for production? `Read this first <http://flask.pocoo.org/docs/deploying/>`.
-        'python_version': sys.version[:3],
+        'python_version': sys.version,
-
+from . import __version__
-        AppGroup.__init__(self, **extra)
+    def __init__(self, add_default_commands=True, create_app=None,
-        print line
+        print(line)
-    print >> sys.stderr, 'Error:', message % args
+    print('Error:', message % args, file=sys.stderr)
-    print >> sys.stderr, message % args
+    print(message % args, file=sys.stderr)
-  %(prefix)s%(cmd)s FLASK_APP=hello
+  %(prefix)s%(cmd)s FLASK_APP=hello.py
-            .format(x=modname), ExtDeprecationWarning
+            .format(x=modname), ExtDeprecationWarning, stacklevel=2
-    'https://wtforms.readthedocs.org/en/latest/': None,
+    'https://wtforms.readthedocs.io/en/latest/': None,
-__version__ = '0.11'
+__version__ = '0.12-dev'
-__version__ = '0.11.dev0'
+__version__ = '0.11'
-        rv = _app_ctx_stack.pop()
+        try:
-            app_ctx.pop(exc)
+        try:
-    to click.
+    to click.  In future versions of Flask this object will most likely play
-            self.app_import_path = None
+            app_import_path = None
-                                     'environment variable.')
+            if not self.app_import_path:
-     locked_cached_property, _endpoint_from_view_func, find_package
+     locked_cached_property, _endpoint_from_view_func, find_package, \
-        'DEBUG':                                False,
+        'DEBUG':                                get_debug_flag(default=False),
-        self.debug = debug
+    def __init__(self, app_import_path=None, create_app=None):
-                                     '--app parameter.')
+                                     'You did not provide the FLASK_APP '
-            rv.debug = self.debug
+        debug = get_debug_flag()
-        AppGroup.__init__(self, params=params, **extra)
+    def __init__(self, add_default_commands=True, create_app=None, **extra):
-
+
-        reload = info.debug
+        reload = bool(debug)
-        debugger = info.debug
+        debugger = bool(debug)
-               passthrough_errors=True)
+               use_debugger=debugger, threaded=with_threads)
-by the application or Flask itself.
+variable) and then provides commands either provided by the application or
-""")
+\b
-from datetime import timedelta
+def get_debug_flag(default=None):
-    find_best_app, locate_app, script_info_option, with_appcontext
+    find_best_app, locate_app, with_appcontext
-    "Make sure the CLI object's name is the app's name and not the app itself"
+    """Make sure the CLI object's name is the app's name and not the app itself"""
-    .. versionadded:: 1.0
+    .. versionadded:: 0.11
-    #: .. versionadded:: 1.0
+    #: .. versionadded:: 0.11
-    #: .. versionadded:: 1.0
+    #: .. versionadded:: 0.11
-        #: .. versionadded:: 1.0
+        #: .. versionadded:: 0.11
-        .. versionchanged:: 1.0
+        .. versionchanged:: 0.11
-        .. versionadded:: 1.0
+        .. versionadded:: 0.11
-        .. versionchanged:: 1.0
+        .. versionchanged:: 0.11
-        .. versionadded:: 1.0
+        .. versionadded:: 0.11
-        .. versionadded:: 1.0
+        .. versionadded:: 0.11
-        .. versionadded:: 1.0
+        .. versionadded:: 0.11
-        .. versionadded:: 1.0
+        .. versionadded:: 0.11
-        .. versionadded:: 1.0
+        .. versionadded:: 0.11
-        .. versionadded:: 1.0
+        .. versionadded:: 0.11
-    .. versionchanged:: 1.0
+    .. versionchanged:: 0.11
-        .. versionadded:: 1.0
+        .. versionadded:: 0.11
-        .. versionadded:: 1.0
+        .. versionadded:: 0.11
-        """Registers a blueprint on the application.
+        """Register a blueprint on the application. For information about 
-        explain = self.app.config['EXPLAIN_TEMPLATE_LOADING']
+        if self.app.config['EXPLAIN_TEMPLATE_LOADING']:
-        tmplrv = None
+        trv = None
-                    break
+                if trv is None:
-            explain_template_loading_attempts(self.app, template, attempts)
+        from .debughelpers import explain_template_loading_attempts
-            return tmplrv
+    def _get_source_fast(self, environment, template):
-                               force_external=external)
+        try:
-            gc.collect()
+        gc.collect()
-    print '[EXTTEST]', msg % args
+    print('[EXTTEST] ' + (msg % args))
-    print 'Results written to', filename
+    print('Results written to {}'.format(filename))
-        self.cli = cli.AppGroup(self)
+        self.cli = cli.AppGroup(self.name)
-    about how to use this class refer to :class:`werkzeug.test.Client`.
+    end of a ``with`` body when used in a ``with`` statement.  For general
-        """When used in combination with a with statement this opens a
+        """When used in combination with a ``with`` statement this opens a
-        the test client uses.  Once the with block is left the session is
+        the test client uses.  Once the ``with`` block is left the session is
-        but this can be overridden by the `force` parameter.
+        """Parses the incoming JSON request data and returns it.  By default
-
+from __future__ import print_function
-              'flaskdocext']
+extensions = [
-    print 'metadata.  A virtualenv is recommended!'
+    print('Flask must be installed to build the documentation.')
-    print '-' * 74
+except ImportError as e:
-        mimetype='application/json'
+        mimetype=current_app.config['JSONIFY_MIMETYPE']
-    #: A for which methods this pluggable view can handle.
+    #: A list of methods this view can handle.
-        :attr:`debug` flag is set the server will automatically reload
+        """Runs the application on a local development server.
-  <http://github.com/mitsuhiko/flask/zipball/master#egg=Flask-dev>`_
+  <http://github.com/pallets/flask/zipball/master#egg=Flask-dev>`_
-    url='http://github.com/mitsuhiko/flask/',
+    url='http://github.com/pallets/flask/',
-from werkzeug.exceptions import NotFound
+from werkzeug.exceptions import BadRequest, NotFound
-        raise NotFound()
+    try:
-        if fullname.startswith(self.prefix):
+        if fullname.startswith(self.prefix) and \
-            gen = generator_or_function()
+            gen = generator_or_function(*args, **kwargs)
-                yield 'Hello '
+            def generate(hello):
-            return flask.Response(generate())
+            return flask.Response(generate('Hello '))
-    Popen([sys.executable, 'setup.py', 'release', 'sdist', 'upload']).wait()
+    Popen([sys.executable, 'setup.py', 'release', 'sdist', 'bdist_wheel', 'upload']).wait()
-            assert False, 'expected exception'
+        e = pytest.raises(RuntimeError, f, *args, **kwargs)
-        assert False, 'Expected exception'
+    with pytest.raises(KeyError) as e:
-        try:
+        with pytest.raises(DebugFilesKeyError) as e:
-            assert False, 'Expected exception'
+        assert 'no file contents were transmitted' in str(e.value)
-            try:
+            with pytest.raises(Exception):
-    try:
+    with pytest.raises(AssertionError) as e:
-        assert False, 'Expected exception'
+    assert 'A setup function was called' in str(e)
-        try:
+        with pytest.raises(AssertionError) as e:
-            assert False, 'Expected exception'
+        assert 'http://localhost/foo/' in str(e)
-        try:
+        with pytest.raises(TemplateNotFound) as e:
-            assert 0, 'expected exception'
+        assert e.value.name == 'missing.html'
-        try:
+        with pytest.raises(RuntimeError) as e:
-            assert 0, 'expected exception'
+        assert "'FOO_SETTINGS' is not set" in str(e.value)
-        try:
+        with pytest.raises(IOError) as e:
-            assert False, 'expected IOError'
+        msg = str(e.value)
-    try:
+    with pytest.raises(IOError) as e:
-        assert 0, 'expected config'
+    msg = str(e.value)
-    try:
+    with pytest.raises(IOError) as e:
-        assert 0, 'expected config'
+    msg = str(e.value)
-    try:
+    with pytest.raises(RuntimeError):
-        try:
+        with pytest.raises(RuntimeError) as e:
-            assert False, 'Expected runtime error'
+        assert 'Session backend did not open a session' in str(e.value)
-    try:
+    with pytest.raises(RuntimeError) as e:
-        assert False, 'Expected runtime error'
+    assert 'cookies' in str(e.value)
-        #: :meth:`after_request` decorator.
+        #: example be used to close database connections. To register a function
-        support.
+        be using the :command:`flask` command line script's ``run`` support.
-        #: example be used to open database connections or getting hold of the
+        #: example be used to close database connections or getting hold of the
-        The resulting dictionary `image_store` would look like::
+        The resulting dictionary `image_store_config` would look like::
-        self.__dict__.setdefault(name, default)
+        return self.__dict__.setdefault(name, default)
-    fp.write(unicode(htmlsafe_dumps(obj, **kwargs)))
+    fp.write(text_type(htmlsafe_dumps(obj, **kwargs)))
-       and not request.is_xhr:
+    if current_app.config['JSONIFY_PRETTYPRINT_REGULAR'] and not request.is_xhr:
-        )
+        raise TypeError('jsonify() behavior undefined when passed both args and kwargs')
-    rv = current_app.response_class(
+    return current_app.response_class(
-    return rv
+        mimetype='application/json'
-    :func:`dumps`.
+       :func:`dumps`.
-    :func:`dumps`.
+       :func:`dumps`.
-       security risk in ancient browsers. See :ref:`json_security` for details.
+       security risk in ancient browsers. See :ref:`json-security` for details.
-    elif len(args) == 1: # single args are passed directly to dumps()
+    elif len(args) == 1:  # single args are passed directly to dumps()
-        data = dict(kwargs)
+    else:
-    constructor.
+    """This function wraps :func:`dumps` to add a few enhancements that make
-    information about this, have a look at :ref:`json-security`.
+
-         '\n'),
+        (dumps(data, indent=indent, separators=separators), '\n'),
-        d = dict(a=23, b=42, c=[1, 2, 3])
+    def test_json_as_unicode(self):
-    def test_json_as_unicode(self):
+    def test_jsonify_arrays(self):
-            assert rv == '"\\u2603"'
+    def test_jsonify_date_types(self):
-            assert rv == u'"\u2603"'
+        test_dates = (
-            rv.set_etag('flask-%s-%s-%s' % (
+            rv.set_etag('%s-%s-%s' % (
-        request handling is stopped.
+        """Called before the request dispatching.
-        the actual :meth:`before_request` functions are called.
+        Triggers two set of hook functions that should be invoked prior to request dispatching:
-               use_debugger=debugger, threaded=with_threads)
+               use_debugger=debugger, threaded=with_threads,
-from redbaron import RedBaron
+redbaron = pytest.importorskip("redbaron")
-    red = RedBaron("from flask.ext import foo")
+    red = redbaron.RedBaron("from flask.ext import foo")
-    red = RedBaron("from flask.ext.foo import bar")
+    red = redbaron.RedBaron("from flask.ext.foo import bar")
-    red = RedBaron("from flask.ext.foo import bar, foobar, something")
+    red = redbaron.RedBaron("from flask.ext.foo import bar, foobar, something")
-    red = RedBaron("from flask.ext.foo import \
+    red = redbaron.RedBaron("from flask.ext.foo import \
-    red = RedBaron("import flask.ext.foo")
+    red = redbaron.RedBaron("import flask.ext.foo")
-    red = RedBaron("import flask.ext.foo as foobar")
+    red = redbaron.RedBaron("import flask.ext.foo as foobar")
-    red = RedBaron("from flask.ext.foo import bar as baz")
+    red = redbaron.RedBaron("from flask.ext.foo import bar as baz")
-    red = RedBaron("from flask.ext.foo import (bar, foo, foobar)")
+    red = redbaron.RedBaron("from flask.ext.foo import (bar, foo, foobar)")
-    red = RedBaron("flask.ext.foo(var)")
+    red = redbaron.RedBaron("flask.ext.foo(var)")
-    red = RedBaron("import flask.ext.foo\n\n"
+    red = redbaron.RedBaron("import flask.ext.foo\n\n"
-    red = RedBaron("from flask import Flask")
+    red = redbaron.RedBaron("from flask import Flask")
-        function accepts the same arguments).
+        function accepts the same arguments plus two additional).
-def make_test_environ_builder(app, path='/', base_url=None, *args, **kwargs):
+def make_test_environ_builder(app, path='/', base_url=None, subdomain=None,
-    app_root = app.config.get('APPLICATION_ROOT')
+    assert not (base_url or subdomain or url_scheme) \
-        base_url = 'http://%s/' % (url.netloc or http_host or 'localhost')
+        base_url = '%s://%s/' % (url_scheme, url.netloc or http_host or 'localhost')
-    #: 3. Return None instead of AttributeError on expected attributes.
+    #: 3. Return None instead of AttributeError on unexpected attributes.
-        # Some python versions will will clean up modules so early that the
+        # Some python versions will clean up modules so early that the
-        'SEND_FILE_MAX_AGE_DEFAULT':            12 * 60 * 60,  # 12 hours
+        'SEND_FILE_MAX_AGE_DEFAULT':            timedelta(hours=12),
-        return current_app.config['SEND_FILE_MAX_AGE_DEFAULT']
+        return total_seconds(current_app.send_file_max_age_default)
-
+from datetime import timedelta
-from collections import Mapping, deque
+from collections import deque
-from ._compat import reraise, string_types, text_type, integer_types, iterkeys
+from ._compat import reraise, string_types, text_type, integer_types
-    def add_url_rule(self, rule, endpoint=None, view_func=None, **options):
+    def add_url_rule(self, rule, endpoint=None, view_func=None,
-
+        if provide_automatic_options is None:
-    return type.__new__(metaclass, 'temporary_class', (object,), {})
+    class metaclass(type):
-    # __init__ comes back from type etc.).
+    # itself with the actual metaclass.
-    return metaclass('temporary_class', None, {})
+    constructor = lambda c, name, b, dct: meta(name, bases, dct)
-                    raise exc_type(exc_value, endpoint, values).with_traceback(tb)
+                    raise exc_type, exc_value, tb
-                pass
+            except BuildError as e:
-                    raise exc_type, exc_value, tb
+                    raise exc_type(exc_value, endpoint, values).with_traceback(tb)
-            'provide_automatic_options', None)
+        provide_automatic_options = options.pop(
-        template name.
+        template name. If no template name is given, returns `True`.
-            return False
+            return True
-    with the given context.
+    with the given context. Template variables will be autoescaped.
-            '{{ foo }}', foo='<test>') == '<test>'
+            '{{ foo }}', foo='<test>') == '&lt;test&gt;'
-        
+
-        
+
-    
+
-        
+
-        
+
-        
+
-        
+
-        
+
-
+    def pop(self, name, default=_sentinel):
-                           'returned data')
+    """Renders the template and fires the signal"""
-            return first_resp[1]
+    overrides = [rv for _, rv in brt_resp if rv is not None]
-        assert rv.data == 'Not template string'
+        assert rv.data == b'Not template string'
-    with flask.before_render_template.connected_to(record):
+    flask.before_render_template.connect(record, app)
-    with flask.before_render_template.connected_to(record):
+    flask.before_render_template.connect(record, app)
-    before_render_template.send(app, template=template, context=context)
+    """Renders the template and fires signals.
-message_flashed = _signals.signal('message-flashed')
+message_flashed = _signals.signal('message-flashed')
-    try:
+    with flask.before_render_template.connected_to(record):
-        flask.before_render_template.disconnect(record, app)
+
-     appcontext_popped, message_flashed
+     appcontext_popped, message_flashed, before_render_template
-message_flashed = _signals.signal('message-flashed')
+message_flashed = _signals.signal('message-flashed')
-from .signals import template_rendered
+from .signals import template_rendered, before_render_template
-    flask.run
+    flask.cli
-    static_folder = property(_get_static_folder, _set_static_folder)
+    static_folder = property(_get_static_folder, _set_static_folder, doc='''
-                           of data to send before calling :func:`send_file`.
+    :param filename_or_fp: the filename of the file to send in `latin-1`.
-    jinja_env_class = Environment
+    jinja_environment = Environment
-        rv = self.jinja_env_class(self, **options)
+        rv = self.jinja_environment(self, **options)
-        jinja_env_class = CustomEnvironment
+        jinja_environment = CustomEnvironment
-    #: .. versionadded:: 0.11
+    #: .. versionadded:: 1.0
-        .. versionadded:: 0.11
+        .. versionadded:: 1.0
-        .. versionadded:: 0.11
+        .. versionadded:: 1.0
-            while True:
+            while queue:
-        folder named ``'static'``.
+        folder for static files.
-    the default simplejson encoder.  Consult the :mod:`json` documentation
+    the default simplejson decoder.  Consult the :mod:`json` documentation
-        If neither blueprint nor App has a suitable handler registered, returns None
+        Otherwise falls back to the app, returns None if not a suitable
-import imp
+import types
-        d = imp.new_module('config')
+        d = types.ModuleType('config')
-    ext_module = imp.new_module('flask.ext')
+    ext_module = types.ModuleType('flask.ext')
-            if x.level == 0 and app.debug:
+        def getEffectiveLevel(self):
-            return Logger.getEffectiveLevel(x)
+            return Logger.getEffectiveLevel(self)
-	app = flask.Flask(__name__)
+    app = flask.Flask(__name__)
-		pass
+    class ParentException(Exception):
-		pass
+    class ChildExceptionUnregistered(ParentException):
-		pass
+    class ChildExceptionRegistered(ParentException):
-		return 'parent'
+    @app.errorhandler(ParentException)
-		return 'child-registered'
+    @app.errorhandler(ChildExceptionRegistered)
-		raise ParentException()
+    @app.route('/parent')
-		raise ChildExceptionUnregistered()
+    @app.route('/child-unregistered')
-		raise ChildExceptionRegistered()
+    @app.route('/child-registered')
-	assert c.get('/child-registered').data == b'child-registered'
+    assert c.get('/parent').data == b'parent'
-		pass
+    app = flask.Flask(__name__)
-		pass
+    class ForbiddenSubclassRegistered(Forbidden):
-		return 'forbidden'
+    class ForbiddenSubclassUnregistered(Forbidden):
-		return 'forbidden-registered'
+    @app.errorhandler(403)
-		raise Forbidden()
+    @app.errorhandler(ForbiddenSubclassRegistered)
-		raise ForbiddenSubclassRegistered()
+    @app.route('/forbidden')
-		raise ForbiddenSubclassUnregistered()
+    @app.route('/forbidden-registered')
-	c = app.test_client()
+    c = app.test_client()
-	assert c.get('/forbidden-registered').data == b'forbidden-registered'
+    assert c.get('/forbidden').data == b'forbidden'
-	assert c.get('/bp/error').data == b'bp-error'
+    bp = flask.Blueprint('bp', __name__)
-from collections import Mapping
+from collections import Mapping, deque
-        def find_superclass(handler_map):
+
-                handler = handler_map.get(superclass)
+                return
-                    handler_map[exc_class] = handler  # cache for next time exc_class is raised
+                    # cache for next time exc_class is raised
-        
+
-        
+        handler = find_handler(self.error_handler_spec
-        
+
-        return find_superclass(self.error_handler_spec[None].get(code))
+        return find_handler(self.error_handler_spec[None].get(code))
-        """ensure that we register only exceptions as handler keys"""
+        """Ensure that we register only exceptions as handler keys"""
-            if not d:
+        def find_superclass(handler_map):
-            for superclass in exc_class.mro():
+            for superclass in exc_class.__mro__:
-                handler = d.get(superclass)
+                handler = handler_map.get(superclass)
-                    d[exc_class] = handler  # cache for next time exc_class is raised
+                    handler_map[exc_class] = handler  # cache for next time exc_class is raised
-    def _ensure_exc_class(exc_class_or_code):
+    def _get_exc_class_and_code(exc_class_or_code):
-            exc_class = type(exc_class_or_code)
+            exc_class = exc_class_or_code
-        exc_class, code = self._ensure_exc_class(code_or_exception)
+        exc_class, code = self._get_exc_class_and_code(code_or_exception)
-        exc_class, code = self._ensure_exc_class(e)
+        exc_class, code = self._get_exc_class_and_code(type(e))
-        self._error_handlers = ExceptionHandlerDict(self, None)
+        self._error_handlers = {}
-        handlers = self.error_handler_spec.setdefault(key, ExceptionHandlerDict(self, key))
+        exc_class, code = self._ensure_exc_class(code_or_exception)
-        handlers[code_or_exception] = f
+        handlers = self.error_handler_spec.setdefault(key, {}).setdefault(code, {})
-        If nether blueprint nor App has a suitable handler registered, returns None
+        If neither blueprint nor App has a suitable handler registered, returns None
-        return handlers.find_handler(e)
+        exc_class, code = self._ensure_exc_class(e)
-        handler = self.error_handler_spec[None].get(500)
+        handler = self._find_error_handler(InternalServerError())
-        assert not isinstance(code_or_exception, HTTPException)  # old broken behavior
+        if isinstance(code_or_exception, HTTPException):  # old broken behavior
-    def get_class(self, exc_class_or_code):
+    @staticmethod
-
+from collections import Mapping
-from ._compat import reraise, string_types, text_type, integer_types
+from ._compat import reraise, string_types, text_type, integer_types, iterkeys
-class ExceptionHandlerDict(ChainMap):
+class ExceptionHandlerDict(Mapping):
-        init = super(ExceptionHandlerDict, self).__init__
+        self.data = {}
-            init({}, app.error_handler_spec[None])
+            self.fallback = app.error_handler_spec[None]
-            init({})
+            self.fallback = {}
-        return super(ExceptionHandlerDict, self).__contains__(self.get_class(e_or_c))
+        clazz = self.get_class(e_or_c)
-        return super(ExceptionHandlerDict, self).__getitem__(self.get_class(e_or_c))
+        clazz = self.get_class(e_or_c)
-        return super(ExceptionHandlerDict, self).__setitem__(self.get_class(e_or_c), handler)
+        self.data[self.get_class(e_or_c)] = handler
-     MethodNotAllowed, BadRequest
+     MethodNotAllowed, BadRequest, default_exceptions
-        self._error_handlers = {}
+        self._error_handlers = ExceptionHandlerDict(self, None)
-            assert code_or_exception != 500 or key is None, \
+        """
-                .append((code_or_exception, f))
+        
-            handler = self.error_handler_spec[None].get(e.code)
+        
-
+        
-        reraise(exc_type, exc_value, tb)
+        handler = self._find_error_handler(e)
-        rv = Environment(self, **options)
+        rv = self.jinja_env_class(self, **options)
-    def apprunner(configkey):
+    def apprunner(config_key):
-            c.get('/')
+def test_exception_propagation():
-        assert c.get('/').status_code == 500
+        @app.route('/')
-    # is not torn down.  This causes other tests that run after this fail
+    # we have to run this test in an isolated thread because if the
-        flask._app_ctx_stack.pop()
+    for config_key in 'TESTING', 'PROPAGATE_EXCEPTIONS', 'DEBUG', None:
-        app.config['LOGGER_HANDLER_POLICY'] = 'never'
+@pytest.mark.parametrize('config_key',
-            assert c.get('/').status_code == 500
+    @app.route('/')
-        t.join()
+    if config_key is not None:
-    def do_teardown_request(self, exc=None):
+    def do_teardown_request(self, exc=_sentinel):
-        if exc is None:
+        if exc is _sentinel:
-    def do_teardown_appcontext(self, exc=None):
+    def do_teardown_appcontext(self, exc=_sentinel):
-        if exc is None:
+        if exc is _sentinel:
-    def pop(self, exc=None):
+    def pop(self, exc=_sentinel):
-            if exc is None:
+            if exc is _sentinel:
-    def pop(self, exc=None):
+    def pop(self, exc=_sentinel):
-            if exc is None:
+            if exc is _sentinel:
-                return None
+        if self._static_url_path is not None:
-from .globals import _request_ctx_stack, current_app
+from .globals import _request_ctx_stack
-                raise BadRequest('Failed to decode JSON object: {0}'.format(e))
+        if ctx is not None and ctx.app.config.get('DEBUG', False):
-                raise BadRequest('Failed to decode JSON object: {}'.format(e))
+                raise BadRequest('Failed to decode JSON object: {0}'.format(e))
-                raise BadRequest('No JSON object could be decoded')
+                raise BadRequest('Failed to decode JSON object: {}'.format(e))
-        assert b'No JSON object could be decoded' in rv.data
+        assert b'Failed to decode JSON object' in rv.data
-        assert b'No JSON object could be decoded' not in rv.data
+        assert b'Failed to decode JSON object' not in rv.data
-                raise BadRequest(e)
+                raise BadRequest('No JSON object could be decoded')
-    def test_post_empty_json_adds_exception_to_reponse_content_in_debug(self):
+    def test_post_empty_json_adds_exception_to_response_content_in_debug(self):
-        assert 'No JSON object could be decoded' in rv.data
+        assert b'No JSON object could be decoded' in rv.data
-    def test_post_empty_json_doesnt_add_exception_to_reponse_if_no_debug(self):
+    def test_post_empty_json_wont_add_exception_to_response_if_no_debug(self):
-        assert 'No JSON object could be decoded' not in rv.data
+        assert b'No JSON object could be decoded' not in rv.data
-        assert '<p>No JSON object could be decoded</p>' in rv.data
+        assert 'No JSON object could be decoded' in rv.data
-        assert '<p>No JSON object could be decoded</p>' not in rv.data
+        assert 'No JSON object could be decoded' not in rv.data
-            raise BadRequest()
+        ctx = _request_ctx_stack.top
-
+from .globals import _request_ctx_stack, current_app
-        raise BadRequest(e)
+        if current_app.config['DEBUG']:
-        raise BadRequest()
+        raise BadRequest(e)
-def test__named_from_import():
+def test_named_from_import():
-#
+# format.
-                package = node.value[0].value[2]
+                package = node.value[0].value[2].value
-                node.replace("import flask_%s as %s" % (package, name))
+                if name == package:
-                node.replace("flask_%s%s" % (node.value[3], node.value[3]))
+                params = _form_function_call(node)
-    assert output == "import flask_foo as foo"
+    assert output == "import flask_foo"
-                node.replace("flask_foo%s" % node.value[3])
+                node.replace("flask_%s%s" % (node.value[3], node.value[3]))
-                imports[x].replace("import flask_%s as %s" % (package, name))
+            if (node.value[0].value[0].value == 'flask' and
-    Takes a list of modules and converts into a string
+    Takes a list of modules and converts into a string.
-def fix(ast):
+def fix_tester(ast):
-    return fix_imports(ast).dumps()
+    ast = fix_imports(ast)
-if __name__ == "__main__":
+def fix():
-    output = migrate.fix(red)
+    output = migrate.fix_tester(red)
-    output = migrate.fix(red)
+    output = migrate.fix_tester(red)
-    output = migrate.fix(red)
+    output = migrate.fix_tester(red)
-    output = migrate.fix(red)
+    output = migrate.fix_tester(red)
-    assert output == "import flask_foo"
+    output = migrate.fix_tester(red)
-def test_module_import():
+def test_named_module_import():
-    output = migrate.fix(red)
+    output = migrate.fix_tester(red)
-    output = migrate.fix(red)
+    output = migrate.fix_tester(red)
-                                 % (package, r.format(*modules)[:-1]))
+                                 % (package, module_string))
-                                 % (package, modules.pop(), name))
+                                 % (package, module_string, name))
-    """Wrapper which allows for testing when not running from shell"""
+    """Wrapper which allows for testing when not running from shell."""
-        sys.exit("No filename was included, please try again.")
+    check_user_input()
-        values = from_imports[x].value
+    for x, node in enumerate(from_imports):
-            if len(from_imports[x].value) == 3:
+            if len(node.value) == 3:
-                                        % (package, r.format(*modules)[:-1]))
+                modules = node.modules()
-                                        % (module, module))
+                module = node.modules()[0]
-        values = imports[x].value
+    for x, node in enumerate(imports):
-                imports[x].replace("import flask_%s" % package)
+            if (node.value[0].value == 'flask' and
-
+import sys
-    assert output == "from flask_foo import bar"
+    assert output == "from flask_foo import bar as bar"
-    fix(input_file)
+    ast = read_source(input_file)
-    old_file = open(sys.arv[1])
+# Tester for the flaskext_migrate.py module located in flask/scripts/
-    write_source(new_ast, input_file)
+def fix(ast):
-    input_file = sys.argv[1]
+def fix(input_file):
-# CASE 2 - from flask.ext import foo --> import flask_foo as foo
+# Script which modifies source code away from the deprecated "flask.ext"
-                print modules
+import flask.ext.foo
-    red = RedBaron(source_code.read())
+def read_source(input_file):
-#     source_code.write(red.dumps())
+def write_source(red, input_file):
-from flask.ext.foo import bam
+from flask.ext.foo import \
-    old_file = open(sys.arv[1])
+    old_file = open(sys.arv[1])
-# import flask.ext.foo => import flask_foo
+# CASE 1 - from flask.ext.foo import bam --> from flask_foo import bam
-                        import_statement)
+with open("test.py", "r") as source_code:
-    new_file.close()
+print red.dumps()
-    migrate(old_file)
+# with open("code.py", "w") as source_code:
-            abort(404)
+    Please never pass filenames to this function from user sources;
-    def before_request():
+    def before_request1():
-    assert not evts
+    assert evts == [1, 2]
-    assert rv == 'hello'
+    assert rv == b'hello'
-from setuptools import Command, setup
+import re
-    version='0.11.dev0',
+    version=version,
-__version__ = '0.11-dev'
+__version__ = '0.11.dev0'
-    version='0.11-dev',
+    version='0.11.dev0',
-        """Registers a function to run before each request."""
+        """Registers a function to run before each request.
-        If any of these function returns a value it's handled as
+        call each :meth:`before_request` decorated function, passing no
-           immediately.  Instead if will keep it alive so that the interactive
+           immediately.  Instead it will keep it alive so that the interactive
-from datetime import datetime
+from datetime import date
-            return http_date(o)
+        if isinstance(o, date):
-copyright = u'2014, Armin Ronacher'
+copyright = u'2015, Armin Ronacher'
-    :copyright: (c) 2014 by Armin Ronacher.
+    :copyright: (c) 2015 by Armin Ronacher.
-    :copyright: (c) 2014 by Armin Ronacher.
+    :copyright: (c) 2015 by Armin Ronacher.
-    :copyright: (c) 2014 by Armin Ronacher.
+    :copyright: (c) 2015 by Armin Ronacher.
-    :copyright: (c) 2014 by Armin Ronacher.
+    :copyright: (c) 2015 by Armin Ronacher.
-    :copyright: (c) 2014 by Armin Ronacher.
+    :copyright: (c) 2015 by Armin Ronacher.
-    :copyright: (c) 2014 by Armin Ronacher.
+    :copyright: (c) 2015 by Armin Ronacher.
-    :copyright: (c) 2014 by Armin Ronacher.
+    :copyright: (c) 2015 by Armin Ronacher.
-    :copyright: (c) 2014 by Armin Ronacher.
+    :copyright: (c) 2015 by Armin Ronacher.
-    :copyright: (c) 2014 by Armin Ronacher.
+    :copyright: (c) 2015 by Armin Ronacher.
-    :copyright: (c) 2014 by Armin Ronacher.
+    :copyright: (c) 2015 by Armin Ronacher.
-    :copyright: (c) 2014 by Armin Ronacher.
+    :copyright: (c) 2015 by Armin Ronacher.
-    :copyright: (c) 2014 by Armin Ronacher.
+    :copyright: (c) 2015 by Armin Ronacher.
-    :copyright: (c) 2014 by Armin Ronacher.
+    :copyright: (c) 2015 by Armin Ronacher.
-    :copyright: (c) 2014 by Armin Ronacher.
+    :copyright: (c) 2015 by Armin Ronacher.
-    :copyright: (c) 2014 by Armin Ronacher.
+    :copyright: (c) 2015 by Armin Ronacher.
-    :copyright: (c) 2014 by Armin Ronacher.
+    :copyright: (c) 2015 by Armin Ronacher.
-    :copyright: (c) 2014 by Armin Ronacher.
+    :copyright: (c) 2015 by Armin Ronacher.
-    :copyright: (c) 2014 by Armin Ronacher.
+    :copyright: (c) 2015 by Armin Ronacher.
-    :copyright: (c) 2014 by Armin Ronacher.
+    :copyright: (c) 2015 by Armin Ronacher.
-    :copyright: (c) 2014 by Armin Ronacher.
+    :copyright: (c) 2015 by Armin Ronacher.
-    :copyright: (c) 2014 by Armin Ronacher.
+    :copyright: (c) 2015 by Armin Ronacher.
-    :copyright: (c) 2014 by Armin Ronacher.
+    :copyright: (c) 2015 by Armin Ronacher.
-    :copyright: (c) 2014 by Armin Ronacher.
+    :copyright: (c) 2015 by Armin Ronacher.
-    :copyright: (c) 2014 by Armin Ronacher.
+    :copyright: (c) 2015 by Armin Ronacher.
-    :copyright: (c) 2014 by Armin Ronacher.
+    :copyright: (c) 2015 by Armin Ronacher.
-    :copyright: (c) 2014 by Armin Ronacher.
+    :copyright: (c) 2015 by Armin Ronacher.
-    :copyright: (c) Copyright 2014 by Armin Ronacher.
+    :copyright: (c) Copyright 2015 by Armin Ronacher.
-    :copyright: (c) 2014 by Armin Ronacher.
+    :copyright: (c) 2015 by Armin Ronacher.
-    :copyright: (c) 2014 by Ali Afshar.
+    :copyright: (c) 2015 by Ali Afshar.
-    :copyright: (c) 2014 by Armin Ronacher.
+    :copyright: (c) 2015 by Armin Ronacher.
-    :copyright: (c) 2014 by the Flask Team, see AUTHORS for more details.
+    :copyright: (c) 2015 by the Flask Team, see AUTHORS for more details.
-    :copyright: (c) 2014 by Armin Ronacher.
+    :copyright: (c) 2015 by Armin Ronacher.
-    :copyright: (c) 2014 by Armin Ronacher.
+    :copyright: (c) 2015 by Armin Ronacher.
-    :copyright: (c) 2014 by Armin Ronacher.
+    :copyright: (c) 2015 by Armin Ronacher.
-    :copyright: (c) 2014 by the Flask Team, see AUTHORS for more details.
+    :copyright: (c) 2015 by the Flask Team, see AUTHORS for more details.
-    :copyright: (c) 2014 by Armin Ronacher.
+    :copyright: (c) 2015 by Armin Ronacher.
-    :copyright: (c) 2014 by Armin Ronacher.
+    :copyright: (c) 2015 by Armin Ronacher.
-    :copyright: (c) 2014 by Armin Ronacher.
+    :copyright: (c) 2015 by Armin Ronacher.
-    :copyright: (c) 2014 by the Flask Team, see AUTHORS for more details.
+    :copyright: (c) 2015 by the Flask Team, see AUTHORS for more details.
-    :copyright: (c) 2014 by Armin Ronacher.
+    :copyright: (c) 2015 by Armin Ronacher.
-    :copyright: (c) 2014 by Armin Ronacher.
+    :copyright: (c) 2015 by Armin Ronacher.
-    :copyright: (c) 2014 by Armin Ronacher.
+    :copyright: (c) 2015 by Armin Ronacher.
-    :copyright: (c) 2014 by Armin Ronacher.
+    :copyright: (c) 2015 by Armin Ronacher.
-    :copyright: (c) 2014 by Armin Ronacher.
+    :copyright: (c) 2015 by Armin Ronacher.
-    :copyright: (c) 2014 by Armin Ronacher.
+    :copyright: (c) 2015 by Armin Ronacher.
-    :copyright: (c) 2014 by Armin Ronacher.
+    :copyright: (c) 2015 by Armin Ronacher.
-        methods = set(methods)
+        methods = set(item.upper() for item in methods)
-    to this function are the same as to the :class:`dict` constructor.
+    the given arguments with an :mimetype:`application/json` mimetype.  The
-        indent=indent, separators=separators),
+    # Note that we add '\n' to end of response
-        assert rv.data == b'{\n  "msg": "W00t"\n}'
+        assert rv.data == b'{\n  "msg": "W00t"\n}\n'
-        compressed_msg = b'{"msg":{"submsg":"W00t"},"msg2":"foobar"}'
+        compressed_msg = b'{"msg":{"submsg":"W00t"},"msg2":"foobar"}\n'
-            b'{\n  "msg": {\n    "submsg": "W00t"\n  }, \n  "msg2": "foobar"\n}'
+            b'{\n  "msg": {\n    "submsg": "W00t"\n  }, \n  "msg2": "foobar"\n}\n'
-        raise RuntimeError('the session is unavailable because no secret '
+        raise RuntimeError('The session is unavailable because no secret '
-            # chop of the port which is usually not supported by browsers
+            # chop off the port which is usually not supported by browsers
-        #: returns ``None`` or raises a `BuildError` the next function is
+        #: returns ``None`` or raises a :exc:`BuildError` the next function is
-      parameter must be set to ``True`` or a `ValueError` is raised. The default
+      parameter must be set to ``True`` or a :exc:`ValueError` is raised. The default
-        raise a ``TypeError``).
+        raise a :exc:`TypeError`).
-    an :file:`__init__.py` file inside) or a standard module (just a `.py` file).
+    an :file:`__init__.py` file inside) or a standard module (just a ``.py`` file).
-        If you want to open the `schema.sql` file you would do the
+        If you want to open the :file:`schema.sql` file you would do the
-    the given arguments with an `application/json` mimetype.  The arguments
+    the given arguments with an :mimetype:`application/json` mimetype.  The arguments
-        """If the mimetype is `application/json` this will contain the
+        """If the mimetype is :mimetype:`application/json` this will contain the
-        ``application/json`` or ``application/*+json``.
+        :mimetype:`application/json` or :mimetype:`application/*+json`.
-        only load the json data if the mimetype is ``application/json``
+        only load the json data if the mimetype is :mimetype:`application/json`
-        of the context until the end of the `with` block.  This is useful if
+        The test client can be used in a ``with`` block to defer the closing down
-           added support for `with` block usage for the client.
+           added support for ``with`` block usage for the client.
-        to the current context for the duration of the `with` block.
+        combination with the ``with`` statement because the request is only bound
-        The object returned can also be used without the `with` statement
+        The object returned can also be used without the ``with`` statement
-           Added support for non-with statement usage and `with` statement
+           Added support for non-with statement usage and ``with`` statement
-    requires support of the underlying webserver for `X-Sendfile`.
+    to ``True`` to directly emit an ``X-Sendfile`` header.  This however
-                           in which case `X-Sendfile` might not work and
+                           in which case ``X-Sendfile`` might not work and
-       It is strongly recommended to activate either `X-Sendfile` support in
+       It is strongly recommended to activate either ``X-Sendfile`` support in
-    #: This attribute can also be configured from the config with the `DEBUG`
+    #: This attribute can also be configured from the config with the ``DEBUG``
-    #: `TESTING` configuration key.  Defaults to ``False``.
+    #: ``TESTING`` configuration key.  Defaults to ``False``.
-    #: `SECRET_KEY` configuration key.  Defaults to ``None``.
+    #: ``SECRET_KEY`` configuration key.  Defaults to ``None``.
-    #: `SESSION_COOKIE_NAME` configuration key.  Defaults to ``'session'``
+    #: ``SESSION_COOKIE_NAME`` configuration key.  Defaults to ``'session'``
-    #: `PERMANENT_SESSION_LIFETIME` configuration key.  Defaults to
+    #: ``PERMANENT_SESSION_LIFETIME`` configuration key.  Defaults to
-    #: `USE_X_SENDFILE` configuration key.  Defaults to ``False``.
+    #: ``USE_X_SENDFILE`` configuration key.  Defaults to ``False``.
-        """Returns the value of the `PROPAGATE_EXCEPTIONS` configuration
+        """Returns the value of the ``PROPAGATE_EXCEPTIONS`` configuration
-        """Returns the value of the `PRESERVE_CONTEXT_ON_EXCEPTION`
+        """Returns the value of the ``PRESERVE_CONTEXT_ON_EXCEPTION``
-    that did not fail and outside of `DEBUG` mode.  By setting
+    that did not fail and outside of ``DEBUG`` mode.  By setting
-      address can be changed via `SERVER_NAME` configuration variable which
+      address can be changed via ``SERVER_NAME`` configuration variable which
-        """Read-only view of the `MAX_CONTENT_LENGTH` config key."""
+        """Read-only view of the ``MAX_CONTENT_LENGTH`` config key."""
-        #: registered here show up in the ``flask`` command once the
+        #: registered here show up in the :command:`flask` command once the
-        be using the ``flask`` command line script's ``runserver``
+        be using the :command:`flask` command line script's ``runserver``
-    :param add_app_option: adds the default ``--app`` option.  This gets
+    :param add_app_option: adds the default :option:`--app` option.  This gets
-    :param add_debug_option: adds the default ``--debug`` option.
+    :param add_debug_option: adds the default :option:`--debug` option.
-    an `__init__.py` file inside) or a standard module (just a `.py` file).
+    an :file:`__init__.py` file inside) or a standard module (just a `.py` file).
-    in the `__init__.py` file of your package like this::
+    in the :file:`__init__.py` file of your package like this::
-        For example if your application is defined in `yourapplication/app.py`
+        For example if your application is defined in :file:`yourapplication/app.py`
-    template named `_cider.html` with the following contents:
+    template named :file:`_cider.html` with the following contents:
-           `OPTIONS` is added automatically as method.
+           ``OPTIONS`` is added automatically as method.
-                        Starting with Flask 0.6, `OPTIONS` is implicitly
+                        to (``GET``, ``POST`` etc.).  By default a rule
-        # a tuple of only `GET` as default.
+        # a tuple of only ``GET`` as default.
-                        Starting with Flask 0.6, `OPTIONS` is implicitly
+                        to (``GET``, ``POST`` etc.).  By default a rule
-        """This method is called to create the default `OPTIONS` response.
+        """This method is called to create the default ``OPTIONS`` response.
-        behavior of `OPTIONS` responses.
+        behavior of ``OPTIONS`` responses.
-    :param instance_relative_config: if set to `True` relative filenames
+    :param instance_relative_config: if set to ``True`` relative filenames
-    #: The debug flag.  Set this to `True` to enable debugging of the
+    #: The debug flag.  Set this to ``True`` to enable debugging of the
-    #: configuration key.  Defaults to `False`.
+    #: configuration key.  Defaults to ``False``.
-    #: The testing flag.  Set this to `True` to enable the test mode of
+    #: The testing flag.  Set this to ``True`` to enable the test mode of
-    #: `TESTING` configuration key.  Defaults to `False`.
+    #: `TESTING` configuration key.  Defaults to ``False``.
-    #: `SECRET_KEY` configuration key.  Defaults to `None`.
+    #: `SECRET_KEY` configuration key.  Defaults to ``None``.
-    #: `USE_X_SENDFILE` configuration key.  Defaults to `False`.
+    #: `USE_X_SENDFILE` configuration key.  Defaults to ``False``.
-        #: A dictionary of all registered error handlers.  The key is `None`
+        #: A dictionary of all registered error handlers.  The key is ``None``
-        #: special key `None` points to a list of tuples where the first item
+        #: special key ``None`` points to a list of tuples where the first item
-        #: returns `None` or raises a `BuildError` the next function is
+        #: returns ``None`` or raises a `BuildError` the next function is
-        #: the blueprint this function is active for, `None` for all requests.
+        #: the blueprint this function is active for, ``None`` for all requests.
-        #: this function is active for, `None` for all requests.  This can for
+        #: this function is active for, ``None`` for all requests.  This can for
-        #: `None` for all requests. These functions are not allowed to modify
+        #: ``None`` for all requests. These functions are not allowed to modify
-        #: `None` here is used for application wide
+        #: ``None`` here is used for application wide
-        #: preprocessors.  The key `None` here is used for application wide
+        #: preprocessors.  The key ``None`` here is used for application wide
-        #: name of the blueprint this function is active for, `None` for all
+        #: name of the blueprint this function is active for, ``None`` for all
-        """This attribute is set to `True` if the application started
+        """This attribute is set to ``True`` if the application started
-        """Returns `True` if autoescaping should be active for the given
+        """Returns ``True`` if autoescaping should be active for the given
-           Setting ``use_debugger`` to `True` without being in debug mode
+           Setting ``use_debugger`` to ``True`` without being in debug mode
-        handler should be application wide `None` shall be used.
+        The first ``None`` refers to the active blueprint.  If the error
-        also returns `True` if ``TRAP_HTTP_EXCEPTIONS`` is set to `True`.
+        this will return ``False`` for all exceptions except for a bad request
-        If it returns `True` for any exception the error handler for this
+        If it returns ``True`` for any exception the error handler for this
-        function returns `True` then the teardown handlers will not be
+        function returns ``True`` then the teardown handlers will not be
-        #: The subdomain that the blueprint should be active for, `None`
+        #: The subdomain that the blueprint should be active for, ``None``
-        :param silent: set to `True` if you want silent failure for missing
+        :param silent: set to ``True`` if you want silent failure for missing
-        :return: bool. `True` if able to load config, `False` otherwise.
+        :return: bool. ``True`` if able to load config, ``False`` otherwise.
-        :param silent: set to `True` if you want silent failure for missing
+        :param silent: set to ``True`` if you want silent failure for missing
-        :param silent: set to `True` if you want silent failure for missing
+        :param silent: set to ``True`` if you want silent failure for missing
-    ``'flask._preserve_context'`` to `True` on the WSGI environment the
+    ``'flask._preserve_context'`` to ``True`` on the WSGI environment the
-    is `None`, the whole pair is skipped.  In case blueprints are active
+    is ``None``, the whole pair is skipped.  In case blueprints are active
-    it is not `None`, which can return a string to use as the result of
+    it is not ``None``, which can return a string to use as the result of
-    :param _external: if set to `True`, an absolute URL is generated. Server
+    :param _external: if set to ``True``, an absolute URL is generated. Server
-      parameter must be set to `True` or a `ValueError` is raised. The default
+      parameter must be set to ``True`` or a `ValueError` is raised. The default
-    but when `with_categories` is set to `True`, the return value will
+    but when `with_categories` is set to ``True``, the return value will
-      text (`True` gives a tuple, where `False` gives just the message text).
+      text (``True`` gives a tuple, where ``False`` gives just the message text).
-    :param with_categories: set to `True` to also receive categories.
+    :param with_categories: set to ``True`` to also receive categories.
-    :param as_attachment: set to `True` if you want to send this file with
+    :param as_attachment: set to ``True`` if you want to send this file with
-    :param conditional: set to `True` to enable conditional responses.
+    :param add_etags: set to ``False`` to disable attaching of etags.
-    :param cache_timeout: the timeout in seconds for the headers. When `None`
+    :param cache_timeout: the timeout in seconds for the headers. When ``None``
-        #: location of the templates.  `None` if templates should not be
+        #: location of the templates.  ``None`` if templates should not be
-        """This is `True` if the package bound object's container has a
+        """This is ``True`` if the package bound object's container has a
-        :data:`~flask.current_app` when the given cache_timeout is `None`. If a
+        :data:`~flask.current_app` when the given cache_timeout is ``None``. If a
-    #: implementation just hardcodes `False` in.
+    #: implementation just hardcodes ``False`` in.
-    #: for some backends this will always be `True`, but some backends will
+    #: for some backends this will always be ``True``, but some backends will
-    #: The default mixin implementation just hardcodes `True` in.
+    #: The default mixin implementation just hardcodes ``True`` in.
-    If :meth:`open_session` returns `None` Flask will call into
+    If :meth:`open_session` returns ``None`` Flask will call into
-        uses ``/`` if it's `None`.
+        uses ``/`` if it's ``None``.
-        or `None` if the session is linked to the browser session.  The
+        or ``None`` if the session is linked to the browser session.  The
-        modified, if set to `True` it's always set if the session is
+        it's set to ``False`` then a cookie is only set if the session is
-        """This method has to be implemented and must either return `None`
+        """This method has to be implemented and must either return ``None``
-    #: happened when matching, this will be `None`.
+    #: happened when matching, this will be ``None``.
-        be `None`.
+        be ``None``.
-        parsed JSON data.  Otherwise this will be `None`.
+        parsed JSON data.  Otherwise this will be ``None``.
-        :param cache: if set to `True` the parsed JSON data is remembered
+        :param force: if set to ``True`` the mimetype is ignored.
-    """This should help developers understand what """
+    """This should help developers understand what failed"""
-    # if we know the file modification date, we can store it as the
+    # if we know the file modification date, we can store it as
-            # the baseclass or another subclass of a base method view
+            # the base class or another subclass of a base method view
-# Core signals.  For usage examples grep the sourcecode or consult
+# Core signals.  For usage examples grep the source code or consult
-    :param source: the sourcecode of the template to be
+    :param source: the source code of the template to be
-    falls silently back to a noop
+    falls silently back to a noop.
-    """Baseclass for sessions based on signed cookies."""
+    """Base class for sessions based on signed cookies."""
-    # features that support "relative" urls.
+    # features that support "relative" URLs.
-    # the urls external by default.
+    # the URLs external by default.
-        on the file system, can be used by extensions to improve debugging
+        on the filesystem, can be used by extensions to improve debugging
-        # memory.  This is usually only a problem in testsuite since this
+        # memory.  This is usually only a problem in test suite since this
-        'SEND_FILE_MAX_AGE_DEFAULT':            12 * 60 * 60, # 12 hours
+        'SEND_FILE_MAX_AGE_DEFAULT':            12 * 60 * 60,  # 12 hours
-                content = fd.read() # Read and process the file content...
+                content = fd.read()  # Read and process the file content...
-            'simple_template.html', # should render this
+            ['no_template.xml',  # should skip this one
-    assert flask._app_ctx_stack.top == None
+    assert flask._app_ctx_stack.top is None
-    assert flask._app_ctx_stack.top == None
+    assert flask._app_ctx_stack.top is None
-    """Special subclass of the the :class:`AppGroup` group that supports
+    """Special subclass of the :class:`AppGroup` group that supports
-    some very advanced usecases for which it makes sense to create an
+    some very advanced use cases for which it makes sense to create an
-        'TEMPLATES_AUTO_RELOAD':                True,
+        'TEMPLATES_AUTO_RELOAD':                None,
-                or self.config['TEMPLATES_AUTO_RELOAD']
+            if self.config['TEMPLATES_AUTO_RELOAD'] is not None:
-    assert app.jinja_env.auto_reload
+    assert app.debug is False
-    assert not app.jinja_env.auto_reload
+    assert app.debug is False
-    def get_namespace(self, namespace, lowercase=True):
+    def get_namespace(self, namespace, lowercase=True, trim_namespace=True):
-            key = k[len(namespace):]
+            if trim_namespace:
-        indent=indent),
+        indent=indent, separators=separators),
-    def test_client(self, use_cookies=True):
+    def test_client(self, use_cookies=True, **kwargs):
-        return cls(self, self.response_class, use_cookies=use_cookies)
+        return cls(self, self.response_class, use_cookies=use_cookies, **kwargs)
-                       and return `False`.
+        :param silent: if set to `True` this method will fail silently
-        # XXX: deprecate property
+        from warnings import warn
-    ~~~~~~~~~~~~~~~~~~~~~~
+    ~~~~~~~~~~~~
-    ~~~~~~~~~~~~~~~~~~~~~~~~~~
+    ~~~~~~~~~~~~~~~~
-    ~~~~~~~~~~~~~~~~~~~~~~
+    ~~~~~~~~~~~~
-import unittest
+
-    ~~~~~~~~~~~~~~~~~~~~~~~~~~~
+    ~~~~~~~~~~~~~~~~~
-    ~~~~~~~~~~~~~~~~~~~~~~~~~~
+    ~~~~~~~~~~~~~~~~
-    ~~~~~~~~~~~~~~~~~~~~~~~
+    ~~~~~~~~~~~~~
-    ~~~~~~~~~~~~~~~~~~~~~
+    ~~~~~~~~~~~
-import unittest
+import werkzeug.serving
-    return update_wrapper(new_f, f)
+
-    def test_send_file_object(self):
+    def test_send_file_object(self, catch_deprecation_warnings):
-        with catch_warnings() as captured:
+        with catch_deprecation_warnings() as captured:
-        with catch_warnings() as captured:
+        with catch_deprecation_warnings() as captured:
-            with catch_warnings() as captured:
+            with catch_deprecation_warnings() as captured:
-            with catch_warnings() as captured:
+            with catch_deprecation_warnings() as captured:
-            with catch_warnings() as captured:
+            with catch_deprecation_warnings() as captured:
-        with catch_warnings() as captured:
+        with catch_deprecation_warnings() as captured:
-    def test_attachment(self):
+    def test_attachment(self, catch_deprecation_warnings):
-        with catch_warnings() as captured:
+        with catch_deprecation_warnings() as captured:
-    def test_debug_log(self):
+    def test_debug_log(self, capsys):
-                    assert False, 'debug log ate the exception'
+            c.get('/')
-def test_meta_path_loader_without_is_package():
+def test_meta_path_loader_without_is_package(request, modules_tmpdir):
-        def find_module(self, name):
+        def find_module(self, name, path=None):
-        sys.meta_path.pop()
+    request.addfinalizer(sys.meta_path.pop)
-    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+    ~~~~~~~~~~~~~~~~~~
-    cmdclass={'audit': run_audit}
+    '''
-    ~~~~~~~~~~~~~~~~~~~~~~
+    tests.test_config
-    :copyright: (c) 2014 by Armin Ronacher.
+    :copyright: (c) 2014 by the Flask Team, see AUTHORS for more details.
-class TestConfig(object):
+def common_object_test(app):
-        self.common_object_test(app)
+def test_config_from_file():
-        self.common_object_test(app)
+def test_config_from_object():
-        self.common_object_test(app)
+def test_config_from_json():
-        app = flask.Flask(__name__)
+
-            TEST_KEY='foo'
+            {}, {}
-    def test_config_missing(self):
+def test_config_from_class():
-            assert msg.endswith("missing.cfg'")
+            app.config.from_envvar('FOO_SETTINGS')
-        assert not app.config.from_pyfile('missing.cfg', silent=True)
+            assert 0, 'expected exception'
-        app = flask.Flask(__name__)
+        os.environ = {'FOO_SETTINGS': __file__.rsplit('.', 1)[0] + '.py'}
-            app.config.from_json('missing.json')
+            app = flask.Flask(__name__)
-            assert msg.endswith("missing.json'")
+            assert msg.endswith("missing.cfg'")
-                sys.meta_path.pop()
+            assert False, 'expected IOError'
-class TestBasicFunctionality(object):
+def test_options_work():
-        assert rv.data == b''
+    @app.route('/', methods=['GET', 'POST'])
-            return flask.request.method
+def test_options_on_multiple_rules():
-                return "Hey"
+    @app.route('/', methods=['GET', 'POST'])
-            return flask.request.method
+    @app.route('/', methods=['PUT'])
-        app.view_functions['index'] = index
+def test_options_handling_disabled():
-        assert c.get('/foo/bar').data == b'bar'
+    def index():
-        ]))
+    app = flask.Flask(__name__)
-            return 'bar'
+    def index2():
-        assert c.get('/foo/bar').data == b'bar'
+def test_request_dispatching():
-            return flask.session['value']
+    @app.route('/')
-        assert c.get('/get').data == b'42'
+    @app.route('/more', methods=['GET', 'POST'])
-        assert 'httponly' in rv.headers['set-cookie'].lower()
+    c = app.test_client()
-        @app.route('/')
+def test_disallow_string_for_allowed_methods():
-                return self.app(environ, start_response)
+            return "Hey"
-        assert 'path=/bar' in rv.headers['set-cookie'].lower()
+    def index():
-            expect_exception(flask.session.pop, 'foo')
+    @app.teardown_request
-        app.testing = True
+    @app.route('/')
-            return repr(flask.session.get('foo'))
+    @app.after_request
-        assert c.get('/').data == b'42'
+    @app.after_request
-            return response
+    @app.teardown_request
-        app.secret_key = 'testkey'
+def test_error_handling():
-        # instead of propagating exceptions.
+    @app.errorhandler(Forbidden)
-        app.testing = True
+    @app.before_request
-        # Create new test client on each test to clean flashed messages.
+    @app.route('/3')
-        c.get('/test/')
+    @app.route('/fail')
-        c.get('/test_with_categories/')
+    c = app.test_client()
-        c.get('/test_filters/')
+def test_enctype_debug_helper():
-        c.get('/test_filters_without_returning_categories/')
+    @app.route('/fail', methods=['POST'])
-        assert rv == b'request|after'
+    # with statement is important because we leave an exception on the
-        rv = app.test_client().get('/')
+def test_response_creation():
-        assert len(called) == 1
+        assert rv.data == b''
-        rv = app.test_client().get('/')
+        rv = flask.make_response('Awesome')
-        assert len(called) == 1
+        assert rv.data == b'Awesome'
-        assert len(called) == 2
+        rv = flask.make_response('W00t', 404)
-        rv = c.get('/')
+def test_make_response_with_response_instance():
-        rv = app.test_client().get('/')
+    except ValueError as e:
-        assert rv.data == b'value'
+    except ValueError as e:
-            pass
+def test_exception_propagation():
-            return '42'
+        app.config['LOGGER_HANDLER_POLICY'] = 'never'
-
+            1 // 0
-        assert c.get('/').data == b'42'
+        if config_key is not None:
-            raise Forbidden()
+def test_max_content_length():
-        assert c.get('/3').data == b'apple'
+    @app.before_request
-        assert c.get('/fail').status_code == 400
+    @app.route('/accept', methods=['POST'])
-            assert False, 'Expected exception'
+    @app.errorhandler(413)
-            flask.abort(404)
+    c = app.test_client()
-            return flask.request.files['foo'].filename
+def test_url_processors():
-                assert False, 'Expected exception'
+    @app.url_defaults
-            }
+    @app.url_value_preprocessor
-                'http://localhost/hello/test%20x'
+    @app.route('/<lang_code>/')
-        app = flask.Flask(__name__)
+    @app.route('/<lang_code>/about')
-            pytest.raises(BuildError, flask.url_for, 'spam')
+    @app.route('/foo')
-        assert c.get('/1,2,3').data == b'1|2|3'
+    c = app.test_client()
-        rv.close()
+    assert c.get('/de/').data == b'/de/about'
-        assert not flask.g
+def test_inject_blueprint_url_defaults():
-            return 'Foo'
+    @bp.url_defaults
-            return 'Foo SubDomain'
+    @bp.route('/<page>')
-        assert rv.data == b'Foo'
+    app.register_blueprint(bp)
-        assert rv.data == b'Foo'
+    values = dict()
-        assert rv.data == b'Foo'
+    with app.test_request_context('/somepage'):
-            )
+def test_nonascii_pathinfo():
-            return '42'
+    @app.route(u'/ÐºÐ¸ÑÑÐµÑÑ')
-        assert rv.data == b'42'
+    c = app.test_client()
-                values.setdefault('lang_code', flask.g.lang_code)
+def test_debug_mode_complains_after_first_request():
-            flask.g.lang_code = values.pop('lang_code', None)
+    @app.route('/')
-            return flask.url_for('about')
+    app.debug = False
-            return flask.url_for('something_else')
+    @app.route('/foo')
-        c = app.test_client()
+def test_before_first_request_functions():
-        assert c.get('/foo').data == b'/en/about'
+    @app.before_first_request
-        def view(page): pass
+def test_before_first_request_functions_concurrent():
-        app.register_blueprint(bp)
+    @app.before_first_request
-        assert values == expected
+    c = app.test_client()
-        assert url == expected
+    def get_and_assert():
-        app.testing = True
+    t = Thread(target=get_and_assert)
-        assert rv.data == b'Hello World!'
+def test_routing_redirect_debugging():
-        assert app.test_client().get('/').data == b'Awesome'
+    @app.route('/foo/', methods=['GET', 'POST'])
-                return 'Meh'
+            c.post('/foo', data={})
-            assert 'A setup function was called' in str(e)
+            assert 'http://localhost/foo/' in str(e)
-        assert app.got_first_request
+        rv = c.get('/foo', data={}, follow_redirects=True)
-        assert app.got_first_request
+    app.debug = False
-            got.append(42)
+def test_route_decorator_custom_endpoint():
-            assert got == [42]
+    @app.route('/foo/')
-        assert app.got_first_request
+    @app.route('/bar/', endpoint='bar')
-                assert False, 'Expected exception'
+    @app.route('/bar/123', endpoint='123')
-            assert rv.data == b'success'
+    with app.test_request_context():
-            assert rv.data == b'success'
+    c = app.test_client()
-            return flask.request.endpoint
+def test_preserve_only_once():
-            return flask.request.endpoint
+    @app.route('/fail')
-            return flask.request.endpoint
+    c = app.test_client()
-            assert flask.url_for('123') == '/bar/123'
+    assert flask._request_ctx_stack.top is not None
-        app.debug = True
+def test_preserve_remembers_exception():
-            1 // 0
+    @app.route('/fail')
-        errors = []
+    @app.route('/success')
-            1 // 0
+    @app.teardown_request
-            return 'Okay'
+    c = app.test_client()
-            errors.append(exc)
+    # After this failure we did not yet call the teardown handler
-        c = app.test_client()
+    # But this request triggers it, and it's an error
-        assert errors == []
+    # At this point another request does nothing.
-        assert errors[1] == None
+def test_get_method_on_g():
-        app.testing = True
+    with app.app_context():
-        app.testing = True
+def test_g_iteration_protocol():
-            assert sorted(flask.g) == ['bar', 'foo']
+    with app.app_context():
-class TestSubdomain(object):
+def test_subdomain_basic_support():
-            return 'test index'
+    @app.route('/')
-        assert rv.data == b'normal index'
+    @app.route('/', subdomain='test')
-        assert rv.data == b'test index'
+    c = app.test_client()
-            return 'index for %s' % user
+    rv = c.get('/', 'http://test.localhost/')
-            return 'index for %s' % user
+def test_subdomain_matching():
-        assert rv.data == b'index for mitsuhiko'
+    @app.route('/', subdomain='<user>')
-        app = flask.Flask(__name__)
+    c = app.test_client()
-        assert rv.data == b'b'
+def test_subdomain_matching_with_ports():
-                app.add_url_rule('/<test>/', 'index', self.index)
+    @app.route('/', subdomain='<user>')
-                return test
+    c = app.test_client()
-        assert rv.data == b'b'
+
-        self.testcase = testcase
+class assert_no_leak(object):
-            self.testcase.fail('Example code leaked')
+            pytest.fail('Example code leaked')
-        app = flask.Flask(__name__)
+def test_memory_consumption():
-            return flask.render_template('simple_template.html', whiskey=42)
+    @app.route('/')
-                assert rv.data == b'<h1>42</h1>'
+    def fire():
-        fire()
+    # Trigger caches
-                    fire()
+    # This test only works on CPython 2.7.
-            safe_join('/foo', '..')
+def test_safe_join_toplevel_pardir():
-        app.testing = True
+def test_aborting():
-            return str(e.whatever)
+    @app.errorhandler(Foo)
-            raise flask.abort(flask.redirect(flask.url_for('test')))
+    @app.route('/')
-            raise Foo()
+    @app.route('/test')
-            assert rv.data == b'42'
+    with app.test_client() as c:
-            assert rv.data == b'index'
+def test_environ_defaults_from_config():
-        c = app.test_client(use_cookies=False)
+        rv = c.get('/getsession')
-            with c.session_transaction() as s:
+            with c.session_transaction() as sess:
-            assert 'cookies' in str(e)
+            assert 'Session backend did not open a session' in str(e)
-        except (AttributeError, RuntimeError):
+def test_session_transactions_keep_context():
-            assert called == []
+    except RuntimeError as e:
-
+    assert called == [None, None]
-        assert b'xxx' == response.data
+    with app.test_client() as c:
-            return company_id
+def test_nosubdomain():
-        assert b'xxx' == response.data
+    with app.test_client() as c:
-    rv = tmpdir.mkdir('test_apps')
+def modules_tmpdir(tmpdir, monkeypatch):
-    return apps_tmpdir
+def modules_tmpdir_prefix(modules_tmpdir, monkeypatch):
-def site_packages(apps_tmpdir, monkeypatch):
+def site_packages(modules_tmpdir, monkeypatch):
-    rv = apps_tmpdir \
+    rv = modules_tmpdir \
-def install_egg(apps_tmpdir, monkeypatch):
+def install_egg(modules_tmpdir, monkeypatch):
-    def inner(name, base=apps_tmpdir):
+    def inner(name, base=modules_tmpdir):
-            cwd=str(apps_tmpdir)
+            cwd=str(modules_tmpdir)
-        egg_path, = apps_tmpdir.join('dist/').listdir()
+        egg_path, = modules_tmpdir.join('dist/').listdir()
-    def test_explicit_instance_paths(self, apps_tmpdir):
+    def test_explicit_instance_paths(self, modules_tmpdir):
-        assert app.instance_path == str(apps_tmpdir)
+        app = flask.Flask(__name__, instance_path=str(modules_tmpdir))
-        app = apps_tmpdir.join('main_app.py')
+    def test_main_module_paths(self, modules_tmpdir, purge_module):
-        app = apps_tmpdir.join('config_module_app.py').write(
+    def test_uninstalled_module_paths(self, modules_tmpdir, purge_module):
-        assert app.instance_path == str(apps_tmpdir.join('instance'))
+        assert app.instance_path == str(modules_tmpdir.join('instance'))
-        app = apps_tmpdir.mkdir('config_package_app')
+    def test_uninstalled_package_paths(self, modules_tmpdir, purge_module):
-        assert app.instance_path == str(apps_tmpdir.join('instance'))
+        assert app.instance_path == str(modules_tmpdir.join('instance'))
-    def test_installed_module_paths(self, apps_tmpdir, apps_tmpdir_prefix,
+    def test_installed_module_paths(self, modules_tmpdir, modules_tmpdir_prefix,
-            apps_tmpdir.join('var').join('site_app-instance')
+            modules_tmpdir.join('var').join('site_app-instance')
-                                     apps_tmpdir_prefix, purge_module,
+    def test_installed_package_paths(self, limit_loader, modules_tmpdir,
-        installed_path = apps_tmpdir.mkdir('path')
+        installed_path = modules_tmpdir.mkdir('path')
-            apps_tmpdir.join('var').join('installed_package-instance')
+            modules_tmpdir.join('var').join('installed_package-instance')
-                                  apps_tmpdir_prefix, purge_module,
+    def test_prefix_package_paths(self, limit_loader, modules_tmpdir,
-            apps_tmpdir.join('var').join('site_package-instance')
+            modules_tmpdir.join('var').join('site_package-instance')
-        apps_tmpdir.mkdir('site_egg').join('__init__.py').write(
+    def test_egg_installed_paths(self, install_egg, modules_tmpdir,
-                str(apps_tmpdir.join('var/').join('site_egg-instance'))
+                str(modules_tmpdir.join('var/').join('site_egg-instance'))
-    x = apps_tmpdir.join('flask_newext_simple.py')
+def newext_simple(modules_tmpdir):
-    flaskext = apps_tmpdir.mkdir('flaskext')
+def oldext_simple(modules_tmpdir):
-    pkg = apps_tmpdir.mkdir('flask_newext_package')
+def newext_package(modules_tmpdir):
-    flaskext = apps_tmpdir.mkdir('flaskext')
+def oldext_package(modules_tmpdir):
-    ext = apps_tmpdir.mkdir('flask_broken')
+def flaskext_broken(modules_tmpdir):
-        apps_tmpdir.join('importerror.py').write('raise NotImplementedError()')
+    def test_name_with_import_error(self, modules_tmpdir):
-    def test_name_with_import_error(self):
+    def test_name_with_import_error(self, apps_tmpdir):
-        if (entry.startswith('flask.ext.') or
+        if (
-            entry == 'flaskext') and value is not None:
+            entry == 'flaskext'
-def test_flaskext_new_simple_import_normal(test_apps):
+
-def test_flaskext_new_simple_import_module(test_apps):
+
-def test_flaskext_new_package_import_normal(test_apps):
+
-def test_flaskext_new_package_import_module(test_apps):
+
-def test_flaskext_new_package_import_submodule_function(test_apps):
+
-def test_flaskext_new_package_import_submodule(test_apps):
+
-def test_flaskext_old_simple_import_normal(test_apps):
+
-def test_flaskext_old_simple_import_module(test_apps):
+
-def test_flaskext_old_package_import_normal(test_apps):
+
-def test_flaskext_old_package_import_module(test_apps):
+
-def test_flaskext_old_package_import_submodule(test_apps):
+
-def test_flaskext_old_package_import_submodule_function(test_apps):
+
-def test_flaskext_broken_package_no_module_caching(test_apps):
+
-    try:
+
-            next.tb_frame.f_code.co_filename
+
-        1/0  # XXX
+        message = 'No module named \'missing_module\''
-def setup_path(monkeypatch):
+@pytest.fixture
-def test_templates_and_static():
+def test_templates_and_static(test_apps):
-def test_templates_list():
+def test_templates_list(test_apps):
-def test_flaskext_new_simple_import_normal():
+def test_flaskext_new_simple_import_normal(test_apps):
-def test_flaskext_new_simple_import_module():
+def test_flaskext_new_simple_import_module(test_apps):
-def test_flaskext_new_package_import_normal():
+def test_flaskext_new_package_import_normal(test_apps):
-def test_flaskext_new_package_import_module():
+def test_flaskext_new_package_import_module(test_apps):
-def test_flaskext_new_package_import_submodule_function():
+def test_flaskext_new_package_import_submodule_function(test_apps):
-def test_flaskext_new_package_import_submodule():
+def test_flaskext_new_package_import_submodule(test_apps):
-def test_flaskext_old_simple_import_normal():
+def test_flaskext_old_simple_import_normal(test_apps):
-def test_flaskext_old_simple_import_module():
+def test_flaskext_old_simple_import_module(test_apps):
-def test_flaskext_old_package_import_normal():
+def test_flaskext_old_package_import_normal(test_apps):
-def test_flaskext_old_package_import_module():
+def test_flaskext_old_package_import_module(test_apps):
-def test_flaskext_old_package_import_submodule():
+def test_flaskext_old_package_import_submodule(test_apps):
-def test_flaskext_old_package_import_submodule_function():
+def test_flaskext_old_package_import_submodule_function(test_apps):
-def test_flaskext_broken_package_no_module_caching():
+def test_flaskext_broken_package_no_module_caching(test_apps):
-def test_no_error_swallowing():
+def test_no_error_swallowing(test_apps):
-def test_template_loader_debugging():
+def test_template_loader_debugging(test_apps):
-from tests import TestFlask
+
-from tests import TestFlask, emits_module_deprecation_warning
+from tests import emits_module_deprecation_warning
-from tests import TestFlask
+
-from tests import TestFlask
+
-from tests import TestFlask, catch_warnings
+from tests import catch_warnings
-from tests import TestFlask
+
-from tests import TestFlask, catch_warnings, catch_stderr
+from tests import catch_warnings, catch_stderr
-from tests import TestFlask
+
-from tests import TestFlask
+
-from tests import TestFlask
+
-from tests import TestFlask
+
-from tests import TestFlask
+
-from tests import TestFlask
+
-from tests import TestFlask
+
-class TestBasicFunctionality(TestFlask):
+class TestBasicFunctionality(object):
-class TestSubdomain(TestFlask):
+class TestSubdomain(object):
-class TestBlueprint(TestFlask):
+def test_blueprint_specific_error_handling():
-        sideend = flask.Blueprint('sideend', __name__)
+    @frontend.errorhandler(403)
-            return 'frontend says no', 403
+    @frontend.route('/frontend-no')
-            flask.abort(403)
+    @backend.errorhandler(403)
-            return 'backend says no', 403
+    @backend.route('/backend-no')
-            flask.abort(403)
+    @sideend.route('/what-is-a-sideend')
-            flask.abort(403)
+    app = flask.Flask(__name__)
-        app.register_blueprint(sideend)
+    @app.errorhandler(403)
-            return 'application itself says no', 403
+    with app.test_request_context():
-        c = app.test_client()
+    with app.test_request_context():
-        assert c.get('/what-is-a-sideend').data == b'application itself says no'
+    with flask.Flask(__name__).test_request_context():
-            pass
+def test_default_static_cache_timeout():
-        blue = flask.Blueprint('blue', __name__)
+    blueprint = MyBlueprint('blueprint', __name__, static_folder='static')
-            return 'boom'
+    # try/finally, in case other tests use this app for Blueprint tests.
-        blue.register_error_handler(MyFunctionException, my_function_exception_handler)
+def test_templates_list():
-            raise MyFunctionException()
+def test_dotted_names():
-        app.register_blueprint(blue)
+    @frontend.route('/fe')
-        c = app.test_client()
+    @frontend.route('/fe2')
-        assert c.get('/function').data == b'bam'
+    @backend.route('/be')
-        bp = flask.Blueprint('test', __name__)
+    app = flask.Flask(__name__)
-            return '%s/%d' % (bar, baz)
+    c = app.test_client()
-            return text_type(bar)
+def test_dotted_names_from_app():
-        app.register_blueprint(bp, url_prefix='/2', url_defaults={'bar': 19})
+    @app.route('/')
-        assert c.get('/2/bar').data == b'19'
+    @test.route('/test/')
-        bp = flask.Blueprint('frontend', __name__, url_prefix='/<lang_code>')
+    app.register_blueprint(test)
-            values.setdefault('lang_code', flask.g.lang_code)
+    with app.test_client() as c:
-            flask.g.lang_code = values.pop('lang_code')
+def test_empty_url_defaults():
-            return flask.url_for('.about')
+    @bp.route('/', defaults={'page': 1})
-            return flask.url_for('.index')
+    app = flask.Flask(__name__)
-        app.register_blueprint(bp)
+    c = app.test_client()
-        c = app.test_client()
+def test_route_decorator_custom_endpoint():
-        assert c.get('/de/about').data == b'/de/'
+    bp = flask.Blueprint('bp', __name__)
-        c = app.test_client()
+    @bp.route('/foo')
-        rv.close()
+    @bp.route('/bar', endpoint='bar')
-            app.config['SEND_FILE_MAX_AGE_DEFAULT'] = max_age_default
+    @bp.route('/bar/123', endpoint='123')
-            assert flask.url_for('admin.static', filename='test.txt') == '/admin/static/test.txt'
+    @bp.route('/bar/foo')
-            return flask.request.endpoint
+    app = flask.Flask(__name__)
-            return flask.request.endpoint
+    @app.route('/')
-            return flask.request.endpoint
+    c = app.test_client()
-            return flask.request.endpoint
+def test_route_decorator_custom_endpoint_with_dots():
-        app.register_blueprint(bp, url_prefix='/py')
+    @bp.route('/foo')
-        def index():
+    try:
-        def foo():
+    try:
-            lambda: None
+    except AssertionError:
-    return suite
+    )
-class TestConfig(TestFlask):
+class TestConfig(object):
-class TestInstance(TestFlask):
+class TestInstance(object):
-    Tests deprecation support.
+    Tests deprecation support. Not used currently.
-class TestJSON(TestFlask):
+class TestJSON(object):
-class TestSendfile(TestFlask):
+class TestSendfile(object):
-class TestLogging(TestFlask):
+class TestLogging(object):
-class TestNoImports(TestFlask):
+class TestNoImports(object):
-class TestStreaming(TestFlask):
+class TestStreaming(object):
-class TestMemory(TestFlask):
+class TestMemory(object):
-class TestException(TestFlask):
+class TestException(object):
-class TestRequestContext(TestFlask):
+def test_teardown_on_pop():
-            buffer.append(exception)
+def test_proper_test_request_context():
-            pass
+    @app.route('/')
-        assert buffer == [None]
+    @app.route('/', subdomain='foo')
-        )
+    with app.test_request_context('/'):
-            pass
+    with app.test_request_context('/'):
-        with app.test_request_context('/', environ_overrides={'SERVER_NAME': 'localhost:80'}):
+    try:
-        ctx.push()
+    app.config.update(SERVER_NAME='localhost')
-            def g():
+
-    return suite
+            assert not flask.request
-            assert app.test_client().get('/').status_code == 500
+def test_template_rendered():
-            flask.message_flashed.disconnect(record, app)
+            message, category = recorded[0]
-class TestTestTools(TestFlask):
+class TestTestTools(object):
-class TestSubdomain(TestFlask):
+class TestSubdomain(object):
-
+import flask
-import sys
+@pytest.fixture(autouse=True)
-    def test_url_generation_without_context_fails(self):
+def test_basic_url_generation():
-    return suite
+def test_url_generation_without_context_fails():
-    def teardown(self):
+
-        try:
+    request.addfinalizer(teardown)
-    return suite
+
-    return suite
+def test_suppressed_exception_logging():
-    return suite
+def test_context_processing():
-
+def common_test(app):
-    return suite
+    # But these tests should still pass. We just log a warning.
-        assert res.data == u''
+        assert res.data == b''
-            self.assert_true(log, 'expected deprecation warning')
+            assert log, 'expected deprecation warning'
-                self.assert_in('Modules are deprecated', str(entry['message']))
+                assert 'Modules are deprecated' in str(entry['message'])
-        self.assert_equal(leaks, [])
+        assert leaks == []
-        raise AssertionError(msg)
+import pytest
-            self.assert_equal(rv, 'https://localhost/')
+            assert rv == 'https://localhost/'
-            with self.assert_raises(RuntimeError):
+            with pytest.raises(RuntimeError):
-        with self.assert_raises(RuntimeError):
+        with pytest.raises(RuntimeError):
-        self.assert_equal(flask._app_ctx_stack.top, None)
+            assert flask.current_app._get_current_object() == app
-        self.assert_equal(flask._app_ctx_stack.top, None)
+            assert flask.current_app._get_current_object() == app
-        self.assert_equal(cleanup_stuff, [None])
+        assert cleanup_stuff == [None]
-        self.assert_equal(cleanup_stuff, [None])
+        assert cleanup_stuff == [None]
-                flask.render_template_string('{{ g.spam }}'), 'eggs')
+            assert flask.render_template_string('{{ g.spam }}') == 'eggs'
-                ['werkzeug.request'] is not None)
+            env = flask._request_ctx_stack.top.request.environ
-        self.assert_equal(called, ['request', 'app'])
+        res = c.get('/')
-        self.assert_equal(rv.data, b'')
+        assert sorted(rv.allow) == ['GET', 'HEAD', 'OPTIONS', 'POST']
-        self.assert_equal(sorted(rv.allow), ['GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'])
+        assert sorted(rv.allow) == ['GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']
-        self.assert_equal(rv.status_code, 405)
+        assert rv.status_code == 405
-        self.assert_equal(sorted(rv.allow), ['OPTIONS'])
+        assert sorted(rv.allow) == ['OPTIONS']
-        self.assert_equal(c.get('/').data, b'GET')
+        assert c.get('/').data == b'GET'
-        self.assert_equal(sorted(rv.allow), ['GET', 'HEAD', 'OPTIONS'])
+        assert rv.status_code == 405
-        self.assert_equal(c.get('/more').data, b'GET')
+        assert rv.status_code == 200
-        self.assert_equal(sorted(rv.allow), ['GET', 'HEAD', 'OPTIONS', 'POST'])
+        assert rv.status_code == 405
-        with self.assert_raises(TypeError):
+        with pytest.raises(TypeError):
-        self.assert_equal(c.get('/').data, b'GET')
+        assert c.get('/').data == b'GET'
-        self.assert_equal(sorted(rv.allow), ['GET', 'HEAD', 'OPTIONS'])
+        assert rv.status_code == 405
-        self.assert_equal(c.get('/more').data, b'GET')
+        assert rv.status_code == 200
-        self.assert_equal(sorted(rv.allow), ['GET', 'HEAD', 'OPTIONS', 'POST'])
+        assert rv.status_code == 405
-        self.assert_equal(c.get('/foo/bar').data, b'bar')
+        assert c.get('/foo/').data == b'index'
-        self.assert_equal(c.get('/foo/bar').data, b'bar')
+        assert c.get('/foo/').data == b'index'
-        self.assert_equal(c.get('/get').data, b'42')
+        assert c.post('/set', data={'value': '42'}).data == b'value set'
-        self.assert_in('httponly', rv.headers['set-cookie'].lower())
+        assert 'domain=.example.com' in rv.headers['set-cookie'].lower()
-        self.assert_in('httponly', rv.headers['set-cookie'].lower())
+        assert 'domain=.example.com' in rv.headers['set-cookie'].lower()
-        self.assert_in('httponly', rv.headers['set-cookie'].lower())
+        assert 'domain=example.com' in rv.headers['set-cookie'].lower()
-        self.assert_in('path=/bar', rv.headers['set-cookie'].lower())
+        assert 'path=/bar' in rv.headers['set-cookie'].lower()
-        self.assert_not_in('httponly', cookie)
+        assert 'domain=.example.com' in cookie
-                self.assert_true(e.args and 'session is unavailable' in e.args[0])
+                assert e.args and 'session is unavailable' in e.args[0]
-                self.assert_true(False, 'expected exception')
+                assert False, 'expected exception'
-            self.assert_true(flask.session.get('missing_key') is None)
+            assert flask.session.get('missing_key') is None
-        self.assert_in('set-cookie', rv.headers)
+        assert 'set-cookie' in rv.headers
-        self.assert_equal(expires.day, expected.day)
+        assert expires.year == expected.year
-        self.assert_equal(rv.data, b'True')
+        assert rv.data == b'True'
-        self.assert_in('set-cookie', rv.headers)
+        assert 'set-cookie' in rv.headers
-        self.assert_true(match is None)
+        assert match is None
-        self.assert_equal(c.get('/').data, b'42')
+        assert c.get('/').data == b'None'
-        self.assert_equal(rv['t'], (1, 2, 3))
+        assert rv['m'] == flask.Markup('Hello!')
-                self.assert_equal(c.get('/bump').data, b'3')
+                assert c.get('/bump').data == b'1'
-                self.assert_equal(rv.data, b'3')
+                assert (set_cookie is not None) == expect_header
-            self.assert_false(flask.session.modified)
+            assert not flask.session.modified
-            self.assert_equal(list(flask.get_flashed_messages()), ['Zap', 'Zip'])
+            assert flask.session.modified
-            self.assert_equal(messages[2], flask.Markup(u'<em>Testing</em>'))
+            assert list(messages) == [
-            self.assert_equal(messages[2], ('warning', flask.Markup(u'<em>Testing</em>')))
+            assert len(messages) == 3
-            self.assert_equal(messages[0], ('message', u'Hello World'))
+            assert list(messages) == [('message', u'Hello World')]
-            self.assert_equal(messages[1], ('warning', flask.Markup(u'<em>Testing</em>')))
+            assert list(messages) == [
-            self.assert_equal(messages[1], flask.Markup(u'<em>Testing</em>'))
+            assert len(messages) == 2
-            self.assert_not_in('after', evts)
+            assert 'before' in evts
-        self.assert_not_in('after', evts)
+        assert 'after' not in evts
-        self.assert_equal(rv, b'request|after')
+        assert 'after' in evts
-        self.assert_equal(resp.headers['X-Foo'], 'a header')
+        assert resp.status_code == 200
-        self.assert_equal(len(called), 1)
+        assert rv.status_code == 200
-        self.assert_equal(len(called), 1)
+        assert rv.status_code == 200
-            self.assert_equal(type(exc), ZeroDivisionError)
+            assert type(exc) == ZeroDivisionError
-            self.assert_equal(type(exc), ZeroDivisionError)
+            assert type(exc) == ZeroDivisionError
-        self.assert_equal(len(called), 2)
+        assert rv.status_code == 500
-        self.assert_equal(called, [1, 2, 3, 4, 5, 6])
+        assert rv.data == b'42'
-        self.assert_equal(rv.data, b'not found')
+        assert rv.status_code == 404
-        self.assert_equal(b'internal server error', rv.data)
+        assert rv.status_code == 500
-        self.assert_equal(b'forbidden', rv.data)
+        assert rv.status_code == 403
-        self.assert_equal(rv.data, b'value')
+        assert rv.status_code == 404
-            self.assert_true(isinstance(e, MyException))
+            assert isinstance(e, MyException)
-        self.assert_equal(c.get('/').data, b'42')
+        assert c.get('/').data == b'42'
-            self.assert_true(isinstance(e, ForbiddenSubclass))
+            assert isinstance(e, ForbiddenSubclass)
-            self.assert_true(isinstance(e, Forbidden))
+            assert not isinstance(e, ForbiddenSubclass)
-        self.assert_equal(c.get('/3').data, b'apple')
+        assert c.get('/1').data == b'banana'
-        self.assert_equal(c.get('/fail').status_code, 400)
+        assert c.get('/fail').status_code == 400
-            self.assert_true(isinstance(e, BadRequest))
+            assert isinstance(e, BadRequest)
-            self.fail('Expected exception')
+            assert False, 'Expected exception'
-            self.fail('Expected exception')
+            assert False, 'Expected exception'
-                self.assert_in('This was submitted: "index.txt"', str(e))
+                assert 'no file contents were transmitted' in str(e)
-                self.fail('Expected exception')
+                assert False, 'Expected exception'
-        self.assert_equal(c.get('/string').data, u'HÃ¤llo WÃ¶rld'.encode('utf-8'))
+        assert c.get('/unicode').data == u'HÃ¤llo WÃ¶rld'.encode('utf-8')
-        self.assert_equal(rv.mimetype, 'text/plain')
+        assert rv.data == b'Meh'
-        self.assert_equal(rv2.mimetype, 'text/plain')
+        assert rv2.data == b'Hello'
-        self.assert_equal(rv3.mimetype, 'text/html')
+        assert rv3.data == b'Hi, status!'
-        self.assert_equal(rv4.status_code, 404)
+        assert rv4.data == b'Hello world'
-            self.assert_equal(rv.mimetype, 'text/html')
+            assert rv.status_code == 200
-            self.assert_equal(rv.mimetype, 'text/html')
+            assert rv.status_code == 200
-            self.assert_equal(rv.mimetype, 'text/html')
+            assert rv.status_code == 404
-            self.assert_equal(rv.mimetype, 'application/json')
+            assert rv.status_code == 400
-            self.assert_equal(rv.mimetype, 'text/html')
+            assert rv.status_code == 400
-            self.assert_equal(rv.headers['X-Foo'], 'bar')
+            assert rv.status_code == 400
-                              'http://localhost/hello/test%20x')
+            assert flask.url_for('hello', name='test x') == '/hello/test%20x'
-            self.assert_raises(BuildError, flask.url_for, 'spam')
+            pytest.raises(BuildError, flask.url_for, 'spam')
-            self.assert_raises(BuildError, app.handle_url_build_error, error, 'spam', {})
+            pytest.raises(BuildError, app.handle_url_build_error, error, 'spam', {})
-            self.assert_equal(flask.url_for('spam'), '/test_handler/')
+            assert flask.url_for('spam') == '/test_handler/'
-        self.assert_equal(c.get('/1,2,3').data, b'1|2|3')
+        assert c.get('/1,2,3').data == b'1|2|3'
-        self.assert_equal(rv.data.strip(), b'<h1>Hello World!</h1>')
+        assert rv.status_code == 200
-                              '/static/index.html')
+            assert flask.url_for('static', filename='index.html') == \
-            self.assert_equal(str(e), 'View function did not return a response')
+            assert str(e) == 'View function did not return a response'
-            self.assert_true("Expected ValueError")
+            assert "Expected ValueError"
-        self.assert_false(flask.g)
+        assert repr(flask.g) == '<LocalProxy unbound>'
-        self.assert_equal(rv.data, b'Foo')
+        assert rv.data == b'Foo'
-        self.assert_equal(rv.data, b'Foo')
+        assert rv.data == b'Foo'
-        self.assert_equal(rv.data, b'Foo')
+        assert rv.data == b'Foo'
-        self.assert_equal(rv.data, b'Foo')
+        assert rv.data == b'Foo'
-            self.assert_equal(rv.status_code, 404)
+            assert rv.status_code == 404
-                    "server name from the WSGI environment ('localhost.localdomain')")
+            assert str(e) == (
-            self.assert_equal(rv.status_code, 404)
+            assert rv.status_code == 404
-                    "server name from the WSGI environment ('foo.localhost')")
+            assert str(e) == (
-        self.assert_equal(rv.data, b'Foo SubDomain')
+        assert rv.data == b'Foo SubDomain'
-                    self.fail('expected exception')
+                    assert False, 'expected exception'
-                self.assert_equal(c.get('/').status_code, 500)
+                assert c.get('/').status_code == 500
-            self.assert_true(False)
+            assert False
-            self.assert_true(False)
+            assert False
-        self.assert_equal(rv.data, b'42')
+        assert rv.data == b'42'
-        self.assert_equal(c.get('/foo').data, b'/en/about')
+        assert c.get('/de/').data == b'/de/about'
-        self.assert_equal(values, expected)
+        assert values == expected
-        self.assert_equal(url, expected)
+        assert url == expected
-        self.assert_equal(rv.data, b'Hello World!')
+        assert rv.data == b'Hello World!'
-        self.assert_equal(app.test_client().get('/').data, b'Awesome')
+        assert not app.got_first_request
-            self.assert_in('A setup function was called', str(e))
+            assert 'A setup function was called' in str(e)
-            self.fail('Expected exception')
+            assert False, 'Expected exception'
-        self.assert_true(app.got_first_request)
+        assert app.test_client().get('/foo').data == b'Meh'
-        self.assert_equal(got, [42])
+        assert got == [42]
-        self.assert_true(app.got_first_request)
+        assert got == [42]
-            self.assert_equal(got, [42])
+            assert got == [42]
-        self.assert_true(app.got_first_request)
+        assert app.got_first_request
-                               'to this URL', str(e))
+                assert 'http://localhost/foo/' in str(e)
-                self.fail('Expected exception')
+                assert False, 'Expected exception'
-            self.assert_equal(rv.data, b'success')
+            assert rv.data == b'success'
-            self.assert_equal(rv.data, b'success')
+            assert rv.data == b'success'
-        self.assert_equal(c.get('/bar/123').data, b'123')
+        assert c.get('/foo/').data == b'foo'
-            with self.assert_raises(ZeroDivisionError):
+            with pytest.raises(ZeroDivisionError):
-        self.assert_true(flask._app_ctx_stack.top is not None)
+        assert flask._request_ctx_stack.top is not None
-        self.assert_true(flask._app_ctx_stack.top is None)
+        assert flask._request_ctx_stack.top is None
-        with self.assert_raises(ZeroDivisionError):
+        with pytest.raises(ZeroDivisionError):
-        self.assert_equal(errors, [])
+        assert errors == []
-        self.assert_true(isinstance(errors[0], ZeroDivisionError))
+        assert len(errors) == 2
-        self.assert_equal(errors[1], None)
+        assert len(errors) == 3
-            self.assert_equal(flask.g.get('x', 11), 11)
+            assert flask.g.get('x') == None
-            self.assert_equal(flask.g.x, 42)
+            assert flask.g.get('x') == 42
-            self.assert_equal(sorted(flask.g), ['bar', 'foo'])
+            assert 'foo' in flask.g
-        self.assert_equal(rv.data, b'normal index')
+        assert rv.data == b'normal index'
-        self.assert_equal(rv.data, b'test index')
+        assert rv.data == b'test index'
-        self.assert_equal(rv.data, b'index for mitsuhiko')
+        assert rv.data == b'index for mitsuhiko'
-        self.assert_equal(rv.data, b'index for mitsuhiko')
+        assert rv.data == b'index for mitsuhiko'
-        self.assert_equal(rv.data, b'a')
+        assert rv.data == b'a'
-        self.assert_equal(rv.data, b'b')
+        assert rv.data == b'b'
-        self.assert_equal(rv.data, b'a')
+        assert rv.data == b'a'
-        self.assert_equal(rv.data, b'b')
+        assert rv.data == b'b'
-        self.assert_equal(c.get('/what-is-a-sideend').data, b'application itself says no')
+        assert c.get('/frontend-no').data == b'frontend says no'
-            self.assert_true(isinstance(e, MyDecoratorException))
+            assert isinstance(e, MyDecoratorException)
-            self.assert_true(isinstance(e, MyFunctionException))
+            assert isinstance(e, MyFunctionException)
-        self.assert_equal(c.get('/function').data, b'bam')
+        assert c.get('/decorator').data == b'boom'
-        self.assert_equal(c.get('/2/bar').data, b'19')
+        assert c.get('/1/foo').data == b'23/42'
-        self.assert_equal(c.get('/de/about').data, b'/de/')
+        assert c.get('/de/').data == b'/de/about'
-        self.assert_equal(rv.data, b'Hello from the Frontend')
+        assert rv.data == b'Hello from the Frontend'
-        self.assert_equal(rv.data, b'Hello from the Admin')
+        assert rv.data == b'Hello from the Admin'
-        self.assert_equal(rv.data, b'Hello from the Admin')
+        assert rv.data == b'Hello from the Admin'
-        self.assert_equal(rv.data.strip(), b'Admin File')
+        assert rv.data.strip() == b'Admin File'
-        self.assert_equal(rv.data.strip(), b'/* nested file */')
+        assert rv.data.strip() == b'/* nested file */'
-            self.assert_equal(cc.max_age, expected_max_age)
+            assert cc.max_age == expected_max_age
-                              '/admin/static/test.txt')
+            assert flask.url_for('admin.static', filename='test.txt') == '/admin/static/test.txt'
-                self.assert_equal(e.name, 'missing.html')
+                assert e.name == 'missing.html'
-                self.assert_true(0, 'expected exception')
+                assert 0, 'expected exception'
-            self.assert_equal(flask.render_template('nested/nested.txt'), 'I\'m nested')
+            assert flask.render_template('nested/nested.txt') == 'I\'m nested'
-                self.assert_equal(cc.max_age, 100)
+                assert cc.max_age == 100
-                                     'frontend/index.html'])
+        assert templates == ['admin/index.html', 'frontend/index.html']
-        self.assert_equal(c.get('/be').data.strip(), b'/fe')
+        assert c.get('/fe').data.strip() == b'/be'
-            self.assert_equal(rv.data, b'/test/')
+            assert rv.data == b'/test/'
-        self.assert_equal(c.get('/page/2').data, b'2')
+        assert c.get('/').data == b'1'
-        self.assert_equal(c.get('/py/bar/foo').data, b'bp.bar_foo')
+        assert c.get('/').data == b'index'
-        self.assert_raises(
+        pytest.raises(
-        self.assert_raises(
+        pytest.raises(
-        self.assert_equal(c.get('/py/foo').data, b'bp.foo')
+        assert c.get('/py/foo').data == b'bp.foo'
-        self.assert_equal(app.jinja_env.filters['my_reverse']('abcd'), 'dcba')
+        assert 'my_reverse' in app.jinja_env.filters.keys()
-        self.assert_equal(app.jinja_env.filters['my_reverse']('abcd'), 'dcba')
+        assert 'my_reverse' in app.jinja_env.filters.keys()
-        self.assert_equal(app.jinja_env.filters['strrev']('abcd'), 'dcba')
+        assert 'strrev' in app.jinja_env.filters.keys()
-        self.assert_equal(app.jinja_env.filters['strrev']('abcd'), 'dcba')
+        assert 'strrev' in app.jinja_env.filters.keys()
-        self.assert_equal(rv.data, b'dcba')
+        assert rv.data == b'dcba'
-        self.assert_equal(rv.data, b'dcba')
+        assert rv.data == b'dcba'
-        self.assert_equal(rv.data, b'dcba')
+        assert rv.data == b'dcba'
-        self.assert_equal(rv.data, b'dcba')
+        assert rv.data == b'dcba'
-        self.assert_equal(rv.data, b'dcba')
+        assert rv.data == b'dcba'
-        self.assert_true(app.jinja_env.tests['is_boolean'](False))
+        assert 'is_boolean' in app.jinja_env.tests.keys()
-        self.assert_true(app.jinja_env.tests['is_boolean'](False))
+        assert 'is_boolean' in app.jinja_env.tests.keys()
-        self.assert_true(app.jinja_env.tests['boolean'](False))
+        assert 'boolean' in app.jinja_env.tests.keys()
-        self.assert_true(app.jinja_env.tests['boolean'](False))
+        assert 'boolean' in app.jinja_env.tests.keys()
-        self.assert_in(b'Success!', rv.data)
+        assert b'Success!' in rv.data
-        self.assert_in(b'Success!', rv.data)
+        assert b'Success!' in rv.data
-        self.assert_in(b'Success!', rv.data)
+        assert b'Success!' in rv.data
-        self.assert_in(b'Success!', rv.data)
+        assert b'Success!' in rv.data
-        self.assert_in(b'Success!', rv.data)
+        assert b'Success!' in rv.data
-        self.assert_not_in('TestConfig', app.config)
+        assert app.secret_key == 'devkey'
-        with self.assert_raises(TypeError):
+        with pytest.raises(TypeError):
-                self.assert_true("'FOO_SETTINGS' is not set" in str(e))
+                assert "'FOO_SETTINGS' is not set" in str(e)
-            self.assert_false(app.config.from_envvar('FOO_SETTINGS', silent=True))
+                assert 0, 'expected exception'
-            self.assert_true(app.config.from_envvar('FOO_SETTINGS'))
+            assert app.config.from_envvar('FOO_SETTINGS')
-                self.assert_true(msg.endswith("missing.cfg'"))
+                assert msg.startswith('[Errno 2] Unable to load configuration '
-            self.assert_false(app.config.from_envvar('FOO_SETTINGS', silent=True))
+                assert False, 'expected IOError'
-            self.assert_true(msg.endswith("missing.cfg'"))
+            assert msg.startswith('[Errno 2] Unable to load configuration '
-        self.assert_false(app.config.from_pyfile('missing.cfg', silent=True))
+            assert 0, 'expected config'
-            self.assert_true(msg.endswith("missing.json'"))
+            assert msg.startswith('[Errno 2] Unable to load configuration '
-        self.assert_false(app.config.from_json('missing.json', silent=True))
+            assert 0, 'expected config'
-        self.assert_isinstance(app.config, Config)
+        assert isinstance(app.config, Config)
-        self.assert_equal(app.permanent_session_lifetime.seconds, 42)
+        assert app.permanent_session_lifetime.seconds == 42
-        self.assert_equal('foo option 2', foo_options['option_2'])
+        assert 2 == len(foo_options)
-        self.assert_equal('bar stuff 2', bar_options['STUFF_2'])
+        assert 2 == len(bar_options)
-        self.assert_equal(app.instance_path, str(apps_tmpdir))
+        assert app.instance_path == str(apps_tmpdir)
-                with self.assert_raises(AttributeError):
+                with pytest.raises(AttributeError):
-        self.assert_equal(import_hooks, 1)
+        assert import_hooks == 1
-            self.assert_not_in('.', key)
+            assert '.' not in key
-        self.assert_equal(ext_id, 'newext_simple')
+        assert ext_id == 'newext_simple'
-        self.assert_equal(newext_simple.__name__, 'flask_newext_simple')
+        assert newext_simple.ext_id == 'newext_simple'
-        self.assert_equal(ext_id, 'newext_package')
+        assert ext_id == 'newext_package'
-        self.assert_equal(newext_package.__name__, 'flask_newext_package')
+        assert newext_package.ext_id == 'newext_package'
-        self.assert_equal(test_function(), 42)
+        assert test_function() == 42
-        self.assert_equal(submodule.test_function(), 42)
+        assert submodule.__name__ == 'flask_newext_package.submodule'
-        self.assert_equal(ext_id, 'oldext_simple')
+        assert ext_id == 'oldext_simple'
-        self.assert_equal(oldext_simple.__name__, 'flaskext.oldext_simple')
+        assert oldext_simple.ext_id == 'oldext_simple'
-        self.assert_equal(ext_id, 'oldext_package')
+        assert ext_id == 'oldext_package'
-        self.assert_equal(oldext_package.__name__, 'flaskext.oldext_package')
+        assert oldext_package.ext_id == 'oldext_package'
-        self.assert_equal(submodule.test_function(), 42)
+        assert submodule.__name__ == 'flaskext.oldext_package.submodule'
-        self.assert_equal(test_function(), 42)
+        assert test_function() == 42
-            with self.assert_raises(ImportError):
+            with pytest.raises(ImportError):
-            self.assert_true(exc_type is ImportError)
+            assert exc_type is ImportError
-            self.assert_true(tb.tb_frame.f_globals is globals())
+            assert str(exc_value) == message
-            self.assert_in(os.path.join('flask_broken', '__init__.py'), next.tb_frame.f_code.co_filename)
+            assert os.path.join('flask_broken', '__init__.py') in \
-        self.assert_equal(rv.status_code, 400)
+        assert rv.status_code == 400
-        self.assert_equal(rv.data, b'foo')
+        assert rv.data == b'foo'
-        self.assert_equal(resp.data, u'HÃ¤llo WÃ¶rld'.encode('utf-8'))
+        assert resp.data == u'HÃ¤llo WÃ¶rld'.encode('utf-8')
-            self.assert_equal(flask.json.loads(rv.data), d)
+            assert rv.mimetype == 'application/json'
-            self.assert_equal(rv, '"\\u2603"')
+            assert rv == '"\\u2603"'
-            self.assert_equal(rv, u'"\u2603"')
+            assert rv == u'"\u2603"'
-        self.assert_equal(rv.data, b'3')
+        assert rv.data == b'3'
-            self.assert_equal(type(rv), text_type)
+            assert rv == u'"\\u003c/script\\u003e"'
-            self.assert_equal(rv, '"\\u003c/script\\u003e"')
+            assert rv == '"\\u003c/script\\u003e"'
-            self.assert_equal(rv, '"\\u003c\\u0000/script\\u003e"')
+            assert rv == '"\\u003c\\u0000/script\\u003e"'
-            self.assert_equal(rv, '"\\u003c!--\\u003cscript\\u003e"')
+            assert rv == '"\\u003c!--\\u003cscript\\u003e"'
-            self.assert_equal(rv, '"\\u0026"')
+            assert rv == '"\\u0026"'
-            self.assert_equal(rv, '"\\u0027"')
+            assert rv == '"\\u0027"'
-                '<a ng-data=\'{"x": ["foo", "bar", "baz\\u0027"]}\'></a>')
+            assert rv == '<a ng-data=\'{"x": ["foo", "bar", "baz\\u0027"]}\'></a>'
-        self.assert_equal(rv.data, b'"<42>"')
+        assert rv.data == b'"<42>"'
-        self.assert_equal(rv.data, u'ì ìì²ë¦¬'.encode('utf-8'))
+        assert rv.status_code == 200
-        self.assert_equal(app.config['JSON_SORT_KEYS'], True)
+        assert app.config['JSON_SORT_KEYS'] == True
-            self.assert_equal(lines, sorted_by_int)
+            assert lines == sorted_by_int
-            self.assert_equal(lines, sorted_by_str)
+            assert lines == sorted_by_str
-            self.assert_equal(rv.mimetype, 'text/html')
+            assert rv.direct_passthrough
-                self.assert_equal(rv.data, f.read())
+                assert rv.data == f.read()
-            self.assert_equal(rv.mimetype, 'text/html')
+            assert rv.direct_passthrough
-                self.assert_equal(rv.mimetype, 'text/html')
+                    assert rv.data == f.read()
-            self.assert_equal(len(captured), 2)
+            assert len(captured) == 2
-                    os.path.join(app.root_path, 'static/index.html'))
+                assert rv.mimetype == 'text/html'
-            self.assert_equal(len(captured), 2)
+            assert len(captured) == 2
-                self.assert_equal(rv.mimetype, 'application/octet-stream')
+                assert rv.data == b'Test'
-            self.assert_equal(len(captured), 1)
+            assert len(captured) == 1
-                self.assert_equal(rv.mimetype, 'text/plain')
+                assert rv.data == b'Test'
-            self.assert_equal(len(captured), 3)
+            assert len(captured) == 3
-                self.assert_equal(rv.mimetype, 'text/plain')
+                assert rv.data == b'Test'
-            self.assert_equal(len(captured), 1)
+            assert len(captured) == 1
-                self.assert_not_in('x-sendfile', rv.headers)
+                assert 'x-sendfile' not in rv.headers
-            self.assert_equal(len(captured), 1)
+            assert len(captured) == 1
-                self.assert_equal(value, 'attachment')
+                assert value == 'attachment'
-            self.assert_equal(len(captured), 2)
+            assert len(captured) == 2
-            self.assert_equal(options['filename'], 'index.html')
+            assert options['filename'] == 'index.html'
-            self.assert_equal(options['filename'], 'index.html')
+            assert value == 'attachment'
-            self.assert_equal(rv.mimetype, 'text/plain')
+            assert rv.mimetype == 'text/plain'
-            self.assert_equal(options['filename'], 'index.txt')
+            assert value == 'attachment'
-            self.assert_equal(cc.max_age, 12 * 60 * 60)
+            assert cc.max_age == 12 * 60 * 60
-            self.assert_equal(cc.max_age, 12 * 60 * 60)
+            assert cc.max_age == 12 * 60 * 60
-            self.assert_equal(cc.max_age, 3600)
+            assert cc.max_age == 3600
-            self.assert_equal(cc.max_age, 3600)
+            assert cc.max_age == 3600
-            self.assert_equal(cc.max_age, 10)
+            assert cc.max_age == 10
-            self.assert_equal(cc.max_age, 10)
+            assert cc.max_age == 10
-            self.assert_equal(rv.data.strip(), b'Hello Subdomain')
+            assert rv.data.strip() == b'Hello Subdomain'
-        self.assert_equal(logger1.name, __name__)
+        assert app.logger is logger1
-        self.assert_true(app.logger is not logger1)
+        assert app.logger is not logger1
-                self.assert_in('this is a debug statement', out)
+                assert 'WARNING in test_helpers [' in out
-                    self.assert_true(False, 'debug log ate the exception')
+                    assert False, 'debug log ate the exception'
-        self.assert_equal(app.logger.level, 10)
+        assert app.logger.level == 10
-        self.assert_in(b'Internal Server Error', rv.data)
+        assert rv.status_code == 500
-        self.assert_in('ZeroDivisionError:', err)
+        assert 'Exception on / [GET]' in err
-            self.assert_equal(rv.data, b'Hello Server Error')
+            assert rv.status_code == 500
-                              '/#x%20y')
+            assert flask.url_for('index', _anchor='x y') == '/#x%20y'
-                              'https://localhost/')
+            assert flask.url_for('index', _external=True, _scheme='https') == 'https://localhost/'
-            self.assert_raises(ValueError,
+            pytest.raises(ValueError,
-                              '/myview/create')
+            assert flask.url_for('myview', _method='GET') == '/myview/'
-            self.fail('Flask(import_name) is importing import_name.')
+            assert False, 'Flask(import_name) is importing import_name.'
-        self.assert_equal(rv.data, b'Hello World!')
+        assert rv.data == b'Hello World!'
-        self.assert_equal(rv.data, b'Hello World!')
+        assert rv.data == b'Hello World!'
-        self.assert_equal(called, [42])
+        assert rv.data == b'Hello World!'
-                self.assert_equal(rv.data, b'<h1>42</h1>')
+                assert rv.status_code == 200
-        with self.assert_raises(NotFound):
+        with pytest.raises(NotFound):
-            self.assert_equal(rv.headers['Location'], 'http://localhost/test')
+            assert rv.headers['Location'] == 'http://localhost/test'
-            self.assert_equal(rv.data, b'42')
+            assert rv.data == b'42'
-        self.assert_equal(buffer, [])
+        assert buffer == []
-        self.assert_equal(buffer, [None])
+        assert buffer == [None]
-        self.assert_equal(buffer, [None])
+            assert buffer == []
-            self.assert_equal(flask.url_for('index', _external=True), 'http://localhost.localdomain:5000/')
+            assert flask.url_for('index', _external=True) == \
-            self.assert_equal(flask.url_for('sub', _external=True), 'http://foo.localhost.localdomain:5000/')
+            assert flask.url_for('sub', _external=True) == \
-                "No ValueError exception should have been raised \"%s\"" % e
+            assert str(e) == (
-            )
+        app.config.update(SERVER_NAME='localhost')
-            self.assert_equal(index(), 'Hello World!')
+            assert index() == 'Hello World!'
-        self.assert_true(flask._request_ctx_stack.top is None)
+            assert meh() == 'http://localhost/meh'
-        self.assert_false(flask.has_request_context())
+        assert not flask.request
-            self.assert_true(flask.has_request_context())
+            assert flask.request
-        self.assert_equal(index(), 'Hello World!')
+        assert index() == 'Hello World!'
-            self.assert_true(0, 'expected runtime error')
+            assert 0, 'expected runtime error'
-                self.assert_false(flask.current_app)
+                assert not flask.request
-                self.assert_false(flask.request)
+                    assert flask.request
-        self.assert_equal(rv.data, b'Hello World!')
+        assert rv.data == b'Hello World!'
-        self.assert_equal(result, 42)
+        assert result == 42
-                self.assert_equal(flask.request.args['foo'], 'bar')
+                assert flask.request
-        self.assert_equal(rv.data, b'Hello World!')
+        assert rv.data == b'Hello World!'
-        self.assert_equal(result, 42)
+        assert result == 42
-            self.assert_equal(len(recorded), 1)
+            assert len(recorded) == 1
-            self.assert_equal(context['whiskey'], 42)
+            assert template.name == 'simple_template.html'
-            self.assert_equal(response.data, b'stuff')
+            assert response.data == b'stuff'
-            self.assert_equal(rv.data, b'stuff')
+            assert rv.data == b'stuff'
-                                      'after-signal'])
+            assert calls == ['before-signal', 'before-handler', 'handler',
-            self.assert_true(isinstance(recorded[0], ZeroDivisionError))
+            assert app.test_client().get('/').status_code == 500
-            self.assert_equal(recorded, ['push', 'pop'])
+                assert rv.data == b'Hello'
-                self.assert_equal(len(recorded), 1)
+                assert len(recorded) == 1
-                self.assert_equal(category, 'notice')
+                assert message == 'This is a flash message'
-        self.assert_in(b'Internal Server Error', rv.data)
+        assert rv.status_code == 500
-        self.assert_equal(err, '')
+        assert err == ''
-        self.assert_equal(rv.data, b'<p>23|42')
+        assert rv.data == b'<p>23|42'
-        self.assert_equal(rv.data, b'42')
+        assert rv.data == b'42'
-            self.assert_equal(rv, 'Hello Special World 42')
+            assert rv == 'Hello Special World 42'
-        self.assert_equal(rv.data.split(), [b'42', b'23', b'False', b'aha'])
+        assert rv.data.split() == [b'42', b'23', b'False', b'aha']
-        self.assert_equal(lines, [
+        assert lines == [
-        ])
+        ]
-                              '<test> Mail')
+            assert flask.render_template_string(
-            self.assert_equal(macro('World'), 'Hello World!')
+            assert macro('World') == 'Hello World!'
-        self.assert_equal(app.jinja_env.filters['my_reverse']('abcd'), 'dcba')
+        assert 'my_reverse' in app.jinja_env.filters.keys()
-        self.assert_equal(app.jinja_env.filters['my_reverse']('abcd'), 'dcba')
+        assert 'my_reverse' in app.jinja_env.filters.keys()
-        self.assert_equal(app.jinja_env.filters['strrev']('abcd'), 'dcba')
+        assert 'strrev' in app.jinja_env.filters.keys()
-        self.assert_equal(app.jinja_env.filters['strrev']('abcd'), 'dcba')
+        assert 'strrev' in app.jinja_env.filters.keys()
-        self.assert_equal(rv.data, b'dcba')
+        assert rv.data == b'dcba'
-        self.assert_equal(rv.data, b'dcba')
+        assert rv.data == b'dcba'
-        self.assert_equal(rv.data, b'dcba')
+        assert rv.data == b'dcba'
-        self.assert_equal(rv.data, b'dcba')
+        assert rv.data == b'dcba'
-        self.assert_true(app.jinja_env.tests['boolean'](False))
+        assert 'boolean' in app.jinja_env.tests.keys()
-        self.assert_true(app.jinja_env.tests['boolean'](False))
+        assert 'boolean' in app.jinja_env.tests.keys()
-        self.assert_true(app.jinja_env.tests['boolean'](False))
+        assert 'boolean' in app.jinja_env.tests.keys()
-        self.assert_true(app.jinja_env.tests['boolean'](False))
+        assert 'boolean' in app.jinja_env.tests.keys()
-        self.assert_in(b'Success!', rv.data)
+        assert b'Success!' in rv.data
-        self.assert_in(b'Success!', rv.data)
+        assert b'Success!' in rv.data
-        self.assert_in(b'Success!', rv.data)
+        assert b'Success!' in rv.data
-        self.assert_in(b'Success!', rv.data)
+        assert b'Success!' in rv.data
-        self.assert_true(app.jinja_env.globals['get_stuff'](), 42)
+        assert 'get_stuff' in app.jinja_env.globals.keys()
-            self.assert_equal(rv, '42')
+            assert rv == '42'
-        self.assert_equal(rv.data, b'Hello Custom World!')
+        assert rv.data == b'Hello Custom World!'
-        self.assert_equal(rv.data, b'<h1>Jameson</h1>')
+        assert rv.data == b'<h1>Jameson</h1>'
-        self.assert_true(app.jinja_env.auto_reload)
+        assert app.config['TEMPLATES_AUTO_RELOAD']
-        self.assert_false(app.jinja_env.auto_reload)
+        assert not app.jinja_env.auto_reload
-                    'See http://flask.pocoo.org/docs/blueprints/#templates' in text)
+                assert '1: trying loader of application "blueprintapp"' in text
-                    self.assert_('missing_template.html' in str(e))
+                    assert 'missing_template.html' in str(e)
-        self.assert_equal(len(called), 1)
+        assert len(called) == 1
-        self.assert_equal(ctx.request.url, 'http://example.com:1234/foo/')
+        assert ctx.request.url == 'http://example.com:1234/foo/'
-            self.assert_equal(rv.data, b'http://example.com:1234/foo/')
+            assert rv.data == b'http://example.com:1234/foo/'
-        self.assert_equal(ctx.request.url, 'http://localhost/')
+        assert ctx.request.url == 'http://localhost/'
-            self.assert_equal(rv.data, b'http://localhost/')
+            assert rv.data == b'http://localhost/'
-                self.assert_equal(len(sess), 0)
+                assert len(sess) == 0
-                self.assert_equal(len(sess), 1)
+                assert len(sess) == 1
-            self.assert_equal(rv.data, b'[42]')
+            assert rv.data == b'[42]'
-                self.assert_equal(sess['foo'], [42])
+                assert len(sess) == 1
-                self.assert_in('Session backend did not open a session', str(e))
+                assert 'Session backend did not open a session' in str(e)
-                self.fail('Expected runtime error')
+                assert False, 'Expected runtime error'
-            self.assert_true(req is not None)
+            assert req is not None
-                self.assert_true(req is flask.request._get_current_object())
+                assert req is flask.request._get_current_object()
-            self.assert_in('cookies', str(e))
+            assert 'cookies' in str(e)
-            self.fail('Expected runtime error')
+            assert False, 'Expected runtime error'
-            self.assert_equal(resp.status_code, 200)
+            assert flask.g.value == 42
-            self.assert_equal(resp.status_code, 500)
+            assert not hasattr(flask.g, 'value')
-            self.assert_equal(c.get('/').status_code, 404)
+            assert c.get('/').status_code == 404
-            self.assert_equal(c.get('/').status_code, 404)
+            assert c.get('/').status_code == 404
-            self.assert_equal(called, [])
+            assert called == []
-        self.assert_equal(called, [None])
+            assert called == []
-            self.assert_equal(called, [])
+            assert called == []
-            self.assert_equal(called, [])
+            assert called == []
-        self.assert_equal(called, [None, None])
+            assert called == [None]
-            self.assert_true('vodka' in flask.request.args)
+            assert rv.status_code == 200
-        self.assert_equal(b'xxx', response.data)
+        assert 200 == response.status_code
-        self.assert_equal(b'xxx', response.data)
+        assert 200 == response.status_code
-        self.assert_equal(c.put('/').status_code, 405)
+        assert c.get('/').data == b'GET'
-        self.assert_equal(sorted(meths), ['GET', 'HEAD', 'OPTIONS', 'POST'])
+        assert sorted(meths) == ['GET', 'HEAD', 'OPTIONS', 'POST']
-        self.assert_equal(sorted(meths), ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST'])
+        assert sorted(meths) == ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST']
-        self.assert_equal(rv.data, b'Awesome')
+        assert rv.headers['X-Parachute'] == 'awesome'
-        self.assert_equal(rv.headers['X-Method'], 'GET')
+        assert rv.data == b'Blub'
-        self.assert_equal(rv.headers['X-Method'], 'HEAD')
+        assert rv.data == b''
-        self.assert_equal(rv.data, b'GET')
+        assert rv.data == b'GET'
-        self.assert_equal(rv.headers['X-Method'], 'HEAD')
+        assert rv.data == b''
-        with self.assert_raises(AssertionError):
+        with pytest.raises(AssertionError):
-import unittest
+pytestmark = pytest.mark.skipif(
-                             'after-signal'])
+                                      'handler', 'after-handler',
-    return suite
+# -*- coding: utf-8 -*-
-
+import pytest
-def patch_pkgutil_get_loader(wrapper_class=LimitedLoaderMockWrapper):
+@pytest.fixture(params=(True, False))
-
+        return LimitedLoader(old_get_loader(*args, **kwargs))
-        try:
+    @pytest.fixture
-            self.fail('Expected value error')
+        assert 'must be absolute' in str(excinfo.value)
-        self.assert_equal(app.instance_path, here)
+    def test_main_module_paths(self, apps_tmpdir, purge_module):
-            del sys.modules['main_app']
+        assert app.instance_path == os.path.join(here, 'instance')
-        self.assert_equal(app.instance_path, os.path.join(here, 'test_apps', 'instance'))
+        assert app.instance_path == str(apps_tmpdir.join('instance'))
-        monkeypatch.syspath_prepend(site_packages)
+        assert app.instance_path == str(apps_tmpdir.join('instance'))
-                                           'site_egg-instance'))
+            import site_egg
-    def test_egg_installed_paths(self):
+    def test_egg_installed_paths(self, monkeypatch):
-        site_packages = os.path.join(expected_prefix, 'lib', 'python2.5', 'site-packages')
+        monkeypatch.setattr(sys, 'prefix', expected_prefix)
-        sys.path.append(egg_path)
+        monkeypatch.syspath_prepend(egg_path)
-    packages=['flask', 'flask.ext', 'flask.testsuite'],
+    packages=['flask', 'flask.ext'],
-    unittest.main()
+# -*- coding: utf-8 -*-
-    unittest.main()
+# -*- coding: utf-8 -*-
-    unittest.main()
+# -*- coding: utf-8 -*-
-from flask._compat import reraise, StringIO
+from flask._compat import StringIO
-
+
-class FlaskTestCase(unittest.TestCase):
+class TestFlask(object):
-        return self.assertEqual(x, y)
+        assert x == y
-            callable(*args, **kwargs)
+        if callable:
-        self.assertTrue(x, msg)
+        assert x
-        self.assertFalse(x, msg)
+        assert not x
-        self.assertIn(x, y)
+        assert x in y
-        self.assertNotIn(x, y)
+        assert x not in y
-
+        assert isinstance(obj, cls)
-        print('Error: %s' % e)
+    def fail(self, msg):
-from tests import FlaskTestCase
+from tests import TestFlask
-class AppContextTestCase(FlaskTestCase):
+class TestAppContext(TestFlask):
-        self.assertEqual(called, ['request', 'app'])
+        self.assert_equal(called, ['request', 'app'])
-    suite.addTest(unittest.makeSuite(AppContextTestCase))
+    suite.addTest(unittest.makeSuite(TestAppContext))
-# NoImportsTestCase
+# TestNoImports
-from tests import FlaskTestCase, emits_module_deprecation_warning
+from tests import TestFlask, emits_module_deprecation_warning
-class BasicFunctionalityTestCase(FlaskTestCase):
+class TestBasicFunctionality(TestFlask):
-        self.assertEqual(resp.headers['X-Foo'], 'a header')
+        self.assert_equal(resp.status_code, 200)
-            self.assertEqual(rv.mimetype, 'application/json')
+            self.assert_equal(rv.status_code, 400)
-            self.assertEqual(rv.mimetype, 'text/html')
+            self.assert_equal(rv.status_code, 400)
-            self.assertEqual(rv.headers['X-Foo'], 'bar')
+            self.assert_equal(rv.status_code, 400)
-            self.assertRaises(BuildError, flask.url_for, 'spam')
+            self.assert_raises(BuildError, flask.url_for, 'spam')
-            self.assertRaises(BuildError, app.handle_url_build_error, error, 'spam', {})
+            self.assert_raises(BuildError, app.handle_url_build_error, error, 'spam', {})
-        self.assertFalse(flask.g)
+        self.assert_false(flask.g)
-        self.assertEqual(c.get('/bar/123').data, b'123')
+        self.assert_equal(c.get('/foo/').data, b'foo')
-class SubdomainTestCase(FlaskTestCase):
+class TestSubdomain(TestFlask):
-from tests import FlaskTestCase
+from tests import TestFlask
-class BlueprintTestCase(FlaskTestCase):
+class TestBlueprint(TestFlask):
-        self.assertEqual(c.get('/py/bar/foo').data, b'bp.bar_foo')
+        self.assert_equal(c.get('/').data, b'index')
-        self.assertRaises(
+        self.assert_raises(
-        self.assertRaises(
+        self.assert_raises(
-        self.assertEqual(c.get('/py/foo').data, b'bp.foo')
+        self.assert_equal(c.get('/py/foo').data, b'bp.foo')
-    suite.addTest(unittest.makeSuite(BlueprintTestCase))
+    suite.addTest(unittest.makeSuite(TestBlueprint))
-from tests import FlaskTestCase
+from tests import TestFlask
-# config keys used for the ConfigTestCase
+# config keys used for the TestConfig
-class ConfigTestCase(FlaskTestCase):
+class TestConfig(TestFlask):
-        self.assert_not_in('ConfigTestCase', app.config)
+        self.assert_not_in('TestConfig', app.config)
-            self.assertFalse(app.config.from_envvar('FOO_SETTINGS', silent=True))
+            self.assert_false(app.config.from_envvar('FOO_SETTINGS', silent=True))
-class InstanceTestCase(FlaskTestCase):
+class TestInstance(TestFlask):
-    suite.addTest(unittest.makeSuite(InstanceTestCase))
+    suite.addTest(unittest.makeSuite(TestConfig))
-from tests import FlaskTestCase, catch_warnings
+from tests import TestFlask, catch_warnings
-class DeprecationsTestCase(FlaskTestCase):
+class TestDeprecations(TestFlask):
-    suite.addTest(unittest.makeSuite(DeprecationsTestCase))
+    suite.addTest(unittest.makeSuite(TestDeprecations))
-        from minitwit_tests import MiniTwitTestCase
+        from minitwit_tests import TestMiniTwit
-        suite.addTest(unittest.makeSuite(MiniTwitTestCase))
+        suite.addTest(unittest.makeSuite(TestMiniTwit))
-        from flaskr_tests import FlaskrTestCase
+        from flaskr_tests import TestFlaskr
-        suite.addTest(unittest.makeSuite(FlaskrTestCase))
+        suite.addTest(unittest.makeSuite(TestFlaskr))
-from tests import FlaskTestCase
+from tests import TestFlask
-class ExtImportHookTestCase(FlaskTestCase):
+class TestExtImportHook(TestFlask):
-    suite.addTest(unittest.makeSuite(ExtImportHookTestCase))
+    suite.addTest(unittest.makeSuite(TestExtImportHook))
-from tests import FlaskTestCase, catch_warnings, catch_stderr
+from tests import TestFlask, catch_warnings, catch_stderr
-class JSONTestCase(FlaskTestCase):
+class TestJSON(TestFlask):
-        self.assertEqual(rv.data, b'"<42>"')
+        self.assert_equal(rv.data, b'"<42>"')
-class SendfileTestCase(FlaskTestCase):
+class TestSendfile(TestFlask):
-class LoggingTestCase(FlaskTestCase):
+class TestLogging(TestFlask):
-                self.assert_in('WARNING in helpers [', out)
+                self.assert_in('WARNING in test_helpers [', out)
-class NoImportsTestCase(FlaskTestCase):
+class TestNoImports(TestFlask):
-class StreamingTestCase(FlaskTestCase):
+class TestStreaming(TestFlask):
-        self.assertEqual(rv.data, b'Hello World!')
+        self.assert_equal(rv.data, b'Hello World!')
-        self.assertEqual(rv.data, b'Hello World!')
+        self.assert_equal(rv.data, b'Hello World!')
-        self.assertEqual(called, [42])
+        self.assert_equal(rv.data, b'Hello World!')
-    suite.addTest(unittest.makeSuite(StreamingTestCase))
+        suite.addTest(unittest.makeSuite(TestJSON))
-from tests import FlaskTestCase
+from tests import TestFlask
-class MemoryTestCase(FlaskTestCase):
+@pytest.mark.skipif(os.environ.get('RUN_FLASK_MEMORY_TESTS') != '1',
-class ExceptionTestCase(FlaskTestCase):
+class TestException(TestFlask):
-            self.assertEqual(rv.headers['Location'], 'http://localhost/test')
+            self.assert_equal(rv.headers['Location'], 'http://localhost/test')
-    return suite
+            self.assert_equal(rv.data, b'42')
-from tests import FlaskTestCase
+from tests import TestFlask
-class RequestContextTestCase(FlaskTestCase):
+class TestRequestContext(TestFlask):
-    suite.addTest(unittest.makeSuite(RequestContextTestCase))
+    suite.addTest(unittest.makeSuite(TestRequestContext))
-from tests import FlaskTestCase
+from tests import TestFlask
-class SignalsTestCase(FlaskTestCase):
+class TestSignals(TestFlask):
-        suite.addTest(unittest.makeSuite(SignalsTestCase))
+        suite.addTest(unittest.makeSuite(TestSignals))
-from tests import FlaskTestCase
+from tests import TestFlask
-class FlaskSubclassingTestCase(FlaskTestCase):
+class TestFlaskSubclassing(TestFlask):
-    suite.addTest(unittest.makeSuite(FlaskSubclassingTestCase))
+    suite.addTest(unittest.makeSuite(TestFlaskSubclassing))
-from tests import FlaskTestCase
+from tests import TestFlask
-class TemplatingTestCase(FlaskTestCase):
+class TestTemplating(TestFlask):
-    suite.addTest(unittest.makeSuite(TemplatingTestCase))
+    suite.addTest(unittest.makeSuite(TestTemplating))
-from tests import FlaskTestCase
+from tests import TestFlask
-class TestToolsTestCase(FlaskTestCase):
+class TestTestTools(TestFlask):
-class SubdomainTestCase(FlaskTestCase):
+class TestSubdomain(TestFlask):
-        self.client = self.app.test_client()
+    @pytest.fixture
-        self._ctx.push()
+        def teardown():
-            self._ctx.pop()
+    @pytest.fixture
-        @self.app.route('/', subdomain='<company_id>')
+    def test_subdomain(self, app, client):
-        response = self.client.get(url)
+        response = client.get(url)
-        @self.app.route('/<company_id>')
+    def test_nosubdomain(self, app, client):
-        response = self.client.get(url)
+        response = client.get(url)
-from tests import FlaskTestCase
+from tests import TestFlask
-class ViewTestCase(FlaskTestCase):
+class TestView(TestFlask):
-    suite.addTest(unittest.makeSuite(ViewTestCase))
+    suite.addTest(unittest.makeSuite(TestView))
-    flask.testsuite
+    tests
-    flask.testsuite.appctx
+    tests.appctx
-from flask.testsuite import FlaskTestCase
+from tests import FlaskTestCase
-    flask.testsuite.basic
+    tests.basic
-from flask.testsuite import FlaskTestCase, emits_module_deprecation_warning
+from tests import FlaskTestCase, emits_module_deprecation_warning
-    flask.testsuite.blueprints
+    tests.blueprints
-from flask.testsuite import FlaskTestCase
+from tests import FlaskTestCase
-    flask.testsuite.config
+    tests.config
-from flask.testsuite import FlaskTestCase
+from tests import FlaskTestCase
-    flask.testsuite.deprecations
+    tests.deprecations
-from flask.testsuite import FlaskTestCase, catch_warnings
+from tests import FlaskTestCase, catch_warnings
-    flask.testsuite.examples
+    tests.examples
-from flask.testsuite import add_to_path
+from tests import add_to_path
-    flask.testsuite.ext
+    tests.ext
-from flask.testsuite import FlaskTestCase
+from tests import FlaskTestCase
-    flask.testsuite.helpers
+    tests.helpers
-from flask.testsuite import FlaskTestCase, catch_warnings, catch_stderr
+from tests import FlaskTestCase, catch_warnings, catch_stderr
-    flask.testsuite.regression
+    tests.regression
-from flask.testsuite import FlaskTestCase
+from tests import FlaskTestCase
-    flask.testsuite.reqctx
+    tests.reqctx
-from flask.testsuite import FlaskTestCase
+from tests import FlaskTestCase
-    flask.testsuite.signals
+    tests.signals
-from flask.testsuite import FlaskTestCase
+from tests import FlaskTestCase
-    flask.testsuite.subclassing
+    tests.subclassing
-from flask.testsuite import FlaskTestCase
+from tests import FlaskTestCase
-    flask.testsuite.templating
+    tests.templating
-from flask.testsuite import FlaskTestCase
+from tests import FlaskTestCase
-    flask.testsuite.testing
+    tests.testing
-from flask.testsuite import FlaskTestCase
+from tests import FlaskTestCase
-    flask.testsuite.views
+    tests.views
-from flask.testsuite import FlaskTestCase
+from tests import FlaskTestCase
-    test_suite='flask.testsuite.suite'
+    cmdclass={'audit': run_audit}
-# actually rememberable.
+# actually memorable.
-        # In case the root module is a pcakage we need to chop of the
+        # In case the root module is a package we need to chop of the
-        for blueprint in itervalues(self.app.blueprints):
+        for blueprint in self.app.iter_blueprints():
-        for name, blueprint in iteritems(self.app.blueprints):
+        for blueprint in self.app.iter_blueprints():
-                text = unicode(record.msg)
+                text = str(record.msg)
-            from debughelpers import explain_template_loading_attempts
+            from .debughelpers import explain_template_loading_attempts
-from ._compat import implements_to_string
+from ._compat import implements_to_string, text_type
-        for loader, local_name in self._iter_loaders(template):
+        explain = self.app.config['EXPLAIN_TEMPLATE_LOADING']
-                return loader.get_source(environment, local_name)
+                rv = loader.get_source(environment, template)
-                pass
+                rv = None
-            yield loader, template
+            yield self.app, loader
-                yield loader, template
+                yield blueprint, loader
-from .debughelpers import attach_enctype_error_multidict
+            from .debughelpers import attach_enctype_error_multidict
-from ._compat import iteritems
+from ._compat import iteritems, reraise
-            raise exc_info[0], exc_info[1], exc_info[2]
+            reraise(*exc_info)
-from threading import Lock
+from threading import Lock, Thread
-    errors for import problems into the browser as error.
+    is imported by name in a background thread.  If an error happens
-        """Indicates weather a cookie should be set now or not.  This is
+        """Indicates whether a cookie should be set now or not.  This is
-    this.  Not to be confused with :class:`AppGroup`.
+class AppGroup(click.Group):
-        click.Group.__init__(self, params=params, **extra)
+        AppGroup.__init__(self, params=params, **extra)
-        rv = click.Group.get_command(self, ctx, name)
+        rv = AppGroup.get_command(self, ctx, name)
-        return decorator
+        return AppGroup.main(self, *args, **kwargs)
-      request context is available.
+      request context is available. As of Werkzeug 0.10, this also can be set
-def should_log_for(app, mode):
+@LocalProxy
-            if app.debug and should_log_for(app, 'debug'):
+            if app.debug and _should_log_for(app, 'debug'):
-            if not app.debug and should_log_for(app, 'production'):
+            if not app.debug and _should_log_for(app, 'production'):
-    prod_handler = ProductionHandler()
+    prod_handler = ProductionHandler(_proxy_stream)
-                    result.add(prefix + template)
+                    result.add(template)
-from flask.testsuite import FlaskTestCase, emits_module_deprecation_warning
+from flask.testsuite import FlaskTestCase
-
+        'LOGGER_HANDLER_POLICY':               'always',
-from logging import getLogger, StreamHandler, Formatter, getLoggerClass, DEBUG
+from logging import getLogger, StreamHandler, Formatter, getLoggerClass, \
-            StreamHandler.emit(x, record) if app.debug else None
+        def emit(self, record):
-    logger.addHandler(handler)
+    logger.addHandler(debug_handler)
-                    resp = c.get('/')
+                    c.get('/')
-    code.interact(banner=banner, local=app.make_shell_context())
+    ctx = {}
-            return click.Group.command(*args, **kwargs)(f)
+            return click.Group.command(self, *args, **kwargs)(f)
-
+    'http://click.pocoo.org/': None,
-    'http://discorporate.us/projects/Blinker/docs/1.1/': None
+    'https://wtforms.readthedocs.org/en/latest/': None,
-        The idea of the first parameter is to give Flask an idea what
+        The idea of the first parameter is to give Flask an idea of what
-from . import json
+from . import json, cli
-        self.cli = click.Group(self)
+        self.cli = cli.AppGroup(self)
-from contextlib import contextmanager
+from functools import update_wrapper
-pass_script_info = click.make_pass_decorator(ScriptInfo)
+pass_script_info = click.make_pass_decorator(ScriptInfo, ensure=True)
-    special commands like the runserver one.
+def with_appcontext(f):
-    return f
+    @click.pass_context
-    this.
+    this.  Not to be confused with :class:`AppGroup`.
-
+class AppGroup(click.Group):
-@without_appcontext
+@with_appcontext
-    def callback(ctx, value):
+    def callback(ctx, param, value):
-def set_debug_value(ctx, value):
+def set_debug_value(ctx, param, value):
-def set_app_value(ctx, value):
+def set_app_value(ctx, param, value):
-        'click>=0.6',
+        'click>=2.0',
-      parameter must be set to `True` or a `ValueError` is raised.
+      parameter must be set to `True` or a `ValueError` is raised. The default
-        :meth:`from_object` function.
+        behaves as if the JSON object was a dictionary and passed to the
-        return True
+        return self.from_mapping(obj)
-    integer_types = (int, )
+    integer_types = (int,)
-    #: flask.g object is not application context scoped.
+    #: flask.g object is now application context scoped.
-                                 '"app".  Be explicit!' % module.__name__)
+    if len(matches) == 1:
-
+import click
-        self.cli = make_default_cli(self)
+        self.cli = click.Group(self)
-                _no_such_app()
+                raise NoAppException('Could not locate Flask application. '
-    return click.Group()
+cli = FlaskGroup(help="""\
-    This shell command acts as general utility script for Flask applications.
+The most useful commands are the "run" and "shell" command.
-    by the application or Flask itself.
+Example usage:
-    """
+  flask --app=hello --debug run
-    from cli import main
+    from .cli import main
-        except NoAppException:
+        except Exception:
-        raise RuntimeError('working outside of request context')
+        raise RuntimeError(_request_ctx_err_msg)
-        raise RuntimeError('working outside of application context')
+        raise RuntimeError(_app_ctx_err_msg)
-        raise RuntimeError('working outside of application context')
+        raise RuntimeError(_app_ctx_err_msg)
-def locate_app(app_id, debug=None):
+def locate_app(app_id):
-        app.debug = debug
+
-        """Loads the Flask app (if not yet loaded) and returns it."""
+        """Loads the Flask app (if not yet loaded) and returns it.  Calling
-            rv = locate_app(self.app_import_path, self.debug)
+            rv = locate_app(self.app_import_path)
-            with self.load_app(self).app_context() as ctx:
+            with self.load_app().app_context() as ctx:
-#: with the :func:`without_appcontext` decorator.
+def set_debug_value(ctx, value):
-                                is automatically added.
+    """Special subclass of the a regular click group that supports loading
-        click.Group.__init__(self, **extra)
+    def __init__(self, add_default_commands=True, add_app_option=None,
-            self.add_debug_option()
+
-
+def script_info_option(*args, **kwargs):
-    app = info.make_wsgi_app(use_eager_loading=eager_loading)
+    app = DispatchingApp(info.load_app, use_eager_loading=eager_loading)
-This shell command acts as general utility script for Flask applications.
+@click.group(cls=FlaskGroup)
-by the application or Flask itself.
+    It loads the application configured (either through the FLASK_APP environment
-The most useful commands are the "run" and "shell" command.
+    The most useful commands are the "run" and "shell" command.
-Example usage:
+    Example usage:
-''')
+      flask --app=hello --debug run
-        'click',
+        'click>=0.6',
-              'is active is debug is enabled.')
+              'is active if debug is enabled.')
-    def __init__(self, app_import_path=None, debug=None, load_callback=None):
+    def __init__(self, app_import_path=None, debug=None, create_app=None):
-        self.load_callback = load_callback
+        self.create_app = create_app
-        """Loads the app (if not yet loaded) and returns it."""
+        """Loads the Flask app (if not yet loaded) and returns it."""
-            rv = self.load_callback()
+        if self.create_app is not None:
-            rv = locate_app(self.get_app_import_path(), self.debug)
+            if self.app_import_path is None:
-        later stage.
+        """Returns a WSGI app that loads the actual application at a later
-            if self.load_callback is None:
+            if self.create_app is None:
-                return self.load_callback()
+                return self.create_app(self)
-        given parameter but always works as context manager.
+        """Creates an application context or not, depending on the given
-            with self.load_app().app_context() as ctx:
+            with self.load_app(self).app_context() as ctx:
-class ContextGroupMixin(object):
+class FlaskGroup(click.Group):
-        info = ctx.find_object(ScriptInfo)
+        info = ctx.ensure_object(ScriptInfo)
-        return super(ContextGroupMixin, self).get_command(ctx, name)
+        return click.Group.get_command(self, ctx, name)
-        info = ctx.find_object(ScriptInfo)
+        rv = set(click.Group.list_commands(self, ctx))
-
+            return click.Group.invoke_subcommand(
-            ctx.ensure_object(ScriptInfo).debug = value
+    def main(self, *args, **kwargs):
-@cli.command('run', short_help='Runs a development server.')
+@click.command('run', short_help='Runs a development server.')
-    """Runs a local development server for the Flask application."""
+    """Runs a local development server for the Flask application.
-@cli.command('shell', short_help='Runs a shell in the app context.')
+@click.command('shell', short_help='Runs a shell in the app context.')
-             auto_envvar_prefix='FLASK')
+    cli.main(args=args, prog_name=name)
-        ])
+class ContextGroupMixin(object):
-        return click.Group.get_command(self, ctx, name)
+        return super(ContextGroupMixin, self).get_command(ctx, name)
-        rv = set(click.Group.list_commands(self, ctx))
+        rv = set(super(ContextGroupMixin, self).list_commands(ctx))
-                self, ctx, cmd, cmd_name, args)
+            return super(ContextGroupMixin, self).invoke_subcommand(
-        self.debug = debug
+    def __init__(self, loader, use_eager_loading=False):
-        self.app = rv = locate_app(self.app_id, self.debug)
+        self._app = rv = self.loader()
-            return self.app(environ, start_response)
+        if self._app is not None:
-                rv = self.app
+            if self._app is not None:
-    def __init__(self, app_import_path=None, debug=None):
+    def __init__(self, app_import_path=None, debug=None, load_callback=None):
-                             '--app parameter.')
+        _no_such_app()
-        rv = locate_app(self.get_app_import_path(), self.debug)
+        if self.load_callback is not None:
-    app_id = info.get_app_import_path()
+    app = info.make_wsgi_app(use_eager_loading=eager_loading)
-        print(' * Serving Flask app "%s"' % app_id)
+        # If we have an import path we can print it out now which can help
-    """Creates the database tables."""
+def init_db():
-        flaskr.init_db()
+        with flaskr.app.app_context():
-    """Creates the database tables."""
+def init_db():
-        minitwit.init_db()
+        with minitwit.app.app_context():
-            ctx.obj.app_import_path = value
+            ctx.ensure_object(ScriptInfo).app_import_path = value
-            ctx.obj.debug = value
+            ctx.ensure_object(ScriptInfo).debug = value
-        self.debug = None
+    def __init__(self, app_import_path=None, debug=None):
-class FlaskClickGroup(click.Group):
+class FlaskGroup(click.Group):
-cli = FlaskClickGroup(help='''\
+cli = FlaskGroup(help='''\
-        name = 'flask'
+        name = None
-    app.run(debug=True)
+app.register_blueprint(simple_page, url_prefix='/pages')
-def init_db():
+@app.cli.command()
-        db.commit()
+    db = get_db()
-                 '@' not in request.form['email']:
+                '@' not in request.form['email']:
-    app.run()
+    else:
-    """Special applicationt that dispatches to a flask application which
+    """Special application that dispatches to a flask application which
-def init_db():
+@app.cli.command()
-        db.commit()
+    db = get_db()
-                 [request.form['title'], request.form['text']])
+               [request.form['title'], request.form['text']])
-    app.run()
+                elif '.' not in sys.path:
-                   os.altsep is not None and os.altsep in value:
+                if os.path.isfile(value):
-    from run import main
+    from cli import main
-            
+
-                rv = self.response_class(rv, headers=headers, status=status_or_headers)
+                rv = self.response_class(rv, headers=headers,
-
+# -*- coding: utf-8 -*-
-    main(as_module=True)
+
-        import os, sys
+        import os
-                    if file != '__init__.py' and file.endswith('.py') :
+                    if file != '__init__.py' and file.endswith('.py'):
-        'itsdangerous>=0.21'
+        'itsdangerous>=0.21',
-        flask-run=flask.run:main
+        flask=flask.cli:main
-    'http://docs.python.org/dev': None,
+    'https://docs.python.org/dev': None,
-# happend until the next bytecode instruction?
+# happened until the next bytecode instruction?
-                               'the root path needs to be explictly '
+                               'the root path needs to be explicitly '
-    # Otherwise find the first object named Flask
+    # Otherwise find exactly one Flask instance, or fail.
-    # Chop off file extensions or package markers
+    # Chop off file extensions or package markers.
-    """Special applicationt that dispatches to a flask application which
+    """Special application that dispatches to a flask application which
-    errors for import problems into the browser as error.
+    the application up front because it means that we can forward all
-    is known by it's import name.  By default the app ID can also be a
+    is known by its import name.  By default the app ID can also be a
-    # Extra startup messages.  This depends a but on Werkzeug internals to
+    # Extra startup messages.  This depends a bit on Werkzeug internals to
-        name = 'python -m ' + this_module
+        if sys.version_info >= (2, 7):
-                    use_eager_loading=None, magic_app_id=True):
+                    use_eager_loading=None, magic_app_id=True,
-               use_debugger=use_debugger)
+               use_debugger=use_debugger, **options)
-                    use_eager_loading=opts.with_eager_loading)
+                    use_eager_loading=opts.with_eager_loading,
-    stream_with_context
+     get_flashed_messages, get_template_attribute, make_response, safe_join, \
-            return
+        if session.accessed:
-        """Registers a module with this application.  The keyword argument
+        """Registers a module with this application.  The keyword arguments
-    and can be overriden by the simplejson ``ensure_ascii`` parameter.
+    and can be overridden by the simplejson ``ensure_ascii`` parameter.
-        but this can be overriden by the `force` parameter.
+        but this can be overridden by the `force` parameter.
-                 instance_path=None, instance_relative_config=False):
+                 instance_path=None, instance_relative_config=False,
-                                     template_folder=template_folder)
+                                     template_folder=template_folder,
-        _PackageBoundObject.__init__(self, import_name, template_folder)
+                 url_prefix=None, subdomain=None, url_defaults=None,
-        filepath = sys.modules[import_name].__file__
+        mod = sys.modules[import_name]
-    def __init__(self, import_name, template_folder=None):
+    def __init__(self, import_name, template_folder=None, root_path=None):
-        self.root_path = get_root_path(self.import_name)
+        self.root_path = root_path
-          loader.__name__ == 'NamespaceLoader'):
+    elif (loader.__class__.__module__ == '_frozen_importlib' and
-                 'required by Flask of PEP 302 import hooks') % loader.__class__.__name__)
+
-            length = len(match.group(1))
+
-        fail('Release date is not today (%s != %s)')
+        fail('Release date is not today (%s != %s)',
-    #: the internal URL rule that matched the request.  This can be
+    #: The internal URL rule that matched the request.  This can be
-    #: a dict of view arguments that matched the request.  If an exception
+    #: A dict of view arguments that matched the request.  If an exception
-    #: if matching the URL failed, this is the exception that will be
+    #: If matching the URL failed, this is the exception that will be
-    # module functionality
+    # Switched by the request context until 1.0 to opt in deprecated
-        # in debug mode we're replacing the files multidict with an ad-hoc
+        # In debug mode we're replacing the files multidict with an ad-hoc
-        # we attach the view class to the view function for two reasons:
+        # We attach the view class to the view function for two reasons:
-            # if we have no method at all in there we don't want to
+            # If we have no method at all in there we don't want to
-        # retry with GET
+        # If the request method is HEAD and we don't have a handler for it
-# the namespace for code signals.  If you are not flask code, do
+# The namespace for code signals.  If you are not flask code, do
-# core signals.  For usage examples grep the sourcecode or consult
+# Core signals.  For usage examples grep the sourcecode or consult
-        default implementation uses the value from the SESSION_COOKIE_PATH``
+        default implementation uses the value from the ``SESSION_COOKIE_PATH``
-# figure out if simplejson escapes slashes.  This behavior was changed
+# Figure out if simplejson escapes slashes.  This behavior was changed
-from ._compat import string_types
+from ._compat import string_types, iteritems
-        for k, v in self.iteritems():
+        for k, v in iteritems(self):
-        a new response object or the same (see :meth:`process_response`).
+        """Register a function to be run after each request.
-copyright = u'2013, Armin Ronacher'
+copyright = u'2014, Armin Ronacher'
-from threading import Thread, Condition
+from threading import Thread
-        cv = Condition()
+
-                cv.wait()
+            time.sleep(0.2)
-                cv.notify()
+
-            self.assert_equal(rv.get_data().strip(), b'Hello Subdomain')
+            self.assert_equal(rv.data.strip(), b'Hello Subdomain')
-from time import sleep
+from threading import Thread, Condition
-            sleep(1)
+            with cv:
-            self._got_first_request = True
+            self._got_first_request = True
-                    pass
+                class PyStringIO(object):
-                f = PYStringIO('Test')
+                class PyStringIO(StringIO):
-            self.assert_('vodka' in flask.request.args)
+            self.assert_true('gin' in flask.request.form)
-    DATABASE='/tmp/flaskr.db',
+    DATABASE=os.path.join(app.root_path, 'flaskr.db'),
-        ))
+        try:
-            self.ssert_('vodka' in flask.request.args)
+            self.assert_('vodka' in flask.request.args)
-        if self.mimetype != 'application/json' and not force:
+        if not (force or self.is_json):
-from ._compat import BROKEN_PYPY_CTXMGR_EXIT
+from ._compat import BROKEN_PYPY_CTXMGR_EXIT, reraise
-            raise exc_type, exc_value, tb
+            reraise(exc_type, exc_value, tb)
-            raise exc_type, exc_value, tb
+            reraise(exc_type, exc_value, tb)
-1   :copyright: (c) 2014 by Armin Ronacher.
+    :copyright: (c) 2014 by Armin Ronacher.
-from flask import Flask, render_template, session, request, json, abort, g
+from flask import Flask, render_template, session, request, abort, g
-        verification_data = json.loads(resp.content)
+        verification_data = resp.json()
-#html_favicon = None
+html_favicon = "flask-favicon.ico"
-    :copyright: (c) 2010 by Armin Ronacher.
+    :copyright: (c) 2014 by Armin Ronacher.
-    :copyright: (c) 2010 by Armin Ronacher.
+    :copyright: (c) 2014 by Armin Ronacher.
-    :copyright: (c) 2010 by Armin Ronacher.
+    :copyright: (c) 2014 by Armin Ronacher.
-    :copyright: (c) 2010 by Armin Ronacher.
+    :copyright: (c) 2014 by Armin Ronacher.
-    :copyright: (c) 2010 by Armin Ronacher.
+    :copyright: (c) 2014 by Armin Ronacher.
-    :copyright: (c) 2011 by Armin Ronacher.
+    :copyright: (c) 2014 by Armin Ronacher.
-    :copyright: (c) 2013 by Armin Ronacher.
+    :copyright: (c) 2014 by Armin Ronacher.
-    :copyright: (c) 2011 by Armin Ronacher.
+    :copyright: (c) 2014 by Armin Ronacher.
-    :copyright: (c) 2011 by Armin Ronacher.
+    :copyright: (c) 2014 by Armin Ronacher.
-    :copyright: (c) 2011 by Armin Ronacher.
+    :copyright: (c) 2014 by Armin Ronacher.
-    :copyright: (c) 2011 by Armin Ronacher.
+    :copyright: (c) 2014 by Armin Ronacher.
-    :copyright: (c) 2011 by Armin Ronacher.
+1   :copyright: (c) 2014 by Armin Ronacher.
-    :copyright: (c) 2011 by Armin Ronacher.
+    :copyright: (c) 2014 by Armin Ronacher.
-    :copyright: (c) 2011 by Armin Ronacher.
+    :copyright: (c) 2014 by Armin Ronacher.
-    :copyright: (c) 2011 by Armin Ronacher.
+    :copyright: (c) 2014 by Armin Ronacher.
-    :copyright: (c) 2011 by Armin Ronacher.
+    :copyright: (c) 2014 by Armin Ronacher.
-    :copyright: (c) 2012 by Armin Ronacher.
+    :copyright: (c) 2014 by Armin Ronacher.
-    :copyright: (c) 2011 by Armin Ronacher.
+    :copyright: (c) 2014 by Armin Ronacher.
-    :copyright: (c) 2011 by Armin Ronacher.
+    :copyright: (c) 2014 by Armin Ronacher.
-    :copyright: (c) 2012 by Armin Ronacher.
+    :copyright: (c) 2014 by Armin Ronacher.
-    :copyright: (c) 2011 by Armin Ronacher.
+    :copyright: (c) 2014 by Armin Ronacher.
-    :copyright: (c) 2011 by Armin Ronacher.
+    :copyright: (c) 2014 by Armin Ronacher.
-    :copyright: (c) 2011 by Armin Ronacher.
+    :copyright: (c) 2014 by Armin Ronacher.
-    :copyright: (c) 2011 by Armin Ronacher.
+    :copyright: (c) 2014 by Armin Ronacher.
-    :copyright: (c) 2012 by Armin Ronacher.
+    :copyright: (c) 2014 by Armin Ronacher.
-    :copyright: (c) 2011 by Armin Ronacher.
+    :copyright: (c) 2014 by Armin Ronacher.
-    :copyright: (c) 2011 by Armin Ronacher.
+    :copyright: (c) 2014 by Armin Ronacher.
-    :copyright: (c) 2011 by Armin Ronacher.
+    :copyright: (c) 2014 by Armin Ronacher.
-    :copyright: (c) 2011 by Armin Ronacher.
+    :copyright: (c) 2014 by Armin Ronacher.
-    :copyright: (c) 2011 by Armin Ronacher.
+    :copyright: (c) 2014 by Armin Ronacher.
-    :copyright: (c) 2011 by Armin Ronacher.
+    :copyright: (c) 2014 by Armin Ronacher.
-    :copyright: (c) 2011 by Armin Ronacher.
+    :copyright: (c) 2014 by Armin Ronacher.
-    :copyright: (c) 2011 by Armin Ronacher.
+    :copyright: (c) 2014 by Armin Ronacher.
-    :copyright: (c) 2012 by Armin Ronacher.
+    :copyright: (c) 2014 by Armin Ronacher.
-    :copyright: (c) 2011 by Armin Ronacher.
+    :copyright: (c) 2014 by Armin Ronacher.
-    :copyright: (c) 2011 by Armin Ronacher.
+    :copyright: (c) 2014 by Armin Ronacher.
-    :copyright: (c) 2011 by Armin Ronacher.
+    :copyright: (c) 2014 by Armin Ronacher.
-    :copyright: (c) 2011 by Armin Ronacher.
+    :copyright: (c) 2014 by Armin Ronacher.
-    :copyright: (c) 2011 by Armin Ronacher.
+    :copyright: (c) 2014 by Armin Ronacher.
-    :copyright: (c) 2011 by Armin Ronacher.
+    :copyright: (c) 2014 by Armin Ronacher.
-    :copyright: (c) 2011 by Armin Ronacher.
+    :copyright: (c) 2014 by Armin Ronacher.
-    :copyright: (c) Copyright 2011 by Armin Ronacher.
+    :copyright: (c) Copyright 2014 by Armin Ronacher.
-    :copyright: (c) 2011 by Armin Ronacher.
+    :copyright: (c) 2014 by Armin Ronacher.
-    :copyright: (c) 2010 by Ali Afshar.
+    :copyright: (c) 2014 by Ali Afshar.
-    :copyright: (c) 2011 by Armin Ronacher.
+    :copyright: (c) 2014 by Armin Ronacher.
-        @app.route("/two_args")
+        @app.route('/two_args')
-            return "Hello", {
+            return 'Hello', {
-        @app.route("/args_status")
+        @app.route('/args_status')
-            return "Hi, status!", 400
+            return 'Hi, status!', 400
-        rv2 = c.get("/two_args")
+        rv2 = c.get('/two_args')
-        rv3 = c.get("/args_status")
+        rv3 = c.get('/args_status')
-
+        rv4 = c.get('/args_header')
-                                headers)`` where `response` is any of the
+                                headers)`` or ``(response, headers)``
-        status = headers = None
+        status_or_headers = headers = None
-            rv, status, headers = rv + (None,) * (3 - len(rv))
+            rv, status_or_headers, headers = rv + (None,) * (3 - len(rv))
-                headers = status = None
+                rv = self.response_class(rv, headers=headers, status=status_or_headers)
-                rv.status = status
+        if status_or_headers is not None:
-                rv.status_code = status
+                rv.status_code = status_or_headers
-    # are always in sync with the sess on object, which is not true for session
+    # are always in sync with the session object, which is not true for session
-        #: where they key is the status code of the http exception.  The
+        #: where the key is the status code of the http exception.  The
-        #: case of a "Flask-Foo" extension in `flaskext.foo`, the key would be
+        #: The key must match the name of the extension module. For example in
-    :data:`~flask.current_app` calls its :attr:`~Flask.build_error_handler` if
+    errors through :attr:`Flask.url_build_error_handlers`.  The `url_for`
-        def external_url_handler(error, endpoint, **values):
+        def external_url_handler(error, endpoint, values):
-        app.build_error_handler = external_url_handler
+        app.url_build_error_handlers.append(external_url_handler)
-    `endpoint` and `**values` are the arguments passed into `url_for`.  Note
+    `endpoint` and `values` are the arguments passed into `url_for`.  Note
-    :class:`~flask.blueprint.BlueprintSetupState` later to register functions
+    :class:`~flask.blueprints.BlueprintSetupState` later to register functions
-            return self.handle_http_exception(e)
+        if isinstance(e, HTTPException) and not self.trap_http_exception(e):
-from werkzeug.exceptions import BadRequest, NotFound
+from werkzeug.exceptions import BadRequest, NotFound, Forbidden
-    decorators = []
+    decorators = ()
-                f = open(os.path.join(app.root_path, 'static/index.html'))
+                f = open(os.path.join(app.root_path, 'static/index.html'), mode='rb')
-            self.assert_in('flask_broken/__init__.py', next.tb_frame.f_code.co_filename)
+            
-            rv = func(exc)
+            func(exc)
-            except KeyError as e:
+            except KeyError:
-        and not request.is_xhr:
+       and not request.is_xhr:
-     render_template, flash, _app_ctx_stack
+from flask import Flask, request, session, g, redirect, url_for, abort, \
-app.config.from_object(__name__)
+
-    return top.sqlite_db
+    if not hasattr(g, 'sqlite_db'):
-def close_db_connection(exception):
+def close_db(error):
-        top.sqlite_db.close()
+    if hasattr(g, 'sqlite_db'):
-from flask import Flask, request, session, g, redirect, url_for, abort, \
+from flask import Flask, request, session, redirect, url_for, abort, \
-                       and return `False`.
+        :param silent: if set to `True` this method will fail silently
-                                or an integer and `headers` is a list of
+                                or an integer and `headers` is a list or
-        default implementation uses the value from the SESSION_COOKIE_PATH``
+        default implementation uses the value from the ``SESSION_COOKIE_PATH``
-            package_path = os.path.dirname(package_path)
+        if hasattr(loader, 'is_package'):
-        :func:`werkzeug.test.EnvironBuilder` for more information, this
+        :class:`werkzeug.test.EnvironBuilder` for more information, this
-        self.assert_equal(lines, [
+        sorted_by_str = [
-        ])
+        ]
-                self.assert_equal(c.get('/bump').data, '3')
+                self.assert_equal(c.get('/bump').data, b'1')
-                self.assert_equal(rv.data, '3')
+                self.assert_equal(rv.data, b'3')
-            recorded.append('push')
+            recorded.append('pop')
-        return Config(root_path, self.default_config)
+        return self.config_class(root_path, self.default_config)
-            assert '.' not in endpoint, "Blueprint endpoint's should not contain dot's"
+            assert '.' not in endpoint, "Blueprint endpoints should not contain dots"
-__version__ = '0.10.2-dev'
+__version__ = '0.11-dev'
-    version='0.10.2-dev',
+    version='0.11-dev',
-__version__ = '0.10.1'
+__version__ = '0.10.2-dev'
-    version='0.10.1',
+    version='0.10.2-dev',
-__version__ = '0.11-dev'
+__version__ = '0.10.1'
-    version='0.11-dev',
+    version='0.10.1',
-            if old_func is not None and old_func is not view_func:
+            if old_func is not None and old_func != view_func:
-       if outside of script tags or if used in XHTML.
+       if outside of script tags or if used in XHTML.  This rule does not
-        .replace(u'&', u'\\u0026')
+        .replace(u'&', u'\\u0026') \
-        'Programming Language :: Python :: 2.7',
+        'Programming Language :: Python :: 3',
-__version__ = '0.10'
+__version__ = '0.10.1-dev'
-    version='0.10',
+    version='0.10.1-dev',
-__version__ = '0.10'
+__version__ = '0.11-dev'
-    version='0.10',
+    version='0.11-dev',
-__version__ = '0.10-dev'
+__version__ = '0.10'
-    version='0.10-dev',
+    version='0.10',
-            return flask.jsonify(foo=text_type(flask.request.json))
+            return flask.jsonify(foo=text_type(flask.request.get_json()))
-            return flask.request.json
+            return flask.request.get_json()
-            return text_type(flask.request.json['a'] + flask.request.json['b'])
+            json = flask.request.get_json()
-            return flask.json.dumps(flask.request.json['x'])
+            return flask.json.dumps(flask.request.get_json()['x'])
-from werkzeug.utils import cached_property
+_missing = object()
-    @cached_property
+    @property
-                return self.on_json_loading_failed(e)
+        rv = getattr(self, '_cached_json', _missing)
-        implementation just raises a :class:`BadRequest` exception.
+        this method is used by :meth:`get_json` when an error occurred.  The
-           The default port is now picked from the ``SEVER_NAME`` variable.
+           The default port is now picked from the ``SERVER_NAME`` variable.
-            return None
+    def get(self, name, default=None):
-        setattr(self, name, value)
+    def __contains__(self, item):
-        delattr(self, name, value)
+    def __iter__(self):
-    def test_subscript_syntax_on_g(self):
+    def test_get_method_on_g(self):
-            self.assert_equal(flask.g['x'], None)
+            self.assert_equal(flask.g.get('x'), None)
-            self.assert_equal(flask.g['x'], 42)
+            self.assert_equal(flask.g.get('x'), 42)
-            self.assert_equal(flask.g.x, 23)
+
-                          provided endpoint
+from flask import Flask, render_template, session, request, json, abort, g
-from ._compat import reraise, string_types, integer_types
+from ._compat import reraise, string_types, text_type, integer_types
-            if isinstance(rv, string_types + (bytes, )):
+            if isinstance(rv, (text_type, bytes, bytearray)):
-        :param port: the port of the webserver. Defaults to ``5000``.
+        :param port: the port of the webserver. Defaults to ``5000`` or the
-            port = 5000
+            server_name = self.config['SERVER_NAME']
-    locked_cached_property, _endpoint_from_view_func, find_package
+     locked_cached_property, _endpoint_from_view_func, find_package
-    _default_template_ctx_processor
+     _default_template_ctx_processor
-    request_tearing_down, appcontext_tearing_down
+     request_tearing_down, appcontext_tearing_down
-     appcontext_tearing_down, message_flashed
+     appcontext_tearing_down, appcontext_pushed, \
-        self.assert_in('path=/;', cookie)
+        self.assert_in('path=/', cookie)
-        match = re.search(r'\bexpires=([^;]+)', rv.headers['set-cookie'])
+        match = re.search(r'\bexpires=([^;]+)(?i)', rv.headers['set-cookie'])
-        rv.filters['tojson'] = json.htmlsafe_dumps
+        rv.filters['tojson'] = json.tojson_filter
-
+from jinja2 import Markup
-    have to be wrapped in ``|safe`` unless **true** XHTML is being used.
+    this is available in templates through the ``|tojson`` filter which will
-    return rv.replace('<!', '<\\u0021')
+    rv = dumps(obj, **kwargs) \
-    fp.write(htmlsafe_dumps(obj, **kwargs))
+    fp.write(unicode(htmlsafe_dumps(obj, **kwargs)))
-            self.assert_equal(rv, '"<\\u0021--<script>"')
+            rv = flask.json.htmlsafe_dumps('</script>')
-            top.pop()
+            top.pop(top._preserved_exc)
-    from cStringIO import StringIO as StringIO
+    from cStringIO import StringIO
-    NativeStringIO = StringIO
+    from io import StringIO
-    NativeStringIO = BytesIO
+    from cStringIO import StringIO as StringIO
-from werkzeug.urls import url_quote
+try:
-from flask._compat import StringIO, text_type, implements_iterator
+from flask._compat import StringIO, text_type
-        @implements_iterator
+            next = __next__
-    kwargs.setdefault('sort_keys', True)
+    else:
-        'JSON_AS_ASCII':                        True
+        'JSON_AS_ASCII':                        True,
-        indent=None if request.is_xhr else 2),
+        indent=indent),
-        with self.request_context(environ):
+        ctx = self.request_context(environ)
-            self.pop(exc_value)
+        self.auto_pop(exc_value)
-                raise TypeError
+                raise TypeError()
-                raise TypeError
+                raise TypeError()
-        headers['Content-Length'] = os.path.getsize(filename)
+            headers['Content-Length'] = os.path.getsize(filename)
-
+import io
-from ._compat import text_type
+from ._compat import text_type, PY2
-    return _json.dumps(obj, **kwargs)
+    encoding = kwargs.pop('encoding', None)
-    return _json.dump(obj, fp, **kwargs)
+    encoding = kwargs.pop('encoding', None)
-    
+
-from ._compat import urlparse
+
-        url = urlparse(path)
+        url = url_parse(path)
-            if isinstance(rv, string_types):
+            if isinstance(rv, string_types + (bytes, )):
-            self.assert_true(flask._request_ctx_stack.request.environ
+            self.assert_true(flask._request_ctx_stack.top.request.environ
-        flashes = filter(lambda f: f[0] in category_filter, flashes)
+        flashes = list(filter(lambda f: f[0] in category_filter, flashes))
-            1/0
+            1 // 0
-                1/0
+                1 // 0
-            1/0
+            1 // 0
-            1/0
+            1 // 0
-            1/0
+            1 // 0
-        self.assert_in('1/0', err)
+        self.assert_in('1 // 0', err)
-                1/0
+                1 // 0
-                1/0
+                1 // 0
-            1/0
+            1 // 0
-            1/0
+            1 // 0
-            1/0
+            1 // 0
-                1/0
+                1 // 0
-                1/0
+                1 // 0
-        'itsdangerous>=0.17'
+        'itsdangerous>=0.21'
-    # dummy metaclass for one level of class instanciation that replaces
+    # dummy metaclass for one level of class instantiation that replaces
-    #: exception ocurrs and the integrated server will automatically reload
+    #: exception occurs and the integrated server will automatically reload
-        Flask needs the name of the application.  It can be set and overriden
+        Flask needs the name of the application.  It can be set and overridden
-        in the context will not be overriden if a context processor
+        in the context will not be overridden if a context processor
-        however is discouraged as it requires fidling with nested dictionaries
+        however is discouraged as it requires fiddling with nested dictionaries
-            # specific values (like defualt content type selection).
+            # specific values (like default content type selection).
-        # If an exception ocurrs in debug mode or if context preservation is
+        # If an exception occurs in debug mode or if context preservation is
-    :param attribute: the name of the variable of macro to acccess
+    :param attribute: the name of the variable of macro to access
-        def inject_all_regualr():
+        def inject_all_regular():
-        # The rule's din't actually made it through
+        # The rule's didn't actually made it through
-            response.data += '|after'
+            response.data += b'|after'
-        self.assert_in(b'after', evts)
+        self.assert_in('after', evts)
-from flask._compat import reraise, string_types, integer_types
+from ._compat import reraise, string_types, integer_types
-from flask._compat import string_types
+from ._compat import string_types
-from flask._compat import implements_to_string
+from ._compat import implements_to_string
-from flask._compat import reraise
+from ._compat import reraise
-from flask._compat import string_types, text_type
+from ._compat import string_types, text_type
-from flask._compat import urlparse
+from ._compat import urlparse
-class MethodView(View):
+class MethodView(with_metaclass(MethodViewType, View)):
-from flask._compat import StringIO, text_type
+from flask._compat import StringIO, text_type, implements_iterator
-            def next(self):
+            def __next__(self):
-        with app.open_resource('schema.sql') as f:
+        with app.open_resource('schema.sql', mode='r') as f:
-        assert 'No entries here so far' in rv.data
+        assert b'No entries here so far' in rv.data
-        assert 'You were logged in' in rv.data
+        assert b'You were logged in' in rv.data
-        assert 'You were logged out' in rv.data
+        assert b'You were logged out' in rv.data
-        assert 'Invalid username' in rv.data
+        assert b'Invalid username' in rv.data
-        assert 'Invalid password' in rv.data
+        assert b'Invalid password' in rv.data
-        assert '<strong>HTML</strong> allowed here' in rv.data
+        assert b'No entries here so far' not in rv.data
-        with app.open_resource('schema.sql') as f:
+        with app.open_resource('schema.sql', mode='r') as f:
-            assert 'Your message was recorded' in rv.data
+            assert b'Your message was recorded' in rv.data
-               'and can login now' in rv.data
+        assert b'You were successfully registered ' \
-        assert 'The username is already taken' in rv.data
+        assert b'The username is already taken' in rv.data
-        assert 'You have to enter a username' in rv.data
+        assert b'You have to enter a username' in rv.data
-        assert 'You have to enter a password' in rv.data
+        assert b'You have to enter a password' in rv.data
-        assert 'The two passwords do not match' in rv.data
+        assert b'The two passwords do not match' in rv.data
-        assert 'You have to enter a valid email address' in rv.data
+        assert b'You have to enter a valid email address' in rv.data
-        assert 'You were logged in' in rv.data
+        assert b'You were logged in' in rv.data
-        assert 'You were logged out' in rv.data
+        assert b'You were logged out' in rv.data
-        assert 'Invalid password' in rv.data
+        assert b'Invalid password' in rv.data
-        assert 'Invalid username' in rv.data
+        assert b'Invalid username' in rv.data
-        assert '&lt;test message 2&gt;' in rv.data
+        assert b'test message 1' in rv.data
-        assert 'the message by bar' in rv.data
+        assert b'the message by foo' in rv.data
-        assert 'the message by bar' in rv.data
+        assert b'the message by foo' not in rv.data
-        assert 'You are now following &#34;foo&#34;' in rv.data
+        assert b'You are now following &#34;foo&#34;' in rv.data
-        assert 'the message by bar' in rv.data
+        assert b'the message by foo' in rv.data
-        assert 'the message by bar' in rv.data
+        assert b'the message by foo' not in rv.data
-        assert 'the message by bar' not in rv.data
+        assert b'the message by foo' in rv.data
-        assert 'You are no longer following &#34;foo&#34;' in rv.data
+        assert b'You are no longer following &#34;foo&#34;' in rv.data
-        assert 'the message by bar' in rv.data
+        assert b'the message by foo' not in rv.data
-        #: all the attached blueprints in a directory by name.  Blueprints
+        #: all the attached blueprints in a dictionary by name.  Blueprints
-            next = tb.tb_next
+            # reraise() adds a second frame so we need to skip that one too.
-            return unicode(flask.request.json)
+            return flask.jsonify(foo=unicode(flask.request.json))
-
+from werkzeug.exceptions import BadRequest
-        error description::
+        implementation just raises a :class:`BadRequest` exception.
-           :class:`~werkzeug.exceptions.BadRequest` by default.
+        .. versionchanged:: 0.10
-        raise JSONBadRequest()
+        raise BadRequest()
-from itsdangerous import simplejson as _json
+# depend anyways.  This name changed at one point so support both.
-            pass
+        except BuildError as err:
-            exec(compile(open(filename).read(), filename, 'exec'), d.__dict__)
+            with open(filename) as config_file:
-    six.advance_iterator(wrapped_g)
+    next(wrapped_g)
-            return six.text_type(o.__html__())
+            return text_type(o.__html__())
-import six
+from ._compat import itervalues, iteritems
-        for blueprint in six.itervalues(self.app.blueprints):
+        for blueprint in itervalues(self.app.blueprints):
-        for name, blueprint in six.iteritems(self.app.blueprints):
+        for name, blueprint in iteritems(self.app.blueprints):
-            return six.text_type(flask.session.permanent)
+            return text_type(flask.session.permanent)
-            return six.text_type(bar)
+            return text_type(bar)
-from flask._compat import StringIO
+from flask._compat import StringIO, text_type
-            return six.text_type(flask.request.json)
+            return text_type(flask.request.json)
-            return six.text_type(flask.request.json)
+            return text_type(flask.request.json)
-            return six.text_type(flask.request.json['a'] + flask.request.json['b'])
+            return text_type(flask.request.json['a'] + flask.request.json['b'])
-                return six.advance_iterator(self._gen)
+                return next(self._gen)
-import six
+from flask._compat import text_type
-            return six.text_type(flask.session['foo'])
+            return text_type(flask.session['foo'])
-        'six>=1.3.0',
+from ._compat import iteritems, text_type
-                return {' m': six.text_type(value.__html__())}
+                return {' m': text_type(value.__html__())}
-                return dict((k, _tag(v)) for k, v in six.iteritems(value))
+                return dict((k, _tag(v)) for k, v in iteritems(value))
-                    return six.text_type(value)
+                    return text_type(value)
-            the_key, the_value = six.advance_iterator(obj.iteritems())
+            the_key, the_value = next(iteritems(obj))
-        self.assert_equal(flask._request_ctx_stack.top, None)
+        leaks = []
-        self.msg = ''.join(buf).encode('utf-8')
+        self.msg = ''.join(buf)
-            self.assert_equal(str(exc_value), 'No module named missing_module')
+            if PY2:
-        self.assert_true(not rv.data) # head truncates
+        self.assert_false(rv.data) # head truncates
-        self.assert_true(not rv.data) # head truncates
+        self.assert_false(rv.data) # head truncates
-            self.assert_true(not flask.session.modified)
+            self.assert_false(flask.session.modified)
-        self.assert_true(not app.got_first_request)
+        self.assert_false(app.got_first_request)
-            self.assert_true(not app.config.from_envvar('FOO_SETTINGS', silent=True))
+            self.assert_false(app.config.from_envvar('FOO_SETTINGS', silent=True))
-        self.assert_true(not app.config.from_pyfile('missing.cfg', silent=True))
+        self.assert_false(app.config.from_pyfile('missing.cfg', silent=True))
-        self.assert_true(not flask.has_request_context())
+        self.assert_false(flask.request)
-                self.assert_true(not flask.current_app)
+                self.assert_false(flask.request)
-                self.assert_true(not flask.request)
+                self.assert_false(flask.request)
-            self.assert_true(not hasattr(flask.g, 'value'))
+            self.assert_false(hasattr(flask.g, 'value'))
-                self.assert_true('Modules are deprecated' in str(entry['message']))
+                self.assert_in('Modules are deprecated', str(entry['message']))
-        self.assert_true('httponly' in rv.headers['set-cookie'].lower())
+        self.assert_in('domain=.example.com', rv.headers['set-cookie'].lower())
-        self.assert_true('httponly' in rv.headers['set-cookie'].lower())
+        self.assert_in('domain=.example.com', rv.headers['set-cookie'].lower())
-        self.assert_true('httponly' in rv.headers['set-cookie'].lower())
+        self.assert_in('domain=example.com', rv.headers['set-cookie'].lower())
-        self.assert_true('path=/bar' in rv.headers['set-cookie'].lower())
+        self.assert_in('path=/bar', rv.headers['set-cookie'].lower())
-        self.assert_true('httponly' not in cookie)
+        self.assert_in('domain=.example.com', cookie)
-        self.assert_true('set-cookie' in rv.headers)
+        self.assert_in('set-cookie', rv.headers)
-        self.assert_true('set-cookie' in rv.headers)
+        self.assert_in('set-cookie', rv.headers)
-            self.assert_true('after' not in evts)
+            self.assert_in('before', evts)
-        self.assert_true('after' not in evts)
+        self.assert_not_in('after', evts)
-        self.assert_true(b'after' in evts)
+        self.assert_in(b'after', evts)
-        self.assert_true(b'Response' in rv.data)
+        self.assert_in(b'Response', rv.data)
-        self.assert_true(b'Response' in rv.data)
+        self.assert_in(b'Response', rv.data)
-        self.assert_true(b'Internal Server Error' in rv.data)
+        self.assert_in(b'Internal Server Error', rv.data)
-                self.assert_true('This was submitted: "index.txt"' in str(e))
+                self.assert_in('no file contents were transmitted', str(e))
-            self.assert_true('A setup function was called' in str(e))
+            self.assert_in('A setup function was called', str(e))
-                             'to this URL' in str(e))
+                self.assert_in('http://localhost/foo/', str(e))
-        self.assert_true('my_reverse' in app.jinja_env.filters.keys())
+        self.assert_in('my_reverse', app.jinja_env.filters.keys())
-        self.assert_true('my_reverse' in app.jinja_env.filters.keys())
+        self.assert_in('my_reverse', app.jinja_env.filters.keys())
-        self.assert_true('strrev' in app.jinja_env.filters.keys())
+        self.assert_in('strrev', app.jinja_env.filters.keys())
-        self.assert_true('strrev' in app.jinja_env.filters.keys())
+        self.assert_in('strrev', app.jinja_env.filters.keys())
-        self.assert_true('is_boolean' in app.jinja_env.tests.keys())
+        self.assert_in('is_boolean', app.jinja_env.tests.keys())
-        self.assert_true('is_boolean' in app.jinja_env.tests.keys())
+        self.assert_in('is_boolean', app.jinja_env.tests.keys())
-        self.assert_true('boolean' in app.jinja_env.tests.keys())
+        self.assert_in('boolean', app.jinja_env.tests.keys())
-        self.assert_true('boolean' in app.jinja_env.tests.keys())
+        self.assert_in('boolean', app.jinja_env.tests.keys())
-        self.assert_true(b'Success!' in rv.data)
+        self.assert_in(b'Success!', rv.data)
-        self.assert_true(b'Success!' in rv.data)
+        self.assert_in(b'Success!', rv.data)
-        self.assert_true(b'Success!' in rv.data)
+        self.assert_in(b'Success!', rv.data)
-        self.assert_true(b'Success!' in rv.data)
+        self.assert_in(b'Success!', rv.data)
-        self.assert_true(b'Success!' in rv.data)
+        self.assert_in(b'Success!', rv.data)
-        self.assert_true('ConfigTestCase' not in app.config)
+        self.assert_not_in('ConfigTestCase', app.config)
-            self.assert_true('must be absolute' in str(e))
+            self.assert_in('must be absolute', str(e))
-            self.assert_true('.' not in key)
+            self.assert_not_in('.', key)
-            self.assert_true('flask_broken/__init__.py' in next.tb_frame.f_code.co_filename)
+            self.assert_in('flask_broken/__init__.py', next.tb_frame.f_code.co_filename)
-        self.assert_true('<p>' not in flask.json.loads(rv.data)['description'])
+        self.assert_in('description', flask.json.loads(rv.data))
-            self.assert_true('x-sendfile' in rv.headers)
+            self.assert_in('x-sendfile', rv.headers)
-                self.assert_true('x-sendfile' in rv.headers)
+                self.assert_in('x-sendfile', rv.headers)
-                self.assert_true('x-sendfile' not in rv.headers)
+                self.assert_not_in('x-sendfile', rv.headers)
-                self.assert_true('this is a debug statement' in out)
+                self.assert_in('WARNING in helpers [', out)
-        self.assert_true(b'Internal Server Error' in rv.data)
+        self.assert_in(b'Internal Server Error', rv.data)
-        self.assert_true('ZeroDivisionError:' in err)
+        self.assert_in('Exception on / [GET]', err)
-        self.assert_true(b'Internal Server Error' in rv.data)
+        self.assert_in(b'Internal Server Error', rv.data)
-        self.assert_true('my_reverse' in app.jinja_env.filters.keys())
+        self.assert_in('my_reverse', app.jinja_env.filters.keys())
-        self.assert_true('my_reverse' in app.jinja_env.filters.keys())
+        self.assert_in('my_reverse', app.jinja_env.filters.keys())
-        self.assert_true('strrev' in app.jinja_env.filters.keys())
+        self.assert_in('strrev', app.jinja_env.filters.keys())
-        self.assert_true('strrev' in app.jinja_env.filters.keys())
+        self.assert_in('strrev', app.jinja_env.filters.keys())
-        self.assert_true('boolean' in app.jinja_env.tests.keys())
+        self.assert_in('boolean', app.jinja_env.tests.keys())
-        self.assert_true('boolean' in app.jinja_env.tests.keys())
+        self.assert_in('boolean', app.jinja_env.tests.keys())
-        self.assert_true('boolean' in app.jinja_env.tests.keys())
+        self.assert_in('boolean', app.jinja_env.tests.keys())
-        self.assert_true('boolean' in app.jinja_env.tests.keys())
+        self.assert_in('boolean', app.jinja_env.tests.keys())
-        self.assert_true(b'Success!' in rv.data)
+        self.assert_in(b'Success!', rv.data)
-        self.assert_true(b'Success!' in rv.data)
+        self.assert_in(b'Success!', rv.data)
-        self.assert_true(b'Success!' in rv.data)
+        self.assert_in(b'Success!', rv.data)
-        self.assert_true(b'Success!' in rv.data)
+        self.assert_in(b'Success!', rv.data)
-        self.assert_true('get_stuff' in app.jinja_env.globals.keys())
+        self.assert_in('get_stuff', app.jinja_env.globals.keys())
-                self.assert_true('Session backend did not open a session' in str(e))
+                self.assert_in('Session backend did not open a session', str(e))
-            self.assert_true('cookies' in str(e))
+            self.assert_in('cookies', str(e))
-            self.assert_true(b'Internal Server Error' in resp.data)
+            self.assert_in(b'Internal Server Error', resp.data)
-        self.assertTrue(x)
+    def assert_true(self, x, msg=None):
-        self.assertEquals(b'xxx', response.data)
+        self.assert_equal(200, response.status_code)
-        self.assertEquals(b'xxx', response.data)
+        self.assert_equal(200, response.status_code)
-            self.assert_(log, 'expected deprecation warning')
+            self.assert_true(log, 'expected deprecation warning')
-                self.assert_('Modules are deprecated' in str(entry['message']))
+                self.assert_true('Modules are deprecated' in str(entry['message']))
-            self.assert_(flask._request_ctx_stack.request.environ
+            self.assert_true(flask._request_ctx_stack.request.environ
-        self.assert_(not rv.data) # head truncates
+        self.assert_true(not rv.data) # head truncates
-        self.assert_(not rv.data) # head truncates
+        self.assert_true(not rv.data) # head truncates
-        self.assert_('httponly' in rv.headers['set-cookie'].lower())
+        self.assert_true('domain=.example.com' in rv.headers['set-cookie'].lower())
-        self.assert_('httponly' in rv.headers['set-cookie'].lower())
+        self.assert_true('domain=.example.com' in rv.headers['set-cookie'].lower())
-        self.assert_('httponly' in rv.headers['set-cookie'].lower())
+        self.assert_true('domain=example.com' in rv.headers['set-cookie'].lower())
-        self.assert_('path=/bar' in rv.headers['set-cookie'].lower())
+        self.assert_true('path=/bar' in rv.headers['set-cookie'].lower())
-        self.assert_('httponly' not in cookie)
+        self.assert_true('domain=.example.com' in cookie)
-                self.assert_(e.args and 'session is unavailable' in e.args[0])
+                self.assert_true(e.args and 'session is unavailable' in e.args[0])
-                self.assert_(False, 'expected exception')
+                self.assert_true(False, 'expected exception')
-            self.assert_(flask.session.get('missing_key') is None)
+            self.assert_true(flask.session.get('missing_key') is None)
-        self.assert_('set-cookie' in rv.headers)
+        self.assert_true('set-cookie' in rv.headers)
-        self.assert_('set-cookie' in rv.headers)
+        self.assert_true('set-cookie' in rv.headers)
-        self.assert_(match is None)
+        self.assert_true(match is None)
-            self.assert_(not flask.session.modified)
+            self.assert_true(not flask.session.modified)
-            self.assert_(flask.session.modified)
+            self.assert_true(flask.session.modified)
-            self.assert_('after' not in evts)
+            self.assert_true('before' in evts)
-        self.assert_('after' not in evts)
+        self.assert_true('after' not in evts)
-        self.assert_(b'after' in evts)
+        self.assert_true(b'after' in evts)
-        self.assert_(b'Response' in rv.data)
+        self.assert_true(b'Response' in rv.data)
-        self.assert_(b'Response' in rv.data)
+        self.assert_true(b'Response' in rv.data)
-        self.assert_(b'Internal Server Error' in rv.data)
+        self.assert_true(b'Internal Server Error' in rv.data)
-            self.assert_(isinstance(e, MyException))
+            self.assert_true(isinstance(e, MyException))
-            self.assert_(isinstance(e, BadRequest))
+            self.assert_true(isinstance(e, BadRequest))
-                self.assert_('This was submitted: "index.txt"' in str(e))
+                self.assert_true('no file contents were transmitted' in str(e))
-            self.assert_("Expected ValueError")
+            self.assert_true("Expected ValueError")
-            self.assert_(False)
+            self.assert_true(False)
-            self.assert_(False)
+            self.assert_true(False)
-        self.assert_(not app.got_first_request)
+        self.assert_true(not app.got_first_request)
-            self.assert_('A setup function was called' in str(e))
+            self.assert_true('A setup function was called' in str(e))
-        self.assert_(app.got_first_request)
+        self.assert_true(app.got_first_request)
-        self.assert_(app.got_first_request)
+        self.assert_true(app.got_first_request)
-                self.assert_('Make sure to directly send your POST-request '
+                self.assert_true('http://localhost/foo/' in str(e))
-        self.assert_(flask._app_ctx_stack.top is not None)
+        self.assert_true(flask._request_ctx_stack.top is not None)
-        self.assert_(flask._app_ctx_stack.top is None)
+        self.assert_true(flask._request_ctx_stack.top is None)
-                self.assert_(0, 'expected exception')
+                self.assert_true(0, 'expected exception')
-                self.assert_(0, 'expected exception')
+                self.assert_true(0, 'expected exception')
-                self.assert_(0, 'expected exception')
+                self.assert_true(0, 'expected exception')
-                    self.assert_(0, 'expected exception')
+                    self.assert_true(0, 'expected exception')
-                self.assert_(0, 'expected exception')
+                self.assert_true(0, 'expected exception')
-        self.assert_('my_reverse' in app.jinja_env.filters.keys())
+        self.assert_true('my_reverse' in app.jinja_env.filters.keys())
-        self.assert_('my_reverse' in app.jinja_env.filters.keys())
+        self.assert_true('my_reverse' in app.jinja_env.filters.keys())
-        self.assert_('strrev' in app.jinja_env.filters.keys())
+        self.assert_true('strrev' in app.jinja_env.filters.keys())
-        self.assert_('strrev' in app.jinja_env.filters.keys())
+        self.assert_true('strrev' in app.jinja_env.filters.keys())
-        self.assert_('is_boolean' in app.jinja_env.tests.keys())
+        self.assert_true('is_boolean' in app.jinja_env.tests.keys())
-        self.assert_(app.jinja_env.tests['is_boolean'](False))
+        self.assert_true(app.jinja_env.tests['is_boolean'](False))
-        self.assert_('is_boolean' in app.jinja_env.tests.keys())
+        self.assert_true('is_boolean' in app.jinja_env.tests.keys())
-        self.assert_(app.jinja_env.tests['is_boolean'](False))
+        self.assert_true(app.jinja_env.tests['is_boolean'](False))
-        self.assert_('boolean' in app.jinja_env.tests.keys())
+        self.assert_true('boolean' in app.jinja_env.tests.keys())
-        self.assert_(app.jinja_env.tests['boolean'](False))
+        self.assert_true(app.jinja_env.tests['boolean'](False))
-        self.assert_('boolean' in app.jinja_env.tests.keys())
+        self.assert_true('boolean' in app.jinja_env.tests.keys())
-        self.assert_(app.jinja_env.tests['boolean'](False))
+        self.assert_true(app.jinja_env.tests['boolean'](False))
-        self.assert_(b'Success!' in rv.data)
+        self.assert_true(b'Success!' in rv.data)
-        self.assert_(b'Success!' in rv.data)
+        self.assert_true(b'Success!' in rv.data)
-        self.assert_(b'Success!' in rv.data)
+        self.assert_true(b'Success!' in rv.data)
-        self.assert_(b'Success!' in rv.data)
+        self.assert_true(b'Success!' in rv.data)
-        self.assert_(b'Success!' in rv.data)
+        self.assert_true(b'Success!' in rv.data)
-        self.assert_('ConfigTestCase' not in app.config)
+        self.assert_true('ConfigTestCase' not in app.config)
-                self.assert_("'FOO_SETTINGS' is not set" in str(e))
+                self.assert_true("'FOO_SETTINGS' is not set" in str(e))
-            self.assert_(not app.config.from_envvar('FOO_SETTINGS', silent=True))
+                self.assert_true(0, 'expected exception')
-            self.assert_(app.config.from_envvar('FOO_SETTINGS'))
+            self.assert_true(app.config.from_envvar('FOO_SETTINGS'))
-                self.assert_(msg.startswith('[Errno 2] Unable to load configuration '
+                self.assert_true(msg.startswith('[Errno 2] Unable to load configuration '
-                self.assert_(msg.endswith("missing.cfg'"))
+                self.assert_true(msg.endswith("missing.cfg'"))
-            self.assert_(msg.startswith('[Errno 2] Unable to load configuration '
+            self.assert_true(msg.startswith('[Errno 2] Unable to load configuration '
-            self.assert_(msg.endswith("missing.cfg'"))
+            self.assert_true(msg.endswith("missing.cfg'"))
-        self.assert_(not app.config.from_pyfile('missing.cfg', silent=True))
+            self.assert_true(0, 'expected config')
-            self.assert_('must be absolute' in str(e))
+            self.assert_true('must be absolute' in str(e))
-            self.assert_('.' not in key)
+            self.assert_true('.' not in key)
-            self.assert_(exc_type is ImportError)
+            self.assert_true(exc_type is ImportError)
-            self.assert_(tb.tb_frame.f_globals is globals())
+            self.assert_true(tb.tb_frame.f_globals is globals())
-            self.assert_('flask_broken/__init__.py' in next.tb_frame.f_code.co_filename)
+            self.assert_true('flask_broken/__init__.py' in next.tb_frame.f_code.co_filename)
-        self.assert_('<p>' not in flask.json.loads(rv.data)['description'])
+        self.assert_true('description' in flask.json.loads(rv.data))
-            self.assert_(rv.direct_passthrough)
+            self.assert_true(rv.direct_passthrough)
-            self.assert_('x-sendfile' in rv.headers)
+            self.assert_true(rv.direct_passthrough)
-                self.assert_('x-sendfile' in rv.headers)
+                self.assert_true('x-sendfile' in rv.headers)
-                self.assert_('x-sendfile' not in rv.headers)
+                self.assert_true('x-sendfile' not in rv.headers)
-        self.assert_(app.logger is logger1)
+        self.assert_true(app.logger is logger1)
-        self.assert_(app.logger is not logger1)
+        self.assert_true(app.logger is not logger1)
-                self.assert_('this is a debug statement' in out)
+                self.assert_true('WARNING in helpers [' in out)
-                    self.assert_(False, 'debug log ate the exception')
+                    self.assert_true(False, 'debug log ate the exception')
-        self.assert_(b'Internal Server Error' in rv.data)
+        self.assert_true(b'Internal Server Error' in rv.data)
-        self.assert_('ZeroDivisionError:' in err)
+        self.assert_true('Exception on / [GET]' in err)
-            self.assert_(isinstance(e, ValueError))
+            self.assert_true(isinstance(e, ValueError))
-        self.assert_(flask._request_ctx_stack.top is None)
+        self.assert_true(flask._request_ctx_stack.top is None)
-        self.assert_(not flask.has_request_context())
+        self.assert_true(not flask.request)
-            self.assert_(flask.has_request_context())
+            self.assert_true(flask.request)
-            self.assert_(0, 'expected runtime error')
+            self.assert_true(0, 'expected runtime error')
-                self.assert_(not flask.current_app)
+                self.assert_true(not flask.request)
-                    self.assert_(flask.request)
+                    self.assert_true(flask.request)
-                self.assert_(not flask.request)
+                self.assert_true(not flask.request)
-                self.assert_(flask.request)
+                self.assert_true(flask.request)
-            self.assert_(isinstance(recorded[0], ZeroDivisionError))
+            self.assert_true(isinstance(recorded[0], ZeroDivisionError))
-        self.assert_(b'Internal Server Error' in rv.data)
+        self.assert_true(b'Internal Server Error' in rv.data)
-        self.assert_('my_reverse' in app.jinja_env.filters.keys())
+        self.assert_true('my_reverse' in app.jinja_env.filters.keys())
-        self.assert_('my_reverse' in app.jinja_env.filters.keys())
+        self.assert_true('my_reverse' in app.jinja_env.filters.keys())
-        self.assert_('strrev' in app.jinja_env.filters.keys())
+        self.assert_true('strrev' in app.jinja_env.filters.keys())
-        self.assert_('strrev' in app.jinja_env.filters.keys())
+        self.assert_true('strrev' in app.jinja_env.filters.keys())
-        self.assert_('boolean' in app.jinja_env.tests.keys())
+        self.assert_true('boolean' in app.jinja_env.tests.keys())
-        self.assert_(app.jinja_env.tests['boolean'](False))
+        self.assert_true(app.jinja_env.tests['boolean'](False))
-        self.assert_('boolean' in app.jinja_env.tests.keys())
+        self.assert_true('boolean' in app.jinja_env.tests.keys())
-        self.assert_(app.jinja_env.tests['boolean'](False))
+        self.assert_true(app.jinja_env.tests['boolean'](False))
-        self.assert_('boolean' in app.jinja_env.tests.keys())
+        self.assert_true('boolean' in app.jinja_env.tests.keys())
-        self.assert_(app.jinja_env.tests['boolean'](False))
+        self.assert_true(app.jinja_env.tests['boolean'](False))
-        self.assert_('boolean' in app.jinja_env.tests.keys())
+        self.assert_true('boolean' in app.jinja_env.tests.keys())
-        self.assert_(app.jinja_env.tests['boolean'](False))
+        self.assert_true(app.jinja_env.tests['boolean'](False))
-        self.assert_(b'Success!' in rv.data)
+        self.assert_true(b'Success!' in rv.data)
-        self.assert_(b'Success!' in rv.data)
+        self.assert_true(b'Success!' in rv.data)
-        self.assert_(b'Success!' in rv.data)
+        self.assert_true(b'Success!' in rv.data)
-        self.assert_(b'Success!' in rv.data)
+        self.assert_true(b'Success!' in rv.data)
-        self.assert_('get_stuff' in app.jinja_env.globals.keys())
+        self.assert_true('get_stuff' in app.jinja_env.globals.keys())
-        self.assert_(app.jinja_env.globals['get_stuff'](), 42)
+        self.assert_true(app.jinja_env.globals['get_stuff'](), 42)
-                self.assert_('Session backend did not open a session' in str(e))
+                self.assert_true('Session backend did not open a session' in str(e))
-            self.assert_(req is not None)
+            self.assert_true(req is not None)
-                self.assert_(req is flask.request._get_current_object())
+                self.assert_true(req is flask.request._get_current_object())
-            self.assert_('cookies' in str(e))
+            self.assert_true('cookies' in str(e))
-            self.assert_(b'Internal Server Error' in resp.data)
+            self.assert_true(not hasattr(flask.g, 'value'))
-        self.assert_('after' in evts)
+        self.assert_(b'after' in evts)
-        
+
-        bp = flask.Blueprint('foo.bar.baz', __name__, 
+        bp = flask.Blueprint('foo.bar.baz', __name__,
-        self.assert_equal(rv.data.strip(), 'Hello Subdomain')
+        self.assert_equal(rv.data.strip(), b'Hello Subdomain')
-        self.assert_equal('internal server error', rv.data)
+        self.assert_equal(b'internal server error', rv.data)
-        self.assert_equal(rv.data.strip(), 'Admin File')
+        self.assert_equal(rv.data.strip(), b'Admin File')
-        self.assert_equal(rv.data.strip(), '/* nested file */')
+        self.assert_equal(rv.data.strip(), b'/* nested file */')
-        self.assert_equal(c.get('/2/bar').data, u'19')
+        self.assert_equal(c.get('/1/foo').data, b'23/42')
-        self.assert_equal(rv.data.strip(), 'Admin File')
+        self.assert_equal(rv.data.strip(), b'Admin File')
-        self.assert_equal(rv.data.strip(), '/* nested file */')
+        self.assert_equal(rv.data.strip(), b'/* nested file */')
-        self.assert_equal(c.get('/be').data.strip(), '/fe')
+        self.assert_equal(c.get('/fe').data.strip(), b'/be')
-        self.assert_('Success!' in rv.data)
+        self.assert_(b'Success!' in rv.data)
-        self.assert_('Success!' in rv.data)
+        self.assert_(b'Success!' in rv.data)
-        self.assert_('Success!' in rv.data)
+        self.assert_(b'Success!' in rv.data)
-        self.assert_('Success!' in rv.data)
+        self.assert_(b'Success!' in rv.data)
-        self.assert_('Success!' in rv.data)
+        self.assert_(b'Success!' in rv.data)
-        self.assert_('Internal Server Error' in rv.data)
+        self.assert_(b'Internal Server Error' in rv.data)
-        self.assert_('Internal Server Error' in rv.data)
+        self.assert_(b'Internal Server Error' in rv.data)
-        self.assert_equal(rv.data.split(), ['42', '23', 'False', 'aha'])
+        self.assert_equal(rv.data.split(), [b'42', b'23', b'False', b'aha'])
-            '<p>Hello World!'
+            b'&lt;p&gt;Hello World!',
-        self.assert_('Success!' in rv.data)
+        self.assert_(b'Success!' in rv.data)
-        self.assert_('Success!' in rv.data)
+        self.assert_(b'Success!' in rv.data)
-        self.assert_('Success!' in rv.data)
+        self.assert_(b'Success!' in rv.data)
-        self.assert_('Success!' in rv.data)
+        self.assert_(b'Success!' in rv.data)
-            assert rv.data == '<missing>'
+            assert rv.data == b'<missing>'
-            assert rv.data == 'index'
+            assert rv.data == b'index'
-            assert rv.data == 'foo'
+            assert rv.data == b'foo'
-            assert rv.data == 'foo'
+            assert rv.data == b'foo'
-            self.assert_('Internal Server Error' in resp.data)
+            self.assert_(b'Internal Server Error' in resp.data)
-        self.assertEquals('xxx', response.data)
+        self.assertEquals(b'xxx', response.data)
-        self.assertEquals('xxx', response.data)
+        self.assertEquals(b'xxx', response.data)
-        self.assert_equal(rv.data, '')
+        self.assert_equal(rv.data, b'')
-        self.assert_equal(c.get('/').data, 'GET')
+        self.assert_equal(c.get('/').data, b'GET')
-        self.assert_equal(c.get('/more').data, 'GET')
+        self.assert_equal(c.post('/more').data, b'POST')
-        self.assert_equal(c.get('/').data, 'GET')
+        self.assert_equal(c.get('/').data, b'GET')
-        self.assert_equal(c.get('/more').data, 'GET')
+        self.assert_equal(c.post('/more').data, b'POST')
-        self.assert_equal(c.get('/foo/bar').data, 'bar')
+        self.assert_equal(c.get('/foo/').data, b'index')
-        self.assert_equal(c.get('/foo/bar').data, 'bar')
+        self.assert_equal(c.get('/foo/').data, b'index')
-        self.assert_equal(c.get('/get').data, '42')
+        self.assert_equal(c.post('/set', data={'value': '42'}).data, b'value set')
-        self.assert_equal(rv.data, 'True')
+        self.assert_equal(rv.data, b'True')
-        self.assert_equal(c.get('/').data, '42')
+        self.assert_equal(c.get('/').data, b'None')
-        self.assert_equal(rv, 'request|after')
+        self.assert_equal(rv, b'request|after')
-        self.assert_('Response' in rv.data)
+        self.assert_(b'Response' in rv.data)
-        self.assert_('Response' in rv.data)
+        self.assert_(b'Response' in rv.data)
-        self.assert_('Internal Server Error' in rv.data)
+        self.assert_(b'Internal Server Error' in rv.data)
-        self.assert_equal(rv.data, '42')
+        self.assert_equal(rv.data, b'42')
-        self.assert_equal(rv.data, 'not found')
+        self.assert_equal(rv.data, b'not found')
-        self.assert_equal('internal server error', rv.data)
+        self.assert_equal(b'internal server error', rv.data)
-        self.assert_equal(rv.data, 'value')
+        self.assert_equal(rv.data, b'value')
-        self.assert_equal(c.get('/').data, '42')
+        self.assert_equal(c.get('/').data, b'42')
-        self.assert_equal(rv.data, 'Meh')
+        self.assert_equal(rv.data, b'Meh')
-            self.assert_equal(rv.data, '')
+            self.assert_equal(rv.data, b'')
-            self.assert_equal(rv.data, 'Awesome')
+            self.assert_equal(rv.data, b'Awesome')
-            self.assert_equal(rv.data, 'W00t')
+            self.assert_equal(rv.data, b'W00t')
-                             '{\n  "msg": "W00t"\n}')
+            self.assertEqual(rv.data, b'{\n  "msg": "W00t"\n}')
-            self.assertEqual(rv.data, '')
+            self.assertEqual(rv.data, b'')
-        self.assert_equal(c.get('/1,2,3').data, '1|2|3')
+        self.assert_equal(c.get('/1,2,3').data, b'1|2|3')
-        self.assert_equal(rv.data.strip(), '<h1>Hello World!</h1>')
+        self.assert_equal(rv.data.strip(), b'<h1>Hello World!</h1>')
-        self.assert_equal(rv.data, 'Foo')
+        self.assert_equal(rv.data, b'Foo')
-        self.assert_equal(rv.data, 'Foo')
+        self.assert_equal(rv.data, b'Foo')
-        self.assert_equal(rv.data, 'Foo')
+        self.assert_equal(rv.data, b'Foo')
-        self.assert_equal(rv.data, 'Foo')
+        self.assert_equal(rv.data, b'Foo')
-        self.assert_equal(rv.data, 'Foo SubDomain')
+        self.assert_equal(rv.data, b'Foo SubDomain')
-        self.assert_equal(rv.data, '42')
+        self.assert_equal(rv.data, b'42')
-        self.assert_equal(c.get('/foo').data, '/en/about')
+        self.assert_equal(c.get('/de/').data, b'/de/about')
-        self.assert_equal(app.test_client().get('/').data, 'Awesome')
+        self.assert_equal(app.test_client().get('/').data, b'Awesome')
-        self.assert_equal(app.test_client().get('/foo').data, 'Meh')
+        self.assert_equal(app.test_client().get('/foo').data, b'Meh')
-            self.assert_equal(rv.data, 'success')
+            self.assert_equal(rv.data, b'success')
-            self.assert_equal(rv.data, 'success')
+            self.assert_equal(rv.data, b'success')
-        self.assertEqual(c.get('/bar/123').data, '123')
+        self.assertEqual(c.get('/foo/').data, b'foo')
-        self.assert_equal(rv.data, 'normal index')
+        self.assert_equal(rv.data, b'normal index')
-        self.assert_equal(rv.data, 'test index')
+        self.assert_equal(rv.data, b'test index')
-        self.assert_equal(rv.data, 'index for mitsuhiko')
+        self.assert_equal(rv.data, b'index for mitsuhiko')
-        self.assert_equal(rv.data, 'index for mitsuhiko')
+        self.assert_equal(rv.data, b'index for mitsuhiko')
-        self.assert_equal(rv.data, 'Test')
+        self.assert_equal(rv.data, b'Test')
-        self.assert_equal(rv.data, 'Outside')
+        self.assert_equal(rv.data, b'Outside')
-        self.assert_equal(c.get('/admin/logout').data, 'admin logout')
+        self.assert_equal(c.get('/').data, b'the index')
-        self.assert_equal(rv.data, 'Awesome')
+        self.assert_equal(rv.data, b'Awesome')
-        self.assert_equal(c.get('/').data, 'the index')
+        self.assert_equal(c.get('/').data, b'the index')
-        self.assert_equal(c.get('/admin/').data, 'the admin')
+        self.assert_equal(c.get('/admin/').data, b'the admin')
-        self.assert_equal(c.get('/admin/').data, '123')
+        self.assert_equal(c.get('/').data, b'13')
-        self.assert_equal(app.test_client().get('/admin/').data, '42')
+        self.assert_equal(app.test_client().get('/admin/').data, b'42')
-        self.assert_equal(rv.data, 'not found')
+        self.assert_equal(rv.data, b'not found')
-        self.assert_equal(rv.data, 'Hello from the Frontend')
+        self.assert_equal(rv.data, b'Hello from the Frontend')
-        self.assert_equal(rv.data, 'Hello from the Admin')
+        self.assert_equal(rv.data, b'Hello from the Admin')
-        self.assert_equal(rv.data, 'Hello from the Admin')
+        self.assert_equal(rv.data, b'Hello from the Admin')
-        self.assert_equal(c.get('/foo/bar').data, 'bar')
+        self.assert_equal(c.get('/foo/').data, b'index')
-        self.assert_equal(c.get('/what-is-a-sideend').data, 'application itself says no')
+        self.assert_equal(c.get('/frontend-no').data, b'frontend says no')
-        self.assert_equal(c.get('/de/about').data, '/de/')
+        self.assert_equal(c.get('/de/').data, b'/de/about')
-        self.assert_equal(rv.data, 'Hello from the Frontend')
+        self.assert_equal(rv.data, b'Hello from the Frontend')
-        self.assert_equal(rv.data, 'Hello from the Admin')
+        self.assert_equal(rv.data, b'Hello from the Admin')
-        self.assert_equal(rv.data, 'Hello from the Admin')
+        self.assert_equal(rv.data, b'Hello from the Admin')
-        self.assert_equal(c.get('/page/2').data, '2')
+        self.assert_equal(c.get('/').data, b'1')
-        self.assertEqual(c.get('/py/bar/foo').data, 'bp.bar_foo')
+        self.assertEqual(c.get('/').data, b'index')
-        self.assertEqual(c.get('/py/foo').data, 'bp.foo')
+        self.assertEqual(c.get('/py/foo').data, b'bp.foo')
-        self.assert_equal(rv.data, 'dcba')
+        self.assert_equal(rv.data, b'dcba')
-        self.assert_equal(rv.data, 'dcba')
+        self.assert_equal(rv.data, b'dcba')
-        self.assert_equal(rv.data, 'dcba')
+        self.assert_equal(rv.data, b'dcba')
-        self.assert_equal(rv.data, 'dcba')
+        self.assert_equal(rv.data, b'dcba')
-        self.assert_equal(rv.data, 'dcba')
+        self.assert_equal(rv.data, b'dcba')
-        self.assert_equal(rv.data, '3')
+        self.assert_equal(rv.data, b'3')
-        self.assertEqual(rv.data, '"<42>"')
+        self.assertEqual(rv.data, b'"<42>"')
-                self.assert_equal(rv.data, 'Test')
+                self.assert_equal(rv.data, b'Test')
-                self.assert_equal(rv.data, 'Test')
+                self.assert_equal(rv.data, b'Test')
-            self.assert_equal(rv.data, 'Hello Server Error')
+            self.assert_equal(rv.data, b'Hello Server Error')
-        self.assertEqual(rv.data, 'Hello World!')
+        self.assertEqual(rv.data, b'Hello World!')
-        self.assertEqual(rv.data, 'Hello World!')
+        self.assertEqual(rv.data, b'Hello World!')
-        self.assertEqual(rv.data, 'Hello World!')
+        self.assertEqual(rv.data, b'Hello World!')
-                self.assert_equal(rv.data, '<h1>42</h1>')
+                self.assert_equal(rv.data, b'<h1>42</h1>')
-            self.assertEqual(rv.data, '42')
+            self.assertEqual(rv.data, b'42')
-        self.assert_equal(rv.data, 'Hello World!')
+        self.assert_equal(rv.data, b'Hello World!')
-        self.assert_equal(rv.data, 'Hello World!')
+        self.assert_equal(rv.data, b'Hello World!')
-            self.assert_equal(response.data, 'stuff')
+            self.assert_equal(response.data, b'stuff')
-            self.assert_equal(rv.data, 'stuff')
+            self.assert_equal(rv.data, b'stuff')
-        self.assert_equal(rv.data, '<p>23|42')
+        self.assert_equal(rv.data, b'<p>23|42')
-        self.assert_equal(rv.data, '42')
+        self.assert_equal(rv.data, b'42')
-        self.assert_equal(rv.data, 'dcba')
+        self.assert_equal(rv.data, b'dcba')
-        self.assert_equal(rv.data, 'dcba')
+        self.assert_equal(rv.data, b'dcba')
-        self.assert_equal(rv.data, 'dcba')
+        self.assert_equal(rv.data, b'dcba')
-        self.assert_equal(rv.data, 'dcba')
+        self.assert_equal(rv.data, b'dcba')
-        self.assert_equal(rv.data, 'Hello Custom World!')
+        self.assert_equal(rv.data, b'Hello Custom World!')
-        self.assert_equal(rv.data, '<h1>Jameson</h1>')
+        self.assert_equal(rv.data, b'<h1>Jameson</h1>')
-            self.assert_equal(rv.data, 'http://example.com:1234/foo/')
+            self.assert_equal(rv.data, b'http://example.com:1234/foo/')
-            self.assert_equal(rv.data, 'http://localhost/')
+            self.assert_equal(rv.data, b'http://localhost/')
-            self.assert_equal(rv.data, '[42]')
+            self.assert_equal(rv.data, b'[42]')
-            self.assert_equal(resp.data, 'Hello World!')
+            self.assert_equal(resp.data, b'Hello World!')
-        self.assert_equal(c.post('/').data, 'POST')
+        self.assert_equal(c.get('/').data, b'GET')
-        self.assert_equal(rv.data, 'Awesome')
+        self.assert_equal(rv.data, b'Awesome')
-        self.assert_equal(rv.data, 'Blub')
+        self.assert_equal(rv.data, b'Blub')
-        self.assert_equal(rv.data, '')
+        self.assert_equal(rv.data, b'')
-        self.assert_equal(rv.data, 'GET')
+        self.assert_equal(rv.data, b'GET')
-        self.assert_equal(rv.data, '')
+        self.assert_equal(rv.data, b'')
-from itsdangerous import simplejson as _json
+from itsdangerous import json as _json
-from __future__ import with_statement
+
-from __future__ import with_statement
+
-
+from flask._compat import reraise, string_types, integer_types
-        return rv
+        return self.create_jinja_environment()
-        if isinstance(code_or_exception, (int, long)):
+        if isinstance(code_or_exception, integer_types):
-              for i in xrange(2, int(math.ceil(math.sqrt(n))) + 1):
+              for i in range(2, int(math.ceil(math.sqrt(n))) + 1):
-        raise exc_type, exc_value, tb
+        reraise(exc_type, exc_value, tb)
-                raise exc_type, exc_value, tb
+                reraise(exc_type, exc_value, tb)
-            if isinstance(rv, basestring):
+            if isinstance(rv, string_types):
-            if isinstance(status, basestring):
+            if isinstance(status, string_types):
-            raise exc_type, exc_value, tb
+            reraise(exc_type, exc_value, tb)
-
+from flask._compat import string_types
-        if isinstance(obj, basestring):
+        if isinstance(obj, string_types):
-                    raise exc_type, exc_value, tb.tb_next
+                    reraise(exc_type, exc_value, tb.tb_next)
-
+from flask._compat import string_types, text_type
-    if isinstance(filename_or_fp, basestring):
+    if isinstance(filename_or_fp, string_types):
-           and isinstance(filename, basestring):
+           and isinstance(filename, string_types):
-                filename.encode('utf-8') if isinstance(filename, unicode)
+                filename.encode('utf-8') if isinstance(filename, text_type)
-from urlparse import urlparse
+from flask._compat import urlparse
-from StringIO import StringIO
+from flask._compat import reraise, StringIO
-            raise exc_type, exc_value, tb
+            reraise(exc_type, exc_value, tb)
-        for x in xrange(3):
+        for x in range(3):
-            self.assert_('init_jinja_globals' in str(log[0]['message']))
+    """not used currently"""
-        for entry, value in sys.modules.items():
+        for entry, value in list(sys.modules.items()):
-        for x in xrange(2):
+        for x in range(2):
-from StringIO import StringIO
+from flask._compat import StringIO
-                for x in xrange(10):
+                for x in range(10):
-from StringIO import StringIO
+from flask._compat import StringIO
-from __future__ import with_statement
+
-    again from here as soon as we require a new enough "six" release.
+    Some py2/py3 compatibility support based on a stripped down
-            print "Audit requires PyFlakes installed in your system."
+            print("Audit requires PyFlakes installed in your system.")
-            print "Audit finished with total %d warnings." % warns
+            print("Audit finished with total %d warnings." % warns)
-            print "No problems found in sourcecode."
+            print("No problems found in sourcecode.")
-from six import reload_module
+from six.moves import reload_module
-
+from six import reload_module
-        reload(ext)
+        reload_module(ext)
-            return unicode(o.__html__())
+            return six.text_type(o.__html__())
-                return {' m': unicode(value.__html__())}
+                return {' m': six.text_type(value.__html__())}
-                    return unicode(value)
+                    return six.text_type(value)
-            return unicode(flask.session.permanent)
+            return six.text_type(flask.session.permanent)
-            return unicode(bar)
+            return six.text_type(bar)
-            return unicode(flask.request.json)
+            return six.text_type(flask.request.json)
-            return unicode(flask.request.json)
+            return six.text_type(flask.request.json)
-            return unicode(flask.request.json['a'] + flask.request.json['b'])
+            return six.text_type(flask.request.json['a'] + flask.request.json['b'])
-            return unicode(flask.session['foo'])
+            return six.text_type(flask.session['foo'])
-    wrapped_g.next()
+    six.advance_iterator(wrapped_g)
-            the_key, the_value = obj.iteritems().next()
+            the_key, the_value = six.advance_iterator(obj.iteritems())
-                return self._gen.next()
+                return six.advance_iterator(self._gen)
-                return dict((k, _tag(v)) for k, v in value.iteritems())
+                return dict((k, _tag(v)) for k, v in six.iteritems(value))
-        for blueprint in self.app.blueprints.itervalues():
+        for blueprint in six.itervalues(self.app.blueprints):
-        for name, blueprint in self.app.blueprints.iteritems():
+        for name, blueprint in six.iteritems(self.app.blueprints):
-        print 'Error: %s' % e
+        print('Error: %s' % e)
-            raise AttributeError, msg
+            raise AttributeError(msg)
-    security reasons only objects are supported toplevel.  For more
+    For security reasons only objects are supported toplevel.  For more
-                     'Python 2.5.')
+        parser.error('Python 2.6 or later is required to run the upgrade script.')
-           Flask.init_jinja_globals.im_func:
+           Flask.init_jinja_globals.__func__:
-            execfile(filename, d.__dict__)
+            exec(compile(open(filename).read(), filename, 'exec'), d.__dict__)
-        except Exception, e:
+        except Exception as e:
-            except MethodNotAllowed, e:
+            except MethodNotAllowed as e:
-            except HTTPException, e:
+            except HTTPException as e:
-            except BuildError, error:
+            except BuildError as error:
-            except Exception, e:
+            except Exception as e:
-        except IOError, e:
+        except IOError as e:
-        except HTTPException, e:
+        except HTTPException as e:
-            except KeyError, e:
+            except KeyError as e:
-    except BuildError, error:
+    except BuildError as error:
-    except Exception, e:
+    except Exception as e:
-            except RuntimeError, e:
+            except RuntimeError as e:
-        except KeyError, e:
+        except KeyError as e:
-        except NotFound, e:
+        except NotFound as e:
-            except DebugFilesKeyError, e:
+            except DebugFilesKeyError as e:
-        except BuildError, error:
+        except BuildError as error:
-        except ValueError, e:
+        except ValueError as e:
-        except ValueError, e:
+        except ValueError as e:
-        except ValueError, e:
+        except ValueError as e:
-        except AssertionError, e:
+        except AssertionError as e:
-            except AssertionError, e:
+            except AssertionError as e:
-            except TemplateNotFound, e:
+            except TemplateNotFound as e:
-            except TemplateNotFound, e:
+            except TemplateNotFound as e:
-            except RuntimeError, e:
+            except RuntimeError as e:
-            except IOError, e:
+            except IOError as e:
-        except IOError, e:
+        except IOError as e:
-        except ValueError, e:
+        except ValueError as e:
-        except Exception, e:
+        except Exception as e:
-        except ValueError, e:
+        except ValueError as e:
-        except ValueError, e:
+        except ValueError as e:
-            except RuntimeError, e:
+            except RuntimeError as e:
-        except RuntimeError, e:
+        except RuntimeError as e:
-            except ValueError, e:
+            except ValueError as e:
-    suite.addTest(unittest.makeSuite(MemoryTestCase))
+    if os.environ.get('RUN_FLASK_MEMORY_TESTS') == '1':
-    date format).  In order to support more data types override the
+    encoder by also supporting ``datetime`` objects, ``UUID`` as well as
-            return 2 * n
+            @app.template_global()
-        function name will be used.
+                     function name will be used.
-        function name will be used.
+                     function name will be used.
-     after_this_request
+     after_this_request, copy_current_request_context
-    pass
+
-    def __init__(self, app, environ):
+    def __init__(self, app, environ, request=None):
-        self.request = app.request_class(environ)
+        if request is None:
-            self.app.name
+            self.app.name,
-        self.assert_equal(values, expected) 
+        self.assert_equal(values, expected)
-    suite.addTest(unittest.makeSuite(ContextTestCase))
+# -*- coding: utf-8 -*-
-::
+.. code:: python
-::
+.. code:: bash
-            funcs = reversed(self.after_request_funcs[bp])
+            funcs = chain(funcs, reversed(self.after_request_funcs[bp]))
-     appcontext_tearing_down
+     appcontext_tearing_down, message_flashed
-            return '.' + app.config['SERVER_NAME'].rsplit(':', 1)[0]
+            rv = '.' + app.config['SERVER_NAME'].rsplit(':', 1)[0]
-           and not self.trap_http_exception(e):
+        # trap_http_exception method so that's their fault then.
-        if isinstance(e, HTTPException) and not self.trap_http_exception(e):
+        # trap_http_exception method so that's their fault then.  Proxy
-                           'context being pushed.  This has to be executed ')
+        raise RuntimeError('Attempted to generate a URL without the '
-copyright = u'2012, Armin Ronacher'
+copyright = u'2013, Armin Ronacher'
-from .globals import _request_ctx_stack, request
+from .globals import _request_ctx_stack, request, session, g
-            config=self.config
+            config=self.config,
-from .ctx import RequestContext, AppContext, _RequestGlobals
+from .ctx import RequestContext, AppContext, _AppCtxGlobals
-    request_globals_class = _RequestGlobals
+    #: In Flask 0.9 this property was called `request_globals_class` but it
-class _RequestGlobals(object):
+class _AppCtxGlobals(object):
-        self.g = app.request_globals_class()
+    def _get_g(self):
-def _lookup_object(name):
+
-g = LocalProxy(partial(_lookup_object, 'g'))
+request = LocalProxy(partial(_lookup_req_object, 'request'))
-    )
+    appctx = _app_ctx_stack.top
-    def test_custom_request_globals_class(self):
+    def test_custom_app_ctx_globals_class(self):
-        with app.test_request_context():
+        app.app_ctx_globals_class = CustomRequestGlobals
-        flask._request_ctx_stack.pop()
+        self.assert_(flask._app_ctx_stack.top is not None)
-        top.sqlite_db = sqlite3.connect(app.config['DATABASE'])
+        sqlite_db = sqlite3.connect(app.config['DATABASE'])
-    entries = [dict(title=row[0], text=row[1]) for row in cur.fetchall()]
+    entries = cur.fetchall()
-    def find_module(self, fullname):
+    def find_module(self, fullname, path=None):
-        'PREFERRED_URL_SCHEME':                 'http'
+        'PREFERRED_URL_SCHEME':                 'http',
-        kwargs.setdefault('cls', current_app.json_encoder)
+    _dump_arg_defaults(kwargs)
-        kwargs.setdefault('cls', current_app.json_encoder)
+    _dump_arg_defaults(kwargs)
-        kwargs.setdefault('cls', current_app.json_decoder)
+    _load_arg_defaults(kwargs)
-        kwargs.setdefault('cls', current_app.json_decoder)
+    _load_arg_defaults(kwargs)
-                           force_external=external)
+from __future__ import with_statement
-     render_template, flash
+     render_template, flash, _app_ctx_stack
-    with closing(connect_db()) as db:
+    with app.app_context():
-    g.db = connect_db()
+def get_db():
-def teardown_request(exception):
+@app.teardown_appcontext
-        g.db.close()
+    top = _app_ctx_stack.top
-    cur = g.db.execute('select title, text from entries order by id desc')
+    db = get_db()
-    g.db.execute('insert into entries (title, text) values (?, ?)',
+    db = get_db()
-    g.db.commit()
+    db.commit()
-     render_template, abort, g, flash
+     render_template, abort, g, flash, _app_ctx_stack
-    return sqlite3.connect(app.config['DATABASE'])
+def get_db():
-    with closing(connect_db()) as db:
+    with app.app_context():
-               for idx, value in enumerate(row)) for row in cur.fetchall()]
+    cur = get_db().execute(query, args)
-                       [username]).fetchone()
+    rv = query_db('select user_id from user where username = ?',
-    g.db.commit()
+    db = get_db()
-    g.db.commit()
+    db = get_db()
-        g.db.commit()
+        db = get_db()
-            g.db.commit()
+            db = get_db()
-        # it's invalidated otherwise we run at risk that something leaks
+        # it's invalidated, otherwise we run at risk that something leaks
-        # request context (e.g. flask-sqlalchemy).
+        # request context (e.g. code that access database information
-            get_flashed_messages=get_flashed_messages
+            get_flashed_messages=get_flashed_messages,
-            funcs = chain(funcs, self.template_context_processors[bp])
+        reqctx = _request_ctx_stack.top
-from .globals import _request_ctx_stack
+from .globals import _request_ctx_stack, _app_ctx_stack
-    ctx = _request_ctx_stack.top
+    ctx = _app_ctx_stack.top
-    ctx = _request_ctx_stack.top
+    ctx = _app_ctx_stack.top
-    configured encoder (:attr:`~flask.Flask.json_encoder`).
+    configured encoder (:attr:`~flask.Flask.json_encoder`) if there is an
-    kwargs.setdefault('cls', current_app.json_encoder)
+    if current_app:
-    kwargs.setdefault('cls', current_app.json_encoder)
+    if current_app:
-    configured decoder (:attr:`~flask.Flask.json_decoder`).
+    configured decoder (:attr:`~flask.Flask.json_decoder`) if there is an
-    kwargs.setdefault('cls', current_app.json_decoder)
+    if current_app:
-    kwargs.setdefault('cls', current_app.json_decoder)
+    if current_app:
-    get_template_attribute, make_response, safe_join, \
+from .helpers import url_for, flash, send_file, send_from_directory, \
-from .helpers import json
+# We're not exposing the actual json module but a convenient wrapper around
-    find_package
+    locked_cached_property, _endpoint_from_view_func, find_package
-        rv.filters['tojson'] = _tojson_filter
+        rv.filters['tojson'] = json.htmlsafe_dumps
-from .helpers import json
+from . import json
-
+# -*- coding: utf-8 -*-
-from . import Markup
+from . import Markup, json
-from .helpers import json
+from . import json
-                filename.encode('utf8') if isinstance(filename, unicode)
+                filename.encode('utf-8') if isinstance(filename, unicode)
-    if os.path.isabs(filename) or filename.startswith('../'):
+    if os.path.isabs(filename) or \
-        def test_filters():
+        def test_filters2():
-        except (IOError, OSError):
+        except (IOError, OSError, AttributeError):
-    _tojson_filter = json.dumps
+_slash_escape = '\\/' not in json.dumps('/')
-        max_age = app.permanent_session_lifetime.total_seconds()
+        max_age = total_seconds(app.permanent_session_lifetime)
-     request_finished, got_request_exception, request_tearing_down
+     request_finished, got_request_exception, request_tearing_down, \
-        self.assert_('my_reverse' in  app.jinja_env.filters.keys())
+        self.assert_('my_reverse' in app.jinja_env.filters.keys())
-        self.assert_('my_reverse' in  app.jinja_env.filters.keys())
+        self.assert_('my_reverse' in app.jinja_env.filters.keys())
-        self.assert_('strrev' in  app.jinja_env.filters.keys())
+        self.assert_('strrev' in app.jinja_env.filters.keys())
-        self.assert_('strrev' in  app.jinja_env.filters.keys())
+        self.assert_('strrev' in app.jinja_env.filters.keys())
-        self.assert_('my_reverse' in  app.jinja_env.filters.keys())
+        self.assert_('my_reverse' in app.jinja_env.filters.keys())
-        self.assert_('my_reverse' in  app.jinja_env.filters.keys())
+        self.assert_('my_reverse' in app.jinja_env.filters.keys())
-        self.assert_('strrev' in  app.jinja_env.filters.keys())
+        self.assert_('strrev' in app.jinja_env.filters.keys())
-        self.assert_('strrev' in  app.jinja_env.filters.keys())
+        self.assert_('strrev' in app.jinja_env.filters.keys())
-
+from urlparse import urlparse
-        base_url = 'http://%s/' % (http_host or 'localhost')
+        url = urlparse(path)
-    system.
+    Implements cookie based sessions based on itsdangerous.
-    :copyright: (c) 2011 by Armin Ronacher.
+    :copyright: (c) 2012 by Armin Ronacher.
-        occours that is not caught.  In debug mode the exception will
+        occurs that is not caught.  In debug mode the exception will
-                          rendered
+    :param source: the sourcecode of the template to be
-        the actually :meth:`before_request` functions are called.
+        the actual :meth:`before_request` functions are called.
-            app.logger.error('An error occoured')
+            app.logger.warning('A warning occurred (%d apples)', 42)
-                'A blueprint\'s name collision ocurred between %r and ' \
+                'A blueprint\'s name collision occurred between %r and ' \
-        request in case an unhandled exception ocurred.
+        request in case an unhandled exception occurred.
-        Generally teardown functions must take every necesary step to avoid
+        Generally teardown functions must take every necessary step to avoid
-        statements and log ocurring errors.
+        statements and log occurring errors.
-        occours that is not caught.  In debug mode the exception will
+        occurs that is not caught.  In debug mode the exception will
-        the actualy :meth:`before_request` functions are called.
+        the actually :meth:`before_request` functions are called.
-           error ocurred or not.  See :ref:`callbacks-and-errors`.
+           error occurred or not.  See :ref:`callbacks-and-errors`.
-        # Some python verisons will will clean up modules so early that the
+        # Some python versions will will clean up modules so early that the
-        class SupressedFlask(flask.Flask):
+    def test_suppressed_exception_logging(self):
-        app.logger_name = 'flask_tests/test_supressed_exception_logging'
+        app = SuppressedFlask(__name__)
-        this method is used by :attr:`json` when an error ocurred.  The default
+        this method is used by :attr:`json` when an error occurred.  The default
-    def find_module(self, fullname, path=None):
+    def find_module(self, fullname):
-                return {'##t': [_tag(x) for x in value]}
+                return {' t': [_tag(x) for x in value]}
-                return {'##m': unicode(value.__html__())}
+                return {' m': unicode(value.__html__())}
-                return {'##d': http_date(value)}
+                return {' d': http_date(value)}
-            if the_key == '##t':
+            if the_key == ' t':
-            elif the_key == '##m':
+            elif the_key == ' m':
-            elif the_key == '##d':
+            elif the_key == ' d':
-    session_class = SecureCookieSession
+    #: the hash function to use for the signature.  The default is sha1
-    def get_serializer(self, app):
+    def get_signing_serializer(self, app):
-                                      serializer=self.serializer)
+        signer_kwargs = dict(
-        s = self.get_serializer(app)
+        s = self.get_signing_serializer(app)
-        secure = self.get_cookie_secure(app)
+        httponly = self.get_cookie_httponly(app)
-        val = self.get_serializer(app).dumps(dict(session))
+        val = self.get_signing_serializer(app).dumps(dict(session))
-        'itsdangerous>=0.16'
+        'itsdangerous>=0.17'
-from .helpers import url_for, jsonify, json_available, flash, \
+from .helpers import url_for, jsonify, flash, \
-    from .helpers import json
+from .helpers import json
-            json_available = False
+# Use the same json implementation as itsdangerous on which we
-
+if '\\/' not in json.dumps('/'):
-from .helpers import json, _assert_have_json
+from .helpers import json
-from .helpers import json, _assert_have_json
+from werkzeug.datastructures import CallbackDict
-
+class SecureCookieSession(CallbackDict, SessionMixin):
-    serialization_method = _UpgradeSerializer()
+    def __init__(self, initial=None):
-    """
+    salt = 'cookie-session'
-                                                  secret_key=key)
+        s = self.get_serializer(app)
-    session_class = UpgradeSecureCookieSession
+        if not session:
-        'Jinja2>=2.4'
+        'Jinja2>=2.4',
-__version__ = '0.9'
+__version__ = '0.10-dev'
-    version='0.9',
+    version='0.10-dev',
-    and non-permanent sessions.
+    and non-permanent sessions and changes the default pickle based
-    Alternatively it can also be used around a specific generator:
+    Alternatively it can also be used around a specific generator::
-    :param _external: if set to `True`, an absolute URL is generated.
+    :param _external: if set to `True`, an absolute URL is generated. Server
-           UR adapter is created for the application context.
+           URL adapter is created for the application context.
-    Alternatively it can also be used around a specific generator:
+    Alternatively it can also be used around a specific generator::
-    Alternatively it can also be used around a specific generator:
+    Alternatively it can also be used around a specific generator::
-__version__ = '0.8.1-dev'
+__version__ = '0.8.1'
-    version='0.8.1-dev',
+    version='0.8.1',
-    get_template_attribute, make_response, safe_join
+    get_template_attribute, make_response, safe_join, \
-
+        # Like request context, app contexts can be pushed multiple times
-        self.app.do_teardown_appcontext(exc)
+        self._refcnt -= 1
-        self.pop()
+        self.pop(exc_value)
-        self._pushed_application_context = _push_app_if_necessary(self.app)
+        app_ctx = _app_ctx_stack.top
-        self.app.do_teardown_request(exc)
+        app_ctx = self._implicit_app_ctx_stack.pop()
-        rv.request.environ['werkzeug.request'] = None
+        if clear_request:
-            self._pushed_application_context = None
+        if app_ctx is not None:
-        # object.  These will even be called in case of an error.
+        # object.  These will be called before the regular "after_request"
-from functools import partial
+    # Module already imported and has a file attribute.  Use that first.
-        # import name is not found, or interactive/main module
+
-            def add_header():
+            def add_header(response):
-        for url in '/kw', '/dict', '/unpadded':
+        for url in '/kw', '/dict':
-    if cache_timeout:
+    if cache_timeout is not None:
-            callback = request.args.get(kwargs['padded']) or 'jsonp'
+        del kwargs['padded']
-        del kwargs['padded']
+        flaskext_compat.activate()
-from .ctx import has_request_context, has_app_context
+from .ctx import has_request_context, has_app_context, \
-        funcs = ()
+        funcs = ctx._after_request_functions
-                methods = tuple(methods) + ('OPTIONS',)
+                required_methods.add('OPTIONS')
-from werkzeug.routing import Map, Rule, RequestRedirect
+from werkzeug.routing import Map, Rule, RequestRedirect, BuildError
-        #: `**values` are the arguments passed into :meth:`url_for`.
+        #: A list of functions that are called when :meth:`url_for` raises a
-        self.build_error_handler = None
+        self.url_build_error_handlers = []
-    def handle_build_error(self, error, endpoint, **values):
+    def handle_url_build_error(self, error, endpoint, values):
-        return self.build_error_handler(error, endpoint, **values)
+        exc_type, exc_value, tb = sys.exc_info()
-import imp
+        # We need to inject the values again so that the app callback can
-        return appctx.app.handle_build_error(error, endpoint, **values)
+        return appctx.app.handle_url_build_error(error, endpoint, values)
-            self.assertRaises(BuildError, app.handle_build_error, error, 'spam')
+            self.assertRaises(BuildError, app.handle_url_build_error, error, 'spam', {})
-        def handler(error, endpoint, **values):
+        def handler(error, endpoint, values):
-        app.build_error_handler = handler
+        app.url_build_error_handlers.append(handler)
-from .ctx import RequestContext, AppContext
+from .ctx import RequestContext, AppContext, _RequestGlobals
-        self.g = _RequestGlobals()
+        self.g = app.request_globals_class()
-              cache_timeout=60 * 60 * 12, conditional=False):
+              cache_timeout=None, conditional=False):
-
+    .. versionchanged:: 0.9
-    :param cache_timeout: the timeout in seconds for the headers.
+
-        """Provides keyword arguments to send to :func:`send_from_directory`.
+    def get_send_file_max_age(self, filename):
-        to 60 seconds (note the options are keywords for :func:`send_file`)::
+        to 60 seconds::
-                    return options
+                def get_send_file_max_age(self, name):
-        return options
+        return current_app.config['SEND_FILE_MAX_AGE_DEFAULT']
-                **self.get_send_file_options(filename))
+                                   cache_timeout=cache_timeout)
-        # override get_send_file_options with some new values and check them
+            # Test again with direct use of send_file utility.
-                return opts
+            def get_send_file_max_age(self, filename):
-        'Werkzeug>=0.6.1',
+        'Werkzeug>=0.7',
-                fire()
+        # This test only works on CPython 2.7.
-            raise error
+            exc_type, exc_value, tb = sys.exc_info()
-            bp = endpoint.split('.', 1)[0]
+            bp = endpoint.rsplit('.', 1)[0]
-        def return_padded_json():
+        def return_padded_true():
-        for url in '/kw', '/dict':
+        for url in '/kw', '/dict', '/unpadded':
-        behaviour of `OPTIONS` responses.
+        behavior of `OPTIONS` responses.
-# figure out if simplejson escapes slashes.  This behaviour was changed
+# figure out if simplejson escapes slashes.  This behavior was changed
-        for JSONP calls and the response mimetype will be changed to 
+        for JSONP calls and the response mimetype will be changed to
-       added.  The default behaviour is now to attach etags.
+       added.  The default behavior is now to attach etags.
-        # XXX: this behaviour is now deprecated because it was unreliable.
+        # XXX: this behavior is now deprecated because it was unreliable.
-                'function because this behaviour was unreliable.  Pass '
+                'function because this behavior was unreliable.  Pass '
-                # very this seems to be redundant, but if recursive imports
+                # end this seems to be redundant, but if recursive imports
-                # is the one from __import__ above which we don't care about
+                # is the one from __import__ above which we don't care about.
-        # Some python verisons will will clean up modules so early that the
+        # Some python versions will clean up modules so early that the
-        #: a reference to the blurprint that created this setup state.
+        #: a reference to the blueprint that created this setup state.
-    """Worksl ike :func:`has_request_context` but for the application
+    """Works like :func:`has_request_context` but for the application
-from .ctx import has_request_context
+from .ctx import has_request_context, has_app_context
-            self._pushed_application_context.pop()
+            self._pushed_application_context.pop(exc)
-    request_tearing_down
+    request_tearing_down, appcontext_tearing_down
-    def do_teardown_request(self):
+    def do_teardown_request(self, exc=None):
-        request_tearing_down.send(self)
+        request_tearing_down.send(self, exc=exc)
-    def pop(self):
+    def pop(self, exc=None):
-    def pop(self):
+    def pop(self, exc=None):
-        self.app.do_teardown_request()
+        if exc is None:
-            self.pop()
+            self.pop(exc_value)
-        return {}
+        options = {}
-                                contents of the tuple as arguments
+        :class:`tuple`          A tuple in the form ``(response, status,
-                return new_response
+
-        return self.response_class.force_type(rv, request.environ)
+                rv.status_code = status
-            return 'Meh', 400, {'X-Foo': 'Testing'}, 'text/plain'
+            return 'Meh', 400, {
-                400, {'Content-Type': 'text/html'})
+                400, [('X-Foo', 'bar')])
-
+            self.assertEqual(rv.headers['X-Foo'], 'bar')
-from .globals import current_app, g, request, session, _request_ctx_stack
+from .globals import current_app, g, request, session, _request_ctx_stack, \
-    def test_basic_support(self):
+    def test_basic_url_generation(self):
-        'TRAP_HTTP_EXCEPTIONS':                 False
+        'TRAP_HTTP_EXCEPTIONS':                 False,
-            server_name=self.config['SERVER_NAME'])
+        if request is not None:
-from .globals import session, _request_ctx_stack, current_app, request
+from .globals import session, _request_ctx_stack, _app_ctx_stack, \
-            else:
+    appctx = _app_ctx_stack.top
-    external = values.pop('_external', False)
+        url_adapter = appctx.url_adapter
-                               force_external=external)
+    appctx.app.inject_url_defaults(endpoint, values)
-from .ctx import RequestContext
+from .ctx import RequestContext, AppContext
-from .globals import _request_ctx_stack
+from .globals import _request_ctx_stack, _app_ctx_stack
-current_app = LocalProxy(partial(_lookup_object, 'app'))
+_app_ctx_stack = LocalStack()
-        # XXX: Support for deprecated functionality.  This is doing away with
+        # XXX: Support for deprecated functionality.  This is going away with
-copyright = u'2010, Armin Ronacher'
+copyright = u'2012, Armin Ronacher'
-
+    # Original implementation:
-            print "Audit requires PyFlakes installed in your system."""
+            print "Audit requires PyFlakes installed in your system."
-            print "Audit requires PyFlakes installed in your system."""
+            print "Audit requires PyFlakes installed in your system."
-            for key, value in d.iteritems():
+            for key in d:
-    def get_static_file_options(self, filename):
+    def get_send_file_options(self, filename):
-                    options = super(MyFlask, self).get_static_file_options(filename)
+                def get_send_file_options(self, filename):
-        .. versionaded:: 0.9
+        .. versionadded:: 0.9
-                **self.get_static_file_options(filename))
+                **self.get_send_file_options(filename))
-        # default cache timeout is 12 hours (hard-coded)
+        # default cache timeout is 12 hours
-        # override get_static_file_options with some new values and check them
+        app.config['SEND_FILE_MAX_AGE_DEFAULT'] = 3600
-                opts = super(StaticFileApp, self).get_static_file_options(filename)
+            def get_send_file_options(self, filename):
-        to send to :func:`send_from_directory` for a specific file."""
+        """Provides keyword arguments to send to :func:`send_from_directory`.
-        app = StaticFileApp()
+        app = StaticFileApp(__name__)
-from werkzeug.exceptions import BadRequest, HTTPException
+from .exceptions import JSONBadRequest
-        ``text/javascript``. By default, the request arguments ``callback``
+        ``application/javascript``. By default, the request arguments ``callback``
-        return current_app.response_class(content, mimetype='text/javascript')
+        return current_app.response_class(content, mimetype='application/javascript')
-        no function name it will fallback and use ``jsonp`` as function name.
+        If the ``padded`` argument is true, the JSON object will be padded
-    return send_file(filename, conditional=True, **options)
+    options.setdefault('conditional', True)
-        return send_from_directory(self.static_folder, filename)
+        return send_from_directory(self.static_folder, filename,
-from werkzeug.http import parse_options_header
+from werkzeug.http import parse_cache_control_header, parse_options_header
-            return self.response_class(*rv)
+            if len(rv) > 0 and isinstance(rv[0], self.response_class):
-from werkzeug.exceptions import BadRequest
+from werkzeug.exceptions import BadRequest, HTTPException
-        default implementation raises a :class:`~werkzeug.exceptions.BadRequest`.
+        this method is used by :attr:`json` when an error ocurred.  The default
-        raise BadRequest()
+        raise JSONBadRequest()
-    session.setdefault('_flashes', []).append((category, message))
+    flashes = session.get('_flashes', [])
-            self.assert_(not app.config.from_envvar('FOO_SETTINGS', silent=True))
+                self.fail('expected IOError')
-        return True
+        return self.from_pyfile(rv, silent=silent)
-def render_template(template_name, **context):
+def render_template(template_name_or_list, **context):
-    :param template_name: the name of the template to be rendered
+    :param template_name_or_list: the name of the template to be
-    return _render(ctx.app.jinja_env.get_template(template_name),
+    return _render(ctx.app.jinja_env.get_or_select_template(template_name_or_list),
-    $ easy_install Flask
+    $ pip install Flask
-    This module provides class based views inspired by the ones in Django.
+    This module provides class-based views inspired by the ones in Django.
-    #: The canonical way to decorate class based views is to decorate the
+    #: The canonical way to decorate class-based views is to decorate the
-        # first of all it allows us to easily figure out what class based
+        # first of all it allows us to easily figure out what class-based
-    """Like a regular class based view but that dispatches requests to
+    """Like a regular class-based view but that dispatches requests to
-                               'delete', 'put', 'trace'])
+                               'delete', 'put', 'trace', 'patch'])
-        on each request and call the :meth:`dispatch_request` method on it.
+        """Converts the class into an actual view function that can be used
-        a function on the fly that will instanciate the :class:`View`
+        a function on the fly that will instantiate the :class:`View`
-        # view this thing came from, secondly it's also used for instanciating
+        # view this thing came from, secondly it's also used for instantiating
-        # Also, create new test client on each test to clean flashed messages.
+        # Create new test client on each test to clean flashed messages.
-        assert c.get('/test/').status_code == 200
+        c.get('/test/')
-        assert c.get('/test_with_categories/').status_code == 200
+        c.get('/test_with_categories/')
-        assert c.get('/test_filter/').status_code == 200
+        c.get('/test_filter/')
-        assert c.get('/test_filters/').status_code == 200
+        c.get('/test_filters/')
-        assert c.get('/test_filters_without_returning_categories/').status_code == 200
+        c.get('/test_filters_without_returning_categories/')
-        .. versionadded: 0.3
+        .. versionadded:: 0.3
-        .. versionadded: 0.3
+        .. versionadded:: 0.3
-    def run(self, host='127.0.0.1', port=5000, debug=None, **options):
+    def run(self, host=None, port=None, debug=None, **options):
-        :param port: the port of the webserver
+        :param host: the hostname to listen on. Set this to ``'0.0.0.0'`` to
-        {% endwith %}
+    See :ref:`message-flashing-pattern` for examples.
-    .. versionchanged: 0.3
+    .. versionchanged:: 0.3
-    .. versionchanged: 0.9
+    .. versionchanged:: 0.9
-def get_flashed_messages(with_categories=False):
+def get_flashed_messages(with_categories=False, category_filter=[]):
-        @app.route('/test')
+        @app.route('/test/')
-        @app.route('/test_with_categories')
+        @app.route('/test_with_categories/')
-        @app.route('/test_filter')
+        @app.route('/test_filter/')
-        @app.route('/test_filters')
+        @app.route('/test_filters/')
-        @app.route('/test_filters_without_returning_categories')
+        @app.route('/test_filters_without_returning_categories/')
-        c.get('/test')
+        c.get('/')
-        c.get('/test_with_categories')
+        c = app.test_client()
-        c.get('/test_filter')
+        c = app.test_client()
-        c.get('/test_filters')
+        c = app.test_client()
-        c.get('/test_filters_without_returning_categories')
+        c = app.test_client()
-            self.assert_equal(len(messages), 3)
+
-            self.assert_equal(messages[2], flask.Markup(u'<em>Testing</em>'))
+            self.assert_equal(messages[1], flask.Markup(u'<em>Testing</em>'))
-        c.get('/')
+        c.get('/') # Flash some messages.
-            self.jinja_env.filters[name or f.__name__] = f
+            self.add_template_filter(f, name=name)
-        is available for the entire application.
+    def app_template_filter(self, name=None):
-            self.record_once(register_template)
+            self.add_app_template_filter(f, name=name)
-    not this function can be used.  For instance, if you want to take advantage
+    not this function can be used.  For instance, you may want to take advantage
-    object is unavailable.
+    not this function can be used.  For instance, if you want to take advantage
-        assert meth is not None, 'Not implemented method %r' % request.method
+        assert meth is not None, 'Unimplemented method %r' % request.method
-        else:
+        elif hasattr(loader, 'archive'):
-    "Test Flasks are created without __import__."
+    """Test Flasks are created without import.
-        sys.modules['myapp'] = mod
+        here = os.path.abspath(os.path.dirname(__file__))
-                                          'myapp-instance'))
+            import site_app
-            sys.modules['myapp'] = None
+            sys.prefix = real_prefix
-        sys.modules['myapp'] = mod
+        here = os.path.abspath(os.path.dirname(__file__))
-                                          'myapp-instance'))
+            import installed_package
-        sys.modules['myapp'] = mod
+            sys.prefix = real_prefix
-                                          'myapp-instance'))
+            import site_package
-            sys.modules['myapp'] = None
+            sys.prefix = real_prefix
-        sys.modules['myapp'] = mod
+        here = os.path.abspath(os.path.dirname(__file__))
-                                          'myapp-instance'))
+            import site_egg # in SiteEgg.egg
-            sys.modules['myapp'] = None
+            sys.prefix = real_prefix
-    if loader is None:
+    if loader is None or import_name == '__main__':
-    return os.path.dirname(filepath)
+    # For .egg, zipimporter does not have get_filename until Python 2.7.
-        filename = loader.get_filename(root_mod_name)
+    if loader is None or import_name == '__main__':
-    site_parent, site_folder = os.path.split(test_package_path)
+    site_parent, site_folder = os.path.split(package_path)
-    if test_package_path.startswith(py_prefix):
+    if package_path.startswith(py_prefix):
-        # python shell.  It will never be used for production code however
+    loader = pkgutil.get_loader(import_name)
-    if package_path is None:
+    root_mod_name = import_name.split('.')[0]
-        package_path = os.path.dirname(package_path)
+class NoImportsTestCase(FlaskTestCase):
-            ##assert flask.session.get('data') == 'foo'
+            # This support requires a new Werkzeug version
-                return flask.redirect('/redirect')
+                return flask.redirect('/getsession')
-            return 'redirect'
+        @app.route('/getsession')
-            ctx.push()
+            rv = c.get('/getsession')
-            ctx.pop()
+            assert rv.data == 'foo'
-            self.save_session(ctx.session, response)
+        if not self.session_interface.is_null_session(ctx.session):
-       The `_anchor` parameter was added.
+       The `_anchor` and `_method` parameters were added.
-    rv = ctx.url_adapter.build(endpoint, values, force_external=external)
+    rv = ctx.url_adapter.build(endpoint, values, method=method,
-            return DEBUG if app.debug else Logger.getEffectiveLevel(x)
+            if x.level == 0 and app.debug:
-    return ctx.url_adapter.build(endpoint, values, force_external=external)
+    rv = ctx.url_adapter.build(endpoint, values, force_external=external)
-from .sessions import *
+from .sessions import SecureCookieSession, NullSession
-__version__ = '0.8'
+__version__ = '0.8.1-dev'
-    version='0.8',
+    version='0.8.1-dev',
-__version__ = '0.8'
+__version__ = '0.9-dev'
-    version='0.8',
+    version='0.9-dev',
-__version__ = '0.8-dev'
+__version__ = '0.8'
-    version='0.8-dev',
+    version='0.8',
-            print ("Audit finished with total %d warnings." % warns)
+            print "Audit finished with total %d warnings." % warns
-            print ("No problems found in sourcecode.")
+            print "No problems found in sourcecode."
-    _module_choices = ['flask_%s', 'flaskext.%s']
+def setup():
-del _ExtensionImporter
+setup()
-               cls.__name__ == '_ExtensionImporter':
+            if cls.__module__ == 'flask.exthook' and \
-ext_module.__package__ = ext_module.__name__
+class ExtensionImporter(object):
-    prefix_cutoff = prefix.count('.')
+    def __eq__(self, other):
-        for path in self._module_choices:
+        for path in self.module_choices:
-                    raise exc_type, exc_value, tb
+                    raise exc_type, exc_value, tb.tb_next
-                setattr(ext_module, modname, module)
+                setattr(sys.modules[self.wrapper_module], modname, module)
-            if tb.tb_frame.f_globals.get('__name__') == important_module:
+            if self.is_important_frame(important_module, tb):
-    sys.meta_path.append(_ExtensionImporter())
+    ext_module = imp.new_module('flask.ext')
-        self.assert_equal(app.permanent_session_lifetime.total_seconds(), 42)
+        self.assert_equal(app.permanent_session_lifetime.seconds, 42)
-    def __init__(self, name):
+    def __init__(self, name, get_converter=None):
-        return obj.config[self.__name__]
+        rv = obj.config[self.__name__]
-
+    def _get_permanent_session_lifetime(self):
-        :ref:`view-func-options`.
+        Internally :meth:`route` invokes :meth:`add_url_rule` so if you want
-        given URL rule.  Example::
+        given URL rule.  This does the same thing as :meth:`add_url_rule`
-        as well:
+        For more information refer to :ref:`url-route-registrations`.
-        :param methods: a list of methods this rule should be limited
+        :param endpoint: the endpoint for the registered URL rule.  Flask
-                        :class:`~werkzeug.routing.Rule` object.
+        # indicator if the context was preserved.  Next time another context
-        _request_ctx_stack.pop()
+        rv = _request_ctx_stack.pop()
-           (tb is None or not self.app.preserve_context_on_exception):
+        if self.request.environ.get('flask._preserve_context') or \
-    preserve_context = context_preserved = False
+    preserve_context = False
-            self.context_preserved = _request_ctx_stack.top is not old
+        return Client.open(self, builder,
-            self.context_preserved = False
+
-                return 'unknown'
+                return '__main__'
-    """Adds an entry to sys.path_info if it's not already there.  This does
+    """Adds an entry to sys.path if it's not already there.  This does
-    """Adds an entry to sys.path_info if it's not already there."""
+    """Adds an entry to sys.path_info if it's not already there.  This does
-    sys.path.append(path)
+    sys.path[:] = [x for x in sys.path if not _samefile(path, x)]
-                entry.startswith('flaskext.')) and value is not None:
+                entry.startswith('flaskext.') or
-    packages=['flask', 'flask.testsuite'],
+    packages=['flask', 'flask.ext', 'flask.testsuite'],
-    include_package_data = True,
+    include_package_data=True,
-    locations.
+    locations.  For implementation details see the code in Flask 0.8
-        """
+        # Why can we access f_globals' __name__ here and the value is
-        from sys import modules
+        from sys import modules, exc_info
-        raise ImportError(fullname)
+        raise ImportError('No module named %s' % fullname)
-        raise ImportError(fullname)
+        raise ImportError('No module named %s' % fullname)
-    newer flask_name without people having a hard time.
+    """This importer redirects imports from the flask.ext module to other
-        meta_path[:] = [x for x in meta_path if _name(x) != this] + [self]
+    prefix = ext_module.__name__ + '.'
-            return modules[fullname]
+        if fullname in sys.modules:
-            module = modules[fullname] = modules[realname]
+            module = sys.modules[fullname] = sys.modules[realname]
-                setattr(modules[__name__], modname, module)
+                setattr(ext_module, modname, module)
-del _ExtensionImporter, sys, flask
+def activate():
-    def run(self, host='127.0.0.1', port=5000, **options):
+    def run(self, host='127.0.0.1', port=5000, debug=None, **options):
-            self.debug = options.pop('debug')
+        if debug is not None:
-        all = None
+        pass
-        # TODO: Add test subdirectories
+        # Define top-level directories
-                    warns += flakes.checkPath(os.path.join(dir, filename))
+            for root, _, files in os.walk(dir):
-            if entry.startswith('flask.ext.') and value is not None:
+            if (entry.startswith('flask.ext.') or
-            setattr(modules[__name__], modname, module)
+            if '.' not in modname:
-    def test_flaskext_simple_import_normal(self):
+    def test_flaskext_new_simple_import_normal(self):
-    def test_flaskext_simple_import_module(self):
+    def test_flaskext_new_simple_import_module(self):
-    def test_flaskext_package_import_normal(self):
+    def test_flaskext_new_package_import_normal(self):
-    def test_flaskext_package_import_module(self):
+    def test_flaskext_new_package_import_module(self):
-    def test_flaskext_package_import_submodule(self):
+    def test_flaskext_new_package_import_submodule(self):
-    imprt ``from flask_foo import bar`` first and when that fails it will
+    import ``from flask_foo import bar`` first and when that fails it will
-    hard time.
+    """This importer redirects imports from this submodule to other locations.
-    _modules = sys.modules
+
-        if fullname.rsplit('.', 1)[0] == __name__:
+        if fullname.startswith(self.prefix):
-        packname, modname = fullname.rsplit('.', 1)
+        from sys import modules
-            module.__loader__ = self
+            module = modules[fullname] = modules[realname]
-del sys, _ExtensionImporter
+_ExtensionImporter()
-        assert meth is not None, 'Not implemented method'
+        # if the request method is HEAD and we don't have a handler for it
-            .setdefault(self.name, []).append(f))
+        self.record_once(lambda s: s.app.url_value_preprocessors
-        actual view functionc ode.  This method is called with all
+        actual view function code.  This method is called with all
-        the :meth:`create_jinja_loader` function instead.
+        the :meth:`jinja_loader` function instead.
-            endpoint = options.pop("endpoint", None)
+            endpoint = options.pop('endpoint', None)
-            )
+        rv = app.test_client().get('/')
-            )
+        rv = app.test_client().get('/', 'http://localhost.localdomain:5000')
-            )
+        rv = app.test_client().get('/', 'https://localhost.localdomain:5000')
-            )
+        app.config.update(SERVER_NAME='localhost.localdomain')
-            self.assert_equal(rv.data, 'Foo')
+            # Werkzeug 0.8
-            app.test_client().get('/', 'http://foo.localhost')
+            rv = app.test_client().get('/', 'http://foo.localhost')
-            )
+        rv = app.test_client().get('/', 'http://foo.localhost.localdomain')
-    :copyright: (c) 2010 by Armin Ronacher.
+    :copyright: (c) 2011 by Armin Ronacher.
-    :copyright: (c) 2010 by Armin Ronacher.
+    :copyright: (c) 2011 by Armin Ronacher.
-    :copyright: (c) 2010 by Armin Ronacher.
+    :copyright: (c) 2011 by Armin Ronacher.
-    :copyright: (c) 2010 by Armin Ronacher.
+    :copyright: (c) 2011 by Armin Ronacher.
-    :copyright: (c) 2010 by Armin Ronacher.
+    :copyright: (c) 2011 by Armin Ronacher.
-    :copyright: (c) 2010 by Armin Ronacher.
+    :copyright: (c) 2011 by Armin Ronacher.
-    :copyright: (c) 2010 by Armin Ronacher.
+    :copyright: (c) 2011 by Armin Ronacher.
-    :copyright: (c) 2010 by Armin Ronacher.
+    :copyright: (c) 2011 by Armin Ronacher.
-    :copyright: (c) 2010 by Armin Ronacher.
+    :copyright: (c) 2011 by Armin Ronacher.
-    :copyright: (c) 2010 by Armin Ronacher.
+    :copyright: (c) 2011 by Armin Ronacher.
-    :copyright: (c) 2010 by Armin Ronacher.
+    :copyright: (c) 2011 by Armin Ronacher.
-    :copyright: (c) 2010 by Armin Ronacher.
+    :copyright: (c) 2011 by Armin Ronacher.
-    :copyright: (c) 2010 by Armin Ronacher.
+    :copyright: (c) 2011 by Armin Ronacher.
-    :copyright: (c) 2010 by Armin Ronacher.
+    :copyright: (c) 2011 by Armin Ronacher.
-    },
+    include_package_data = True,
-        'SESSION_COOKIE_NAME':                  'session',
+        'SESSION_COOKIE_NAME':                  'session',
-        configuration variable or uses ``/`` if it's `None`.
+        default implementation uses the value from the SESSION_COOKIE_PATH``
-        return app.config['APPLICATION_ROOT'] or '/'
+        return app.config['SESSION_COOKIE_PATH'] or \
-                                expires=expires, httponly=True, domain=domain)
+                                expires=expires, httponly=httponly,
-        environ_overrides = kwargs.pop('environ_overrides', {})
+        environ_overrides = kwargs.setdefault('environ_overrides', {})
-        bp = request.blueprint
+        bp = _request_ctx_stack.top.request.blueprint
-        bp = request.blueprint
+        bp = _request_ctx_stack.top.request.blueprint
-                   'with form data.' % request.method)
+                   'with form data reliably or without user interaction.' %
-        # Support for deprecated functionality.  This is doing away with
+        # XXX: Support for deprecated functionality.  This is doing away with
-        ))
+        self.log_exception((exc_type, exc_value, tb))
-
+    """Yields all testsuites."""
-    setup_paths()
+    """A testsuite that has all the Flask tests.  You can use this
-    print 'Error: %s' % e
+from flask.testsuite import main
-            temporarily_connected_to = _fail
+            temporarily_connected_to = connected_to = _fail
-            pass
+        adapter = _request_ctx_stack.top.url_adapter
-            self.context_preserved = False
+        self._pop_reqctx_if_necessary()
-            _request_ctx_stack.pop()
+            # we have to use _request_ctx_stack.top.pop instead of
-            self.cookie_jar.inject_wsgi(environ_overrides)
+        self.cookie_jar.inject_wsgi(environ_overrides)
-                self.cookie_jar.extract_wsgi(c.request.environ, headers)
+            headers = resp.get_wsgi_headers(c.request.environ)
-            sys.exit(1)
+            raise LookupError('could not find test case for "%s"' % name)
-unittest.main(testLoader=BetterLoader(), defaultTest='suite')
+try:
-    suites = [suite()]
+def find_all_tests(suite):
-        )
+            yield s, '%s.%s.%s' % (
-                    return testcase
+            return root
-            if testname.endswith('.' + name) or ('.' + name + '.') in testname or \
+        for testcase, testname in find_all_tests(root):
-
+from flask.testsuite import BetterLoader
-            if testname.endswith('.' + name) or ('.' + name + '.') in testname:
+            if testname.endswith('.' + name) or ('.' + name + '.') in testname or \
-        all_results = []
+        all_tests = []
-        sys.exit(1)
+            if testname.endswith('.' + name) or ('.' + name + '.') in testname:
-        app.config.from_pyfile(__file__.rsplit('.')[0] + '.py')
+        app.config.from_pyfile(__file__.rsplit('.', 1)[0] + '.py')
-            os.environ = {'FOO_SETTINGS': __file__.rsplit('.')[0] + '.py'}
+            os.environ = {'FOO_SETTINGS': __file__.rsplit('.', 1)[0] + '.py'}
-                self.assert_(os.path.basename(__file__.rsplit('.')[0] + '.py') in out)
+                self.assert_(os.path.basename(__file__.rsplit('.', 1)[0] + '.py') in out)
-    packages=['flask'],
+    packages=['flask', 'flask.testsuite'],
-        assert not rv.data  # head truncates
+        self.assert_(not rv.data) # head truncates
-        assert not rv.data  # head truncates
+        self.assert_(not rv.data) # head truncates
-        assert 'httponly' in rv.headers['set-cookie'].lower()
+        self.assert_('domain=.example.com' in rv.headers['set-cookie'].lower())
-        assert 'httponly' in rv.headers['set-cookie'].lower()
+        self.assert_('domain=.example.com' in rv.headers['set-cookie'].lower())
-        assert 'path=/bar' in rv.headers['set-cookie'].lower()
+        self.assert_('path=/bar' in rv.headers['set-cookie'].lower())
-                assert e.args and 'session is unavailable' in e.args[0]
+                self.assert_(e.args and 'session is unavailable' in e.args[0])
-                assert False, 'expected exception'
+                self.assert_(False, 'expected exception')
-            assert flask.session.get('missing_key') is None
+            self.assert_(flask.session.get('missing_key') is None)
-        assert 'set-cookie' in rv.headers
+        self.assert_('set-cookie' in rv.headers)
-        assert 'set-cookie' in rv.headers
+        self.assert_('set-cookie' in rv.headers)
-        assert match is None
+        self.assert_(match is None)
-            assert not flask.session.modified
+            self.assert_(not flask.session.modified)
-            assert flask.session.modified
+            self.assert_(flask.session.modified)
-            assert 'after' not in evts
+            self.assert_('before' in evts)
-        assert 'after' not in evts
+        self.assert_('after' not in evts)
-        assert 'after' in evts
+        self.assert_('after' in evts)
-        assert 'Response' in rv.data
+        self.assert_('Response' in rv.data)
-        assert 'Response' in rv.data
+        self.assert_('Response' in rv.data)
-        assert 'Internal Server Error' in rv.data
+        self.assert_('Internal Server Error' in rv.data)
-            assert isinstance(e, MyException)
+            self.assert_(isinstance(e, MyException))
-            assert isinstance(e, BadRequest)
+            self.assert_(isinstance(e, BadRequest))
-                assert 'This was submitted: "index.txt"' in str(e)
+                self.assert_('no file contents were transmitted' in str(e))
-                == 'http://localhost/hello/test%20x'
+            self.assert_equal(flask.url_for('hello', name='test x', _external=True),
-                == '/static/index.html'
+            self.assert_equal(flask.url_for('static', filename='index.html'),
-            assert "Expected ValueError"
+            self.assert_("Expected ValueError")
-            assert isinstance(e, ValueError)
+            self.assert_(isinstance(e, ValueError))
-            assert False
+            self.assert_(False)
-            assert False
+            self.assert_(False)
-        assert flask._request_ctx_stack.top is None
+        self.assert_(flask._request_ctx_stack.top is None)
-        assert not flask.has_request_context()
+        self.assert_(not flask.request)
-            assert flask.has_request_context()
+            self.assert_(flask.request)
-            assert 0, 'expected runtime error'
+            self.assert_(0, 'expected runtime error')
-                == '/admin/static/test.txt'
+            self.assert_equal(flask.url_for('admin.static', filename='test.txt'),
-                assert 0, 'expected exception'
+                self.assert_(0, 'expected exception')
-                assert 0, 'expected exception'
+                self.assert_(0, 'expected exception')
-                assert 0, 'expected exception'
+                self.assert_(0, 'expected exception')
-                    assert 0, 'expected exception'
+                    self.assert_(0, 'expected exception')
-                == '/admin/static/test.txt'
+            self.assert_equal(flask.url_for('admin.static', filename='test.txt'),
-                assert 0, 'expected exception'
+                self.assert_(0, 'expected exception')
-        assert 'ConfigTestCase' not in app.config
+        self.assert_('ConfigTestCase' not in app.config)
-                assert "'FOO_SETTINGS' is not set" in str(e)
+                self.assert_("'FOO_SETTINGS' is not set" in str(e))
-            assert not app.config.from_envvar('FOO_SETTINGS', silent=True)
+                self.assert_(0, 'expected exception')
-            assert app.config.from_envvar('FOO_SETTINGS')
+            self.assert_(app.config.from_envvar('FOO_SETTINGS'))
-            assert msg.endswith("missing.cfg'")
+            self.assert_(msg.startswith('[Errno 2] Unable to load configuration '
-        assert not app.config.from_pyfile('missing.cfg', silent=True)
+            self.assert_(0, 'expected config')
-            assert 'init_jinja_globals' in str(log[0]['message'])
+            self.assert_('init_jinja_globals' in str(log[0]['message']))
-            assert rv.direct_passthrough
+            self.assert_(rv.direct_passthrough)
-            assert 'x-sendfile' in rv.headers
+            self.assert_(rv.direct_passthrough)
-                assert 'x-sendfile' in rv.headers
+                self.assert_('x-sendfile' in rv.headers)
-                assert 'x-sendfile' not in rv.headers
+                self.assert_('x-sendfile' not in rv.headers)
-        assert app.logger is logger1
+        self.assert_(app.logger is logger1)
-        assert app.logger is not logger1
+        self.assert_(app.logger is not logger1)
-                assert 'this is a debug statement' in out
+                self.assert_('WARNING in helpers [' in out)
-                    assert False, 'debug log ate the exception'
+                    self.assert_(False, 'debug log ate the exception')
-        assert 'Internal Server Error' in rv.data
+        self.assert_('Internal Server Error' in rv.data)
-        assert 'ZeroDivisionError:' in err
+        self.assert_('Exception on / [GET]' in err)
-            assert isinstance(recorded[0], ZeroDivisionError)
+            self.assert_(isinstance(recorded[0], ZeroDivisionError))
-                == '<test> Mail'
+            self.assert_equal(flask.render_template_string('{{ foo }}',
-        assert 'my_reverse' in  app.jinja_env.filters.keys()
+        self.assert_('my_reverse' in  app.jinja_env.filters.keys())
-        assert 'strrev' in  app.jinja_env.filters.keys()
+        self.assert_('strrev' in  app.jinja_env.filters.keys())
-            assert 'Internal Server Error' in resp.data
+            self.assert_(not hasattr(flask.g, 'value'))
-        assert rv.data == ''
+        self.assert_equal(sorted(rv.allow), ['GET', 'HEAD', 'OPTIONS', 'POST'])
-        assert sorted(rv.allow) == ['GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']
+        self.assert_equal(sorted(rv.allow), ['GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'])
-        assert rv.status_code == 405
+        self.assert_equal(rv.status_code, 405)
-        assert sorted(rv.allow) == ['OPTIONS']
+        self.assert_equal(sorted(rv.allow), ['OPTIONS'])
-        assert c.get('/').data == 'GET'
+        self.assert_equal(c.get('/').data, 'GET')
-        assert sorted(rv.allow) == ['GET', 'HEAD', 'OPTIONS']
+        self.assert_equal(rv.status_code, 405)
-        assert rv.status_code == 200
+        self.assert_equal(rv.status_code, 200)
-        assert c.get('/more').data == 'GET'
+        self.assert_equal(c.post('/more').data, 'POST')
-        assert sorted(rv.allow) == ['GET', 'HEAD', 'OPTIONS', 'POST']
+        self.assert_equal(rv.status_code, 405)
-        assert c.get('/').data == 'GET'
+        self.assert_equal(c.get('/').data, 'GET')
-        assert sorted(rv.allow) == ['GET', 'HEAD', 'OPTIONS']
+        self.assert_equal(rv.status_code, 405)
-        assert rv.status_code == 200
+        self.assert_equal(rv.status_code, 200)
-        assert c.get('/more').data == 'GET'
+        self.assert_equal(c.post('/more').data, 'POST')
-        assert sorted(rv.allow) == ['GET', 'HEAD', 'OPTIONS', 'POST']
+        self.assert_equal(rv.status_code, 405)
-        assert c.get('/foo/bar').data == 'bar'
+        self.assert_equal(c.get('/foo/').data, 'index')
-        assert c.get('/foo/bar').data == 'bar'
+        self.assert_equal(c.get('/foo/').data, 'index')
-        assert c.get('/get').data == '42'
+        self.assert_equal(c.post('/set', data={'value': '42'}).data, 'value set')
-        assert expires.day == expected.day
+        self.assert_equal(expires.year, expected.year)
-        assert rv.data == 'True'
+        self.assert_equal(rv.data, 'True')
-            assert list(flask.get_flashed_messages()) == ['Zap', 'Zip']
+            self.assert_equal(list(flask.get_flashed_messages()), ['Zap', 'Zip'])
-            assert messages[2] == ('warning', flask.Markup(u'<em>Testing</em>'))
+            self.assert_equal(len(messages), 3)
-            assert messages[2] == flask.Markup(u'<em>Testing</em>')
+            self.assert_equal(len(messages), 3)
-        assert rv == 'request|after'
+        self.assert_equal(rv, 'request|after')
-        assert rv.status_code == 200
+        self.assert_equal(rv.status_code, 200)
-        assert len(called) == 1
+        self.assert_equal(len(called), 1)
-        assert rv.status_code == 200
+        self.assert_equal(rv.status_code, 200)
-        assert len(called) == 1
+        self.assert_equal(len(called), 1)
-            assert type(exc) == ZeroDivisionError
+            self.assert_equal(type(exc), ZeroDivisionError)
-            assert type(exc) == ZeroDivisionError
+            self.assert_equal(type(exc), ZeroDivisionError)
-        assert rv.status_code == 500
+        self.assert_equal(rv.status_code, 500)
-        assert len(called) == 2
+        self.assert_equal(len(called), 2)
-        assert called == [1, 2, 3, 4, 5, 6]
+        self.assert_equal(rv.data, '42')
-        assert rv.data == 'not found'
+        self.assert_equal(rv.status_code, 404)
-        assert 'internal server error' == rv.data
+        self.assert_equal(rv.status_code, 500)
-        assert rv.data == 'value'
+        self.assert_equal(rv.status_code, 404)
-        assert c.get('/').data == '42'
+        self.assert_equal(c.get('/').data, '42')
-        assert c.get('/fail').status_code == 400
+        self.assert_equal(c.get('/fail').status_code, 400)
-        assert buffer == []
+        self.assert_equal(buffer, [])
-        assert buffer == [None]
+        self.assert_equal(buffer, [None])
-        assert c.get('/string').data == u'HÃ¤llo WÃ¶rld'.encode('utf-8')
+        self.assert_equal(c.get('/unicode').data, u'HÃ¤llo WÃ¶rld'.encode('utf-8'))
-        assert rv.mimetype == 'text/plain'
+        self.assert_equal(rv.data, 'Meh')
-            assert rv.mimetype == 'text/html'
+            self.assert_equal(rv.status_code, 200)
-            assert rv.mimetype == 'text/html'
+            self.assert_equal(rv.status_code, 200)
-            assert rv.mimetype == 'text/html'
+            self.assert_equal(rv.status_code, 404)
-            assert flask.url_for('hello', name='test x') == '/hello/test%20x'
+            self.assert_equal(flask.url_for('hello', name='test x'), '/hello/test%20x')
-        assert c.get('/1,2,3').data == '1|2|3'
+        self.assert_equal(c.get('/1,2,3').data, '1|2|3')
-        assert rv.data.strip() == '<h1>Hello World!</h1>'
+        self.assert_equal(rv.status_code, 200)
-            assert str(e) == 'View function did not return a response'
+            self.assert_equal(str(e), 'View function did not return a response')
-            assert flask.url_for('index', _external=True) == 'http://localhost.localdomain:5000/'
+            self.assert_equal(flask.url_for('index', _external=True), 'http://localhost.localdomain:5000/')
-            assert flask.url_for('sub', _external=True) == 'http://foo.localhost.localdomain:5000/'
+            self.assert_equal(flask.url_for('sub', _external=True), 'http://foo.localhost.localdomain:5000/')
-            assert str(e) == "the server name provided " + \
+            self.assert_equal(str(e), "the server name provided " +
-                    "server name from the WSGI environment ('localhost')", str(e)
+                    "server name from the WSGI environment ('localhost')")
-            assert rv.data == 'Foo'
+            self.assert_equal(rv.data, 'Foo')
-            assert rv.data == 'Foo'
+            self.assert_equal(rv.data, 'Foo')
-            assert rv.data == 'Foo'
+            self.assert_equal(rv.data, 'Foo')
-            assert rv.data == 'Foo'
+            self.assert_equal(rv.data, 'Foo')
-            assert rv.data == 'Foo'
+            self.assert_equal(rv.data, 'Foo')
-            assert str(e) == "the server name provided " + \
+            self.assert_equal(str(e), "the server name provided " +
-                    "server name from the WSGI environment ('localhost.localdomain')", str(e)
+                    "server name from the WSGI environment ('localhost.localdomain')")
-            assert str(e) == "the server name provided " + \
+            self.assert_equal(str(e), "the server name provided " + \
-                    "server name from the WSGI environment ('foo.localhost')", str(e)
+                    "server name from the WSGI environment ('foo.localhost')")
-            assert rv.data == 'Foo SubDomain'
+            self.assert_equal(rv.data, 'Foo SubDomain')
-                assert c.get('/').status_code == 500
+                self.assert_equal(c.get('/').status_code, 500)
-        assert rv.data == '42'
+        self.assert_equal(rv.data, '42')
-            assert index() == 'Hello World!'
+            self.assert_equal(index(), 'Hello World!')
-            assert meh() == 'http://localhost/meh'
+            self.assert_equal(meh(), 'http://localhost/meh')
-        assert index() == 'Hello World!'
+        self.assert_equal(index(), 'Hello World!')
-        assert rv.data == 'normal index'
+        self.assert_equal(rv.data, 'normal index')
-        assert rv.data == 'test index'
+        self.assert_equal(rv.data, 'test index')
-        assert rv.data.strip() == 'Hello Subdomain'
+        self.assert_equal(rv.data.strip(), 'Hello Subdomain')
-        assert rv.data == 'index for mitsuhiko'
+        self.assert_equal(rv.data, 'index for mitsuhiko')
-        assert rv.data == 'Test'
+        self.assert_equal(rv.data, 'Test')
-        assert rv.data == 'Outside'
+        self.assert_equal(rv.data, 'Outside')
-        assert c.get('/admin/logout').data == 'admin logout'
+        self.assert_equal(c.get('/').data, 'the index')
-        assert rv.data == 'Awesome'
+        self.assert_equal(rv.data, 'Awesome')
-            assert flask.url_for('frontend.index') == '/'
+            self.assert_equal(flask.url_for('frontend.index'), '/')
-        assert catched == ['before-app', 'after-app']
+        self.assert_equal(c.get('/').data, 'the index')
-                           'after-admin', 'after-app']
+        self.assert_equal(c.get('/admin/').data, 'the admin')
-        assert c.get('/admin/').data == '123'
+        self.assert_equal(c.get('/').data, '13')
-        assert app.test_client().get('/admin/').data == '42'
+        self.assert_equal(app.test_client().get('/admin/').data, '42')
-        assert rv.data == 'not found'
+        self.assert_equal(rv.status_code, 404)
-        assert 'internal server error' == rv.data
+        self.assert_equal(rv.status_code, 500)
-        assert rv.data == 'Hello from the Frontend'
+        self.assert_equal(rv.data, 'Hello from the Frontend')
-        assert rv.data == 'Hello from the Admin'
+        self.assert_equal(rv.data, 'Hello from the Admin')
-        assert rv.data == 'Hello from the Admin'
+        self.assert_equal(rv.data, 'Hello from the Admin')
-        assert rv.data.strip() == 'Admin File'
+        self.assert_equal(rv.data.strip(), 'Admin File')
-        assert rv.data.strip() == '/* nested file */'
+        self.assert_equal(rv.data.strip(), '/* nested file */')
-                assert e.name == 'missing.html'
+                self.assert_equal(e.name, 'missing.html')
-            assert flask.render_template('nested/nested.txt') == 'I\'m nested'
+            self.assert_equal(flask.render_template('nested/nested.txt'), 'I\'m nested')
-        assert c.get('/foo/bar').data == 'bar'
+        self.assert_equal(c.get('/foo/').data, 'index')
-        assert c.get('/what-is-a-sideend').data == 'application itself says no'
+        self.assert_equal(c.get('/frontend-no').data, 'frontend says no')
-        assert rv.data == 'Hello from the Frontend'
+        self.assert_equal(rv.data, 'Hello from the Frontend')
-        assert rv.data == 'Hello from the Admin'
+        self.assert_equal(rv.data, 'Hello from the Admin')
-        assert rv.data == 'Hello from the Admin'
+        self.assert_equal(rv.data, 'Hello from the Admin')
-        assert rv.data.strip() == 'Admin File'
+        self.assert_equal(rv.data.strip(), 'Admin File')
-        assert rv.data.strip() == '/* nested file */'
+        self.assert_equal(rv.data.strip(), '/* nested file */')
-                assert e.name == 'missing.html'
+                self.assert_equal(e.name, 'missing.html')
-            assert flask.render_template('nested/nested.txt') == 'I\'m nested'
+            self.assert_equal(flask.render_template('nested/nested.txt'), 'I\'m nested')
-        assert app.config['TEST_KEY'] == 'foo'
+        self.assert_equal(app.secret_key, 'devkey')
-            assert len(log) == 1
+            self.assert_equal(c.get('/').data, '42')
-        assert resp.data == u'HÃ¤llo WÃ¶rld'.encode('utf-8')
+        self.assert_equal(resp.data, u'HÃ¤llo WÃ¶rld'.encode('utf-8'))
-            assert flask.json.loads(rv.data) == d
+            self.assert_equal(rv.mimetype, 'application/json')
-        assert rv.data == '3'
+        self.assert_equal(rv.data, '3')
-            assert rv == '"<\\/script>"'
+            self.assert_equal(rv, '"<\\/script>"')
-            assert rv == '"<\\u0000\\/script>"'
+            self.assert_equal(rv, '"<\\u0000\\/script>"')
-        assert rv.data == u'ì ìì²ë¦¬'.encode('utf-8')
+        self.assert_equal(rv.status_code, 200)
-            assert rv.mimetype == 'text/html'
+            self.assert_equal(rv.mimetype, 'text/html')
-                assert rv.data == f.read()
+                self.assert_equal(rv.data, f.read())
-            assert rv.mimetype == 'text/html'
+            self.assert_equal(rv.headers['x-sendfile'],
-                assert rv.mimetype == 'text/html'
+                    self.assert_equal(rv.data, f.read())
-            assert len(captured) == 2
+            self.assert_equal(len(captured), 2)
-                assert rv.mimetype == 'text/html'
+                self.assert_equal(rv.mimetype, 'text/html')
-                    os.path.join(app.root_path, 'static/index.html')
+                self.assert_equal(rv.headers['x-sendfile'],
-            assert len(captured) == 2
+            self.assert_equal(len(captured), 2)
-                assert rv.mimetype == 'application/octet-stream'
+                self.assert_equal(rv.data, 'Test')
-            assert len(captured) == 1
+            self.assert_equal(len(captured), 1)
-                assert rv.mimetype == 'text/plain'
+                self.assert_equal(rv.data, 'Test')
-            assert len(captured) == 1
+            self.assert_equal(len(captured), 1)
-            assert len(captured) == 1
+            self.assert_equal(len(captured), 1)
-                assert value == 'attachment'
+                self.assert_equal(value, 'attachment')
-            assert len(captured) == 2
+            self.assert_equal(len(captured), 2)
-            assert options['filename'] == 'index.html'
+            self.assert_equal(options['filename'], 'index.html')
-            assert options['filename'] == 'index.html'
+            self.assert_equal(value, 'attachment')
-            assert rv.mimetype == 'text/plain'
+            self.assert_equal(rv.mimetype, 'text/plain')
-            assert options['filename'] == 'index.txt'
+            self.assert_equal(value, 'attachment')
-        assert logger1.name == __name__
+        self.assert_equal(logger1.name, __name__)
-        assert rv.status_code == 500
+        self.assert_equal(rv.status_code, 500)
-            assert rv.data == 'Hello Server Error'
+            self.assert_equal(rv.status_code, 500)
-            assert len(recorded) == 1
+            self.assert_equal(len(recorded), 1)
-            assert context['whiskey'] == 42
+            self.assert_equal(template.name, 'simple_template.html')
-            assert response.data == 'stuff'
+            self.assert_equal(response.data, 'stuff')
-            assert rv.data == 'stuff'
+            self.assert_equal(rv.data, 'stuff')
-            assert calls == ['before-signal', 'before-handler',
+            self.assert_equal(calls, ['before-signal', 'before-handler',
-                             'after-signal']
+                             'after-signal'])
-            assert len(recorded) == 1
+            self.assert_equal(app.test_client().get('/').status_code, 500)
-        assert rv.data == '<p>23|42'
+        self.assert_equal(rv.data, '<p>23|42')
-        assert rv.data == '42'
+        self.assert_equal(rv.data, '42')
-        assert rv.data.split() == ['42', '23', 'False', 'aha']
+        self.assert_equal(rv.data.split(), ['42', '23', 'False', 'aha'])
-        assert lines == [
+        self.assert_equal(lines, [
-        ]
+        ])
-            assert macro('World') == 'Hello World!'
+            self.assert_equal(macro('World'), 'Hello World!')
-        assert app.jinja_env.filters['my_reverse']('abcd') == 'dcba'
+        self.assert_equal(app.jinja_env.filters['my_reverse'], my_reverse)
-        assert app.jinja_env.filters['strrev']('abcd') == 'dcba'
+        self.assert_equal(app.jinja_env.filters['strrev'], my_reverse)
-        assert rv.data == 'dcba'
+        self.assert_equal(rv.data, 'dcba')
-        assert rv.data == 'dcba'
+        self.assert_equal(rv.data, 'dcba')
-        assert rv.data == 'Hello Custom World!'
+        self.assert_equal(rv.data, 'Hello Custom World!')
-            assert resp.status_code == 200
+            self.assert_equal(flask.g.value, 42)
-            assert resp.status_code == 500
+            self.assert_equal(resp.status_code, 500)
-    test_suite='__main__.run_tests'
+    test_suite='flask.testsuite.suite'
-    unittest.main(defaultTest='suite')
+
-    g.db.close()
+    if hasattr(g, 'db'):
-    g.db.close()
+    if hasattr(g, 'db'):
-
+    def test_test_client_context_binding(self):
-        See :class:`~flask.testing.TestClient` for more information.
+        See :class:`~flask.testing.FlaskClient` for more information.
-        return self.request_context(create_environ(*args, **kwargs))
+        from flask.testing import make_test_environ_builder
-                    builder.host = http_host
+    def test_environ_defaults_from_config(self):
-    pass
+
-                assert False, 'debug log ate the exception'
+        with app.test_client() as c:
-class ContextTestCase(unittest.TestCase):
+class FlaskTestCase(unittest.TestCase):
-class BasicFunctionalityTestCase(unittest.TestCase):
+class BasicFunctionalityTestCase(FlaskTestCase):
-class TestToolsTestCase(unittest.TestCase):
+class TestToolsTestCase(FlaskTestCase):
-class InstanceTestCase(unittest.TestCase):
+class InstanceTestCase(FlaskTestCase):
-class JSONTestCase(unittest.TestCase):
+class JSONTestCase(FlaskTestCase):
-class TemplatingTestCase(unittest.TestCase):
+class TemplatingTestCase(FlaskTestCase):
-class ModuleTestCase(unittest.TestCase):
+class ModuleTestCase(FlaskTestCase):
-class BlueprintTestCase(unittest.TestCase):
+class BlueprintTestCase(FlaskTestCase):
-class SendfileTestCase(unittest.TestCase):
+class SendfileTestCase(FlaskTestCase):
-class LoggingTestCase(unittest.TestCase):
+class LoggingTestCase(FlaskTestCase):
-class ConfigTestCase(unittest.TestCase):
+class ConfigTestCase(FlaskTestCase):
-class SubdomainTestCase(unittest.TestCase):
+class SubdomainTestCase(FlaskTestCase):
-class TestSignals(unittest.TestCase):
+class TestSignals(FlaskTestCase):
-class ViewTestCase(unittest.TestCase):
+class ViewTestCase(FlaskTestCase):
-class DeprecationsTestCase(unittest.TestCase):
+class DeprecationsTestCase(FlaskTestCase):
-    in a with statement.
+    """Works like a regular Werkzeug test client but has some knowledge about
-            response.delete_cookie(app.session_cookie_name,
+            response.delete_cookie(app.session_cookie_name, path=path,
-            session.save_cookie(response, app.session_cookie_name,
+            session.save_cookie(response, app.session_cookie_name, path=path,
-            self.add_url_rule(rule, None, f, **options)
+            endpoint = options.pop("endpoint", None)
-            self.add_url_rule(rule, f.__name__, f, **options)
+            endpoint = options.pop("endpoint", f.__name__)
-    #: .. versionadded:: 0.7
+    #: .. versionadded:: 0.8
-    def test_uninstalled_module_paths(self):
+    def test_explicit_instance_paths(self):
-
+        app = flask.Flask(__name__, instance_path=here)
-def get_root_path(name):
+def get_root_path(import_name):
-    except (KeyError, AttributeError):
+        directory = os.path.dirname(sys.modules[import_name].__file__)
-    module as a tuple.
+    module as a tuple.  The package path returned is the module that would
-    """Returns the path to a package or cwd if that cannot be found."""
+def get_root_path(name):
-        self.root_path = get_package_path(self.import_name)
+        self.root_path = get_root_path(self.import_name)
-    locked_cached_property, _tojson_filter, _endpoint_from_view_func
+    locked_cached_property, _tojson_filter, _endpoint_from_view_func, \
-        else:
+        prefix, package_path = find_package(self.import_name)
-        return os.path.join(base_dir, 'share', self.name + '-instance')
+        return os.path.join(prefix, 'var', self.name + '-instance')
-                             os.path.join(expected_prefix, 'share',
+                             os.path.join(expected_prefix, 'var',
-                             os.path.join(expected_prefix, 'share',
+                             os.path.join(expected_prefix, 'var',
-                             os.path.join(expected_prefix, 'share',
+                             os.path.join(expected_prefix, 'var',
-                             os.path.join(expected_prefix, 'share',
+                             os.path.join(expected_prefix, 'var',
-        site_parent, site_folder = os.path.split(package_path)
+        # leave the egg wrapper folder or the actual .egg on the filesystem
-        mod.__file__ = os.path.join(expected_prefix, 'lib',
+        mod.__file__ = os.path.join(expected_prefix, 'lib', 'python2.5',
-        package_path = os.path.join(expected_prefix, 'lib',
+        package_path = os.path.join(expected_prefix, 'lib', 'python2.5',
-        package_path = os.path.join(expected_prefix, 'lib',
+        package_path = os.path.join(expected_prefix, 'lib', 'python2.5',
-        instance_path = None
+        # we're not using root_mod.__file__ here since the module could be
-            instance_path = os.path.join(package_dir, os.path.pardir)
+            package_path = os.path.dirname(package_path)
-        return os.path.join(basedir, 'instance')
+            return os.path.join(package_path, 'instance')
-def _get_package_path(name):
+def get_package_path(name):
-        self.root_path = _get_package_path(self.import_name)
+        self.root_path = get_package_path(self.import_name)
-    def test_basic_instance_paths(self):
+
-    def open_resource(self, resource):
+    def open_resource(self, resource, mode='rb'):
-        return open(os.path.join(self.root_path, resource), 'rb')
+        if mode not in ('r', 'rb'):
-       The `static_path` parameter was added.
+    .. versionadded:: 0.7
-                        *from*.
+    :param static_url_path: can be used to specify a different path for the
-                 static_folder='static', template_folder='templates'):
+                 static_folder='static', template_folder='templates',
-        self.config = Config(self.root_path, self.default_config)
+        self.config = self.make_config(instance_relative_config)
-        parsed JSON data.
+        parsed JSON data.  Otherwise this will be `None`.
-from werkzeug.routing import Map, Rule
+from werkzeug.routing import Map, Rule, RequestRedirect
-            raise req.routing_exception
+            self.raise_routing_exception(req)
-            return json.loads(self.data)
+            try:
-        'TRAP_BAD_REQUEST_KEY_ERRORS':          False,
+        'TRAP_BAD_REQUEST_ERRORS':              False,
-        key error if ``TRAP_BAD_REQUEST_KEY_ERRORS`` is set to `True`.  It
+        key error if ``TRAP_BAD_REQUEST_ERRORS`` is set to `True`.  It
-            return isinstance(e, BadRequest) and isinstance(e, LookupError)
+        if self.config['TRAP_BAD_REQUEST_ERRORS']:
-        app.config['TRAP_BAD_REQUEST_KEY_ERRORS'] = True
+        app.config['TRAP_BAD_REQUEST_ERRORS'] = True
-                   .replace('rd ', ' ').replace('st ', ' ')
+    string = _date_clean_re.sub(r'\1', string)
-extensions = ['sphinx.ext.autodoc', 'sphinx.ext.intersphinx']
+extensions = ['sphinx.ext.autodoc', 'sphinx.ext.intersphinx',
-        #: Prepare the deferred setup of the logger.
+        # Prepare the deferred setup of the logger.
-        .. versionadded:: 0.8
+        :internal:
-        return run_simple(host, port, self, **options)
+        try:
-        self._got_first_request = True
+        self.try_trigger_before_first_request_functions()
-def make_enctype_error_multidict(request):
+def attach_enctype_error_multidict(request):
-from .debughelpers import make_enctype_error_multidict
+from .debughelpers import attach_enctype_error_multidict
-            make_enctype_error_multidict(self)
+            attach_enctype_error_multidict(self)
-        self.msg = ''.join(buf)
+        self.msg = ''.join(buf).encode('utf-8')
-           self.mimetype != 'multipart/form-data':
+           self.mimetype != 'multipart/form-data' and not self.files:
-                       'submitted: %s' % ', '.join('"%s"' % x
+            buf.append('\n\nThe browser instead transmitted some file names. '
-               'to provide enctype="multipart/form-data" in your form.' %
+               'file contents were transmitted.  To fix this error you should '
-                       ', '.join('"%s"' % x for x in form_matches))
+            buf.append('\n\nThe browser instead some file names.  This was '
-            return j
+                return json.loads(self.data, encoding=request_charset)
-     MethodNotAllowed
+     MethodNotAllowed, BadRequest
-        'MAX_CONTENT_LENGTH':                   None
+        'MAX_CONTENT_LENGTH':                   None,
-
+        # ensure not to trash sys.exc_info() at that point in case someone
-from werkzeug.exceptions import NotFound
+from werkzeug.exceptions import NotFound, BadRequest
-                        for more information.
+                        Werkzeug server.  See
-        :func:`werkzeug.create_environ` for more information, this
+        :func:`werkzeug.test.EnvironBuilder` for more information, this
-    :raises: :class:`~werkzeug.exceptions.NotFound` if the retsulting path
+    :raises: :class:`~werkzeug.exceptions.NotFound` if the resulting path
-           :class:~`werkzeug.exceptions.HTTPException` class.
+           :class:`~werkzeug.exceptions.HTTPException` class.
-                    if not blueprint_is_module(blueprint):
+                    if blueprint_is_module(blueprint):
-from moduleapp.apps.frontend import frontend
+from blueprintapp.apps.admin import admin
-admin = Blueprint(__name__, url_prefix='/admin')
+admin = Blueprint('admin', __name__, url_prefix='/admin',
-frontend = Blueprint(__name__)
+frontend = Blueprint('frontend', __name__, template_folder='templates')
-from werkzeug import abort, redirect
+from werkzeug.exceptions import abort
-from werkzeug import ImmutableDict
+from werkzeug.datastructures import ImmutableDict
-        from werkzeug import run_simple
+        from werkzeug.serving import run_simple
-        from werkzeug import create_environ
+        from werkzeug.test import create_environ
-from werkzeug import import_string
+from werkzeug.utils import import_string
-from werkzeug import LocalStack, LocalProxy
+from werkzeug.local import LocalStack, LocalProxy
-from werkzeug import Headers, wrap_file
+from werkzeug.datastructures import Headers
-from werkzeug import Client, EnvironBuilder
+from werkzeug.test import Client, EnvironBuilder
-    cached_property
+from werkzeug.wrappers import Request as RequestBase, Response as ResponseBase
-            provide_automatic_options = True
+
-        pick up SQL queries in `yourapplicaiton.app` and not
+        pick up SQL queries in `yourapplication.app` and not
-    #: The testing flask.  Set this to `True` to enable the test mode of
+    #: The testing flag.  Set this to `True` to enable the test mode of
-from datetime import timedelta, datetime
+from datetime import timedelta
-                            expires=expires, httponly=True, domain=domain)
+        if session.modified and not session:
-                                expires=expires, httponly=True, domain=domain)
+        if not session:
-    .. versionadded:: 0.7
+    .. versionadded:: 0.8
-    #: not necessarily guaranteed.  Use with caution.
+    #: not necessarily guaranteed.  Use with caution.  The default mixin
-from .session import Session, _NullSession
+from .sessions import SecureCookieSessionInterface
-        :attr:`secret_key` is set.
+        :attr:`secret_key` is set.  Instead of overriding this method
-                                       secret_key=key)
+        return self.session_interface.open_session(self, request)
-        implementation, check :meth:`open_session`.
+        implementation, check :meth:`open_session`.  Instead of overriding this
-                            expires=expires, httponly=True, domain=domain)
+        return self.session_interface.save_session(self, session, response)
-        if not isinstance(ctx.session, _NullSession):
+        if not self.session_interface.is_null_session(ctx.session):
-            self.session = _NullSession()
+            self.session = self.app.make_null_session()
-    system.
+    This module used to flask with the session global so we moved it
-from werkzeug.contrib.securecookie import SecureCookie
+from warnings import warn
-    del _fail
+Session = SecureCookieSession
-__version__ = '0.7.1-dev'
+__version__ = '0.8-dev'
-    version='0.7.1-dev',
+    version='0.8-dev',
-        self.url_defaults = dict(self.blueprint.url_defaults)
+        self.url_defaults = dict(self.blueprint.url_values_defaults)
-        self.url_defaults = url_defaults
+        self.url_values_defaults = url_defaults
-                             r'(?:, codename (.*))?(?i)', change_info)
+            match = re.search(r'released on (\w+\s+\d+\w+\s+\d+)'
-            match = re.match(r'^released on (\w+\s+\d+\w+\s+\d+)'
+            match = re.match(r'released on (\w+\s+\d+\w+\s+\d+)'
-__version__ = '0.8-dev'
+__version__ = '0.7.1-dev'
-    version='0.8-dev',
+    version='0.7.1-dev',
-    Popen([sys.executable, 'setup.py', 'sdist', 'release']).wait()
+    Popen([sys.executable, 'setup.py', 'release', 'sdist', 'upload']).wait()
-__version__ = '0.7'
+__version__ = '0.8-dev'
-    version='0.7',
+    version='0.8-dev',
-__version__ = '0.7-dev'
+__version__ = '0.7'
-    version='0.7-dev',
+    version='0.7',
-            self = cls(*class_args, **class_kwargs)
+            self = view.view_class(*class_args, **class_kwargs)
-            methods = []
+        if 'methods' not in d:
-                    methods.append(key.upper())
+                    methods.add(key.upper())
-                rv.methods = methods
+                rv.methods = sorted(methods)
-                '%r.  Both share the same name "%s"' % \
+                '%r.  Both share the same name "%s".  Blueprints that ' \
-        methods = options.pop('methods', ('GET',))
+        methods = options.pop('methods', None)
-
+# -*- coding: utf-8 -*-
-            domain = '.' + self.config['SERVER_NAME']
+            # chop of the port which is usually not supported by browsers
-    is `None`, the whole pair is skipped.
+    is `None`, the whole pair is skipped.  In case blueprints are active
-            return self.url_rule.endpoint.split('.', 1)[0]
+            return self.url_rule.endpoint.rsplit('.', 1)[0]
-_mod_route_re = re.compile(r'([a-zA-Z0-9_][a-zA-Z0-9_]*)\.route')
+_mod_route_re = re.compile(r'@([a-zA-Z0-9_][a-zA-Z0-9_]*)\.route')
-
+def fix_url_for(contents, module_declarations=None):
-    return new_contents
+    return new_contents, dict(modules_declared)
-    new_contents = fix_url_for(contents)
+    new_contents = contents
-    new_contents = rewrite_for_blueprints(new_contents, filename)
+    new_contents, modules = rewrite_for_blueprints(new_contents, filename)
-    new_contents = fix_url_for(contents)
+    new_contents = fix_url_for(contents, None)
-from flask import Flask, Module, render_template
+from flask import Flask, Module, render_template, url_for
-__version__ = '0.7'
+__version__ = '0.7-dev'
-    version='0.7',
+    version='0.7-dev',
-            self.request.routing_exception = e
+        self.match_request()
-        rule = Rule(rule, methods=methods, **options)
+        rule = self.url_rule_class(rule, methods=methods, **options)
-    application.
+    application.  An instance of this class is created by the
-    """Represents a blueprint.
+    """Represents a blueprint.  A blueprint is an object that records
-def rewrite_for_blueprints(contents, filename, template_bundles=False):
+def rewrite_for_blueprints(contents, filename):
-def upgrade_python_file(filename, contents, teardown, template_bundles):
+def upgrade_python_file(filename, contents, teardown):
-                                          template_bundles)
+    new_contents = rewrite_for_blueprints(new_contents, filename)
-def scan_path(path=None, teardown=True, template_bundles=True):
+def scan_path(path=None, teardown=True):
-                                template_bundles)
+            upgrade_python_file(filename, contents, teardown)
-                  template_bundles=template_bundles)
+        scan_path(path, teardown=not options.no_teardown)
-        app.debug = True
+        app.testing = True
-        app.debug = True
+        app.testing = True
-        app.debug = True
+        app.testing = True
-import os
+        self.url_defaults = dict(self.blueprint.url_defaults)
-                              view_func, **options)
+                              view_func, defaults=defaults, **options)
-                 url_prefix=None, subdomain=None):
+                 url_prefix=None, subdomain=None, url_defaults=None):
-        override just the loader and keeping the rest unchanged.
+        override just the loader and keeping the rest unchanged.  It's
-        _PackageBoundObject.__init__(self, import_name)
+                 static_folder='static', template_folder='templates'):
-    def create_jinja_loader(self):
+    def create_global_jinja_loader(self):
-        _PackageBoundObject.__init__(self, import_name)
+                 static_url_path=None, template_folder=None,
-    def __init__(self, import_name):
+    def __init__(self, import_name, template_folder=None):
-                                   filename)
+        return send_from_directory(self.static_folder, filename)
-                           subdomain=subdomain)
+                           subdomain=subdomain, template_folder='templates')
-            options['loader'] = app.create_jinja_loader()
+            options['loader'] = app.create_global_jinja_loader()
-    the module folders.
+    the blueprint folders.
-                return loader.get_source(environment, local_template)
+        for loader, local_name in self._iter_loaders(template):
-        loader = None
+    def _iter_loaders(self, template):
-            module, name = posixpath.normpath(template).split('/', 1)
+            module, local_name = posixpath.normpath(template).split('/', 1)
-        except TemplateNotFound:
+                if loader is not None:
-        return self.app.jinja_loader.get_source(environment, template)
+        for blueprint in self.app.blueprints.itervalues():
-                    result.add('%s/%s' % (name, template))
+        result = set()
-                    result.add('%s:%s' % (name, template))
+            loader = blueprint.jinja_loader
-            def create_jinja_loader(self):
+            def create_global_jinja_loader(self):
-        :func:`url_for` function is prefixed with the name of the module.
+        """Like :meth:`Flask.route` but for a blueprint.  The endpoint for the
-        the :func:`url_for` function is prefixed with the name of the module.
+        """Like :meth:`Flask.add_url_rule` but for a blueprint.  The endpoint for
-        prefix the endpoint with the module name, this has to be done
+        """Like :meth:`Flask.endpoint` but for a blueprint.  This does not
-        """Like :meth:`Flask.before_request` but for a module.  This function
+        """Like :meth:`Flask.before_request` but for a blueprint.  This function
-        that module.
+        that blueprint.
-        before each request, even if outside of a module.
+        before each request, even if outside of a blueprint.
-        """Like :meth:`Flask.after_request` but for a module.  This function
+        """Like :meth:`Flask.after_request` but for a blueprint.  This function
-        that module.
+        that blueprint.
-        is executed after each request, even if outside of the module.
+        """Like :meth:`Flask.after_request` but for a blueprint.  Such a function
-        function is only executed for requests handled by a module.
+        """Like :meth:`Flask.context_processor` but for a blueprint.  This
-        function is executed each request, even if outside of the module.
+        """Like :meth:`Flask.context_processor` but for a blueprint.  Such a
-        handler is used for all requests, even if outside of the module.
+        """Like :meth:`Flask.errorhandler` but for a blueprint.  This
-        """Callback function for URL defaults for this module.  It's called
+        """Callback function for URL defaults for this blueprint.  It's called
-    def _record(self, func):
+    def record(self, func):
-    def _record_once(self, func):
+    def record_once(self, func):
-        return self._record(update_wrapper(wrapper, func))
+        return self.record(update_wrapper(wrapper, func))
-        self._record(lambda s:
+        self.record(lambda s:
-            self._record_once(register_endpoint)
+            self.record_once(register_endpoint)
-        self._record_once(lambda s: s.app.before_request_funcs
+        self.record_once(lambda s: s.app.before_request_funcs
-        self._record_once(lambda s: s.app.before_request_funcs
+        self.record_once(lambda s: s.app.before_request_funcs
-        self._record_once(lambda s: s.app.after_request_funcs
+        self.record_once(lambda s: s.app.after_request_funcs
-        self._record_once(lambda s: s.app.after_request_funcs
+        self.record_once(lambda s: s.app.after_request_funcs
-        self._record_once(lambda s: s.app.template_context_processors
+        self.record_once(lambda s: s.app.template_context_processors
-        self._record_once(lambda s: s.app.template_context_processors
+        self.record_once(lambda s: s.app.template_context_processors
-            self._record_once(lambda s: s.app.errorhandler(code)(f))
+            self.record_once(lambda s: s.app.errorhandler(code)(f))
-        self._record_once(lambda s: s.app.url_value_preprocessors
+        self.record_once(lambda s: s.app.url_value_preprocessors
-        self._record_once(lambda s: s.app.url_default_functions
+        self.record_once(lambda s: s.app.url_default_functions
-        self._record_once(lambda s: s.app.url_value_preprocessor
+        self.record_once(lambda s: s.app.url_value_preprocessor
-        self._record_once(lambda s: s.app.url_default_functions
+        self.record_once(lambda s: s.app.url_default_functions
-            self._record_once(lambda s: s.app._register_error_handler(
+            self.record_once(lambda s: s.app._register_error_handler(
-from flask import Flask, Module
+from flask import Flask, Module, render_template
-def index():
+def mod2_index():
-def index():
+@mod3.route('/')
-                                    r'\(__name__\s*(?:,\s*(%s))?' %
+                                    r'\(__name__\s*(?:,\s*(?:name\s*=\s*)?(%s))?' %
-_from_import_re = re.compile(r'^\s*from flask import\s+')
+_app_re_part = r'((?:[a-zA-Z_][a-zA-Z0-9_]*app)|app|application)'
-    (re.compile(r'(app|application)\.modules'), '\\1.blueprints')
+    (re.compile(r'%s\.modules' % _app_re_part), '\\1.blueprints')
-    parser = OptionParser()
+    parser = OptionParser(usage='%prog [options] [paths]')
-            else:
+            # skip files that are diffs.  These might be false positives
-                    contents = f.read()
+                    contents = f.read(TEMPLATE_LOOKAHEAD)
-
+    if ast is None:
-    (re.compile(r'app\.modules'), 'app.blueprints')
+    (re.compile(r'(app|application)\.modules'), '\\1.blueprints')
-    (re.compile(r'register_module'), 'register_blueprint')
+    (re.compile(r'register_module'), 'register_blueprint'),
-_module_constructor_re = re.compile(r'Module\(__name__\s*(?:,\s*(%s))?' %
+_module_constructor_re = re.compile(r'([a-zA-Z0-9_][a-zA-Z0-9_]*)\s*=\s*Module'
-    found_constructor = []
+def rewrite_render_template_calls(contents, module_declarations):
-        name_param = match.group(1)
+        target = match.group(1)
-        return 'Blueprint(%s, __name__' % name_param
+            modname = get_module_autoname(filename)
-    if found_constructor:
+    if modules_declared:
-def upgrade_python_file(filename, contents, teardown):
+def upgrade_python_file(filename, contents, teardown, template_bundles):
-    new_contents = rewrite_for_blueprints(new_contents, filename)
+    new_contents = rewrite_for_blueprints(new_contents, filename,
-def scan_path(path=None, teardown=True):
+def walk_path(path):
-                upgrade_template_file(filename, contents)
+                yield filename, 'python'
-        scan_path(path, teardown=not options.no_teardown)
+        scan_path(path, teardown=not options.no_teardown,
-        new_file.append(_direct_module_usage_re.sub('flask.Blueprint', line))
+        else:
-        new_contents = fix_teardown_funcs(contents)
+        new_contents = fix_teardown_funcs(new_contents)
-            endpoint = request.blueprint + endpoint
+            if blueprint_name is not None:
-                endpoint = mod + '.' + endpoint
+            if blueprint_name is not None:
-        #: should handle that error.
+        # support for the now deprecated `error_handlers` attribute.  The
-        self.error_handlers = {}
+        self.error_handler_spec = {None: self._error_handlers}
-    def errorhandler(self, code):
+    def errorhandler(self, code_or_exception):
-            app.error_handlers[404] = page_not_found
+            app.error_handler_spec[None][404] = page_not_found
-            self.error_handlers[code] = f
+            self._register_error_handler(None, code_or_exception, f)
-        handler = self.error_handlers.get(e.code)
+        handlers = self.error_handler_spec.get(request.blueprint)
-        handler = self.error_handlers.get(500)
+        handler = self.error_handler_spec[None].get(500)
-            rv = self.handle_http_exception(e)
+        except Exception, e:
-        explicitly by the user of this method.
+        explicitly by the user of this method.  If the endpoint is prefixed
-            adler32(filename) & 0xffffffff
+            adler32(
-            func(request.endpoint, request.values)
+            func(request.endpoint, request.view_args)
-        funcs = self.before_request_funcs.get(None, ())
+
-        blueprint.register(self, options)
+            first_registration = True
-    def __init__(self, blueprint, app, options):
+    def __init__(self, blueprint, app, options, first_registration):
-        return BlueprintSetupState(self, app, options)
+    def _record_once(self, func):
-    def register(self, app, options):
+    def make_setup_state(self, app, options, first_registration=False):
-        state = self.make_setup_state(app, options)
+        state = self.make_setup_state(app, options, first_registration)
-        self._record(register_rule)
+        self._record(lambda s:
-            self._record(register_endpoint)
+            self._record_once(register_endpoint)
-        self._record(lambda s: s.app.before_request_funcs
+        self._record_once(lambda s: s.app.before_request_funcs
-        self._record(lambda s: s.app.before_request_funcs
+        self._record_once(lambda s: s.app.before_request_funcs
-        self._record(lambda s: s.app.after_request_funcs
+        self._record_once(lambda s: s.app.after_request_funcs
-        self._record(lambda s: s.app.after_request_funcs
+        self._record_once(lambda s: s.app.after_request_funcs
-        self._record(lambda s: s.app.template_context_processors
+        self._record_once(lambda s: s.app.template_context_processors
-        self._record(lambda s: s.app.template_context_processors
+        self._record_once(lambda s: s.app.template_context_processors
-            self._record(lambda s: s.app.errorhandler(code)(f))
+            self._record_once(lambda s: s.app.errorhandler(code)(f))
-from .module import _ModuleSetupState
+from .module import blueprint_is_module
-    def __init__(self, import_name, static_path=None):
+    def __init__(self, import_name, static_path=None, static_url_path=None,
-            self.static_path = static_path
+            from warnings import warn
-        #: the module this function is active for, `None` for all requests.
+        #: the blueprint this function is active for, `None` for all requests.
-        #: each request.  The key of the dictionary is the name of the module
+        #: each request.  The key of the dictionary is the name of the blueprint
-        #: dictionary is the name of the module this function is active for,
+        #: dictionary is the name of the blueprint this function is active for,
-        #: name of the module this function is active for, `None` for all
+        #: name of the blueprint this function is active for, `None` for all
-                          view_func=self.send_static_file)
+        if self.has_static_folder:
-            funcs = chain(funcs, self.template_context_processors[mod])
+        bp = _request_ctx_stack.top.request.blueprint
-            func(state)
+        self.register_blueprint(module, **options)
-            funcs = chain(funcs, self.before_request_funcs[mod])
+        bp = request.blueprint
-        mod = ctx.request.module
+        bp = ctx.request.blueprint
-            funcs = reversed(self.after_request_funcs[mod])
+        if bp is not None and bp in self.after_request_funcs:
-            funcs = chain(funcs, reversed(self.teardown_request_funcs[mod]))
+        bp = request.blueprint
-        endpoint = endpoint[1:]
+    if not ctx.request._is_old_module:
-        return os.path.isdir(os.path.join(self.root_path, 'static'))
+        return self.static_folder is not None
-        return FileSystemLoader(os.path.join(self.root_path, 'templates'))
+        if self.template_folder is not None:
-    And here's an example view module (`myapplication/views/admin.py`)::
+import os
-            pass
+from .helpers import _PackageBoundObject, _endpoint_from_view_func
-    :ref:`working-with-modules` section.
+def blueprint_is_module(bp):
-       The `subdomain` parameter was added.
+class Module(Blueprint):
-                        *from*.
+    .. versionchanged:: 0.7
-        return decorator
+        Blueprint.__init__(self, name, import_name, url_prefix=url_prefix,
-        self._register_events.append(func)
+        if os.path.isdir(os.path.join(self.root_path, 'static')):
-            loader = self.app.modules[module].jinja_loader
+            blueprint = self.app.blueprints[module]
-            return self.url_rule.endpoint.rsplit('.', 1)[0]
+        """The name of the current module if the request was dispatched
-            return self.url_rule.endpoint.split(':', 1)[0]
+        if self.url_rule and '.' in self.url_rule.endpoint:
-            raise
+            # if we want to repropagate the exception, we can attempt to
-def after_request(response):
+@app.teardown_request
-def after_request(response):
+@app.teardown_request
-    return response
+
-
+    def test_teardown_on_pop(self):
-     request_finished, got_request_exception
+     request_finished, got_request_exception, request_tearing_down
-from .ctx import _RequestContext
+from .ctx import RequestContext
-from .signals import request_started, request_finished, got_request_exception
+from .signals import request_started, request_finished, got_request_exception, \
-        """Register a function to be run after each request. Your function
+        """Register a function to be run after each request.  Your function
-        regardless of whether there was an exception or not.
+        regardless of whether there was an exception or not.  These functions
-            return self.view_functions[rule.endpoint](**req.view_args)
+            request_started.send(self)
-            return self.handle_http_exception(e)
+            rv = self.handle_http_exception(e)
-        call every as :meth:`teardown_request` decorated function.
+        call every as :meth:`teardown_request` decorated function.  This is
-        current context for the duration of the `with` block.
+        """Creates a :class:`~flask.ctx.RequestContext` from the given
-        return _RequestContext(self, environ)
+        return RequestContext(self, environ)
-           each teardown_request function.
+           The behavior of the before and after request callbacks was changed
-                response = self.make_response(rv)
+                response = self.full_dispatch_request()
-class _RequestContext(object):
+class RequestContext(object):
-        """Binds the request context."""
+        """Binds the request context to the current context."""
-        """Pops the request context."""
+        """Pops the request context and unbinds it by doing that.  This will
-           (tb is None or not self.app.debug):
+           (tb is None or not self.app.preserve_context_on_exception):
-        app.debug = True
+        @app.before_request
-from logging import getLogger, StreamHandler, Formatter, Logger, DEBUG
+from logging import getLogger, StreamHandler, Formatter, getLoggerClass, DEBUG
-            return json.loads(self.data)
+            request_charset = self.mimetype_params.get('charset')
-        after lowercasing.  Example usage::
+        Just the uppercase variables in that object are stored in the config.
-        _request_ctx_stack.top.flashes = flashes = session.pop('_flashes', [])
+        _request_ctx_stack.top.flashes = flashes = session.pop('_flashes') \
-    to the generated URL as query arguments.
+    to the generated URL as query arguments.  If the value of a query argument
-                '%r.' % (blueprint, self.blueprints[blueprint.name])
+                '%r.  Both share the same name "%s"' % \
-        blueprint.register(self, **options)
+        blueprint.register(self, options)
-
+    :param directory: the base directory.
-    
+
-    get_template_attribute, make_response
+    get_template_attribute, make_response, safe_join
-    filename = os.path.join(directory, filename)
+    filename = safe_join(directory, filename)
-        """Register a function to be run after each request."""
+        """Register a function to be run after each request. Your function
-                'passed to send_file is not deprecated.  Pass an '
+                'passed to send_file is now deprecated.  Pass an '
-from .templating import _DispatchingJinjaLoader, \
+from .templating import DispatchingJinjaLoader, Environment, \
-        rv = Environment(loader=self.create_jinja_loader(), **options)
+        rv = Environment(self, **options)
-        return _DispatchingJinjaLoader(self)
+        return DispatchingJinjaLoader(self)
-from jinja2 import BaseLoader, TemplateNotFound
+from jinja2 import BaseLoader, Environment as BaseEnvironment, \
-class _DispatchingJinjaLoader(BaseLoader):
+class Environment(BaseEnvironment):
-            raise TemplateNotFound(template)
+        # newstyle template support.  blueprints are explicit and no further
-            module, name = template.split('/', 1)
+            module, name = posixpath.normpath(template).split('/', 1)
-        except (ValueError, KeyError):
+        except (ValueError, KeyError, TemplateNotFound):
-            try:
+        try:
-        # fall back to application loader if module failed
+        except TemplateNotFound:
-        result = self.app.jinja_loader.list_templates()
+        result = set(self.app.jinja_loader.list_templates())
-        return result
+                    result.add('%s/%s' % (name, template))
-        if self.url_rule and '.' in self.url_rule.endpoint:
+        if self.url_rule and \
-
+def emits_module_deprecation_warning(f):
-        from moduleapp import app
+        app = moduleapp
-        from moduleapp import app
+        app = moduleapp
-from werkzeug import Headers, wrap_file, cached_property
+from werkzeug import Headers, wrap_file
-    @cached_property
+    @locked_cached_property
-    _tojson_filter, _endpoint_from_view_func
+    locked_cached_property, _tojson_filter, _endpoint_from_view_func
-
+    @locked_cached_property
-        and :meth:`select_jinja_autoescape`.
+        and :meth:`select_jinja_autoescape`.  Since 0.7 this also adds
-        return Environment(loader=self.create_jinja_loader(), **options)
+        rv = Environment(loader=self.create_jinja_loader(), **options)
-        `tojson` filter.
+        """Deprecated.  Used to initialize the Jinja2 globals.
-        self.jinja_env.filters['tojson'] = _tojson_filter
+from threading import RLock
-        """Register a function to be run at the end of each request, regardless of whether there was an exception or not."""
+        """Register a function to be run at the end of each request,
-        :param silent: set to `True` if you want silent to fail for missing
+        :param silent: set to `True` if you want silent failure for missing
-        :param silent: set to `True` if you want silent to fail for missing
+        :param silent: set to `True` if you want silent failure for missing
-        :param silent: set to `True` if you want silent to fail for missing
+        :param silent: set to `True` if you want silent failure for missing
-        :param silent: set to `True` if you want silent to fail for missing
+        :param silent: set to `True` if you want silent failure for missing
-        assert called == [1, 2, 3, 4]
+        assert called == [1, 2, 3, 4, 5, 6]
-import sys
+
-            not app.config.from_envvar('FOO_SETTINGS', silent=True)
+            assert not app.config.from_envvar('FOO_SETTINGS', silent=True)
-        a configuration file.  This basically is just a shortcut with nicer
+        a configuration file.  This is basically just a shortcut with nicer
-        :param silent: set to `True` if you want silent failing for missing
+        :param silent: set to `True` if you want silent to fail for missing
-    def from_pyfile(self, filename):
+    def from_pyfile(self, filename, silent=False):
-            self.session = _NullSession()
+        self.session = None
-        return Environment(loader=_DispatchingJinjaLoader(self), **options)
+        return Environment(loader=self.create_jinja_loader(), **options)
-        occours that is not catched.  In debug mode the exception will
+        occours that is not caught.  In debug mode the exception will
-    # a separate date header.
+    # the time of the last modification.
-        rv.date = int(mtime)
+        rv.last_modified = int(mtime)
-    to sent certain files as attachment (HTML for instance).  The mimetype
+    to send certain files as attachment (HTML for instance).  The mimetype
-            if rule.provide_automatic_options and req.method == 'OPTIONS':
+            if getattr(rule, 'provide_automatic_options', False) \
-            /schemal.sql
+            /schema.sql
-    'http://werkzeug.pocoo.org/documentation/dev/': None,
+    'http://werkzeug.pocoo.org/docs/': None,
-                               subdomain=module.subdomain)
+                               subdomain=state.subdomain)
-    if filename.startswith(('/', '../')):
+    for sep in _os_alt_seps:
-    #: 
+    #:
-    def test_client(self):
+    def test_client(self, use_cookies=True):
-        return FlaskClient(self, self.response_class, use_cookies=True)
+        cls = self.test_client_class
-import sqlite3
+from sqlite3 import dbapi2 as sqlite3
-import sqlite3
+from sqlite3 import dbapi2 as sqlite3
-        if self.debug:
+        if self.propagate_exceptions:
-
+    def test_exception_propagation(self):
-                           fall back to the traditional method.
+                           fall back to the traditional method.  Make sure
-        assert '&lt;Hello&gt' in rv.data
+        assert '&lt;Hello&gt;' in rv.data
-        #:    from werkzeug import BaseConverter
+        #:    from werkzeug.routing import BaseConverter
-            # request came with the OPTIONS method, reply automatically 
+            # request came with the OPTIONS method, reply automatically
-            http_host, http_port = server_name.split(':')
+                http_host, http_port = server_name, '80'
-from werkzeug import Client
+from werkzeug import Client, EnvironBuilder
-            return Client.open(self, *args, **kwargs)
+            return Client.open(self, builder,
-        def testit():
+        with app.test_request_context('/'):
-        self.assertRaises(ValueError, testit)
+        except Exception, e:
-        d = type(sys)('config')
+        d = imp.new_module('config')
-        #: :meth:`before_request` decorator.
+        #: :meth:`after_request` decorator.
-                               view_func=module.send_static_file)
+                               view_func=module.send_static_file,
-        rv = app.test_client().get('/')
+
-    to sent certain files as attachment (HTML for instance).
+    to sent certain files as attachment (HTML for instance).  The mimetype
-            assert rv.mimetype == 'text/html'
+        with catch_warnings() as captured:
-                os.path.join(app.root_path, 'static/index.html')
+        with catch_warnings() as captured:
-            assert rv.mimetype == 'text/plain'
+            with catch_warnings() as captured:
-            assert 'x-sendfile' not in rv.headers
+        with catch_warnings() as captured:
-            assert value == 'attachment'
+        with catch_warnings() as captured:
-                                 attachment_filename='index.txt')
+                                 attachment_filename='index.txt',
-g = LocalProxy(lambda: _request_ctx_stack.top.g)
+current_app = LocalProxy(partial(_lookup_object, 'app'))
-        except AttributeError:
+        except RuntimeError:
-from werkzeug import parse_date, parse_options_header, http_date
+from werkzeug import parse_date, parse_options_header
-        def after1(response):
+        def after2(response):
-        def index():
+        def admin_index():
-        def login():
+        def admin_login():
-        def logout():
+        def admin_logout():
-        def index():
+        def admin_index():
-        def index():
+        def admin_index():
-                rv = f('/etc/passwd')
+                f('/etc/passwd')
-                rv = f('../__init__.py')
+                f('../__init__.py')
-            rv = c.get('/')
+            c.get('/')
-            rv = app.test_client().get('/')
+            app.test_client().get('/')
-
+from setuptools import Command, setup
-        #: to register a view function, use the :meth:`route` decorator.
+        #: To register a view function, use the :meth:`route` decorator.
-        #: to populate the template context.  They key of the dictionary is the
+        #: to populate the template context.  The key of the dictionary is the
-    Here some examples:
+    Here are some examples:
-    Here an example structure for a larger appliation::
+    Here's an example structure for a larger application::
-    And here an example view module (`myapplication/views/admin.py`)::
+    And here's an example view module (`myapplication/views/admin.py`)::
-    """The request object used by default in flask.  Remembers the
+    """The request object used by default in Flask.  Remembers the
-    response object from Werkzeug but is set to have a HTML mimetype by
+    """The response object that is used by default in Flask.  Works like the
-        execfile(filename, d.__dict__)
+        try:
-from werkzeug import Headers, wrap_file, is_resource_modified, cached_property
+from werkzeug import Headers, wrap_file, cached_property
-                return self._make_default_options_response()
+                return self.make_default_options_response()
-    def _make_default_options_response(self):
+    def make_default_options_response(self):
-from werkzeug.exceptions import HTTPException, InternalServerError
+from werkzeug.exceptions import HTTPException, InternalServerError, \
-                return rv
+                return self._make_default_options_response()
-    tox_path = os.path.join(checkout_path, 'tox.ini')
+    tox_path = os.path.join(checkout_path, 'tox-flask-test.ini')
-    rv = subprocess.call(['tox'], cwd=checkout_path)
+    rv = subprocess.call(['tox', '-c', 'tox-flask-test.ini'], cwd=checkout_path)
-    version='0.6',
+    version='0.7',
-deps=%(deps)s
+deps=
-                                        '..'))
+flaskdir = os.path.abspath(os.path.join(os.path.dirname(__file__), '..'))
-    <h3>{{ result.name }} - {{ result.version }} [{{ iptr }}]</h3>
+    <h3 id="{{ result.name }}-{{ iptr }}">
-def run_tests(interpreters, only_approved=True):
+def run_tests(extensions, interpreters):
-    for name in iter_extensions(only_approved):
+    for name in extensions:
-    filename = render_results(results, not args.all)
+    if args.extension is not None:
-    # to pipe the output into a logfile
+    # to pipe the output into a logfile.  The /dev/null hack is
-    f.write(test_command + ' &> "$1"\n')
+    f.write(test_command + ' &> "$1" < /dev/null\n')
-from werkzeug.exceptions import HTTPException, InternalServerError, NotFound
+from werkzeug.exceptions import HTTPException, InternalServerError
-import tempfile, subprocess, urllib2, os
+import os
-tdir = tempfile.mkdtemp()
+if sys.platform == 'darwin':
-                           stderr=subprocess.STDOUT)
+
-    if 'Makefile' in files:
+    if os.path.isfile(checkout_dir + '/Makefile'):
-        return 'nosetests'
+    return 'python setup.py test'
-    name = ext['name']
+def checkout_extension(name):
-    checkout_path = PackageIndex().download(ext['name'], root)
+    checkout_path = PackageIndex().download(name, root)
-envlist=py26
+envlist=%(env)s
-%s
+deps=%(deps)s
-def create_tox_ini(checkout_path):
+
-            f.write(tox_template % (get_test_command(checkout_path), tdir))
+            f.write(tox_template % {
-def test_all_extensions(only_approved=only_approved):
+def iter_extensions(only_approved=True):
-            yield ext['name'], ret
+            yield ext['name']
-        print name, ret
+    parser = argparse.ArgumentParser(description='Runs Flask extension tests')
-from jinja2 import BaseLoader, FileSystemLoader, TemplateNotFound
+from jinja2 import BaseLoader, TemplateNotFound
-    'http://discorporate.us/projects/Blinker/docs/1.0/': None
+    'http://discorporate.us/projects/Blinker/docs/1.1/': None
-    def __init__(self, app, url_prefix=None):
+    def __init__(self, app, url_prefix=None, subdomain=None):
-                 static_path=None):
+                 static_path=None, subdomain=None):
-        with flask.template_rendered.temporarily_connected_to(record, app):
+        flask.template_rendered.connect(record, app)
-        with flask.got_request_exception.temporarily_connected_to(record):
+        flask.got_request_exception.connect(record, app)
-    print '  git submodule init'
+    print '  git submodule update --init'
-        and :meth:`create_jinja_loader`.
+        and :meth:`select_jinja_autoescape`.
-    _signals = Namespace()
+        If you want to run the application in debug mode, but disable the
-            server_name=app.config['SERVER_NAME'])
+        self.url_adapter = app.create_url_adapter(self.request)
-
+    def wsgi_app(self, environ, start_response):
-    'http://wtforms.simplecodes.com/docs/0.5/': None
+    'http://wtforms.simplecodes.com/docs/0.5/': None,
-    return ctx.app.jinja_env.get_template(template_name).render(context)
+    return _render(ctx.app.jinja_env.get_template(template_name),
-    return ctx.app.jinja_env.from_string(source).render(context)
+    return _render(ctx.app.jinja_env.from_string(source),
-        response = make_response(render_template('not_found.html', 404))
+        response = make_response(render_template('not_found.html'), 404)
-    get_template_attribute
+    get_template_attribute, make_response
-        else:
+            pass
-        raise TemplateNotFound(template)
+        # fall back to application loader if module failed
-    _tojson_filter
+    _tojson_filter, _endpoint_from_view_func
-            endpoint = view_func.__name__
+            endpoint = _endpoint_from_view_func(view_func)
-from .helpers import _PackageBoundObject
+from .helpers import _PackageBoundObject, _endpoint_from_view_func
-    def add_url_rule(self, rule, endpoint, view_func=None, **options):
+    def add_url_rule(self, rule, endpoint=None, view_func=None, **options):
-            state.app.add_url_rule(the_rule, '%s.%s' % (self.name, endpoint),
+            the_endpoint = endpoint
-        'SERVER_NAME':                          None
+        'SERVER_NAME':                          None,
-from werkzeug import parse_date, parse_options_header
+from werkzeug import parse_date, parse_options_header, http_date
-        This injects request, session and g into the template context.
+        This injects request, session, config and g into the template
-                              view_func=self.send_static_file)
+        # register the static folder for the application.  Do that even
-            return FileSystemLoader(template_folder)
+        return FileSystemLoader(os.path.join(self.root_path, 'templates'))
-            return self.endpoint.rsplit('.', 1)[0]
+        if self.url_rule and '.' in self.url_rule.endpoint:
-                        :class:`~werkzeug.routing.Rule` object
+                        :class:`~werkzeug.routing.Rule` object.  A change
-        self.url_map.add(Rule(rule, **options))
+        methods = options.pop('methods', ('GET',))
-                        just listens for ``GET`` (and implicitly ``HEAD``).
+                        to (`GET`, `POST` etc.).  By default a rule
-            return self.view_functions[req.endpoint](**req.view_args)
+            rule = req.url_rule
-                self.url_adapter.match()
+            url_rule, self.request.view_args = \
-    endpoint = None
+    #: the internal URL rule that matched the request.  This can be
-        assert sorted(rv.allow) == ['GET', 'HEAD']
+        assert sorted(rv.allow) == ['GET', 'HEAD', 'OPTIONS']
-        assert sorted(rv.allow) == ['GET', 'HEAD', 'POST']
+        assert sorted(rv.allow) == ['GET', 'HEAD', 'OPTIONS', 'POST']
-        assert sorted(rv.allow) == ['GET', 'HEAD']
+        assert sorted(rv.allow) == ['GET', 'HEAD', 'OPTIONS']
-        assert sorted(rv.allow) == ['GET', 'HEAD', 'POST']
+        assert sorted(rv.allow) == ['GET', 'HEAD', 'OPTIONS', 'POST']
-            funcs = chain(funcs, self.after_request_funcs[mod])
+            funcs = reversed(self.after_request_funcs[mod])
-            funcs = chain(funcs, self.after_request_funcs[None])
+            funcs = chain(funcs, reversed(self.after_request_funcs[None]))
-        json_available = False
+        try:
-     _default_template_ctx_processor
+    _default_template_ctx_processor
-                            domain=domain)
+                            expires=expires, httponly=True, domain=domain)
-from logging import getLogger, StreamHandler, Formatter, Logger,  DEBUG
+from logging import getLogger, StreamHandler, Formatter, Logger, DEBUG
-    the application of necessary.  It also registers the module on
+    the application if necessary.  It also registers the module on
-                           'application to something unique and secret')
+                           'application to something unique and secret.')
-        # raise the exception with the correct fileame here.
+        # raise the exception with the correct filename here.
-        loader = None
+            if loader is None:
-            raise TemplateNotFound(template)
+            if loader is not None:
-    version='0.5',
+    version='0.5.1',
-    version='0.5',
+    version='0.6',
-       The `static_path` parameter was added.
+       The `static_path` parameter was added and it's now possible for
-        expires = None
+        expires = domain = None
-                            expires=expires, httponly=True)
+                            expires=expires, httponly=True,
-            return logger
+            from flask.logging import create_logger
-from werkzeug import ImmutableDict, create_environ
+from werkzeug import ImmutableDict
-                    _request_ctx_stack.pop()
+        from flask.testing import FlaskClient
-                               '%s.static' % module.name,
+                               endpoint='%s.static' % module.name,
-    send_file, get_flashed_messages, get_template_attribute
+    send_file, send_from_directory, get_flashed_messages, \
-            self.add_url_rule(self.static_path + '/<filename>',
+            self.add_url_rule(self.static_path + '/<path:filename>',
-        return send_file(filename, conditional=True)
+        return send_from_directory(os.path.join(self.root_path, 'static'),
-        state.app.add_url_rule(path + '/<filename>',
+        state.app.add_url_rule(path + '/<path:filename>',
-                  direct_passthrough=True)
+    rv = current_app.response_class(data, mimetype=mimetype, headers=headers,
-from .wrappers import Response
+from werkzeug.exceptions import NotFound
-        if filename.startswith('../'):
+        if filename.startswith(('/', '../')):
-from .wrappers import Response
+
-from flask.helpers import _PackageBoundObject
+from .helpers import _PackageBoundObject
-from .helpers import json
+from .helpers import json, _assert_have_json
-from flask.helpers import url_for, jsonify, json_available, flash, \
+from .app import Flask, Request, Response
-from flask.templating import render_template, render_template_string
+from .globals import current_app, g, request, session, _request_ctx_stack
-    from flask.helpers import json
+    from .helpers import json
-from flask.helpers import _PackageBoundObject, url_for, get_flashed_messages, \
+from .helpers import _PackageBoundObject, url_for, get_flashed_messages, \
-from flask.templating import _DispatchingJinjaLoader, \
+from .wrappers import Request, Response
-from flask.session import _NullSession
+from .globals import _request_ctx_stack
-from flask.wrappers import Response
+from .globals import session, _request_ctx_stack, current_app, request
-from flask.globals import _request_ctx_stack
+from .globals import _request_ctx_stack
-from helpers import json
+from .helpers import json
-    get_flashed_messages, get_template_attribute, json
+from flask.helpers import url_for, jsonify, json_available, flash, \
-           Flask will supress any server error with a generic error page
+           Flask will suppress any server error with a generic error page
-           interactive debugger without the code reloading, you ahve to
+           interactive debugger without the code reloading, you have to
-       The default behaviour is now to attach etags.
+       The `add_etags`, `cache_timeout` and `conditional` parameters were
-def _register_module(module):
+def _register_module(module, static_path):
-        self._register_events = [_register_module(self)]
+        self._register_events = [_register_module(self, static_path)]
-from flask.ctx import _default_template_ctx_processor, _RequestContext
+from flask.ctx import _RequestContext
-from flask.templating import _DispatchingJinjaLoader
+from flask.templating import _DispatchingJinjaLoader, \
-    )
+def _default_template_ctx_processor():
-    get_template_attribute, json
+    get_flashed_messages, get_template_attribute, json
-from jinja2 import Environment, BaseLoader, FileSystemLoader, TemplateNotFound
+from jinja2 import Environment
-
+# -*- coding: utf-8 -*-
-from jinja2 import Environment, PackageLoader, FileSystemLoader
+from jinja2 import Environment, BaseLoader, FileSystemLoader, TemplateNotFound
-    template name.
+class _DispatchingJinjaLoader(BaseLoader):
-    return filename.endswith(('.html', '.htm', '.xml', '.xhtml'))
+
-        autoescape=_select_autoescape,
+        #: all the loaded modules in a dictionary by name.
-        #: by the :meth:`create_jinja_loader` function.
+        #: :attr:`jinja_options`.
-        return FileSystemLoader(os.path.join(self.root_path, 'templates'))
+        options = dict(self.jinja_options)
-from werkzeug import Headers, wrap_file, is_resource_modified
+from werkzeug import Headers, wrap_file, is_resource_modified, cached_property
-def _register_module_static(module):
+def _register_module(module):
-    the application of necessary.
+    the application of necessary.  It also registers the module on
-    def _register_static(state):
+    def _register(state):
-    return _register_static
+    return _register
-            self._record(_register_module_static(self))
+        self._register_events = [_register_module(self)]
-    _tojson_filter, send_file
+    _tojson_filter
-    def __init__(self, import_name):
+    def __init__(self, import_name, static_path=None):
-        if self.static_path is not None:
+        # if there is a static folder, register it for the application.
-
+import posixpath
-    def __init__(self, import_name, name=None, url_prefix=None):
+    def __init__(self, import_name, name=None, url_prefix=None,
-    _tojson_filter, get_pkg_resources, send_file
+    _tojson_filter, send_file
-        return PackageLoader(self.import_name)
+        return FileSystemLoader(os.path.join(self.root_path, 'templates'))
-        return pkg_resources.resource_stream(self.import_name, resource)
+        return open(os.path.join(self.root_path, resource), 'rb')
-from werkzeug import ImmutableDict, SharedDataMiddleware, create_environ
+from werkzeug import ImmutableDict, create_environ
-from werkzeug.exceptions import HTTPException, InternalServerError
+from werkzeug.exceptions import HTTPException, InternalServerError, NotFound
-    _tojson_filter, get_pkg_resources
+    _tojson_filter, get_pkg_resources, send_file
-            })
+                              endpoint='static',
-        filename = os.path.join(current_app.root_path, filename)
+        if not os.path.isabs(filename):
-        """Callde directly after the environment was created to inject
+        """Called directly after the environment was created to inject
-from werkzeug import Headers, wrap_file
+from werkzeug import Headers, wrap_file, is_resource_modified
-              attachment_filename=None):
+              attachment_filename=None, add_etags=True,
-                    direct_passthrough=True)
+    rv = Response(data, mimetype=mimetype, headers=headers,
-from flask.app import Flask
+from flask.app import Flask, Request, Response
-from flask.conf import ConfigAttribute, Config
+from flask.config import ConfigAttribute, Config
-from flask.wrappers import _RequestGlobals
+class _RequestGlobals(object):
-g = LocalProxy(lambda: _request_ctx_stack.top.g)
+g = LocalProxy(lambda: _request_ctx_stack.top.g)
-        
+
-        
+
-    
+
-    py_modules=['flask'],
+    packages=['flask'],
-        :param subdomain: specifies the rule for the subdoain in case
+        :param subdomain: specifies the rule for the subdomain in case
-    get_template_attribute
+    get_template_attribute, json
-        autoescape=True,
+        autoescape=_select_autoescape,
-        self.jinja_env.filters['tojson'] = _tojson_filter
+        self.jinja_env = self.create_jinja_environment()
-            assert json.loads(rv.data) == d
+            assert flask.json.loads(rv.data) == d
-        rv = c.post('/add', data=json.dumps({'a': 1, 'b': 2}),
+        rv = c.post('/add', data=flask.json.dumps({'a': 1, 'b': 2}),
-        autoescape=True,
+        autoescape=_select_autoescape,
-        self.jinja_env.filters['tojson'] = _tojson_filter
+        self.jinja_env = self.create_jinja_environment()
-        :param subdomain: specifies the rule for the subdoain in case
+        :param subdomain: specifies the rule for the subdomain in case
-
+from flask.helpers import json
-            assert flask.json.loads(rv.data) == d
+            assert json.loads(rv.data) == d
-        rv = c.post('/add', data=flask.json.dumps({'a': 1, 'b': 2}),
+        rv = c.post('/add', data=json.dumps({'a': 1, 'b': 2}),
-g = LocalProxy(lambda: _request_ctx_stack.top.g)
+from flask.app import Flask
-            if pkg_resources is not None:
+            if get_pkg_resources() is not None:
-        if pkg_resources is None:
+        if get_pkg_resources() is None:
-
+        pkg_resources = get_pkg_resources()
-
+from flask.helpers import _PackageBoundObject
-g = LocalProxy(lambda: _request_ctx_stack.top.g)
+        .. admonition:: Keep in Mind
-    endpoint = view_args = routing_exception = None
+    #: the endpoint that matched the request.  This in combination with
-        self.url_adapter = app.url_map.bind_to_environ(environ)
+        self.url_adapter = app.url_map.bind_to_environ(environ,
-        'LOGGER_NAME':                          None
+        'LOGGER_NAME':                          None,
-    version='0.4',
+    version='0.5',
-        '%(levelname)s in %(module)s, %(pathname)s:%(lineno)d]:\n' +
+        '%(levelname)s in %(module)s [%(pathname)s:%(lineno)d]:\n' +
-            from logging import getLogger, StreamHandler, Formatter, DEBUG
+            from logging import getLogger, StreamHandler, Formatter, \
-                        StreamHandler.emit(x, record)
+                    StreamHandler.emit(x, record) if self.debug else None
-            assert 'WARNING in flask_tests,' in out
+            assert 'WARNING in flask_tests [' in out
-    template named `_foo.html` with the following contents:
+    template named `_cider.html` with the following contents:
-        hello = get_template_attribute('_foo.html', 'hello')
+        hello = get_template_attribute('_cider.html', 'hello')
-                assert request.args['foo'] == '42'
+                rv = c.get('/?vodka=42')
-    This requires Python 2.6 or an installed version of simplejson.
+    This requires Python 2.6 or an installed version of simplejson.  For
-            /template
+            /templates
-        #: the name of the package or module.  Do not change this once
+        #: The name of the package or module.  Do not change this once
-        #: where is the app root located?
+        #: Where is the app root located?
-    #: the class that is used for request objects.  See :class:`~flask.Request`
+    #: The class that is used for request objects.  See :class:`~flask.Request`
-    #: the class that is used for response objects.  See
+    #: The class that is used for response objects.  See
-    #: path for the static files.  If you don't want to use static files
+    #: Path for the static files.  If you don't want to use static files
-    #: the debug flag.  Set this to `True` to enable debugging of the
+    #: The debug flag.  Set this to `True` to enable debugging of the
-    #: if a secret key is set, cryptographic components can use this to
+    #: If a secret key is set, cryptographic components can use this to
-    #: The secure cookie uses this for the name of the session cookie
+    #: The secure cookie uses this for the name of the session cookie.
-    #: the name of the logger to use.  By default the logger name is the
+    #: The name of the logger to use.  By default the logger name is the
-    #: the logging format used for the debug logger.  This is only used when
+    #: The logging format used for the debug logger.  This is only used when
-    #: options that are passed directly to the Jinja2 environment
+    #: Options that are passed directly to the Jinja2 environment.
-    #: default configuration parameters
+    #: Default configuration parameters.
-        #: the configuration dictionary as :class:`Config`.  This behaves
+        #: The configuration dictionary as :class:`Config`.  This behaves
-        #: prepare the deferred setup of the logger
+        #: Prepare the deferred setup of the logger.
-        #: a dictionary of all view functions registered.  The keys will
+        #: A dictionary of all view functions registered.  The keys will
-        #: a dictionary of all registered error handlers.  The key is
+        #: A dictionary of all registered error handlers.  The key is
-        #: a dictionary with lists of functions that should be called at the
+        #: A dictionary with lists of functions that should be called at the
-        #: a dictionary with lists of functions that should be called after
+        #: A dictionary with lists of functions that should be called after
-        #: a dictionary with list of functions that are called without argument
+        #: A dictionary with list of functions that are called without argument
-        #: the :class:`~werkzeug.routing.Map` for this instance.  You can use
+        #: The :class:`~werkzeug.routing.Map` for this instance.  You can use
-        #: the Jinja2 environment.  It is created from the
+        #: The Jinja2 environment.  It is created from the
-        """Handles a HTTP exception.  By default this will invoke the
+        """Handles an HTTP exception.  By default this will invoke the
-        """Handles an HTTP exception.  By default this will invoke the
+        """Handles a HTTP exception.  By default this will invoke the
-        for an 500 internal server error is used.  If no such handler
+        for a 500 internal server error is used.  If no such handler
-        be re-raised immediately, otherwise it is logged an the handler
+        be re-raised immediately, otherwise it is logged and the handler
-release = __import__('pkg_resources').get_distribution('Flask').version
+import pkg_resources
-        'USE_X_SENDFILE':                       False
+        'USE_X_SENDFILE':                       False,
-    @cached_property
+    @property
-        return logger
+        if self._logger and self._logger.name == self.logger_name:
-        error_out = StringIO()
+        called = []
-        app.logger.addHandler(StreamHandler(error_out))
+            called.append(True)
-        assert 'after_request handler failed' in error_out.getvalue()
+        assert len(called) == 1
-        from logging import StreamHandler
+        app.logger_name = 'flask_tests/test_exception_logging'
-        if tb is None or not self.app.debug:
+        # access the request object in the interactive shell.  Furthermore
-        return Client(self, self.response_class, use_cookies=True)
+        class FlaskClient(Client):
-    ]
+    ],
-        assert 'internal server error' in rv.data
+        assert 'internal server error' == rv.data
-                               'point to a configuration file')
+                               'point to a configuration file' %
-    version='0.3',
+    version='0.4',
-    .. versionchanged: 0.5
+    .. versionchanged: 0.3
-    .. versionchanged:: 0.5
+    .. versionchanged:: 0.3
-    #: .. versionadded:: 0.5
+    #: .. versionadded:: 0.3
-        .. versionadded:: 0.5
+        .. versionadded:: 0.3
-        .. versionadded: 0.5
+        .. versionadded: 0.3
-        .. versionadded: 0.5
+        .. versionadded: 0.3
-        .. versionchanged:: 0.5
+        .. versionchanged:: 0.3
-    version='0.5',
+    version='0.3',
-app.debug = DEBUG
+app.config.from_object(__name__)
-    return sqlite3.connect(DATABASE)
+    return sqlite3.connect(app.config['DATABASE'])
-        if request.form['username'] != USERNAME:
+        if request.form['username'] != app.config['USERNAME']:
-        elif request.form['password'] != PASSWORD:
+        elif request.form['password'] != app.config['PASSWORD']:
-        self.db_fd, flaskr.DATABASE = tempfile.mkstemp()
+        self.db_fd, flaskr.app.config['DATABASE'] = tempfile.mkstemp()
-        os.unlink(flaskr.DATABASE)
+        os.unlink(flaskr.app.config['DATABASE'])
-        rv = self.login(flaskr.USERNAME, flaskr.PASSWORD)
+        rv = self.login(flaskr.app.config['USERNAME'],
-        rv = self.login(flaskr.USERNAME + 'x', flaskr.PASSWORD)
+        rv = self.login(flaskr.app.config['USERNAME'] + 'x',
-        rv = self.login(flaskr.USERNAME, flaskr.PASSWORD + 'x')
+        rv = self.login(flaskr.app.config['USERNAME'],
-        self.login(flaskr.USERNAME, flaskr.PASSWORD)
+        self.login(flaskr.app.config['USERNAME'],
-    return sqlite3.connect(DATABASE)
+    return sqlite3.connect(app.config['DATABASE'])
-# from the configuration.
+# add some filters to jinja
-        self.db_fd, minitwit.DATABASE = tempfile.mkstemp()
+        self.db_fd, minitwit.app.config['DATABASE'] = tempfile.mkstemp()
-        os.unlink(minitwit.DATABASE)
+        os.unlink(minitwit.app.config['DATABASE'])
-    module that calls :meth:`from_module` or provide an import path to
+    module that calls :meth:`from_object` or provide an import path to
-        app.config.from_module(__name__)
+        app.config.from_object(__name__)
-    the same file that implements the application.
+    only uppercase keys are added to the config.  This makes it possible to use
-        :meth:`from_module` function.
+        :meth:`from_object` function.
-        self.from_module(d)
+        self.from_object(d)
-        """Updates the values from the given module.  A module can be of one
+    def from_object(self, obj):
-        -   an actual module reference: that module is used directly
+        -   a string: in this case the object with that name will be imported
-        Just the uppercase variables in that module are stored in the config
+        Objects are usually either modules or classes.
-            app.config.from_module('yourapplication.default_config')
+            app.config.from_object('yourapplication.default_config')
-            app.config.from_module(default_config)
+            app.config.from_object(default_config)
-        with :meth;`from_pyfile` and ideally from a location not within the
+        with :meth:`from_pyfile` and ideally from a location not within the
-        :param module: an import name or module
+        :param obj: an import name or object
-        for key, value in d.iteritems():
+        if isinstance(obj, basestring):
-                self[key.lower()] = value
+                self[key] = getattr(obj, key)
-    debug = ConfigAttribute('debug')
+    debug = ConfigAttribute('DEBUG')
-    secret_key = ConfigAttribute('secret_key')
+    secret_key = ConfigAttribute('SECRET_KEY')
-    session_cookie_name = ConfigAttribute('session_cookie_name')
+    session_cookie_name = ConfigAttribute('SESSION_COOKIE_NAME')
-    permanent_session_lifetime = ConfigAttribute('permanent_session_lifetime')
+    permanent_session_lifetime = ConfigAttribute('PERMANENT_SESSION_LIFETIME')
-    use_x_sendfile = ConfigAttribute('use_x_sendfile')
+    use_x_sendfile = ConfigAttribute('USE_X_SENDFILE')
-        'use_x_sendfile':                       False
+        'DEBUG':                                False,
-    def common_module_test(self, app):
+    def common_object_test(self, app):
-        assert app.config['test_key'] == 'foo'
+        assert app.config['TEST_KEY'] == 'foo'
-        self.common_module_test(app)
+        self.common_object_test(app)
-        self.common_module_test(app)
+        app.config.from_object(__name__)
-     ImmutableDict, cached_property, wrap_file, Headers
+     ImmutableDict, cached_property, wrap_file, Headers, \
-    session_cookie_name = ConfigAttribute('session.cookie_name')
+    session_cookie_name = ConfigAttribute('session_cookie_name')
-    permanent_session_lifetime = ConfigAttribute('session.permanent_lifetime')
+    permanent_session_lifetime = ConfigAttribute('permanent_session_lifetime')
-        'session.permanent_lifetime':           timedelta(days=31),
+        'session_cookie_name':                  'session',
-    def __init__(self, import_name, config=None):
+    def __init__(self, import_name):
-            self.config.update(config)
+        #: the configuration dictionary as :class:`Config`.  This behaves
-    secret_key = None
+    secret_key = ConfigAttribute('secret_key')
-    session_cookie_name = 'session'
+    session_cookie_name = ConfigAttribute('session.cookie_name')
-    permanent_session_lifetime = timedelta(days=31)
+    permanent_session_lifetime = ConfigAttribute('session.permanent_lifetime')
-    use_x_sendfile = False
+    use_x_sendfile = ConfigAttribute('use_x_sendfile')
-    def __init__(self, import_name):
+    #: default configuration parameters
-        self.debug = False
+        #: the configuration dictionary
-#html_theme_options = {}
+html_theme_options = {
-#html_use_modindex = True
+html_use_modindex = False
-#html_show_sphinx = True
+html_show_sphinx = False
-            def page_not_found():
+            def page_not_found(error):
-            def page_not_found():
+            def page_not_found(error):
-    def __enter__(self):
+    def push(self):
-            _request_ctx_stack.pop()
+            self.pop()
-     ImmutableDict, cached_property, wrap_file, Headers
+     ImmutableDict, cached_property, wrap_file, Headers, \
-    session_cookie_name = ConfigAttribute('session.cookie_name')
+    session_cookie_name = ConfigAttribute('session_cookie_name')
-    permanent_session_lifetime = ConfigAttribute('session.permanent_lifetime')
+    permanent_session_lifetime = ConfigAttribute('permanent_session_lifetime')
-        'session.permanent_lifetime':           timedelta(days=31),
+        'session_cookie_name':                  'session',
-    def __init__(self, import_name, config=None):
+    def __init__(self, import_name):
-            self.config.update(config)
+        #: the configuration dictionary as :class:`Config`.  This behaves
-    secret_key = None
+    secret_key = ConfigAttribute('secret_key')
-    session_cookie_name = 'session'
+    session_cookie_name = ConfigAttribute('session.cookie_name')
-    permanent_session_lifetime = timedelta(days=31)
+    permanent_session_lifetime = ConfigAttribute('session.permanent_lifetime')
-    use_x_sendfile = False
+    use_x_sendfile = ConfigAttribute('use_x_sendfile')
-    def __init__(self, import_name):
+    #: default configuration parameters
-        self.debug = False
+        #: the configuration dictionary
-            assert 'WARNING in flask_tests, flask_tests.py' in out
+            assert 'WARNING in flask_tests,' in out
-    version = version.split('dev')[0]
+if 'dev' in version:
-        '%(levelname)s in %(module)s, %(filename)s:%(lineno)d]:\n' +
+        '%(levelname)s in %(module)s, %(pathname)s:%(lineno)d]:\n' +
-        in debug mode.
+        in debug mode.  This logger can be used to (surprise) log messages.
-            response = self.process_response(response)
+            try:
-from werkzeug.exceptions import HTTPException
+from werkzeug.exceptions import HTTPException, InternalServerError
-            return handler(e)
+            return self.handle_http_exception(e)
-            return handler(e)
+            return self.handle_exception(e)
-    suite.addTest(unittest.makeSuite(SendfileTestCase))
+    suite.addTest(unittest.makeSuite(SendfileTestCase))
-                     kind of string and be used as category.
+                     kind of string can be used as category.
-def flash(message):
+def flash(message, category='message'):
-    session.setdefault('_flashes', []).append(message)
+    session.setdefault('_flashes', []).append((category, message))
-def get_flashed_messages():
+def get_flashed_messages(with_categories=False):
-    the same messages.
+    the same messages.  By default just the messages are returned,
-        """Like :meth:`Flask.context_processor` but for a modul.  This
+        """Like :meth:`Flask.context_processor` but for a module.  This
-    #: the class that is used for request objects.  See :class:`~flask.request`
+    #: the class that is used for request objects.  See :class:`~flask.Request`
-    set :attr:`~flask.Flask.request_class` to your subclass.
+    set :attr:`~flask.Flask.response_class` to your subclass.
-        :params environ: a WSGI environment
+        :param environ: a WSGI environment
-    version='0.2',
+    version='0.5',
-        'Development Status :: 3 - Alpha',
+        'Development Status :: 4 - Beta',
-     ImmutableDict, cached_property
+     ImmutableDict, cached_property, wrap_file, Headers
-from werkzeug import parse_date
+from werkzeug import parse_date, parse_options_header
-sys.path.append(os.path.abspath('.'))
+sys.path.append(os.path.abspath('_themes'))
-html_theme = 'flasky'
+html_theme = 'flask'
-        before each request.
+        before each request, even if outside of a module.
-        is executed after each request.
+        is executed after each request, even if outside of the module.
-            if self.url_prefix:
+            if state.url_prefix:
-    """Expands the session for support for switching between permanent
+    """Expands the session with support for switching between permanent
-        #: a list of functions that are called without arguments
+        #: a list of functions that are called without argument
-        assert not rv.data # head truncates
+        assert not rv.data  # head truncates
-        assert not rv.data # head truncates
+        assert not rv.data  # head truncates
-            1/0
+            1 // 0
-                return ','.join(super(ListConverter, self).to_url(x) for x in value)
+                base_to_url = super(ListConverter, self).to_url
-            rv = flask.render_template_string('{{ "</script>"|tojson|safe }}')
+            rv = render('{{ "</script>"|tojson|safe }}')
-            rv = flask.render_template_string('{{ "<\0/script>"|tojson|safe }}')
+            rv = render('{{ "<\0/script>"|tojson|safe }}')
-        except Warning:
+        except ValueError, e:
-            assert "Expected warning"
+            assert "Expected ValueError"
-            return u''
+            raise ValueError('View function did not return a response')
-    return _request_ctx_stack.top.url_adapter.build(endpoint, values)
+    external = values.pop('_external', False)
-class _NullSession(SecureCookie):
+class Session(SecureCookie):
-                                            secret_key=key)
+            return Session.load_cookie(request, self.session_cookie_name,
-        session.save_cookie(response, self.session_cookie_name)
+        expires = None
-  ('index', 'Flask.tex', u'Flask Documentation',
+  ('latexindex', 'Flask.tex', u'Flask Documentation',
-#latex_use_modindex = True
+latex_use_modindex = False
-    def template_filter(self, arg=None):
+    def template_filter(self, name=None):
-          @app.template_filter
+          @app.template_filter()
-            self.jinja_env.filters[arg or f.__name__] = f
+            self.jinja_env.filters[name or f.__name__] = f
-    def test_template_filter_called(self):
+    def test_template_filter(self):
-    """Container object that enables pluggable applications"""
+    """Container object that enables pluggable applications.  A module can
-        """Like :meth:`flask.Flask.route` but for a module"""
+        """Like :meth:`Flask.route` but for a module.  The endpoint for the
-        """Like :meth:`flask.Flask.add_url_rule` but for a module"""
+        """Like :meth:`Flask.add_url_rule` but for a module.  The endpoint for
-        """Like :meth:`flask.Flask.before_request` but for a module"""
+        """Like :meth:`Flask.before_request` but for a module.  This function
-        """Like :meth:`flask.Flask.after_request` but for a module"""
+        """Like :meth:`Flask.after_request` but for a module.  This function
-        """Registers a module with this application."""
+        """Registers a module with this application.  The keyword argument
-class Module(object):
+class Module(_PackageBoundObject):
-    def __init__(self, name, url_prefix=None):
+    def __init__(self, import_name, name=None, url_prefix=None):
-        self._record(self._register_rule, (rule, endpoint, view_func, options))
+        """Like :meth:`flask.Flask.add_url_rule` but for a module"""
-            .setdefault(self.name, []).append(f), ())
+            .setdefault(self.name, []).append(f))
-            .setdefault(self.name, []).append(f), ())
+            .setdefault(self.name, []).append(f))
-                               view_func, **options)
+    def _record(self, func):
-class Flask(object):
+class Flask(_PackageBoundObject):
-    def __init__(self, package_name):
+    def __init__(self, import_name):
-        #: decorator.
+        #: a dictionary with lists of functions that should be called at the
-        #: decorator.
+        #: a dictionary with lists of functions that should be called after
-        self.template_context_processors = [_default_template_ctx_processor]
+        #: a dictionary with list of functions that are called without arguments
-                target = (self.package_name, 'static')
+                target = (self.import_name, 'static')
-        return PackageLoader(self.package_name)
+        return PackageLoader(self.import_name)
-        for func in self.template_context_processors:
+        funcs = self.template_context_processors[None]
-            func(state, *args)
+        for func in module._register_events:
-        self.template_context_processors.append(f)
+        self.template_context_processors[None].append(f)
-        admin = flask.Module('admin', url_prefix='/admin')
+        admin = flask.Module(__name__, 'admin', url_prefix='/admin')
-        admin = flask.Module('admin', url_prefix='/admin')
+        admin = flask.Module(__name__, 'admin', url_prefix='/admin')
-    def __init__(self, name, url_prefix=None, package_name=None):
+    def __init__(self, name, url_prefix=None):
-                              view_func, **options)
+        state.app.add_url_rule(rule, '%s.%s' % (self.name, endpoint),
-        state = _ModuleSetupState(app, options)
+        options.setdefault('url_prefix', module.url_prefix)
-        funcs = self.after_request_funcs.get(None, ())
+        funcs = ()
-        app.register_module('admin', admin)
+        app.register_module(admin)
-    return ctx.url_adapter.build(endpoint.lstrip('.'), values)
+    if '.' not in endpoint:
-        self.before_request_funcs = []
+        self.before_request_funcs = {}
-        self.after_request_funcs = []
+        self.after_request_funcs = {}
-        self.before_request_funcs.append(f)
+        self.before_request_funcs.setdefault(None, []).append(f)
-        self.after_request_funcs.append(f)
+        self.after_request_funcs.setdefault(None, []).append(f)
-        for func in self.before_request_funcs:
+        funcs = self.before_request_funcs.get(None, ())
-        for handler in self.after_request_funcs:
+        ctx = _request_ctx_stack.top
-    endpoint = view_args = None
+    endpoint = view_args = routing_exception = None
-    return _request_ctx_stack.top.url_adapter.build(endpoint, values)
+    ctx = _request_ctx_stack.top
-    def add_url_rule(self, rule, endpoint, view_func=None, **options):
+    def add_url_rule(self, rule, endpoint=None, view_func=None, **options):
-           `view_func` parameter added
+           `view_func` parameter added.
-            self.add_url_rule(rule, f.__name__, f, **options)
+            self.add_url_rule(rule, None, f, **options)
-
+        req = _request_ctx_stack.top.request
-            return self.view_functions[endpoint](**values)
+            if req.routing_exception is not None:
-        The following types are allowd for `rv`:
+        The following types are allowed for `rv`:
-    session['_flashes'] = session.get('_flashes', ()) + (message,)
+    session.setdefault('_flashes', []).append(message)
-        _request_ctx_stack.top.flashes = flashes = session.pop('_flashes', ())
+        _request_ctx_stack.top.flashes = flashes = session.pop('_flashes', [])
-        self.view_args = None
+    endpoint = view_args = None
-    session['_flashes'] = (session.get('_flashes', [])) + [message]
+    session['_flashes'] = session.get('_flashes', ()) + (message,)
-            session.pop('_flashes', [])
+        _request_ctx_stack.top.flashes = flashes = session.pop('_flashes', ())
-    session['_flashes'] = session.get('_flashes', ()) + (message,)
+    session.setdefault('_flashes', []).append(message)
-        _request_ctx_stack.top.flashes = flashes = session.pop('_flashes', ())
+        _request_ctx_stack.top.flashes = flashes = session.pop('_flashes', [])
-        self.view_args = None
+    endpoint = view_args = None
-    session['_flashes'] = (session.get('_flashes', [])) + [message]
+    session['_flashes'] = session.get('_flashes', ()) + (message,)
-            session.pop('_flashes', [])
+        _request_ctx_stack.top.flashes = flashes = session.pop('_flashes', ())
-    def run(self, host='localhost', port=5000, **options):
+    def run(self, host='127.0.0.1', port=5000, **options):
-        self.db = tempfile.NamedTemporaryFile()
+        self.db_fd, flaskr.DATABASE = tempfile.mkstemp()
-        flaskr.DATABASE = self.db.name
+    def tearDown(self):
-        self.db = tempfile.NamedTemporaryFile()
+        self.db_fd, minitwit.DATABASE = tempfile.mkstemp()
-        minitwit.DATABASE = self.db.name
+    def tearDown(self):
-        """Calls dumps for the template engine, escaping slashes properly."""
+# figure out if simplejson escapes slashes.  This behaviour was changed
-        return json.dumps(string, *args, **kwargs).replace('/', '\\/')
+        return json.dumps(*args, **kwargs).replace('/', '\\/')
-    _json_escapes_slashes = '\\/' in json.dumps('/')
+_json_escapes_slashes = json_available and '\\/' in json.dumps('/')
-    return rv
+if not _json_escapes_slashes:
-            [session['user_id'], profile_user['user_id']], one=True) is not None
+            [session['user_id'], profile_user['user_id']],
-    """Logs the user out"""
+    """Logs the user out."""
-    """Helper function that fails if JSON is unavailable"""
+    """Helper function that fails if JSON is unavailable."""
-        decorator. If a view_func is provided it will be registered with the
+        decorator.  If a view_func is provided it will be registered with the
-        :param view_func: the function to call when servicing a request to the
+        :param view_func: the function to call when serving a request to the
-        """Shortcut for :attr:`wsgi_app`"""
+        """Shortcut for :attr:`wsgi_app`."""
-* `development version <http://github.com/mitsuhiko/flask/zipball/master#egg=Flask-dev>`_
+* `development version
-    description='A microframework based on Werkzeug, Jinja2 and good intentions',
+    description='A microframework based on Werkzeug, Jinja2 '
-    return json.dumps(string, *args, **kwargs).replace('</', '<\\/')
+    rv = json.dumps(string, *args, **kwargs)
-        #: request.  Tha function is passed the current response
+        #: request.  The function is passed the current response
-            raise AttributeError('simplejson not available')
+        if __debug__:
-            self.jinja_env.filters['tojson'] = _tojson_filter
+        self.jinja_env.filters['tojson'] = _tojson_filter
-        decorator. If a view_func is provided it will be registered with the endpoint.
+        decorator. If a view_func is provided it will be registered with the
-         view function like so:
+
-        :param view_func: the function to call when servicing a request to the provided endpoint
+        :param view_func: the function to call when servicing a request to the
-        .. versionadded:: 0.2
+import os
-    unittest.main()
+    unittest.main(defaultTest='suite')
-    return json.dumps(string, *args, **kwargs).replace('/', '\\/')
+    return json.dumps(string, *args, **kwargs).replace('</', '<\\/')
-     cached_property
+     ImmutableDict, cached_property
-    jinja_options = dict(
+    jinja_options = ImmutableDict(
-                                  build_only=True, endpoint='static'))
+            self.add_url_rule(self.static_path + '/<filename>',
-        
+
-            self.view_functions[f.__name__] = f
+            self.add_url_rule(rule, f.__name__, f, **options)
-    def add_url_rule(self, rule, endpoint, **options):
+    def add_url_rule(self, rule, endpoint, view_func=None, **options):
-        decorator but does not register the view function for the endpoint.
+        decorator. If a view_func is provided it will be registered with the endpoint.
-            app.add_url_rule('index', '/')
+            app.add_url_rule('/', 'index', index)
-            self.jinja_env.filters['tojson'] = json.dumps
+            self.jinja_env.filters['tojson'] = _tojson_filter
-     LocalStack, LocalProxy, create_environ, SharedDataMiddleware
+     LocalStack, LocalProxy, create_environ, SharedDataMiddleware, \
-
+    .. versionadded:: 0.2
-class BasicFunctionality(unittest.TestCase):
+class BasicFunctionalityTestCase(unittest.TestCase):
-class Templating(unittest.TestCase):
+class JSONTestCase(unittest.TestCase):
-    'http://www.sqlalchemy.org/docs/': None
+    'http://www.sqlalchemy.org/docs/': None,
-    followd = False
+    followed = False
-     SharedDataMiddleware
+     LocalStack, LocalProxy, create_environ, SharedDataMiddleware
-from werkzeug.exceptions import HTTPException, InternalServerError
+from werkzeug.exceptions import HTTPException
-        self.login(flaskr.USERNAME, flaskr.PASSWORD)
+def get_template_attribute(template_name, attribute):
-        `__call__` so that middlewares can be applied:
+        `__call__` so that middlewares can be applied without losing a
-        reqctx = _request_ctx_stack.top
+class _NullSession(SecureCookie):
-            session.save_cookie(response, self.session_cookie_name)
+        session.save_cookie(response, self.session_cookie_name)
-        if session is not None:
+        if not isinstance(session, _NullSession):
-    version='0.1',
+    version='0.2',
-    'http://werkzeug.pocoo.org/documentation/dev/': None
+    'http://werkzeug.pocoo.org/documentation/dev/': None,
-@app.request_init
+@app.before_request
-@app.request_shutdown
+@app.after_request
-@app.request_init
+@app.before_request
-@app.request_shutdown
+@app.after_request
-        #: To register a function here, use the :meth:`request_init`
+        #: To register a function here, use the :meth:`before_request`
-        self.request_init_funcs = []
+        self.before_request_funcs = []
-        #: To register a function here use the :meth:`request_shtdown`
+        #: To register a function here use the :meth:`after_request`
-        self.request_shutdown_funcs = []
+        self.after_request_funcs = []
-    def request_init(self, f):
+    def before_request(self, f):
-        self.request_init_funcs.append(f)
+        self.before_request_funcs.append(f)
-    def request_shutdown(self, f):
+    def after_request(self, f):
-        self.request_shutdown_funcs.append(f)
+        self.after_request_funcs.append(f)
-        call every as :func:`request_init` decorated function.
+        call every as :meth:`before_request` decorated function.
-        for func in self.request_init_funcs:
+        for func in self.before_request_funcs:
-        before it's sent to the WSGI server.
+        before it's sent to the WSGI server.  By default this will
-        for handler in self.request_shutdown_funcs:
+        for handler in self.after_request_funcs:
-        @app.request_init
+        @app.before_request
-        @app.request_shutdown
+        @app.after_request
-from contextlib import contextmanager
+    def __enter__(self):
-            _request_ctx_stack.pop()
+        return _RequestContext(self, environ)
-            sys.modules[self.package_name].__file__))
+        self.root_path = _get_package_path(self.package_name)
-    """
+    """Make sure we are connected to the database each request."""
-    if not g.logged_in:
+    if not session.get('logged_in'):
-from werkzeug import secure_filename
+# -*- coding: utf-8 -*-
-import pkg_resources
+
-from jinja2 import Environment, PackageLoader
+from jinja2 import Environment, PackageLoader, FileSystemLoader
-                self.static_path: (self.package_name, 'static')
+                self.static_path: target
-     LocalStack, LocalProxy, create_environ, cached_property
+     LocalStack, LocalProxy, create_environ, cached_property, \
-            }
+    def test_static_files(self):
-    unittest.main()
+# -*- coding: utf-8 -*-
-        # 'Jinja2'
+        'Werkzeug>=0.6.1',
-        context['g'] = reqctx.g
+        for func in self.template_context_processors:
-        :param request: an instance of :attr:`response_class`
+        :param response: an instance of :attr:`response_class`
-    """Returns a new database connection to the database."""
+    """Returns a new connection to the database."""
-    """Convenience method to look up the id for a username"""
+    """Convenience method to look up the id for a username."""
-    """Format a timestamp for display"""
+    """Format a timestamp for display."""
-    """Return the gravatar image for the given email address"""
+    """Return the gravatar image for the given email address."""
-    """Adds the current user as follower of the given user"""
+    """Adds the current user as follower of the given user."""
-    """Removes the current user as follower of the given user"""
+    """Removes the current user as follower of the given user."""
-    """Registers a new message for the user"""
+    """Registers a new message for the user."""
-    """Logs the user in"""
+    """Logs the user in."""
-    """Registers the user"""
+    """Registers the user."""
-     create_environ, cached_property
+from werkzeug import Request as RequestBase, Response as ResponseBase, \
-class FlaskRequest(Request):
+class Request(RequestBase):
-        Request.__init__(self, environ)
+        RequestBase.__init__(self, environ)
-class FlaskResponse(Response):
+class Response(ResponseBase):
-    default.
+    default.  Quite often you don't have to create this object yourself because
-    request_class = FlaskRequest
+    #: the class that is used for request objects.  See :class:`~flask.request`
-    response_class = FlaskResponse
+    #: the class that is used for response objects.  See
-        """Creates a test client for this application"""
+        """Creates a test client for this application.  For information
-        in the URL accepts any string without a slash however a differnt
+        in the URL accepts any string without a slash however a different
-            error = 'The two passwords to not match'
+            error = 'The two passwords do not match'
-        """A test client for this application"""
+    def test_client(self):
-    app.run(debug=True)
+"""
-def after_request(request):
+def after_request(response):
-    return request
+    return response
-    if not 'user_id' in session:
+    """Shows a users timeline or if no user is logged in it will
-    if 'user_id' in session:
+    if g.user:
-    if not 'user_id' in session:
+    """Adds the current user as follower of the given user"""
-    if not 'user_id' in session:
+    """Removes the current user as follower of the given user"""
-    if 'user_id' in session:
+    """Logs the user in"""
-    if 'user_id' in session:
+    """Registers the user"""
-    modules=['flask'],
+    py_modules=['flask'],
-        'Jinja2==dev',
+    install_requires=[
-        Comment.Special:           "italic #8f5902", # class: 'cs'
+        Comment.Preproc:           "noitalic",       # class: 'cp'
-        Name.Decorator:            "#999",           # class: 'nd' - to be revised
+        Name.Decorator:            "#888",           # class: 'nd' - to be revised
-        Number.Oct:                "bold #0000cf",   # class: 'mo'
+        Number:                    "#990000",        # class: 'm'
-        Generic.Prompt:            "#8f5902",        # class: 'gp'
+        Generic.Output:            "#888",           # class: 'go'
-        :func:`werkzeug.create_environ` for more information).
+        :func:`werkzeug.create_environ` for more information, this
-#sys.path.append(os.path.abspath('.'))
+sys.path.append(os.path.abspath('.'))
-pygments_style = 'sphinx'
+pygments_style = 'flaskext.FlaskyStyle'
-html_theme = 'nature'
+html_theme = 'flasky'
-#html_theme_path = []
+html_theme_path = ['_themes']
-# of the sidebar.
+# of the sidebar.  Do not set, template magic!
-#html_sidebars = {}
+html_sidebars = {
-    def add_url_rule(self, endpoint, **options):
+    def add_url_rule(self, rule, endpoint, **options):
-        Is equivalent to the following:
+        Is equivalent to the following::
-        options['endpoint'] = f.__name__
+        options['endpoint'] = endpoint
-            self.add_url_rule(f.__name__, **options)
+            self.add_url_rule(rule, f.__name__, **options)
-            self.view_functions[options['endpoint']] = f
+            self.add_url_rule(f.__name__, **options)
-    g.db = sqlite3.connect(DATABASE)
+    g.db = connect_db()
-@app.route('/add_message')
+@app.route('/add_message', methods=['POST'])
-@app.route('/login')
+@app.route('/login', methods=['GET', 'POST'])
-@app.route('/register')
+@app.route('/register', methods=['GET', 'POST'])
-                        to (``GET``, ``POST`` etc.)
+                        to (``GET``, ``POST`` etc.).  By default a rule
-extensions = ['sphinx.ext.autodoc']
+extensions = ['sphinx.ext.autodoc', 'sphinx.ext.intersphinx']
-     check_password_hash
+     render_template, abort, g, flash
-from werkzeug import Request, Response, LocalStack, LocalProxy
+from werkzeug import Request, Response, LocalStack, LocalProxy, \
-     html, import_string, generate_password_hash, check_password_hash
+from werkzeug import abort, redirect
-
+    current_app.update_template_context(context)
-            g=g,
+    def update_template_context(self, context):
-        try:
+        with self.request_context(environ):
-        (md5(email.lower().encode('utf-8')).hexdigest(), size)
+        (md5(email.strip().lower().encode('utf-8')).hexdigest(), size)
-    template engine and provides ways to register view functions.
+    object.  It is passed the name of the module or package of the
-        """Runs the application on a local development server"""
+        """Runs the application on a local development server.  If the
-        """Opens a resource from the application's resource folder"""
+        """Opens a resource from the application's resource folder.  To see
-        that `securecookie.secret_key` is set.
+        """Creates or opens a new session.  Default implementation stores all
-        """Saves the session if it needs updates."""
+        """Saves the session if it needs updates.  For the default
